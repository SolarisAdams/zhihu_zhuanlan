{
    "title": "夜曉宸", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/zhang-hao-jie-10", 
        "https://www.zhihu.com/people/jetdancer", 
        "https://www.zhihu.com/people/cai-hui-6", 
        "https://www.zhihu.com/people/login-16", 
        "https://www.zhihu.com/people/jack-pan-23", 
        "https://www.zhihu.com/people/liwei-xie-50", 
        "https://www.zhihu.com/people/wisdommm", 
        "https://www.zhihu.com/people/qiangzhao", 
        "https://www.zhihu.com/people/luoxiaohui", 
        "https://www.zhihu.com/people/snap-39", 
        "https://www.zhihu.com/people/shi-lei-81-5", 
        "https://www.zhihu.com/people/__code__", 
        "https://www.zhihu.com/people/Ccsk", 
        "https://www.zhihu.com/people/qi-qi-deyi", 
        "https://www.zhihu.com/people/person", 
        "https://www.zhihu.com/people/cai-niao-98-80", 
        "https://www.zhihu.com/people/shui-guai-66-38", 
        "https://www.zhihu.com/people/roshanca", 
        "https://www.zhihu.com/people/ji-xu-shan-31", 
        "https://www.zhihu.com/people/yao-yao-56-13-29", 
        "https://www.zhihu.com/people/yi-wen-7-31", 
        "https://www.zhihu.com/people/cui-jiang-hong-54", 
        "https://www.zhihu.com/people/xin-yang-78-2", 
        "https://www.zhihu.com/people/evawa-wa-4", 
        "https://www.zhihu.com/people/wang-xiang-zhong-5", 
        "https://www.zhihu.com/people/zhu-zi-zhuan-shu", 
        "https://www.zhihu.com/people/xi-feng-wu-ding-14", 
        "https://www.zhihu.com/people/bug8bug", 
        "https://www.zhihu.com/people/cubesugarZhang", 
        "https://www.zhihu.com/people/csp1223", 
        "https://www.zhihu.com/people/promisezhang", 
        "https://www.zhihu.com/people/123456-36-71", 
        "https://www.zhihu.com/people/zhu-jiang-50-89", 
        "https://www.zhihu.com/people/CedricChan", 
        "https://www.zhihu.com/people/guo-fan-70", 
        "https://www.zhihu.com/people/chen-shi-meng-89", 
        "https://www.zhihu.com/people/fyh-47-23", 
        "https://www.zhihu.com/people/kk-kk-48-76", 
        "https://www.zhihu.com/people/mokiliy", 
        "https://www.zhihu.com/people/58fe", 
        "https://www.zhihu.com/people/chi-ruo-28", 
        "https://www.zhihu.com/people/leohxj", 
        "https://www.zhihu.com/people/alanzeng-69", 
        "https://www.zhihu.com/people/mo-yao-99", 
        "https://www.zhihu.com/people/wumingli", 
        "https://www.zhihu.com/people/ygnid", 
        "https://www.zhihu.com/people/liu-ji-16-2", 
        "https://www.zhihu.com/people/wo-you-bu-luan-lai-54-70", 
        "https://www.zhihu.com/people/wu-xin-ren-91", 
        "https://www.zhihu.com/people/gaozhongguoliu", 
        "https://www.zhihu.com/people/gou-dong-shan", 
        "https://www.zhihu.com/people/song-yang-17-25", 
        "https://www.zhihu.com/people/li-mu-41", 
        "https://www.zhihu.com/people/ping-ping-41-52", 
        "https://www.zhihu.com/people/deng-lei-87", 
        "https://www.zhihu.com/people/chen-guang-61-55", 
        "https://www.zhihu.com/people/mei-you-gu-shi-82-37", 
        "https://www.zhihu.com/people/zhang-qiang-24-82-46", 
        "https://www.zhihu.com/people/dou-dou-80-58-46", 
        "https://www.zhihu.com/people/qing-niao-93-12", 
        "https://www.zhihu.com/people/xu-yi-xin-98-59", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/andy-34-46", 
        "https://www.zhihu.com/people/shi-kong-19-16", 
        "https://www.zhihu.com/people/interjc", 
        "https://www.zhihu.com/people/fuping", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/jiang-qi-zheng-18", 
        "https://www.zhihu.com/people/likelxl", 
        "https://www.zhihu.com/people/luo-sheng-men-14", 
        "https://www.zhihu.com/people/sophiehui-64", 
        "https://www.zhihu.com/people/dreamhuan", 
        "https://www.zhihu.com/people/xu-ming-ming-78-15", 
        "https://www.zhihu.com/people/raise-guo", 
        "https://www.zhihu.com/people/heyang-36", 
        "https://www.zhihu.com/people/li-xu-94-13", 
        "https://www.zhihu.com/people/xu-qiang-29-78", 
        "https://www.zhihu.com/people/bao-gong-li", 
        "https://www.zhihu.com/people/chen-yi-liang-64-71", 
        "https://www.zhihu.com/people/zhang-zhi-hao-61", 
        "https://www.zhihu.com/people/Zuckjet", 
        "https://www.zhihu.com/people/ping-ping-34-66-66", 
        "https://www.zhihu.com/people/jsupot", 
        "https://www.zhihu.com/people/liu-min-72-21", 
        "https://www.zhihu.com/people/xie-yong-heng-15", 
        "https://www.zhihu.com/people/mello-55", 
        "https://www.zhihu.com/people/alexzhanghc", 
        "https://www.zhihu.com/people/alandong2016", 
        "https://www.zhihu.com/people/zhou-shuai-chao", 
        "https://www.zhihu.com/people/su-ze-lei", 
        "https://www.zhihu.com/people/knowledge-seeking", 
        "https://www.zhihu.com/people/cheng-xun-ri", 
        "https://www.zhihu.com/people/jason-59-32-47-12", 
        "https://www.zhihu.com/people/cang-hai-sang-tian-75-62", 
        "https://www.zhihu.com/people/huang-hun-20", 
        "https://www.zhihu.com/people/yuan-dai-ma-96-13", 
        "https://www.zhihu.com/people/jorden-chang", 
        "https://www.zhihu.com/people/SecondaryMarquis", 
        "https://www.zhihu.com/people/zyg666", 
        "https://www.zhihu.com/people/xiao-ma-que-icknnnn", 
        "https://www.zhihu.com/people/lin-hao-48-12", 
        "https://www.zhihu.com/people/li-zi-an-72", 
        "https://www.zhihu.com/people/jello-chen", 
        "https://www.zhihu.com/people/leng-chu-li-81", 
        "https://www.zhihu.com/people/su-jin-30-42", 
        "https://www.zhihu.com/people/syrxw", 
        "https://www.zhihu.com/people/longfangsong", 
        "https://www.zhihu.com/people/feng-xiao-li", 
        "https://www.zhihu.com/people/yh-ding", 
        "https://www.zhihu.com/people/su-ge-30-5", 
        "https://www.zhihu.com/people/dementia-dang", 
        "https://www.zhihu.com/people/yang-chao-3247", 
        "https://www.zhihu.com/people/ptos", 
        "https://www.zhihu.com/people/yuyesoup", 
        "https://www.zhihu.com/people/JeffJing", 
        "https://www.zhihu.com/people/da-da-83-97", 
        "https://www.zhihu.com/people/jacky-47-49-69"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/88170668", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 0, 
            "title": "读《JavaScript 轻量级函数式编程》", 
            "content": "<p></p><a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-4dad71953b4f3a5c60f78f9d15539666_180x120.jpg\" data-image-width=\"640\" data-image-height=\"512\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">夜曉宸</a><h2>读后感</h2><p>很久之前，组内分享过函数式编程的相关内容，听完之后的感受就是和没听没什么区别。函数式编程中有许多概念，对于熟悉和见惯面向对象编程的人来说，一时半会不能够消化。而且，就连值和引用、闭包等概念都分不清的人，对JavaScript 函数式编程的入门更是困难重重。<a href=\"https://link.zhihu.com/?target=https%3A//github.com/getify/Functional-Light-JS\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《Functional-Light JavaScript》</a>（中文翻译版<a href=\"https://link.zhihu.com/?target=https%3A//www.yexiaochen.com/%25E8%25AF%25BB%25E3%2580%258AJavaScript-%25E8%25BD%25BB%25E9%2587%258F%25E7%25BA%25A7%25E5%2587%25BD%25E6%2595%25B0%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E3%2580%258B/%23more\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《JavaScript 轻量级函数式编程》</a>）自称是轻量级的，抛开了概念的讲解，从为什么用，怎么用，最终呈现什么等几个方面带我们重新认识了函数这个基础且重要的概念。</p><h2>为什么函数式编程</h2><p>当下有三种编程范式，结构化编程、面向对象编程和函数式编程。虽然函数式编程是近些年才采用的编程范式，但是它的发明却是最早的。函数式编程概念是基于 𝛌 演算的直接衍生物，𝛌 演算法的一个核心思想是不变性。故，理论上讲，在函数式编程语言中应该不存在赋值语句的。</p><p>函数式编程的原则可以使得我们写出的代码是可读、可信任的，但这并不代表它是容易理解的。声明式的风格可以让我们知道程序是干什么的，但是要写出这样的程序却不是很容易理解的，起码对于刚接触函数式编程的人来说。</p><p>在维护代码的过程中，大部分时间是用来阅读和理解代码。有时候我们需要小心翼翼地阅读每一行代码，生怕某一个不为人知的骚操作会引发了一些列的 bug；有时候也需要在不同函数调用中了解程序的意图。总之，函数式编程的一些原则可以让我们写出可读性高、可验证的代码。当然，即便掌握了函数式编程，也并不意味着你一定得用它。</p><blockquote> 最好的代码是可读性高的代码，因为它在正确的（理想主义）和必然的（正确的）之间寻求到了恰到好处的平衡。</blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ca6de801be90f4a205bab730d992814d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb\" width=\"611\" data-original=\"https://pic2.zhimg.com/v2-ca6de801be90f4a205bab730d992814d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;611&#39; height=&#39;376&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"611\" data-original=\"https://pic2.zhimg.com/v2-ca6de801be90f4a205bab730d992814d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ca6de801be90f4a205bab730d992814d_b.jpg\"/></figure><h2>函数基础</h2><p>在数学中，函数总是获取一些输入值，然后返回一个输出值，输入值和输出值存在某种关系的映射。在函数式编程中使用的就是数学意义上的函数，接受输入值，明确 <code>return</code> 值。</p><p>函数通常是这个模样：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">foo</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"p\">,</span> <span class=\"nx\">z</span><span class=\"p\">){</span>\n    <span class=\"c1\">//  ...\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n<span class=\"nx\">foo</span><span class=\"p\">.</span><span class=\"nx\">length</span>  <span class=\"c1\">// 3\n</span><span class=\"c1\"></span><span class=\"nx\">foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">);</span>\n</code></pre></div><p><code>foo.length</code> 是函数期望的参数个数，通常就是形參个数。但是，并不要求实参和形參的个数相同，在函数内部可以通过 <code>arguments</code> 查看所有入參（箭头函数无此参数）。</p><p>使用 ES6 中的解构可以轻松给变量绑定入參的值：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">foo</span><span class=\"p\">([</span><span class=\"nx\">x</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">args</span><span class=\"p\">])</span> <span class=\"p\">{</span>\n    <span class=\"c1\">//  ...\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">foo</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">params</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"nx\">params</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">args</span> <span class=\"o\">=</span> <span class=\"nx\">params</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"c1\">//  ...\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>由以上对比，我们可以看出，声明式代码通常比命令式代码更干净。所以只要有可能，还是尽可能使用声明式和自解释的代码。</p><p>有时候函数会根据不同的输入值来重载不同的功能：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">foo</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">,</span><span class=\"nx\">y</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">typeof</span> <span class=\"nx\">x</span> <span class=\"o\">==</span> <span class=\"s2\">&#34;number&#34;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"k\">typeof</span> <span class=\"nx\">y</span> <span class=\"o\">==</span> <span class=\"s2\">&#34;number&#34;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nx\">x</span> <span class=\"o\">*</span> <span class=\"nx\">y</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nx\">x</span> <span class=\"o\">+</span> <span class=\"nx\">y</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这种设计虽然暂时很方便，但是对以后的功能添加或修改会带来很大的麻烦。</p><p>在上面已经提到函数要有明确的 <code>return</code> 值，如果函数内部改变了外层作用域的变量或引用类型的入參，那么这个函数就有了副作用的，对该函数外的环境造成了污染。我们希望函数是个没有副作用的函数，即纯函数。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">sum</span><span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">])</span> <span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n        <span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"nx\">total</span> <span class=\"o\">+</span> <span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"nx\">total</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">nums</span> <span class=\"o\">=</span> <span class=\"p\">[</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">27</span><span class=\"p\">,</span> <span class=\"p\">,</span> <span class=\"mi\">84</span> <span class=\"p\">];</span>\n\n<span class=\"nx\">sum</span><span class=\"p\">(</span> <span class=\"nx\">nums</span> <span class=\"p\">);</span>            <span class=\"c1\">// 124\n</span></code></pre></div><p>函数可以接受并返回任何类型的值，当这种类型的值恰好是函数时，它就叫高阶函数。而真正高阶的用法，就是闭包，它可以记录并且访问作用于外的变量，甚至该函数在不同作用域中被执行。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">runningCounter</span><span class=\"p\">(</span><span class=\"nx\">start</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">val</span> <span class=\"o\">=</span> <span class=\"nx\">start</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"kd\">function</span> <span class=\"nx\">current</span><span class=\"p\">(</span><span class=\"nx\">increment</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">){</span>\n        <span class=\"nx\">val</span> <span class=\"o\">=</span> <span class=\"nx\">val</span> <span class=\"o\">+</span> <span class=\"nx\">increment</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"nx\">val</span><span class=\"p\">;</span>\n    <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">score</span> <span class=\"o\">=</span> <span class=\"nx\">runningCounter</span><span class=\"p\">(</span> <span class=\"mi\">0</span> <span class=\"p\">);</span>\n\n<span class=\"nx\">score</span><span class=\"p\">();</span>                <span class=\"c1\">// 1\n</span><span class=\"c1\"></span><span class=\"nx\">score</span><span class=\"p\">();</span>                <span class=\"c1\">// 2\n</span><span class=\"c1\"></span><span class=\"nx\">score</span><span class=\"p\">(</span> <span class=\"mi\">13</span> <span class=\"p\">);</span>            <span class=\"c1\">// 15\n</span></code></pre></div><p>闭包中保存的变量并不会在函数执行后自动销毁，只要内部函数依然存在对变量的引用，变量就会一直保留。在函数式编程中，闭包是最重要的基础，所以，这个概念一定要理解。</p><p>还有的函数是没有名字的，这种函数称之为匿名函数，使用最多的是立即执行表达式：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(){</span>\n\n    <span class=\"c1\">// 我是 IIFE!\n</span><span class=\"c1\"></span>\n<span class=\"p\">})();</span>\n</code></pre></div><p>命名函数的好处有很多，可以在堆栈中方便调试，可以通过名字引用自身等。但并不是所有的函数都可以命名的，箭头函数可以说是十分简洁，可以使用最简单的符号来表示一个函数。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">people</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span> <span class=\"nx\">person</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">nicknames</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">||</span> <span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">firstName</span> <span class=\"p\">);</span>\n</code></pre></div><p>箭头函数除了写法简洁之外，还有一个可以称之为好处的便是 <code>this</code>。箭头函数中的 <code>this</code> 是基于作用域的，是可以预测的。而对于普通函数，<code>this</code> 是动态绑定的，是基于调用者的。不管是哪一种 <code>this</code>， 我们还是希望能够显式地表示上下文。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">sum</span><span class=\"p\">(</span><span class=\"nx\">ctx</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">ctx</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">+</span> <span class=\"nx\">ctx</span><span class=\"p\">.</span><span class=\"nx\">y</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">context</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"nx\">y</span><span class=\"o\">:</span> <span class=\"mi\">2</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">sum</span><span class=\"p\">(</span> <span class=\"nx\">context</span> <span class=\"p\">);</span>\n</code></pre></div><h2>函数的输入</h2><p>在程序中往往将不变的封装起来，变化的隔离开来。很多时候不变的包括一些预设的参数。</p><p>首先封装一个请求函数：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 步骤一：\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">ajax</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">,</span><span class=\"nx\">data</span><span class=\"p\">,</span><span class=\"nx\">callback</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// ..\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>对于不同的请求，有不同的 url 或参数：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 步骤二：\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">getPerson</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">,</span><span class=\"nx\">cb</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">ajax</span><span class=\"p\">(</span> <span class=\"s2\">&#34;http://some.api/person&#34;</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">,</span> <span class=\"nx\">cb</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">getOrder</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">,</span><span class=\"nx\">cb</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">ajax</span><span class=\"p\">(</span> <span class=\"s2\">&#34;http://some.api/order&#34;</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">,</span> <span class=\"nx\">cb</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>url 就是预设的参数，而剩余的参数在调用的时候传入。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 步骤三：\n</span><span class=\"c1\"></span><span class=\"nx\">getPerson</span><span class=\"p\">(</span> <span class=\"p\">{</span> <span class=\"nx\">user</span><span class=\"o\">:</span> <span class=\"nx\">CURRENT_USER_ID</span> <span class=\"p\">},</span> <span class=\"nx\">cb</span> <span class=\"p\">);</span>\n</code></pre></div><p>仔细观察步骤二，代码似乎还可以提炼下：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 步骤二：\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">partial</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">fn</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">presetArgs</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span>\n                <span class=\"p\">(...</span><span class=\"nx\">laterArgs</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> \n                    <span class=\"nx\">fn</span><span class=\"p\">(...</span><span class=\"nx\">presetArgs</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">laterArgs</span><span class=\"p\">);</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">getPerson</span> <span class=\"o\">=</span> <span class=\"nx\">partial</span><span class=\"p\">(</span><span class=\"nx\">ajax</span><span class=\"p\">,</span> <span class=\"s2\">&#34;http://some.api/person&#34;</span><span class=\"p\">);</span>\n<span class=\"kd\">var</span> <span class=\"nx\">getOrder</span> <span class=\"o\">=</span> <span class=\"nx\">partial</span><span class=\"p\">(</span><span class=\"nx\">ajax</span><span class=\"p\">,</span> <span class=\"s2\">&#34;http://some.api/order&#34;</span><span class=\"p\">);</span>\n</code></pre></div><p>步骤二的转换就是偏函数的应用，它是通过预设参数的方式来减少入參的数量。如果颠倒入參的顺序，就成了右偏函数。</p><p>同样是对函数输入管理的技术，即柯里化，该技术将一个接受多个实参的函数拆解成连续的链式函数，每个链式函数接受单一实参并返回接受下一个实参的函数。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">sum</span><span class=\"p\">(...</span><span class=\"nx\">args</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">sum</span> <span class=\"o\">+=</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nx\">sum</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">sum</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span> <span class=\"p\">);</span> \n\n<span class=\"c1\">// 柯里化\n</span><span class=\"c1\"></span>\n<span class=\"kd\">var</span> <span class=\"nx\">curry</span> <span class=\"o\">=</span>\n    <span class=\"p\">(</span><span class=\"nx\">fn</span><span class=\"p\">,</span> <span class=\"nx\">arity</span> <span class=\"o\">=</span> <span class=\"nx\">fn</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">,</span> <span class=\"nx\">nextCurried</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span>\n        <span class=\"p\">(</span><span class=\"nx\">nextCurried</span> <span class=\"o\">=</span> <span class=\"nx\">prevArgs</span> <span class=\"p\">=&gt;</span>\n            <span class=\"nx\">nextArg</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n                <span class=\"kd\">var</span> <span class=\"nx\">args</span> <span class=\"o\">=</span> <span class=\"nx\">prevArgs</span><span class=\"p\">.</span><span class=\"nx\">concat</span><span class=\"p\">(</span> <span class=\"p\">[</span><span class=\"nx\">nextArg</span><span class=\"p\">]</span> <span class=\"p\">);</span>\n                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">&gt;=</span> <span class=\"nx\">arity</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                    <span class=\"k\">return</span> <span class=\"nx\">fn</span><span class=\"p\">(</span> <span class=\"p\">...</span><span class=\"nx\">args</span> <span class=\"p\">);</span>\n                <span class=\"p\">}</span>\n                <span class=\"k\">else</span> <span class=\"p\">{</span>\n                    <span class=\"k\">return</span> <span class=\"nx\">nextCurried</span><span class=\"p\">(</span> <span class=\"nx\">args</span> <span class=\"p\">);</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">)(</span> <span class=\"p\">[]</span> <span class=\"p\">);</span>\n\n<span class=\"c1\">// (5 用来指定需要链式调用的次数)\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">curriedSum</span> <span class=\"o\">=</span> <span class=\"nx\">curry</span><span class=\"p\">(</span> <span class=\"nx\">sum</span><span class=\"p\">,</span> <span class=\"mi\">5</span> <span class=\"p\">);</span>\n<span class=\"nx\">curriedSum</span><span class=\"p\">(</span> <span class=\"mi\">1</span> <span class=\"p\">)(</span> <span class=\"mi\">2</span> <span class=\"p\">)(</span> <span class=\"mi\">3</span> <span class=\"p\">)(</span> <span class=\"mi\">4</span> <span class=\"p\">)(</span> <span class=\"mi\">5</span> <span class=\"p\">);</span>\n</code></pre></div><p>从以上的代码可以发现，无论是偏函数还是柯里化，都是收齐所有的实参后才执行原函数，也就是说没必要一次性传入所有的参数，而且柯里化这种只接受单一参数的特性在后面的组合函数中也起着很重要的作用。</p><p>函数式编程可以说在参数上下了很大的功夫，甚至还有种称之为无形參的风格，其目的就是移除非必要的形參到实参之间的映射。无形參风格是否提高了代码的可读性，有没有必要使用无形參风格，还需要你自己去定夺。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"kr\">double</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">].</span><span class=\"nx\">map</span><span class=\"p\">(</span> <span class=\"kd\">function</span> <span class=\"nx\">mapper</span><span class=\"p\">(</span><span class=\"nx\">v</span><span class=\"p\">){</span>\n    <span class=\"k\">return</span> <span class=\"kr\">double</span><span class=\"p\">(</span> <span class=\"nx\">v</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span> <span class=\"p\">);</span>\n\n<span class=\"c1\">// 无形參风格；\n</span><span class=\"c1\"></span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">].</span><span class=\"nx\">map</span><span class=\"p\">(</span> <span class=\"kr\">double</span> <span class=\"p\">);</span>\n</code></pre></div><h2>组合函数</h2><p>函数组合，就是把上一个函数的输出值作为下一个函数的输入值，并以此持续下去。</p><p>看个例子，将一句话拆分为单词数组：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 转小写，过虑出单词；\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">words</span><span class=\"p\">(</span><span class=\"nx\">str</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nb\">String</span><span class=\"p\">(</span> <span class=\"nx\">str</span> <span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"nx\">toLowerCase</span><span class=\"p\">()</span>\n        <span class=\"p\">.</span><span class=\"nx\">split</span><span class=\"p\">(</span> <span class=\"sr\">/\\s|\\b/</span> <span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"nx\">filter</span><span class=\"p\">(</span> <span class=\"kd\">function</span> <span class=\"nx\">alpha</span><span class=\"p\">(</span><span class=\"nx\">v</span><span class=\"p\">){</span>\n            <span class=\"k\">return</span> <span class=\"sr\">/^[\\w]+$/</span><span class=\"p\">.</span><span class=\"nx\">test</span><span class=\"p\">(</span> <span class=\"nx\">v</span> <span class=\"p\">);</span>\n        <span class=\"p\">}</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 去重；\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">unique</span><span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">uniqList</span> <span class=\"o\">=</span> <span class=\"p\">[];</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// value not yet in the new list?\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">uniqList</span><span class=\"p\">.</span><span class=\"nx\">indexOf</span><span class=\"p\">(</span> <span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]</span> <span class=\"p\">)</span> <span class=\"o\">===</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nx\">uniqList</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span> <span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]</span> <span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"nx\">uniqList</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"kd\">var</span> <span class=\"nx\">text</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;To compose two functions together, pass the \\\n</span><span class=\"s2\">output of the first function call as the input of the \\\n</span><span class=\"s2\">second function call.&#34;</span><span class=\"p\">;</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">uniqueWords</span><span class=\"p\">(</span><span class=\"nx\">str</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">unique</span><span class=\"p\">(</span> <span class=\"nx\">words</span><span class=\"p\">(</span> <span class=\"nx\">str</span> <span class=\"p\">)</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">wordsUsed</span> <span class=\"o\">=</span> <span class=\"nx\">uniqueWords</span><span class=\"p\">(</span><span class=\"nx\">text</span><span class=\"p\">);</span>\n<span class=\"c1\">// [&#34;to&#34;,&#34;compose&#34;,&#34;two&#34;,&#34;functions&#34;,&#34;together&#34;,&#34;pass&#34;,\n</span><span class=\"c1\">// &#34;the&#34;,&#34;output&#34;,&#34;of&#34;,&#34;first&#34;,&#34;function&#34;,&#34;call&#34;,&#34;as&#34;,\n</span><span class=\"c1\">// &#34;input&#34;,&#34;second&#34;]\n</span></code></pre></div><p>数据的流向：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">wordsUsed</span> <span class=\"o\">&lt;--</span> <span class=\"nx\">unique</span> <span class=\"o\">&lt;--</span> <span class=\"nx\">words</span> <span class=\"o\">&lt;--</span> <span class=\"nx\">text</span>\n</code></pre></div><p>但是函数式编程喜欢声明式风格，关注点在是什么而不是怎么做，我们不需要知道具体的实现细节。我们希望是这样的：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 命令式\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">shorterWords</span><span class=\"p\">(</span><span class=\"nx\">text</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">skipLongWords</span><span class=\"p\">(</span> <span class=\"nx\">unique</span><span class=\"p\">(</span> <span class=\"nx\">words</span><span class=\"p\">(</span> <span class=\"nx\">text</span> <span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 声明式\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">shorterWords</span> <span class=\"o\">=</span> <span class=\"nx\">compose</span><span class=\"p\">(</span> <span class=\"nx\">skipLongWords</span><span class=\"p\">,</span> <span class=\"nx\">unique</span><span class=\"p\">,</span> <span class=\"nx\">words</span> <span class=\"p\">);</span>\n</code></pre></div><p>如何实现函数 <code>compose</code> ？</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 写法一：\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">compose</span> <span class=\"o\">=</span>\n    <span class=\"p\">(...</span><span class=\"nx\">fns</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span>\n        <span class=\"nx\">result</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n            <span class=\"kd\">var</span> <span class=\"nx\">list</span> <span class=\"o\">=</span> <span class=\"nx\">fns</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">();</span>\n\n            <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 将最后一个函数从列表尾部拿出\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 并执行它\n</span><span class=\"c1\"></span>                <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">pop</span><span class=\"p\">()(</span> <span class=\"nx\">result</span> <span class=\"p\">);</span>\n            <span class=\"p\">}</span>\n\n            <span class=\"k\">return</span> <span class=\"nx\">result</span><span class=\"p\">;</span>\n        <span class=\"p\">};</span>\n\n<span class=\"c1\">// 写法二：\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">compose</span> <span class=\"o\">=</span>\n    <span class=\"p\">(...</span><span class=\"nx\">fns</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span>\n        <span class=\"nx\">fns</span><span class=\"p\">.</span><span class=\"nx\">reverse</span><span class=\"p\">().</span><span class=\"nx\">reduce</span><span class=\"p\">(</span> <span class=\"p\">(</span><span class=\"nx\">fn1</span><span class=\"p\">,</span><span class=\"nx\">fn2</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span>\n            <span class=\"p\">(...</span><span class=\"nx\">args</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span>\n                <span class=\"nx\">fn2</span><span class=\"p\">(</span> <span class=\"nx\">fn1</span><span class=\"p\">(</span> <span class=\"p\">...</span><span class=\"nx\">args</span> <span class=\"p\">)</span> <span class=\"p\">)</span>\n        <span class=\"p\">);</span>\n\n<span class=\"c1\">// 写法三：\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">compose</span> <span class=\"o\">=</span>\n    <span class=\"p\">(...</span><span class=\"nx\">fns</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 拿出最后两个参数\n</span><span class=\"c1\"></span>        <span class=\"kd\">var</span> <span class=\"p\">[</span> <span class=\"nx\">fn1</span><span class=\"p\">,</span> <span class=\"nx\">fn2</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">rest</span> <span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">fns</span><span class=\"p\">.</span><span class=\"nx\">reverse</span><span class=\"p\">();</span>\n\n        <span class=\"kd\">var</span> <span class=\"nx\">composedFn</span> <span class=\"o\">=</span>\n            <span class=\"p\">(...</span><span class=\"nx\">args</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span>\n                <span class=\"nx\">fn2</span><span class=\"p\">(</span> <span class=\"nx\">fn1</span><span class=\"p\">(</span> <span class=\"p\">...</span><span class=\"nx\">args</span> <span class=\"p\">)</span> <span class=\"p\">);</span>\n\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">rest</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nx\">composedFn</span><span class=\"p\">;</span>\n\n        <span class=\"k\">return</span> <span class=\"nx\">compose</span><span class=\"p\">(</span> <span class=\"p\">...</span><span class=\"nx\">rest</span><span class=\"p\">.</span><span class=\"nx\">reverse</span><span class=\"p\">(),</span> <span class=\"nx\">composedFn</span> <span class=\"p\">);</span>\n    <span class=\"p\">};</span>\n</code></pre></div><h2>副作用和值的不可变性</h2><p><code>const</code> 是用来声明一个常量的，而常量就是不允许被重新赋值的变量。在排查问题的时，我们很少将注意力放在由 const 声明的变量上，毕竟它就是一个无关痛痒的常量。如果最终就是因为这个常量发生了变化，会不会很刺激？！虽然 const 声明的是常量，但是对于引用类型的值，程序还是允许它改变的。因为 const 的不靠谱，我们不得不重新关注由它声明的常量。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"p\">[</span> <span class=\"mi\">2</span> <span class=\"p\">];</span>\n<span class=\"nx\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n</code></pre></div><p>数据的突变引发了一系列意想不到的 bug，究其原因，是变量被共享或有着不同的用处。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">var</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"nx\">foo</span><span class=\"p\">();</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span> <span class=\"nx\">x</span> <span class=\"p\">);</span>\n\n<span class=\"nx\">bar</span><span class=\"p\">();</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span> <span class=\"nx\">x</span> <span class=\"p\">);</span>\n\n<span class=\"nx\">baz</span><span class=\"p\">();</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span> <span class=\"nx\">x</span> <span class=\"p\">);</span>\n</code></pre></div><p>当变量被共享时（在函数 <code>foo()</code>、<code>bar()</code>、<code>baz()</code> 中，任何一个函数都有可能改变变量 x），最终我们无法确认 x 到底是什么值，为了追踪变量 x 的变化，我们不得不仔细逐个阅读函数 <code>foo()</code>、<code>bar()</code>、<code>baz()</code>。显而易见，这给我们阅读理解代码带来了很大的麻烦。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">sum</span><span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">])</span> <span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n        <span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"nx\">total</span> <span class=\"o\">+</span> <span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"nx\">total</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">nums</span> <span class=\"o\">=</span> <span class=\"p\">[</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">27</span><span class=\"p\">,</span> <span class=\"p\">,</span> <span class=\"mi\">84</span> <span class=\"p\">];</span>\n\n<span class=\"nx\">sum</span><span class=\"p\">(</span> <span class=\"nx\">nums</span> <span class=\"p\">);</span>            <span class=\"c1\">// 124\n</span><span class=\"c1\"></span>\n<span class=\"nx\">sums</span><span class=\"p\">;</span>    <span class=\"c1\">//[1, 3, 9, 27, 0, 84]\n</span></code></pre></div><p>而对于引用同一对象的不同变量，对象的改变也是同步的，这种改变往往是不易察觉的。所以，对于引用类型的特殊性，需要特别注意的。</p><p>归纳一下，什么样的变量被共享时需要额外上心的，外层作用域里的变量和引用类型的变量。</p><p>如何避免这种数据突变带来的状态紊乱的？可以想到的是将变量变成只读的或重新拷贝一份以作区别。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">var</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">freeze</span><span class=\"p\">(</span> <span class=\"p\">[</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]</span> <span class=\"p\">]</span> <span class=\"p\">);</span>\n\n<span class=\"c1\">// 不允许改变：\n</span><span class=\"c1\"></span><span class=\"nx\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">42</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// oops，仍然允许改变：\n</span><span class=\"c1\"></span><span class=\"nx\">x</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">42</span><span class=\"p\">;</span>\n</code></pre></div><p>我们可以使用 <code>Object.freeze</code> 等 API 将数据转为不可变，但是这种 API 的还是有局限性的，只能浅层限制不可变。要想使得一个深层嵌套的对象不可变，就需要深度遍历对每个属性使用 <code>Object.freeze</code> 等 API。</p><p>另一种思路就是拷贝一份数据，这样的话，再怎么折腾副本都不会影响到源数据。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">addValue</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">newArr</span> <span class=\"o\">=</span> <span class=\"p\">[</span> <span class=\"p\">...</span><span class=\"nx\">arr</span><span class=\"p\">,</span> <span class=\"mi\">4</span> <span class=\"p\">];</span>\n    <span class=\"k\">return</span> <span class=\"nx\">newArr</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">addValue</span><span class=\"p\">(</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"p\">);</span>    <span class=\"c1\">// [1,2,3,4]\n</span></code></pre></div><p>在此，我们不由地想起函数式编程的核心 —— 不变性。我们看到了变化的数据给程序造成的可读性差、状态紊乱等坏处，自然我们就想到数据不变性会让程序更加友好。但值的不变性并不意味着值代表的状态不会发生改变，所以就有了值的拷贝。这种不变性是指，当需要改变程序中某个状态时，我们不能改变源数据，而是拷贝跟踪它的副本。拷贝也有深拷贝和浅拷贝，我们需要的是独立于源数据的副本。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">updateLastLogin</span><span class=\"p\">(</span><span class=\"nx\">user</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">newUserRecord</span> <span class=\"o\">=</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">assign</span><span class=\"p\">(</span> <span class=\"p\">{},</span> <span class=\"nx\">user</span> <span class=\"p\">);</span>\n    <span class=\"nx\">newUserRecord</span><span class=\"p\">.</span><span class=\"nx\">lastLogin</span> <span class=\"o\">=</span> <span class=\"nb\">Date</span><span class=\"p\">.</span><span class=\"nx\">now</span><span class=\"p\">();</span>\n    <span class=\"k\">return</span> <span class=\"nx\">newUserRecord</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">user</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// ..\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n\n<span class=\"nx\">user</span> <span class=\"o\">=</span> <span class=\"nx\">updateLastLogin</span><span class=\"p\">(</span> <span class=\"nx\">user</span> <span class=\"p\">);</span>\n</code></pre></div><p>然而，拷贝也不是没有代价的。突然多出来的副本，多少会影响到性能。我们希望有种方式可以减少内存占用，提高性能。它使得不同变量指向同一个数据源同时有着不同版本的数据，不同版本的数据互不影响，这有点像 git 的版本控制，这样的话，值的不变性这个语义也得以保留。其实已经有一些库实现了类似的优化，如 Immutable.js 等。</p><p>如果用两个字总结以上的内容，无疑，就是「干扰」了，这种干扰来自于非预期的数据变化。</p><p>作为函数式编程的主角 —— 函数，我们自然也会希望函数内部不会造成数据的突变，一切结果是可预测的，更多的希望它能够符合函数式编程的核心 —— 不变性。也就是说，我们在编码的过程中要减少函数的副作用。</p><p>除了以上所说的数据共享，副作用还包括随机性 （<code>Math.random()</code>）、IO 操作、竞态问题等。副作用是多种多样，我们使用纯函数来减少这种副作用。换句话说，与纯函数相违背的，我们基本可以认为是副作用。</p><p>什么是纯函数？有说纯函数就是幂等函数，但并不是所有的纯函数都是数学概念上的幂等。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">var</span> <span class=\"nx\">hist</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">getElementById</span><span class=\"p\">(</span> <span class=\"s2\">&#34;orderHistory&#34;</span> <span class=\"p\">);</span>\n\n<span class=\"c1\">// 幂等的：\n</span><span class=\"c1\"></span><span class=\"nx\">hist</span><span class=\"p\">.</span><span class=\"nx\">innerHTML</span> <span class=\"o\">=</span> <span class=\"nx\">order</span><span class=\"p\">.</span><span class=\"nx\">historyText</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// 非幂等的：\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">update</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">createTextNode</span><span class=\"p\">(</span> <span class=\"nx\">order</span><span class=\"p\">.</span><span class=\"nx\">latestUpdate</span> <span class=\"p\">);</span>\n<span class=\"nx\">hist</span><span class=\"p\">.</span><span class=\"nx\">appendChild</span><span class=\"p\">(</span> <span class=\"nx\">update</span> <span class=\"p\">);</span>\n\n<span class=\"c1\">// 非幂等的：\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">calculateAverage</span><span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">sum</span> <span class=\"o\">+=</span> <span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nx\">sum</span> <span class=\"o\">/</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">calculateAverage</span><span class=\"p\">(</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"mi\">22</span><span class=\"p\">]</span> <span class=\"p\">);</span>            <span class=\"c1\">// 9\n</span></code></pre></div><p>另一种定义函数的方法是，给定相同的输入（一个或多个），它总是产生相同的输出。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">PI</span> <span class=\"o\">=</span> <span class=\"mf\">3.141592</span><span class=\"p\">;</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">circleArea</span><span class=\"p\">(</span><span class=\"nx\">radius</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">PI</span> <span class=\"o\">*</span> <span class=\"nx\">radius</span> <span class=\"o\">*</span> <span class=\"nx\">radius</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>还有一种定义就是，即纯函数具有引用透明性。</p><blockquote> 引用透明性是指一个函数调用可以被它的输出值所代替，并且整个程序的行为不会改变。换句话说，不可能从程序的执行中分辨出函数调用是被执行的，还是它的返回值是在函数调用的位置上内联的。<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">calculateAverage</span><span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">sum</span> <span class=\"o\">+=</span> <span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nx\">sum</span> <span class=\"o\">/</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">nums</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"mi\">22</span><span class=\"p\">];</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">avg</span> <span class=\"o\">=</span> <span class=\"nx\">calculateAverage</span><span class=\"p\">(</span> <span class=\"nx\">nums</span> <span class=\"p\">);</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span> <span class=\"s2\">&#34;The average is:&#34;</span><span class=\"p\">,</span> <span class=\"nx\">avg</span> <span class=\"p\">);</span>        <span class=\"c1\">// The average is: 9\n</span><span class=\"c1\"></span>\n<span class=\"kd\">var</span> <span class=\"nx\">avg</span> <span class=\"o\">=</span> <span class=\"mi\">9</span><span class=\"p\">;</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span> <span class=\"s2\">&#34;The average is:&#34;</span><span class=\"p\">,</span> <span class=\"nx\">avg</span> <span class=\"p\">);</span>        <span class=\"c1\">// The average is: 9\n</span></code></pre></div><p>代码的副作用降低了程序的质量，同时也加大了我们对代码的阅读难度。没有副作用的程序是不存在的，我们只是通过重构不纯的函数或封装副作用等方式来避免副作用的产生。</p><h2>闭包和对象</h2><p>首先用两段代码来描述同一个东西：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 闭包方式\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">person</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">,</span><span class=\"nx\">age</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">happyBirthday</span><span class=\"p\">(){</span>\n        <span class=\"nx\">age</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span>\n            <span class=\"s2\">&#34;Happy &#34;</span> <span class=\"o\">+</span> <span class=\"nx\">age</span> <span class=\"o\">+</span> <span class=\"s2\">&#34;th Birthday, &#34;</span> <span class=\"o\">+</span> <span class=\"nx\">name</span> <span class=\"o\">+</span> <span class=\"s2\">&#34;!&#34;</span>\n        <span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">var</span> <span class=\"nx\">birthdayBoy</span> <span class=\"o\">=</span> <span class=\"nx\">person</span><span class=\"p\">(</span> <span class=\"s2\">&#34;Kyle&#34;</span><span class=\"p\">,</span> <span class=\"mi\">36</span> <span class=\"p\">);</span>\n<span class=\"nx\">birthdayBoy</span><span class=\"p\">();</span>            <span class=\"c1\">// Happy 37th Birthday, Kyle!\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// 对象方式\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">birthdayBoy</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s2\">&#34;Kyle&#34;</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"mi\">36</span><span class=\"p\">,</span>\n    <span class=\"nx\">happyBirthday</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">age</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span>\n            <span class=\"s2\">&#34;Happy &#34;</span> <span class=\"o\">+</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">age</span> <span class=\"o\">+</span> <span class=\"s2\">&#34;th Birthday, &#34;</span> <span class=\"o\">+</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">+</span> <span class=\"s2\">&#34;!&#34;</span>\n        <span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"nx\">birthdayBoy</span><span class=\"p\">.</span><span class=\"nx\">happyBirthday</span><span class=\"p\">();</span>\n<span class=\"c1\">// Happy 37th Birthday, Kyle!\n</span></code></pre></div><p>可以发现闭包和对象就是对同一事物的两种表达方式。</p><p>关于闭包和对象有着以下的论调： 1. 一个没有闭包的编程语言可以用对象来模拟闭包。 2. 一个没有对象的编程语言可以用表报模拟对象。</p><p>现在，我们在 JavaScript 中用对象模拟闭包。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">outer</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"kd\">function</span> <span class=\"nx\">inner</span><span class=\"p\">(){</span>\n        <span class=\"k\">return</span> <span class=\"nx\">x</span><span class=\"p\">;</span>\n    <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>首先要解决 <code>outer()</code> 执行后，<code>x</code> 变量没有被销毁。在创建函数 <code>outer</code> 时，有个对象会保存该作用域下的所有变量:</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">scopeOfOuter</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>在创建函数 <code>inner</code> 时，也会生成一个 <code>scopeOfInner</code> 的作用域对象，这个对象的原型指向 <code>scopeOfOuter</code>：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">scopeOfInner</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n<span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">setPrototypeOf</span><span class=\"p\">(</span> <span class=\"nx\">scopeOfInner</span><span class=\"p\">,</span> <span class=\"nx\">scopeOfOuter</span> <span class=\"p\">);</span>\n</code></pre></div><p>所以在访问 x 变量时，更像是在访问 scopeOfInner.x，然后沿原型链查找。</p><p>以上只是些假设，真实的情况肯定比这复杂。这里只是论证可以使用对象实现闭包，同样我们也可以使用闭包实现对象。</p><h2>递归</h2><p>递归可以说是很函数式，它的优点是更具有声明行，简洁易读，但最大的弊端还是内存占用方面。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">foo</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">z</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;foo!&#34;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">bar</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;bar!&#34;</span><span class=\"p\">;</span>\n    <span class=\"nx\">foo</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">baz</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;baz!&#34;</span><span class=\"p\">;</span>\n    <span class=\"nx\">bar</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">baz</span><span class=\"p\">();</span>\n</code></pre></div><p>每个函数调用都将开辟出一小块称为堆栈帧的内存。堆栈帧中包含了函数语句当前状态的某些重要信息，包括任意变量的值。之所以这样，是因为一个函数暂停去执行另外一个函数，而另外一个函数运行结束后，引擎需要返回到之前暂停时候的状态继续执行。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f91c46736c058476295d437120d02590_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb\" width=\"603\" data-original=\"https://pic1.zhimg.com/v2-f91c46736c058476295d437120d02590_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;603&#39; height=&#39;267&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"603\" data-original=\"https://pic1.zhimg.com/v2-f91c46736c058476295d437120d02590_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f91c46736c058476295d437120d02590_b.jpg\"/></figure><p>但是对于递归来说，可能会生成上万的堆栈，最终会导致爆栈。</p><p>我们希望内层函数在函数底部调用时，外部函数的堆栈直接弹出。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5a84778d82954ae0d1ed98201f03e0f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb\" width=\"603\" data-original=\"https://pic2.zhimg.com/v2-5a84778d82954ae0d1ed98201f03e0f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;603&#39; height=&#39;267&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"603\" data-original=\"https://pic2.zhimg.com/v2-5a84778d82954ae0d1ed98201f03e0f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5a84778d82954ae0d1ed98201f03e0f9_b.jpg\"/></figure><p>这种技术叫做尾调用优化。</p><p>减少内存的方法还包括后继传递风格（CPS）和 Trampoline 等。</p><blockquote> 利用CPS变换，把任意递归函数改写成尾调用形式，以 continuation 链的形式，将递归占用的栈空间转移到堆上，避免爆栈的悲剧。（<a href=\"https://www.zhihu.com/question/28458981\" class=\"internal\">CPS变换可以用来将普通递归转变为尾递归？？</a>）<br/>在缺乏尾调用优化的语言中，并不知晓函数不会返回，状态、参数压栈依旧会发生，因此需要手动强制弹出下一层调用的函数，禁止解释器的压栈行为，这就是所谓的Trampoline。 </blockquote><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 斐波那契\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">fib</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">n</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nx\">n</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"nx\">fib</span><span class=\"p\">(</span> <span class=\"nx\">n</span> <span class=\"o\">-</span> <span class=\"mi\">2</span> <span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nx\">fib</span><span class=\"p\">(</span> <span class=\"nx\">n</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">//  CPS\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">fib</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">,</span><span class=\"nx\">cont</span> <span class=\"o\">=</span> <span class=\"nx\">r</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">n</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nx\">cont</span><span class=\"p\">(</span> <span class=\"nx\">n</span> <span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"nx\">fib</span><span class=\"p\">(</span>\n        <span class=\"nx\">n</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n        <span class=\"nx\">n2</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">fib</span><span class=\"p\">(</span>\n            <span class=\"nx\">n</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n            <span class=\"nx\">n1</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">cont</span><span class=\"p\">(</span> <span class=\"nx\">n2</span> <span class=\"o\">+</span> <span class=\"nx\">n1</span> <span class=\"p\">)</span>\n        <span class=\"p\">)</span>\n    <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">trampoline</span><span class=\"p\">(</span><span class=\"nx\">fn</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"kd\">function</span> <span class=\"nx\">trampolined</span><span class=\"p\">(...</span><span class=\"nx\">args</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kd\">var</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">fn</span><span class=\"p\">(</span> <span class=\"p\">...</span><span class=\"nx\">args</span> <span class=\"p\">);</span>\n\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"k\">typeof</span> <span class=\"nx\">result</span> <span class=\"o\">==</span> <span class=\"s2\">&#34;function&#34;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">result</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"k\">return</span> <span class=\"nx\">result</span><span class=\"p\">;</span>\n    <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// trampoline 化\n</span><span class=\"c1\"></span><span class=\"nx\">trampoline</span><span class=\"p\">(</span><span class=\"nx\">fib</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">,</span><span class=\"nx\">cont</span> <span class=\"o\">=</span> <span class=\"nx\">r</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">n</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nx\">cont</span><span class=\"p\">(</span> <span class=\"nx\">n</span> <span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">fib</span><span class=\"p\">(</span>\n        <span class=\"nx\">n</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n        <span class=\"nx\">n2</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">fib</span><span class=\"p\">(</span>\n            <span class=\"nx\">n</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n            <span class=\"nx\">n1</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">cont</span><span class=\"p\">(</span> <span class=\"nx\">n2</span> <span class=\"o\">+</span> <span class=\"nx\">n1</span> <span class=\"p\">)</span>\n        <span class=\"p\">)</span>\n    <span class=\"p\">);</span>\n<span class=\"p\">})</span>\n</code></pre></div><h2>文末</h2><p>书中还有其它章节，大部分属于实操，按下不表。对于 JavaScript 函数式编程入门，本书倒是一个不错的选择。</p>", 
            "topic": [
                {
                    "tag": "函数式编程", 
                    "tagLink": "https://api.zhihu.com/topics/19585411"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "leshao", 
                    "userLink": "https://www.zhihu.com/people/ca274241d95e0c5b7a2d7da8c3d981ac", 
                    "content": "函数闭包作为函数式编程的例子不是很好。作为函数给定确定的输入就应该有确定的输出。这个例子中score（）每次运行输出都不同。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "<p>懂你，可闭包是作为函数基础的一部分，这里只是单纯讲述闭包的概念。而且下文也有展开说明副作用和纯函数的概念。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "leshao"
                        }
                    ]
                }, 
                {
                    "userName": "leshao", 
                    "userLink": "https://www.zhihu.com/people/ca274241d95e0c5b7a2d7da8c3d981ac", 
                    "content": "用一些经典的例子解释闭包也可以，比如循环延时函数赋值的问题<br>for(var i=0;i&lt;5;i++){<br>  setTimeout(alert(i),1000);<br>}<br>这个会弹5次5，如果要弹01234就要用闭包了。当然现在ES6直接用let解决了，不过它作为一个闭包的例子还是挺好的。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "<p>你想说的是 <br>for(var i=0;i&lt;5;i++){<br>setTimeout(() =&gt; alert(i),1000);<br>} 吧，<br>是的，闭包就是作用域的产物，函数内部全部指向了同一个变量，所以更新也是同步的。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "leshao"
                        }, 
                        {
                            "userName": "leshao", 
                            "userLink": "https://www.zhihu.com/people/ca274241d95e0c5b7a2d7da8c3d981ac", 
                            "content": "嗯，手机打字不方便。", 
                            "likes": 0, 
                            "replyToAuthor": "曉宸"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85836269", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 10, 
            "title": "JavaScript 引擎原理（三）", 
            "content": "<p>通过以下方式<b>查看大图</b></p><a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-4dad71953b4f3a5c60f78f9d15539666_180x120.jpg\" data-image-width=\"640\" data-image-height=\"512\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">夜曉宸</a><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/user/57f1dbf5bf22ec00645dfc31/posts\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">曉宸 的个人主页 - 专栏 - 掘金</a><h2>前言</h2><p>本文是根据自己的理解翻译而来，如有疑惑可查看原文 <a href=\"https://link.zhihu.com/?target=https%3A//v8.dev/blog/react-cliff\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The story of a V8 performance cliff in React</a>。</p><p>本次暂定翻译三篇文章： </p><p>1. <a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/shapes-ics\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript engine fundamentals: Shapes and Inline Caches</a>(Published 14th June 2018) </p><p>2. <a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/prototypes\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript engine fundamentals: optimizing prototypes</a>(Published 16th August 2018)</p><p> 3. <a href=\"https://link.zhihu.com/?target=https%3A//v8.dev/blog/react-cliff\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The story of a V8 performance cliff in React</a>(Published 28 August 2019)</p><h2>JavaScript types</h2><p>在 JavaScript 中，值有 8 总类型（当前）：<code>Number</code>，<code>String</code>，<code>Symbol</code>，<code>BigInt</code>，<code>Boolean</code>，<code>Undefined</code>，<code>Null</code>，<code>Object</code>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-38fe4de60875923053a105d3a1374bd8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"497\" class=\"origin_image zh-lightbox-thumb\" width=\"913\" data-original=\"https://pic1.zhimg.com/v2-38fe4de60875923053a105d3a1374bd8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;913&#39; height=&#39;497&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"497\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"913\" data-original=\"https://pic1.zhimg.com/v2-38fe4de60875923053a105d3a1374bd8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-38fe4de60875923053a105d3a1374bd8_b.jpg\"/></figure><p>除了一个明显的例外，这些类型都可以用 <code>typeof</code> 直接查看。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">typeof</span> <span class=\"mi\">42</span><span class=\"p\">;</span>\n<span class=\"c1\">// → &#39;number&#39;\n</span><span class=\"c1\"></span><span class=\"k\">typeof</span> <span class=\"s1\">&#39;foo&#39;</span><span class=\"p\">;</span>\n<span class=\"c1\">// → &#39;string&#39;\n</span><span class=\"c1\"></span><span class=\"k\">typeof</span> <span class=\"nx\">Symbol</span><span class=\"p\">(</span><span class=\"s1\">&#39;bar&#39;</span><span class=\"p\">);</span>\n<span class=\"c1\">// → &#39;symbol&#39;\n</span><span class=\"c1\"></span><span class=\"k\">typeof</span> <span class=\"mi\">42</span><span class=\"nx\">n</span><span class=\"p\">;</span>\n<span class=\"c1\">// → &#39;bigint&#39;\n</span><span class=\"c1\"></span><span class=\"k\">typeof</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n<span class=\"c1\">// → &#39;boolean&#39;\n</span><span class=\"c1\"></span><span class=\"k\">typeof</span> <span class=\"kc\">undefined</span><span class=\"p\">;</span>\n<span class=\"c1\">// → &#39;undefined&#39;\n</span><span class=\"c1\"></span><span class=\"k\">typeof</span> <span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"c1\">// → &#39;object&#39; 🤔\n</span><span class=\"c1\"></span><span class=\"k\">typeof</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">42</span> <span class=\"p\">};</span>\n<span class=\"c1\">// → &#39;object&#39;\n</span></code></pre></div><p><code>typeof null</code> 返回的是 <code>&#39;object&#39;</code>，而不是 <code>&#39;null&#39;</code>，要了解为什么，首先要把所有的 JavaScript 类型分成两组：</p><ul><li>objects(即，对象类型)</li><li>primitives(即，非对象类型)</li></ul><p>照此来说，<code>null</code> 表示「没有对象」，而 <code>undefined</code> 表示 「没有值」。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-725b67b9a5865c3f3a09d8843cfae2bc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic1.zhimg.com/v2-725b67b9a5865c3f3a09d8843cfae2bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;384&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic1.zhimg.com/v2-725b67b9a5865c3f3a09d8843cfae2bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-725b67b9a5865c3f3a09d8843cfae2bc_b.jpg\"/></figure><p>按照这个思路，Brendan Eich 在设计 JavaScript 时，受到 Java 的影响，使得右手边的值执行 <code>typeof</code> 后都返回 <code>object</code>。因此，即便规范里有 <code>Null</code> 类型，<code>typeof null === &#39;object&#39;</code> 依然成立。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bc07a11af54b5cd7bffec708e3cf8b2d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic2.zhimg.com/v2-bc07a11af54b5cd7bffec708e3cf8b2d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;384&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic2.zhimg.com/v2-bc07a11af54b5cd7bffec708e3cf8b2d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bc07a11af54b5cd7bffec708e3cf8b2d_b.jpg\"/></figure><h2>Value representation</h2><p>JavaScript 引擎能够在内存中表示任意的 JavaScript 值。然而，值得注意的是，JavaScript 引擎在内存中值类型的表现形式是不同于 JavaScript 中的类型描述。</p><p>例如，42，在 JavaScript 中是 <code>number</code> 类型。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">typeof</span> <span class=\"mi\">42</span><span class=\"p\">;</span>\n<span class=\"c1\">// → &#39;number&#39;\n</span></code></pre></div><p>在内存中有好多种方式表示整数，例如 42:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2490e3fb325d3fcb9ed1d5b185056034_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1384\" data-rawheight=\"814\" class=\"origin_image zh-lightbox-thumb\" width=\"1384\" data-original=\"https://pic1.zhimg.com/v2-2490e3fb325d3fcb9ed1d5b185056034_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1384&#39; height=&#39;814&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1384\" data-rawheight=\"814\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1384\" data-original=\"https://pic1.zhimg.com/v2-2490e3fb325d3fcb9ed1d5b185056034_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2490e3fb325d3fcb9ed1d5b185056034_b.jpg\"/></figure><p>ECMAScript 将数字标准化为 64 位浮点值，也称为双精度浮点或 Float64。但是，这并不意味着 JavaScript 引擎总是以 Float64 的形式存储数字 —— 这么做会很低效。引擎会选择其它的内部表现形式，除非观测到的行为完全匹配 Float64。</p><p>在真实的 JavaScript 应用中，大多数数字都是合法的 ECMAScript <a href=\"https://link.zhihu.com/?target=https%3A//tc39.es/ecma262/%23array-index\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数组索引</a>，即，属于 0 ~ 2³²−2 范围内的整数。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">array</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span> <span class=\"c1\">// Smallest possible array index.\n</span><span class=\"c1\"></span><span class=\"nx\">array</span><span class=\"p\">[</span><span class=\"mi\">42</span><span class=\"p\">];</span>\n<span class=\"nx\">array</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"mi\">32</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">];</span> <span class=\"c1\">// Greatest possible array index.\n</span></code></pre></div><p>JavaScript 引擎会为数字选择最优存储的表达形式以此优化数组元素的访问效率。对于处理器的内存访问操作，数组索引必须是二进制补码的形式。用 Float64 表示数组是一种很费性能的行为，因为每次访问数组元素引擎都需要在 Float64 和二进制补码之间转换。</p><p>32 位的二进制补码表达形式对数组操作是很有用的。通常来说，处理器执行整型操作比执行浮点型操作要快得多。所以说，下面的例子，第一个循环比第二个循环快两倍。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"nx\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// fast 🚀\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"mf\">1000.1</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"nx\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// slow 🐌\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>操作符也是一样。在下面的代码中，模运算符的性能取决于处理的是否是整数。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">remainder</span> <span class=\"o\">=</span> <span class=\"nx\">value</span> <span class=\"o\">%</span> <span class=\"nx\">divisor</span><span class=\"p\">;</span>\n<span class=\"c1\">// Fast 🚀 if `value` and `divisor` are represented as integers,\n</span><span class=\"c1\">// slow 🐌 otherwise.\n</span></code></pre></div><p>如果两个操作数都是整数的形式，CPU 就可以高效地计算出结果。如果除数是 2 的倍数，V8 还会有额外的捷径。对于值是浮点型的形式，计算过程会变得复杂耗时。</p><p>因为整型操作的执行速度通常比浮点型要快很多，所以，引擎就应该使用二进制补码来表示所有的整型和整型操作的结果。遗憾的是，那是有悖于 ECMAScript 规范的！ECMAScript 采用了 Float64，某些整数运算实际上产生的是浮点型。在下面这种情况下，对于能够产生正确的结果很重要。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Float64 has a safe integer range of 53 bits. Beyond that range,\n</span><span class=\"c1\">// you must lose precision.\n</span><span class=\"c1\"></span><span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"mi\">53</span> <span class=\"o\">===</span> <span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"mi\">53</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"c1\">// → true\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// Float64 supports negative zeros, so -1 * 0 must be -0, but\n</span><span class=\"c1\">// there’s no way to represent negative zero in two’s complement.\n</span><span class=\"c1\"></span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">*</span><span class=\"mi\">0</span> <span class=\"o\">===</span> <span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"c1\">// → true\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// Float64 has infinities which can be produced through division\n</span><span class=\"c1\">// by zero.\n</span><span class=\"c1\"></span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"mi\">0</span> <span class=\"o\">===</span> <span class=\"kc\">Infinity</span><span class=\"p\">;</span>\n<span class=\"c1\">// → true\n</span><span class=\"c1\"></span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"mi\">0</span> <span class=\"o\">===</span> <span class=\"o\">-</span><span class=\"kc\">Infinity</span><span class=\"p\">;</span>\n<span class=\"c1\">// → true\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// Float64 also has NaNs.\n</span><span class=\"c1\"></span><span class=\"mi\">0</span><span class=\"o\">/</span><span class=\"mi\">0</span> <span class=\"o\">===</span> <span class=\"kc\">NaN</span><span class=\"p\">;</span>\n</code></pre></div><p>左边的值都是整型，而右边的却是浮点型。以上的操作在使用 32 位二进制补码的形式是没法正确执行的。JavaScript 引擎必须确保整型操作被合理地处理以生成想要的 Float64 结果。</p><p>对于在 31 位有符号整数范围内的小整数，V8 有特殊的表示形式，称为 Smi。对于非 Smi 的数值会被表示为 HeapObject，它是内存中某些实体的地址。我们使用一种特殊的 HeapObject，即所谓的 HeapNumber，来表示超出 Smi 范围的数字。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"o\">-</span><span class=\"kc\">Infinity</span> <span class=\"c1\">// HeapNumber\n</span><span class=\"c1\"></span><span class=\"o\">-</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"mi\">30</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"c1\">// HeapNumber\n</span><span class=\"c1\"></span>  <span class=\"o\">-</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"mi\">30</span><span class=\"p\">)</span> <span class=\"c1\">// Smi\n</span><span class=\"c1\"></span>       <span class=\"o\">-</span><span class=\"mi\">42</span> <span class=\"c1\">// Smi\n</span><span class=\"c1\"></span>        <span class=\"o\">-</span><span class=\"mi\">0</span> <span class=\"c1\">// HeapNumber\n</span><span class=\"c1\"></span>         <span class=\"mi\">0</span> <span class=\"c1\">// Smi\n</span><span class=\"c1\"></span>       <span class=\"mf\">4.2</span> <span class=\"c1\">// HeapNumber\n</span><span class=\"c1\"></span>        <span class=\"mi\">42</span> <span class=\"c1\">// Smi\n</span><span class=\"c1\"></span>   <span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"mi\">30</span><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"c1\">// Smi\n</span><span class=\"c1\"></span>     <span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"mi\">30</span> <span class=\"c1\">// HeapNumber\n</span><span class=\"c1\"></span>  <span class=\"kc\">Infinity</span> <span class=\"c1\">// HeapNumber\n</span><span class=\"c1\"></span>       <span class=\"kc\">NaN</span> <span class=\"c1\">// HeapNumber\n</span></code></pre></div><p>如上所示，某些数字被表示为 Smi，其它数字被表示为 HeapNumber。V8 对 Smi 专门优化，因为在真实的 JavaScript 编程中，小的整数是非常普遍的。Smi 没必要在内存中分配专用的实体，而且可以素快速地整型操作。</p><h2>Smi vs. HeapNumber vs. MutableHeapNumber</h2><p>有以下对象：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">o</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">42</span><span class=\"p\">,</span>  <span class=\"c1\">// Smi\n</span><span class=\"c1\"></span>  <span class=\"nx\">y</span><span class=\"o\">:</span> <span class=\"mf\">4.2</span><span class=\"p\">,</span> <span class=\"c1\">// HeapNumber\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n</code></pre></div><p>x 的值 42 被编程为 Smi，因此它被存储在对象里。另一方面值 4.2 需要一个独立的实例（空间）来保存这个值，并且这个对象会指向这个实体。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2826084ee57a9032abc3c667d4c9eeb4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic1.zhimg.com/v2-2826084ee57a9032abc3c667d4c9eeb4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;287&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic1.zhimg.com/v2-2826084ee57a9032abc3c667d4c9eeb4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2826084ee57a9032abc3c667d4c9eeb4_b.jpg\"/></figure><p>运行以下 JavaScript 代码片段：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">+=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n<span class=\"c1\">// → o.x is now 52\n</span><span class=\"c1\"></span><span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">y</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"c1\">// → o.y is now 5.2\n</span></code></pre></div><p>这种情况下，x 的值可以就地更新，因为新的值 52 也在 Smi 的范围内。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-210d5d43a0c13034357dc3cfa9b54223_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"301\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-210d5d43a0c13034357dc3cfa9b54223_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;301&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"301\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-210d5d43a0c13034357dc3cfa9b54223_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-210d5d43a0c13034357dc3cfa9b54223_b.jpg\"/></figure><p>然而，新的值 <code>y=5.2</code> 不在 Smi 范围内且不同于之前的值 4.2，因此 V8 为 y 重新分配了新的 HeapNumber 实体。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a3f6a6d0201cc42c0f1253c789a40c2a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic3.zhimg.com/v2-a3f6a6d0201cc42c0f1253c789a40c2a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;375&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic3.zhimg.com/v2-a3f6a6d0201cc42c0f1253c789a40c2a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a3f6a6d0201cc42c0f1253c789a40c2a_b.jpg\"/></figure><p>HeapNumber 是不可变的，它使得某些优化成为可能。例如，我们把 y 赋值给 x：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">y</span><span class=\"p\">;</span>\n<span class=\"c1\">// → o.x is now 5.2\n</span></code></pre></div><p>我们只需要把它连接到同一个 HeapNumber 上而不是重新分配一个新的实体（空间）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0bceea689a4685f36b76c7fbf6fb7ccf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-0bceea689a4685f36b76c7fbf6fb7ccf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;411&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-0bceea689a4685f36b76c7fbf6fb7ccf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0bceea689a4685f36b76c7fbf6fb7ccf_b.jpg\"/></figure><p>HeapNumber 不可变也存在缺点，如果更新的值经常不在 Smi 的范围内，它就会变慢，例如下面的例子：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Create a `HeapNumber` instance.\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">o</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mf\">0.1</span> <span class=\"p\">};</span>\n\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">5</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"nx\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// Create an additional `HeapNumber` instance.\n</span><span class=\"c1\"></span>  <span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>第一行创建了一个 HeapNumber 实例，其初始值为 0.1。在循环体中值从 1.1，2.1，3.1，4.2 变到 5.1，一共创建了 6 个 HeapNumber 实例，其中 5 个会在循环结束后变没有任何用处。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-aa3d4c792fe8a7a9ef6b9573cfe5fc1e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"432\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic3.zhimg.com/v2-aa3d4c792fe8a7a9ef6b9573cfe5fc1e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;432&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"432\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic3.zhimg.com/v2-aa3d4c792fe8a7a9ef6b9573cfe5fc1e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-aa3d4c792fe8a7a9ef6b9573cfe5fc1e_b.jpg\"/></figure><p>为了避免这种情况，作为优化，V8 提供了就地更新非 Smi 数值的方法。当一个字段对应着非 Smi 的数值，V8 会在 shape 上将这个字段标记为 Double，并分配一个保存 Float64 的 MutableHeapNumber 实体。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d648058b07ef88ce657421e79dc9b6eb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"518\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-d648058b07ef88ce657421e79dc9b6eb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;518&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"518\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-d648058b07ef88ce657421e79dc9b6eb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d648058b07ef88ce657421e79dc9b6eb_b.jpg\"/></figure><p>当字段里的值发生变化时，V8 不必分配一个新的 HeapNumber，而是在 MutableHeapNumber 实体中就地更新。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-be5a4567408b16d6b7673c11ce89d53b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-be5a4567408b16d6b7673c11ce89d53b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-be5a4567408b16d6b7673c11ce89d53b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-be5a4567408b16d6b7673c11ce89d53b_b.jpg\"/></figure><p>然而，需要注意的是，MutableHeapNumber 中的值是可以改变的，所以值不应该传来传去的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-34ff06182216f5c4f217ea5b441b5c1a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic3.zhimg.com/v2-34ff06182216f5c4f217ea5b441b5c1a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;513&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic3.zhimg.com/v2-34ff06182216f5c4f217ea5b441b5c1a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-34ff06182216f5c4f217ea5b441b5c1a_b.jpg\"/></figure><p> 例如，你把 <code>o.x</code> 赋值给变量 y，你不希望 y 会随着 <code>o.x</code> 的改变而改变！所以在给 y 赋值前，必须将 <code>o.x</code> 的值重新包装成 HeapNumber。</p><p>对于浮点型，V8 已经默默地包装了一下。但是，对于小的整数也采用和 MutableHeapNumber 相同的方法，就会显得浪费，因为 Smi 本就是一种更高效的表现形式。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n<span class=\"c1\">// → no “boxing” for `x` in object\n</span><span class=\"c1\"></span>\n<span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"c1\">// → update the value of `x` inside object\n</span></code></pre></div><p>为了避免低效率，我们会在 shape 上为小整数对应的字段上标记 Smi，并且会原地更新数值，只要这个数值在 Smi 范围内。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b14f87e0036a662f09ea7024562bef8c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic1.zhimg.com/v2-b14f87e0036a662f09ea7024562bef8c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;424&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic1.zhimg.com/v2-b14f87e0036a662f09ea7024562bef8c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b14f87e0036a662f09ea7024562bef8c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>Shape deprecations and migrations</h2><p>如果一个字段里包含的值在 Smi 范围内，之后又不属于 Smi 范围，这中间发生了什么？现有两个对象，它们的 x 属性值都是 Smi 表示形式。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">a</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n<span class=\"k\">const</span> <span class=\"nx\">b</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"p\">};</span>\n<span class=\"c1\">// → objects have `x` as `Smi` field now\n</span><span class=\"c1\"></span>\n<span class=\"nx\">b</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span><span class=\"p\">;</span>\n<span class=\"c1\">// → `b.x` is now represented as a `Double`\n</span><span class=\"c1\"></span>\n<span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"nx\">a</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">;</span>\n</code></pre></div><p>这两个对象都指向同一个 shape，x 属性特性 Representation 被标记为 Smi：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a4ed44e7df85af2cc6708d24cf805bdc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-a4ed44e7df85af2cc6708d24cf805bdc_b.jpg\"/></figure><p>当 <code>b.x</code> 变成 Double 形式，V8 会创建一个新的 shape，属性 x 的 Representation 被标记为 Double 且指向之前的空 shape。V8 也会为属性 x 分配一个 MutableHeapNumber 实体用来保存值 0.2。然后让对象 b 指向新创建的 shape 并且内部偏移量为 0 的位置指向刚分配的 MutableHeapNumber 实体。最后，我们把旧的 shape 标记为废弃的，并断开与过渡树（transition tree）的链接。这就完成了从空 shape 到新 shape 的过渡。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5abadd26ab81e21fc6dd0dbc096df84d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-5abadd26ab81e21fc6dd0dbc096df84d_b.jpg\"/></figure><p>我们不能同时完全删除旧 shape，因为对象 a 还在使用，而且短时间找到所有链接到旧 shape 的对象并更新它们，对 V8 来说是笔很大的开销。相反，V8 不急着处理：只有在改变对象 a 的时候才开始迁移到新的 shape。最终，标记为废弃的 shape 会慢慢淡出视野并被垃圾回收机制抹除。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4dd78bf41858fe5600d91eff5117f62a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-4dd78bf41858fe5600d91eff5117f62a_b.jpg\"/></figure><p>更棘手的问题是，如果对象上属性特性 Representation 发生变化的属性不是 shape 链上的最后一个，又会发生什么呢？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-86e96781fd2d1b4c301f8c35bc1b6b14_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-86e96781fd2d1b4c301f8c35bc1b6b14_b.jpg\"/></figure><p>从产生分支的 shape 开始，我们为属性 y 创建了一个新的过渡链且 y 被标记为 Double。我们在使用新的过渡链时，也就意味着旧的过渡链将被废弃。在最后一步，我们把实例 o 迁移到新的 shape 并用 MutableHeapNumber 保存 y 的值。就这样，新对象不再使用老的那一套，一旦旧的 shape 上的链接都被移除掉，旧 shape 也会从过渡树上消失。</p><h2>Extensibility and integrity-level transitions</h2><p><code>Object.preventExtensions()</code> 防止将新属性添加到对象中。如果你这么做了，它将会抛异常。（如果是在非严格模式下，它不会抛异常而是默认什么都不做。）</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n<span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">preventExtensions</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">);</span>\n<span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"c1\">// TypeError: Cannot add property y;\n</span><span class=\"c1\">//            object is not extensible\n</span></code></pre></div><p><code>Object.seal</code> 与 <code>Object.preventExtensions</code> 相似，但是它会把所有的属性标记为不可配置，这就意味着你不能删除它们，或改变他们的可枚举性，可配置性，可写性。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n<span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">seal</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">);</span>\n<span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"c1\">// TypeError: Cannot add property y;\n</span><span class=\"c1\">//            object is not extensible\n</span><span class=\"c1\"></span><span class=\"k\">delete</span> <span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">;</span>\n<span class=\"c1\">// TypeError: Cannot delete property x\n</span></code></pre></div><p><code>Object.freeze</code> 与 <code>Object.seal</code> 相似，但是它将所有属性标记为不可写以防止属性值被修改。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n<span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">freeze</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">);</span>\n<span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"c1\">// TypeError: Cannot add property y;\n</span><span class=\"c1\">//            object is not extensible\n</span><span class=\"c1\"></span><span class=\"k\">delete</span> <span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">;</span>\n<span class=\"c1\">// TypeError: Cannot delete property x\n</span><span class=\"c1\"></span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n<span class=\"c1\">// TypeError: Cannot assign to read-only property x\n</span></code></pre></div><p>让我们来思考一个具体的例子，有两个都只有属性 y 的对象，并阻止第二个对象有任何的扩展。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">a</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n<span class=\"k\">const</span> <span class=\"nx\">b</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"p\">};</span>\n\n<span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">preventExtensions</span><span class=\"p\">(</span><span class=\"nx\">b</span><span class=\"p\">);</span>\n</code></pre></div><p>就如我们所知的，从空的 shape 过渡到一个有属性 x （被标记为 Smi）的新 shape 上。当我们阻止 b 的扩展时，我们会过渡到标记为不可扩展的新 shape 上。这个新 shape 没有任何属性，仅仅作为一个标识。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ce126f620ca66ae139fd5b27d984ff63_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-ce126f620ca66ae139fd5b27d984ff63_b.jpg\"/></figure><p>注意，我们不能就地更新有 x 的 shape，因为对象 a 依然是可扩展的。</p><h2>The React performance issue</h2><p>让我们用以上学到的知识来解析下 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/issues/14365\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">the recent React issue #14365</a>。简单重现这个 bug：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">o</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"p\">};</span>\n<span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">preventExtensions</span><span class=\"p\">(</span><span class=\"nx\">o</span><span class=\"p\">);</span>\n<span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span><span class=\"p\">;</span>\n</code></pre></div><p>有一个拥有两个字段的对象，而且它们的属性特性 Representation 被标记为 Smi。我们阻止对象的进一步扩展，但最终我们还是强制改变第二字段的属性特性 Representation 的值（Double）。</p><p>就如之前学到的，大致流程如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-270009120e3e14335c7578ad12f9e4d4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-270009120e3e14335c7578ad12f9e4d4_b.jpg\"/></figure><p>每个属性的特性 Representation 都被标记为 Smi，并最终过渡到被标记为不可扩展的 shape 上。</p><p>我们需要将 y 的属性特性 Representation 标记为 Double，这意味着我们需要从引入 y 属性之前的 shape 开始。在这个例子中，就是引入 x 属性的那个 shape。但是， V8 会很困惑，因为当前的 shape 是不可扩展的，而找到的 shape 却是可扩展的。V8 不知道怎么去处理这个过渡树。因此，V8 不再试图搞清楚这些关系，而是创建了一个独立的 shape，这个 shape 和先前的过渡树没有任何关联，而且也不被任何其它对象共享。可以把它当作孤立的 shape：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9b74b507117fb4f9e3af3b9237d78607_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-9b74b507117fb4f9e3af3b9237d78607_b.jpg\"/></figure><p>你可以想象，如果有很多对象的话，这样会变得很糟糕，因为整个 shape 系统已经失去价值。</p><p>在 React 的案例中，当开始分析数据时，FiberNode 上的一些字段需要记录时间戳。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">FiberNode</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">actualStartTime</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">preventExtensions</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">node1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">FiberNode</span><span class=\"p\">();</span>\n<span class=\"k\">const</span> <span class=\"nx\">node2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">FiberNode</span><span class=\"p\">();</span>\n</code></pre></div><p>这些字段（比如，actualStartTime）初始化值是 0 或 -1，因此属性特性 Representation 为 Smi。但是，之后由 <code>performance.now()</code> 生成的浮点型数值被保存在这些字段中，因此属性特性 Representation 被标记为 Double。除此之外，React 还阻止 FiberNode 实例扩展属性。</p><p>刚开始的状况如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c0e1a02da5a1af81137e6cdf2e53e071_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-c0e1a02da5a1af81137e6cdf2e53e071_b.jpg\"/></figure><p>如预期，两个实例共享着 shape 树。但是之后，一旦你存储了真实的时间戳，V8 就会无从下手：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-33868351931ebbcb33d93746554a256d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-33868351931ebbcb33d93746554a256d_b.jpg\"/></figure><p>V8 先后给 node1，node2 分别分配了独立的 shape，且它们之间没有任何关联。真实中的 React 应用有着数万个这样的 FiberNode。你可以想象，这种情况将会严重影响到 V8 的性能。</p><p>幸运的是，这个<a href=\"https://link.zhihu.com/?target=https%3A//chromium-review.googlesource.com/c/v8/v8/%2B/1442640/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">问题</a>在 <a href=\"https://link.zhihu.com/?target=https%3A//v8.dev/blog/v8-release-74\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">V8 v7.4</a> 中解决了。研发人员找到了改变属性特性 Representation 的方法，V8 终于知道它该怎么做了：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-13b1354caa53ea1136300a224fdde1e1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-13b1354caa53ea1136300a224fdde1e1_b.jpg\"/></figure><p>两个 FiberNode 实例指向不可扩展的 shape，shape 中的 <code>actualStartTime</code> 被标记为 Smi。当 <code>node1.actualStartTime</code> 被分配新的值时，将会生成一条新的过渡链，而且之前的过渡链会被标记为废弃的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b7ed39130d9988935331454b7539a8a9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-b7ed39130d9988935331454b7539a8a9_b.jpg\"/></figure><p>可以注意到，现在的过渡链可以正确的过渡转移。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8da573484ee0f07adddb8fe55fe6e60f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-8da573484ee0f07adddb8fe55fe6e60f_b.jpg\"/></figure><p>当 <code>node2.actualStartTime</code> 也被重新分配时，所有的链接都指向了新的 shape，过渡树中废弃的部分将会被垃圾回收机制清除。</p><p>React 团队将 FiberNode 所有关于时间的字段都改成了 Double 形式从而缓解这个问题。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">FiberNode</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Force `Double` representation from the start.\n</span><span class=\"c1\"></span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">actualStartTime</span> <span class=\"o\">=</span> <span class=\"nb\">Number</span><span class=\"p\">.</span><span class=\"kc\">NaN</span><span class=\"p\">;</span>\n    <span class=\"c1\">// Later, you can still initialize to the value you want:\n</span><span class=\"c1\"></span>    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">actualStartTime</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">preventExtensions</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">node1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">FiberNode</span><span class=\"p\">();</span>\n<span class=\"k\">const</span> <span class=\"nx\">node2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">FiberNode</span><span class=\"p\">();</span>\n</code></pre></div><p>由 React 具体的 Bug 引出了 V8 特有的问题，通常来说，开发者不必对某个版本的 JavaScript 引擎做优化。不过，当时事情向不好的方向发展时，我们也不会束手无策。</p><p>要知道 JavaScript 引擎在幕后做了很多事，尽可能的不要去混合类型。例如，给一个数字字段初始化为 null，这样做的话会使得一些优化化为泡影，而且可读性降低。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Don’t do this!\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Point</span> <span class=\"p\">{</span>\n  <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"p\">;</span>\n  <span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">p</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Point</span><span class=\"p\">();</span>\n<span class=\"nx\">p</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span><span class=\"p\">;</span>\n<span class=\"nx\">p</span><span class=\"p\">.</span><span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"mi\">402</span><span class=\"p\">;</span>\n</code></pre></div><p>换句话说，写可读性代码，性能自然会紧跟其后！</p><h2>Take-aways</h2><p>本文覆盖了一下几点：</p><ol><li>JavaScript 区分了 primitives 和 objects，而且 typeof 不靠谱。</li><li>即使是相同类型的值也会有不同的表达形式。</li><li>JavaScript 引擎会为每个属性找到最优的表达形式。</li><li>讨论了 V8 处理 shape 的废弃，迁移和可扩展。</li></ol><p>基于以上的知识，我们可以使用一些 JavaScript 编程技巧来提升性能：</p><ol><li>以相同的方式初始化对象类型，这样 shape 系统会更高效。</li><li>为你的字段选择合理的值（「Representation」：Smi 或 非 Smi）。</li></ol>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "JavaScript 引擎", 
                    "tagLink": "https://api.zhihu.com/topics/19856435"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "邵不情", 
                    "userLink": "https://www.zhihu.com/people/58bfe3eddab3851c21d547d277f3a5bb", 
                    "content": "请问是什么工具画的这么漂亮的图？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "这是翻译过来的，不知道诶", 
                            "likes": 0, 
                            "replyToAuthor": "邵不情"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85836157", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 6, 
            "title": "JavaScript 引擎原理（二）", 
            "content": "<p>通过以下方式<b>查看大图</b></p><a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-4dad71953b4f3a5c60f78f9d15539666_180x120.jpg\" data-image-width=\"640\" data-image-height=\"512\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">夜曉宸</a><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/user/57f1dbf5bf22ec00645dfc31/posts\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">曉宸 的个人主页 - 专栏 - 掘金</a><h2>前言</h2><p>本文是根据自己的理解翻译而来，如有疑惑可查看原文  <a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/prototypes\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript engine fundamentals: optimizing prototypes</a>。</p><p>本次暂定翻译三篇文章：</p><p> 1. <a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/shapes-ics\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript engine fundamentals: Shapes and Inline Caches</a>(Published 14th June 2018)</p><p> 2. <a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/prototypes\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript engine fundamentals: optimizing prototypes</a>(Published 16th August 2018) </p><p>3. <a href=\"https://link.zhihu.com/?target=https%3A//v8.dev/blog/react-cliff\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The story of a V8 performance cliff in React</a>(Published 28 August 2019)</p><h2>Optimization tiers and execution trade-offs</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/shapes-ics\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">上一篇文章</a>已经讨论了现代 JavaScript 引擎的工作流程：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b0ba818f33199baff3d6d697b1e5c269_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-b0ba818f33199baff3d6d697b1e5c269_b.jpg\"/></figure><p>我们也指出了引擎间的相同之处和编译环节中的差异。为什么会这样？为什么一些引擎的编译器比其他引擎多？结论是基于更快地生成代码和生成更好的代码两者间的考量。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-795faf39e9708c9048ae58e69c15b911_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-795faf39e9708c9048ae58e69c15b911_b.jpg\"/></figure><p>解释器可以很快地生成字节码，但是字节码的效率不高。另一方面，优化编译器虽然会稍微花费些时间，却可以生成效率更高的机器码。</p><p>下图是 V8 模型，V8 的解释器称为 Ignition，是所有引擎中最快的解释器（从原始字节码执行速度的角度）。V8 的优化编译器称为 TurboFan，它最终会生成高度优化的机器码。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bad5e6f142b102b3ee2c16235b876057_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-bad5e6f142b102b3ee2c16235b876057_b.jpg\"/></figure><p>启动速度和执行速度是一些 JavaScript 引擎选择添加优化层的理由。比如，SpiderMonkey 就在解释器和 IonMonkey 编译器间添加了 Baseline 层。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2fe0dc4cdd0ae2ce403bddcb0bdccb34_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-2fe0dc4cdd0ae2ce403bddcb0bdccb34_b.jpg\"/></figure><p>解释器可以快速生成字节码，但是字节码执行的速度比较慢。Baseline 会花些时间生成代码，但同样会提供性能更好的代码。最后，IonMonkey 会花更长的时间去生成机器码，并能够更高效地执行。</p><p>来用一个具体的例子，看看不同引擎之间的处理差异。在这个循环里，一些代码重复执行。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">let</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4242424242</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"nx\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">result</span> <span class=\"o\">+=</span> <span class=\"nx\">i</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">);</span>\n</code></pre></div><p>在 Ignition 解释器中，V8 开始执行字节码。在某个时刻引擎测定代码是 hot 的，就会启动 <code>TurboFan frontend</code>, <code>TurboFan frontend</code> 是负责整合分析数据（profiling data）并构建代码的初级机器码表现形式。这些东西会被送到处在其他线程的 <code>TurboFan</code> 优化程序中作进一步优化。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7516fbc0d7b31bc1d92208fe6591a6e2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-7516fbc0d7b31bc1d92208fe6591a6e2_b.jpg\"/></figure><p>当优化程序进行时，V8 继续执行字节码。在某个时刻，优化程序生成可执行代码后，流程会接着执行下去。</p><p>同样，SpiderMonkey 也是在解释器中开始执行字节码。但是它有 <code>Baseline</code> 层，hot 代码会被送到这里。一旦 <code>Baseline</code> 编译器生成了 <code>Baseline</code> 代码，流程会接着执行下去。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e9a85bd81431941877b50b091691362f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-e9a85bd81431941877b50b091691362f_b.jpg\"/></figure><p><code>Baseline</code> 代码运行一段时间后，SpiderMonkey 最终会启动 <code>IonMonkey frontend</code> 和 优化程序（类似于 V8）。IonMonkey 在优化时，<code>Baseline</code> 也会保持着运行状态。当优化完成后，已优化的代码将取代 <code>Baseline</code> 代码被执行。</p><p>Chakra 的架构和 SpiderMonkey 很相似。Chakra 尝试并行做很多事情同时又不会阻塞主线程。Chakra 会将字节码和编译器可能需要的分析数据复制出来，并发往编译器专用进程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a94ab728ec2e4579f84061a6bf8f5552_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-a94ab728ec2e4579f84061a6bf8f5552_b.jpg\"/></figure><p>当代码准备妥当后，引擎开始执行 SimpleJIT 代码。这种方式的好处在于复制所停留的时间远远小于编译器（ 编译器 frontend）所用的时间。缺点就是，这种启发式复制（copy heuristic）会使得某种优化所必须的信息丢失，因此这是在用代码质量换取时间。</p><p>在 JavaScriptCore，所有的优化编译器和主线程并发运行；主线程只是触发了另一个线程的编译任务。然后编译器通过复杂的加锁从主线程获取分析数据（profiling data）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-91ad0be9899345ce5689a41678d97b6c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-91ad0be9899345ce5689a41678d97b6c_b.jpg\"/></figure><p>这种方式的优点是减少了因 JavaScript 优化引发的麻烦。缺点就是需要处理复杂的多线程问题和各种操作所带来的加锁成本。</p><p>我们讨论了快速生成代码，也讨论了生成快速的代码。但是，还要有一点需要注意：内存的使用！为了解释这个，这里有个两数字相加的例子。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">add</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">x</span> <span class=\"o\">+</span> <span class=\"nx\">y</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n</code></pre></div><p>以下是 V8 的 Ignition 编译器生成的字节码：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">StackCheck</span>\n<span class=\"nx\">Ldar</span> <span class=\"nx\">a1</span>\n<span class=\"nx\">Add</span> <span class=\"nx\">a0</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"nx\">Return</span>\n</code></pre></div><p>不要在意字节码的细节，重点是知道它只有 4 个指令！</p><p>当代码编程 hot 时，TurboFan 会生成以下高度优化过的机器码：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">leaq</span> <span class=\"nx\">rcx</span><span class=\"p\">,[</span><span class=\"nx\">rip</span><span class=\"o\">+</span><span class=\"mh\">0x0</span><span class=\"p\">]</span>\n<span class=\"nx\">movq</span> <span class=\"nx\">rcx</span><span class=\"p\">,[</span><span class=\"nx\">rcx</span><span class=\"o\">-</span><span class=\"mh\">0x37</span><span class=\"p\">]</span>\n<span class=\"nx\">testb</span> <span class=\"p\">[</span><span class=\"nx\">rcx</span><span class=\"o\">+</span><span class=\"mh\">0xf</span><span class=\"p\">],</span><span class=\"mh\">0x1</span>\n<span class=\"nx\">jnz</span> <span class=\"nx\">CompileLazyDeoptimizedCode</span>\n<span class=\"nx\">push</span> <span class=\"nx\">rbp</span>\n<span class=\"nx\">movq</span> <span class=\"nx\">rbp</span><span class=\"p\">,</span><span class=\"nx\">rsp</span>\n<span class=\"nx\">push</span> <span class=\"nx\">rsi</span>\n<span class=\"nx\">push</span> <span class=\"nx\">rdi</span>\n<span class=\"nx\">cmpq</span> <span class=\"nx\">rsp</span><span class=\"p\">,[</span><span class=\"nx\">r13</span><span class=\"o\">+</span><span class=\"mh\">0xe88</span><span class=\"p\">]</span>\n<span class=\"nx\">jna</span> <span class=\"nx\">StackOverflow</span>\n<span class=\"nx\">movq</span> <span class=\"nx\">rax</span><span class=\"p\">,[</span><span class=\"nx\">rbp</span><span class=\"o\">+</span><span class=\"mh\">0x18</span><span class=\"p\">]</span>\n<span class=\"nx\">test</span> <span class=\"nx\">al</span><span class=\"p\">,</span><span class=\"mh\">0x1</span>\n<span class=\"nx\">jnz</span> <span class=\"nx\">Deoptimize</span>\n<span class=\"nx\">movq</span> <span class=\"nx\">rbx</span><span class=\"p\">,[</span><span class=\"nx\">rbp</span><span class=\"o\">+</span><span class=\"mh\">0x10</span><span class=\"p\">]</span>\n<span class=\"nx\">testb</span> <span class=\"nx\">rbx</span><span class=\"p\">,</span><span class=\"mh\">0x1</span>\n<span class=\"nx\">jnz</span> <span class=\"nx\">Deoptimize</span>\n<span class=\"nx\">movq</span> <span class=\"nx\">rdx</span><span class=\"p\">,</span><span class=\"nx\">rbx</span>\n<span class=\"nx\">shrq</span> <span class=\"nx\">rdx</span><span class=\"p\">,</span> <span class=\"mi\">32</span>\n<span class=\"nx\">movq</span> <span class=\"nx\">rcx</span><span class=\"p\">,</span><span class=\"nx\">rax</span>\n<span class=\"nx\">shrq</span> <span class=\"nx\">rcx</span><span class=\"p\">,</span> <span class=\"mi\">32</span>\n<span class=\"nx\">addl</span> <span class=\"nx\">rdx</span><span class=\"p\">,</span><span class=\"nx\">rcx</span>\n<span class=\"nx\">jo</span> <span class=\"nx\">Deoptimize</span>\n<span class=\"nx\">shlq</span> <span class=\"nx\">rdx</span><span class=\"p\">,</span> <span class=\"mi\">32</span>\n<span class=\"nx\">movq</span> <span class=\"nx\">rax</span><span class=\"p\">,</span><span class=\"nx\">rdx</span>\n<span class=\"nx\">movq</span> <span class=\"nx\">rsp</span><span class=\"p\">,</span><span class=\"nx\">rbp</span>\n<span class=\"nx\">pop</span> <span class=\"nx\">rbp</span>\n<span class=\"nx\">ret</span> <span class=\"mh\">0x18</span>\n</code></pre></div><p>和字节码相比较，这里的代码会显得很多！通常来说，字节码会比机器码紧凑得多，尤其对比高度优化过的机器码。另一方面，字节码需要解释器来运行，而优化过的代码则可以被处理器直接执行。</p><p>这是 JavaScript 引擎不「优化一切」的原因之一（仅优化 「hot function」）。正如我们早先看到的，生成优化过的机器码会用很长的时间，除此之外，我们刚才也知道了优化过的机器码会占用用更多的内存空间。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7062fcda99fe7eea61220460b7106515_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-7062fcda99fe7eea61220460b7106515_b.jpg\"/></figure><h2>Optimizing prototype property access</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/shapes-ics%23optimizing-property-access\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">先前的文章</a>阐述了 JavaScript 引擎使用 Shapes 和 Inline Caches 优化对象属性的访问。再次说明，引擎将对象的 Shape 和对象的值分开存储。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-27eb85d2c68fb606e64aebe861ca351b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-27eb85d2c68fb606e64aebe861ca351b_b.jpg\"/></figure><p>结合 Shapes 和 Inline Caches 可以加快代码中同一位置的属性重复性访问。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1c91ac23d7062ba313c122374b20f74c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-1c91ac23d7062ba313c122374b20f74c_b.jpg\"/></figure><h3>Classes and prototype-based programming</h3><p>我们已经知道了如何快速访问 JavaScript 对象上的属性，我们再看看 JavaScript 最近新增的特性：类。下面是 JavaScript 中类的语法：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Bar</span> <span class=\"p\">{</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">x</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"nx\">getX</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>看似是个新概念，其实就是基于原型的语法糖。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Bar</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">x</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">Bar</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">getX</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"nx\">getX</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>在这里，我们给 <code>Bar.prototype</code> 这个对象添加属性 <code>getX</code>，这和其它普通对象添加属性没有区别，因为在 JavaScript中， 原型也是个对象！像 JavaScript 这种基于原型的编程语言，方法可以通过原型共享，而字段则存储在实例中。</p><p>让我们看看通过 Bar 创建实例 foo 会发生什么？</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">foo</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Bar</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">);</span>\n</code></pre></div><p>创建出来的实例（foo）拥有一个只包含属性 <code>&#39;x&#39;</code> 的 shape。foo 的原型指向 <code>Bar.prototype</code>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1f3697648c446b5e95fc944c20f242c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-1f3697648c446b5e95fc944c20f242c8_b.jpg\"/></figure><p><code>Bar.prototype</code> 也有属于自己的 shape，它包含一个 <code>getX</code> 属性，这个属性的值是个返回 <code>this.x</code> 的函数（<code>getX</code>）。<code>Bar.prototype</code> 的原型是 <code>Object.prototype</code>。<code>Object.prototype</code> 是原型链的根源，因此它的原型是 <code>null</code>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-564867ee7e672fc40c3d80d8df7dd5dd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-564867ee7e672fc40c3d80d8df7dd5dd_b.jpg\"/></figure><p>如果你用同一个类又创建了一个实例，那么这两个实例将共享 shape，两个实例也会指向同一个 <code>Bar.prototype</code>。</p><h3>Prototype property access</h3><p>ok，我们已经知道了定义一个类并用类创建实例的过程。那么，如果我们在实例上调用一个方法，又会发生什么呢？</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Bar</span> <span class=\"p\">{</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"nx\">getX</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">foo</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Bar</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">foo</span><span class=\"p\">.</span><span class=\"nx\">getX</span><span class=\"p\">();</span>\n<span class=\"c1\">//        ^^^^^^^^^^\n</span></code></pre></div><p>你可以认为方法的调用分为两个步骤：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">foo</span><span class=\"p\">.</span><span class=\"nx\">getX</span><span class=\"p\">();</span>\n\n<span class=\"c1\">// is actually two steps:\n</span><span class=\"c1\"></span>\n<span class=\"k\">const</span> <span class=\"nx\">$getX</span> <span class=\"o\">=</span> <span class=\"nx\">foo</span><span class=\"p\">.</span><span class=\"nx\">getX</span><span class=\"p\">;</span>\n<span class=\"k\">const</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">$getX</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"nx\">foo</span><span class=\"p\">);</span>\n</code></pre></div><p>步骤 1：加载方法，这个方法只不过是原型上的属性（而它恰好是个函数）。步骤 2：用实例去调用这个方法（重新绑定 <code>this</code>）。先看步骤 1：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ca8090aaf71640c2cfeb6f8e11aee973_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-ca8090aaf71640c2cfeb6f8e11aee973_b.jpg\"/></figure><p>开始时，引擎从实例 foo 上查找并发现 foo 的 shape 上没有 <code>getX</code> 属性，于是它不得不沿着原型链向上查找。到达 <code>Bar.prototype</code> 后，开始查找它的 shape 并找到了 <code>getX</code> 属性。然后根据 <code>getX</code> 的属性信息（Offset：0）在 <code>Bar.prototype</code> 上找到了 <code>getX</code> 函数。</p><p>JavaScript 的灵活性使得原型链可能会突变，例如：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">foo</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Bar</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">);</span>\n<span class=\"nx\">foo</span><span class=\"p\">.</span><span class=\"nx\">getX</span><span class=\"p\">();</span>\n<span class=\"c1\">// → true\n</span><span class=\"c1\"></span>\n<span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">setPrototypeOf</span><span class=\"p\">(</span><span class=\"nx\">foo</span><span class=\"p\">,</span> <span class=\"kc\">null</span><span class=\"p\">);</span>\n<span class=\"nx\">foo</span><span class=\"p\">.</span><span class=\"nx\">getX</span><span class=\"p\">();</span>\n<span class=\"c1\">// → Uncaught TypeError: foo.getX is not a function\n</span></code></pre></div><p>这个例子中，<code>foo.getX()</code> 被调用了两次，但是每次都会有不同的含义，不同的结果。所以说，尽管原型在 JavaScript 中只是个对象，但是提升原型属性的访问速度依然比常规对象更具有挑战性。</p><p>通常情况下，原型属性的加载是个非常频繁的操作：每次方法调用都会去加载属性！</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Bar</span> <span class=\"p\">{</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"nx\">getX</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">foo</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Bar</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">foo</span><span class=\"p\">.</span><span class=\"nx\">getX</span><span class=\"p\">();</span>\n<span class=\"c1\">//        ^^^^^^^^^^\n</span></code></pre></div><p>之前，我们讨论了使用 Shapes 和 ICs 优化常规对象的属性访问。那么，我们能否使用相同的策略去优化原型属性的重复性访问呢？下面，我们看看属性是如何加载的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4181ce5836e1a042cce5bae669868cd6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-4181ce5836e1a042cce5bae669868cd6_b.jpg\"/></figure><p>在这个案例中，为了提高重复加载的速度，我们需要知道三件事：</p><ol><li>foo 的 shape 不包含 <code>getX</code> 且没有改变过。这意味着 foo 没有添加、删除属性，或改变属性特性。</li><li>foo 的原型依然是 <code>Bar.prototype</code>。这意味着，foo 的原型没有通过 <code>Object.setPrototypeOf()</code> 或 <code>__proto__</code> 的方式改变过。</li><li><code>Bar.prototype</code> 的 shape 包含 <code>getX</code> 且没有改变过。这意味着 <code>Bar.prototype</code> 没有添加、删除属性，或改变属性特性。</li></ol><p>一般情况下，这意味着我们需要检查 1 遍实例本身，还有因每增加一个原型就就要增加的 2 遍检查直到找到我们想要的属性。<code>1+2N</code>（N 表示原型链上直到找到存在属性的原型的原型数量） 遍的检查看上去还不是特别糟糕，因为这时的原型链还比较短 —— 但是引擎会经常处理有着很长原型链的对象，就比如常见的 DOM 类。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">anchor</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">createElement</span><span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">);</span>\n<span class=\"c1\">// → HTMLAnchorElement\n</span><span class=\"c1\"></span>\n<span class=\"k\">const</span> <span class=\"nx\">title</span> <span class=\"o\">=</span> <span class=\"nx\">anchor</span><span class=\"p\">.</span><span class=\"nx\">getAttribute</span><span class=\"p\">(</span><span class=\"s1\">&#39;title&#39;</span><span class=\"p\">);</span>\n</code></pre></div><p>现有个 <code>HTMLAnchorElement</code> 并调用 <code>getAttribute()</code> 方法。这简单的 anchor 元素涉及到 6 个原型！<code>getAttribute()</code> 不是 <code>HTMLAnchorElement</code> 原型上的方法，而是原型链上靠近顶部的原型上。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fe72a860d2834e45d64ab132812a4ae7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-fe72a860d2834e45d64ab132812a4ae7_b.jpg\"/></figure><p><code>getAttribute()</code> 是在 <code>Element.prototype</code> 上发现的。这意味着我们每次调用 <code>anchor.getAttribute()</code> 时，都需要做以下这些事：</p><ol><li>检测到 <code>getAttribute</code> 不存在于 <code>anchor</code> 对象本身;</li><li>检测到 <code>anchor</code> 的原型是 <code>HTMLAnchorElement.prototype</code>;</li><li>确认没有 <code>getAttribute</code> 属性；</li><li>检测到下一个原型是 <code>HTMLElement.prototype</code>;</li><li>确认没有 <code>getAttribute</code> 属性；</li><li>继续检测下一个原型 <code>Element.prototype</code>;</li><li>找到 <code>getAttribute</code>。</li></ol><p>一共需要 7 次检测！而这种情况很常见，于是引擎想方设法去减少属性（原型上）加载时的检查次数。</p><p>回到更早的例子，当我们从 foo 访问 <code>getX</code> 时，共做了 3 次检查：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Bar</span> <span class=\"p\">{</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"nx\">getX</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">foo</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Bar</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">$getX</span> <span class=\"o\">=</span> <span class=\"nx\">foo</span><span class=\"p\">.</span><span class=\"nx\">getX</span><span class=\"p\">;</span>\n</code></pre></div><p>在查找属性的过程中，每个牵涉到的原型都需要做缺失检查（确认属性是否存在）。如果我们能够在属性确认的步骤里同时检测原型链，那将会减少总的检查次数。引擎也正是这么做的：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-64be0b127e38187ea944d0c1fab69963_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-64be0b127e38187ea944d0c1fab69963_b.jpg\"/></figure><p>每个 shape 都指向了原型，这意味着 foo 的原型改变时，引擎会自动过渡到新的 shape。现在我们只需要检查对象的 shape 就可以同时检测属性是否存在以及原型链的导向。</p><p>鉴于此，由于检查的次数从 <code>1+2N</code> 降低到 <code>1+N</code>，所以原型上属性的访问速度也变快了。由于在原型链上查找属性的时间复杂度是线性的，所以依然还是很耗时的。引擎使用了不同的方法让检查的次数趋于常量，尤其是同一属性的连续加载（访问）。</p><h3>Validity cells</h3><p>为此，V8 特别处理了原型的 shapes。每个原型都有一个独一无二的 shape，这个 shape 不会被其它的对象共享（特别是其它的原型对象），每一个原型的 shape 都有与之关联的 <code>ValidityCell</code>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c6784c46f4009039bab3d8000418e6e8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-c6784c46f4009039bab3d8000418e6e8_b.jpg\"/></figure><p>如果与之关联的原型被修改，或该原型的上游（原型的原型，原型的原型的原型……）被修改，<code>ValidityCell</code> 都会被标记为无效。让我们看看这是到底怎么一回事？</p><p>为了加快原型上后续的属性加载，V8 使用 ICs 保存着 4 个字段：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d558e2681585822defc4e0d6c43968f5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-d558e2681585822defc4e0d6c43968f5_b.jpg\"/></figure><p>代码第一次执行时，ICs 开始工作了，它要缓存属性在原型上的偏移量 「<code>Offset</code>」，属性所在的原型 「<code>Prototype</code>」（本例中的 <code>Bar.prototype</code>），实例的 shape 「Shape」（本例中 foo 的 shape）,还有就是与原型的 shape 相关联的 <code>ValidityCell</code> 「<code>ValidityCell</code>」，这个原型是实例 shape 直接链接的那个原型（本例中的 <code>Bar.prototype</code>）。</p><p>若在下一次 ICs 命中时，引擎会检查 shape （实例的 shape）和 <code>ValidityCell</code>。如果还有效，引擎会直接从 ICs 中提取信息，根据 <code>Prototype</code> 和 <code>Offset</code> 字段获取属性信息，这样就跳过了之前繁琐的查找步骤。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0c675d7223aefdc98da6151a92a01a27_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-0c675d7223aefdc98da6151a92a01a27_b.jpg\"/></figure><p>当原型发生改变时，一个新的 shape 将会生成，同时先前的 <code>ValidityCell</code> 将会失效。因此在下次执行时，ICs 将不会起作用，性能自然不会好。</p><p>回过头来再看看之前的 DOM，例如，<code>Object.prototype</code> 发生变化后，影响的将不仅仅是自身，还包括链的下游 <code>EventTarget.prototype</code>、<code>Node.prototype</code>、<code>Element.prototype</code>，直到 <code>HTMLAnchorElement.prototype</code>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-792a7feebfdb1913cb655f261197c4cd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-792a7feebfdb1913cb655f261197c4cd_b.jpg\"/></figure><p>事实上，当你在代码中修改了 <code>Object.prototype</code>，就意味着将性能弃之不顾。所以，不要那样做！</p><p>让我们看一个具体的例子，有一个 Bar 类，它有 <code>loadX</code> 方法。我们将使用类的实例调用 <code>loadX</code> 若干次。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Bar</span> <span class=\"p\">{</span> <span class=\"cm\">/* … */</span> <span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">loadX</span><span class=\"p\">(</span><span class=\"nx\">bar</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">bar</span><span class=\"p\">.</span><span class=\"nx\">getX</span><span class=\"p\">();</span> <span class=\"c1\">// IC for &#39;getX&#39; on `Bar` instances.\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"nx\">loadX</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">Bar</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">));</span>\n<span class=\"nx\">loadX</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">Bar</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">));</span>\n<span class=\"c1\">// IC in `loadX` now links the `ValidityCell` for\n</span><span class=\"c1\">// `Bar.prototype`.\n</span><span class=\"c1\"></span>\n<span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">newMethod</span> <span class=\"o\">=</span> <span class=\"nx\">y</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">y</span><span class=\"p\">;</span>\n<span class=\"c1\">// The `ValidityCell` in the `loadX` IC is invalid\n</span><span class=\"c1\">// now, because `Object.prototype` changed.\n</span></code></pre></div><p>此时，ICs 中会记录调用 <code>loadX</code> 后的相关信息。然后我们修改了 <code>Object.prototype</code> —— 所有原型的根源 —— <code>ValidityCell</code> 会被标记为无效的，ICs 不会在下次执行时命中，性能也会变得糟糕。</p><p>改变 <code>Object.prototype</code> 是一个不好的行为，它使得原型链下游所有的 ICs 失去作用。这有另一个不推荐的行为。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">foo</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"cm\">/* … */</span> <span class=\"p\">};</span>\n\n<span class=\"c1\">// Run critical code:\n</span><span class=\"c1\"></span><span class=\"nx\">someObject</span><span class=\"p\">.</span><span class=\"nx\">foo</span><span class=\"p\">();</span>\n<span class=\"c1\">// End of critical code.\n</span><span class=\"c1\"></span>\n<span class=\"k\">delete</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">foo</span><span class=\"p\">;</span>\n</code></pre></div><p>我们拓展了 <code>Object.prototype</code>，它使得原型链下游的所有 ICs 失效。然后调用原型上的新方法，引擎便从头开始为原型属性的访问构建新的 ICs。最后，我们删除了之前添加的方法。</p><p>清除，听着挺不错的，其实在这种情况下，只会更糟。删除 <code>Object.prototype</code> 上的属性就意味着修改 <code>Object.prototype</code>，所有的 ISc 将再一次失效，引擎也将会再一次地重头开始构建 ICs。</p><h2>Take-aways</h2><p>我们知道了 JavaScript 引擎是如何存储对象和类的，也知道了 Shapes、Inline Caches 和 ValidityCells 是如何帮助优化原型操作的。基于这些知识点，我们可以使用一些 JavaScript 编程技巧来提升性能：<b>不要乱动原型</b>（如果你真的，真的需要这么干，那么，至少要在代码运行前）。</p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "JavaScript 引擎", 
                    "tagLink": "https://api.zhihu.com/topics/19856435"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }
            ], 
            "comments": [
                {
                    "userName": "叶雨森", 
                    "userLink": "https://www.zhihu.com/people/5d2f808c757b0f4e9d38684f7a9d54be", 
                    "content": "原文下面已经有中文翻译的链接了", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "<p>是的，就是因为看的费力所以才自己翻译的</p>", 
                            "likes": 0, 
                            "replyToAuthor": "叶雨森"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85833603", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 3, 
            "title": "JavaScript 引擎原理（一）", 
            "content": "<p>通过以下方式<b>查看大图</b></p><a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-4dad71953b4f3a5c60f78f9d15539666_180x120.jpg\" data-image-width=\"640\" data-image-height=\"512\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">夜曉宸</a><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/user/57f1dbf5bf22ec00645dfc31/posts\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">曉宸 的个人主页 - 专栏 - 掘金</a><h2>前言</h2><p>本文是根据自己的理解翻译而来，如有疑惑可查看原文 <a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/shapes-ics\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript engine fundamentals: Shapes and Inline Caches</a>。</p><p>本次暂定翻译三篇文章： </p><p>1. <a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/shapes-ics\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript engine fundamentals: Shapes and Inline Caches</a>(Published 14th June 2018)</p><p> 2. <a href=\"https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/prototypes\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript engine fundamentals: optimizing prototypes</a>(Published 16th August 2018) </p><p>3. <a href=\"https://link.zhihu.com/?target=https%3A//v8.dev/blog/react-cliff\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The story of a V8 performance cliff in React</a>(Published 28 August 2019)</p><h2>JavaScript 引擎工作流</h2><p>一切从你写的 JavaScript 代码开始。JavaScript 引擎会解析源码并将其转换成抽象语法树（AST）。基于 AST，解释器（interpreter）会进一步地生成字节码。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b0ba818f33199baff3d6d697b1e5c269_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-b0ba818f33199baff3d6d697b1e5c269_b.jpg\"/></figure><p>为了能够运行得更快，字节码可能会和分析数据（profiling data）一同发给优化编译器（the optimizing compiler）。优化编译器会根据这些分析数据作出某些假设以此生成高度优化的机器码。</p><p>如果某个时刻，某种假设被证明是错误的，优化编译器将去优化并回滚到解释器部分。</p><h2>JavaScript 引擎中的解释器/编译器流程</h2><p>现在来关注下 JavaScript 代码被解释和优化的地方，并重温下主流 JavaScript 引擎之间的不同之处。</p><p>一般来说，在运行 JavaScript 代码过程中，会有解释器和优化编译器的参与。解释器会快速地生成尚未优化的字节码，而优化编译器会耗费一些时间用来生成高度优化的机器码。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b37f5c21142f4abd5423e7b064a6afb2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-b37f5c21142f4abd5423e7b064a6afb2_b.jpg\"/></figure><p>上面的流程和 V8 在浏览器和 Node 环境下的工作流程及其相似：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f49f95c1725c99cd9ef8bbfb6b68949a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-f49f95c1725c99cd9ef8bbfb6b68949a_b.jpg\"/></figure><p>V8 引擎的解释器被称作 Ignition，主要负责生成和执行字节码。当字节码运行时，解释器会收集分析数据，这些数据之后可能会被用来提升执行速度。如果一个函数经常被调用，即 hot，那么，经过解释器转换来的字节码和收集到的分析数据会传给 TurboFan（V8 的优化编译器），进一步被加工成高度优化的机器码。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b2958b3d925429226b4f0a50b125bf77_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-b2958b3d925429226b4f0a50b125bf77_b.jpg\"/></figure><p>SpiderMonkey，Mozilla 的 JavaScript 引擎，拥有两个优化编译器，Baseline 和 IonMonkey。解释器将转换后的代码传给 Baseline 编译器，Baseline 编译器会将其加工成部分优化的代码。再加上收集到的分析数据，IonMonkey 编译器可以生成高度优化的代码。如果基于假设的优化不成立，IonMonkey 会将代码会滚到 Baseline 部分。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-70fb093f0e695bee3c088741037e7b5d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-70fb093f0e695bee3c088741037e7b5d_b.jpg\"/></figure><p>Chakra，Microsoft 的 JavaScript 引擎，也有着类似的两个优化编译器，SimpleJIT 和 FullJIT。解释器将转换后的代码传给 SimpleJIT（JIT，Just-In-Time），SimpleJIT 会将其加工成部分优化的代码。再加上收集到的分析数据，FullJIT 可以生成高度优化的代码。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f83168b6c2a97549d9f83642fe8e0d75_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-f83168b6c2a97549d9f83642fe8e0d75_b.jpg\"/></figure><p>JavaScriptCore（JSC），Apple 的 JavaScript 引擎，更是发挥到了极致，使用了三个不同的优化编译器，Baseline、DFG 和 FTL。低级解释器（LLInt）将转换后的代码传给 Baseline 编译器，经其加工后传给 DFG（Data Flow Graph） 编译器，进一步加工后，传给 FTL（Faster Than Light） 编译器。</p><p>为什么有些引擎的优化编译器会比其他引擎的多？这完全是取舍问题。解释器可以很快地生成字节码，但是字节码的效率不高。优化编译器虽然会花更长的时间，但是生成的机器码更为高效。是更快地去执行代码，还是花些时间去执行更优的代码，这都是需要考虑的问题。有些引擎添加多种不同特点（省时或高效）的优化编译器，虽然这会变得更加复杂，但却可以对以上的取舍有着更细粒度地控制。还有一点需要考虑的是，内存的使用。</p><p>以上只是强调了不同 JavaScript 引擎的解析器/编译器的区别。抛开这些不谈，从更高的层面来看，所有的 JavaScript 引擎有着相同的架构：一个解析器和一些解释器/编译器。</p><h2>JavaScript 对象模型</h2><p>再来看看，在某些具体实现上，JavaScript 引擎之间还有哪些相同之处。</p><p>例如，JavaScript 引擎是如何实现 JavaScript 对象模型的？它们又是如何提升对象属性访问速度的？事实证明，所有主流的引擎在这点实现上都非常得相似。</p><p>ECMAScript 规范把所有的对象定义为词典，将字符串键映射到属性特性（<a href=\"https://link.zhihu.com/?target=https%3A//tc39.es/ecma262/%23sec-property-attributes\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">property attributes</a>）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5c1a47f088917fc91c727abc06177306_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-5c1a47f088917fc91c727abc06177306_b.jpg\"/></figure><p>除了 <code>[[Value]]</code>， 规范还定义了一下属性：</p><ul><li><code>[[Writable]]</code> 定义是否可写。</li><li><code>[[Enumerable]]</code> 定义是否可枚举。</li><li><code>[[Configurable]]</code> 定义是否可配置。</li></ul><p><code>[[双中括号]]</code> 是用来描述不能直接暴露给 JavaScript 的属性。不过你依然可以通过 <code>Object.getOwnPropertyDescriptor</code> 获取某个对象上的以上属性。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">foo</span><span class=\"o\">:</span> <span class=\"mi\">42</span> <span class=\"p\">};</span>\n<span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">getOwnPropertyDescriptor</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">,</span> <span class=\"s1\">&#39;foo&#39;</span><span class=\"p\">);</span>\n<span class=\"c1\">// → { value: 42, writable: true, enumerable: true, configurable: true }\n</span></code></pre></div><p>ok，这是 JavaScript 如何定义对象的。那么，数组呢？</p><p>你可以认为数组是一个特殊的对象。一个不同点是，数组会对数组索引特殊处理。数组索引是 JavaScript 规范中的一个特殊术语。数组索引是某个范围内的任何有效索引，即在 0 ～ 2³²−2 范围内的任何一个整数。</p><p>另一个不同点是，数组还有一个 <code>length</code> 属性。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">array</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">];</span>\n<span class=\"nx\">array</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"c1\">// → 2\n</span><span class=\"c1\"></span><span class=\"nx\">array</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;c&#39;</span><span class=\"p\">;</span>\n<span class=\"nx\">array</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"c1\">// → 3\n</span></code></pre></div><p>在这个例子里，数组创建好后，<code>&#39;length&#39;</code> 值为 2。当我们给数组索引为 2 的位置赋值时，数组的 <code>&#39;length&#39;</code> 会自动更新。</p><p>在 JavaScript 中，数组的定义和对象很相似。例如，数组的所有的键（包括数组索引）都是字符串表示。数组的第一个元素存在键值为 <code>&#39;0&#39;</code> 的地方。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-83d4c3e3506edaaf415d5d4a3a267807_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-83d4c3e3506edaaf415d5d4a3a267807_b.jpg\"/></figure><p>另一个属性是 <code>&#39;length&#39;</code> 属性，该属性不可枚举不可配置。</p><p>一旦数组添加一个元素，JavaScript 会自动更新 <code>&#39;length&#39;</code>属性上的  <code>[[Value]]</code> 值。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2ee3bc1232aeec503eec8e8df1135564_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-2ee3bc1232aeec503eec8e8df1135564_b.jpg\"/></figure><p>一般来说，数组的行为也是和对象非常相似。</p><h2>优化属性的访问</h2><p>既然我们知道在 JavaScript 中如何定义对象的。接下来让我们深入了解 JavaScript 引擎是如何高效地处理对象的。</p><p>属性访问是最常见的一个操作，对 JavaScript 引擎来说，提升访问速度事件很有意义的事。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">foo</span><span class=\"o\">:</span> <span class=\"s1\">&#39;bar&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">baz</span><span class=\"o\">:</span> <span class=\"s1\">&#39;qux&#39;</span><span class=\"p\">,</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// Here, we’re accessing the property `foo` on `object`:\n</span><span class=\"c1\"></span><span class=\"nx\">doSomething</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">foo</span><span class=\"p\">);</span>\n<span class=\"c1\">//          ^^^^^^^^^^\n</span></code></pre></div><h3>外形（Shapes）</h3><p>在 JavaScript 程序中，有相同键的对象很多，它们有相同的 <code>Shape</code>。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object1</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"p\">};</span>\n<span class=\"k\">const</span> <span class=\"nx\">object2</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"p\">};</span>\n<span class=\"c1\">// `object1` and `object2` have the same shape.\n</span></code></pre></div><p>有着相同 <code>Shape</code> 的对象，自然会访问相同的属性。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">logX</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">);</span>\n    <span class=\"c1\">//          ^^^^^^^^\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">object1</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"p\">};</span>\n<span class=\"k\">const</span> <span class=\"nx\">object2</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"p\">};</span>\n\n<span class=\"nx\">logX</span><span class=\"p\">(</span><span class=\"nx\">object1</span><span class=\"p\">);</span>\n<span class=\"nx\">logX</span><span class=\"p\">(</span><span class=\"nx\">object2</span><span class=\"p\">);</span>\n</code></pre></div><p>考虑到这一点，JavaScript 引擎可以基于 对象的 <code>Shape</code> 来优化对象属性的访问速度。</p><p>我们假设一个对象有 x、y 属性，且用着字典这种数据结构：它包含字符串表示的键，并且键指向各自的属性特性（property attributes）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5c1a47f088917fc91c727abc06177306_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-5c1a47f088917fc91c727abc06177306_b.jpg\"/></figure><p>如果要访问一个属性，例如 <code>object.y</code>，JavaScript 引擎会在 <code>JSObject</code> 中查找 <code>y</code>，然后加载对应的属性特性，最后返回 <code>[[Value]]</code>。</p><p>但是在内存中，这些属性特性要存储在哪儿呢？我们应该把它们当作 <code>JSObject</code> 的一部分存储吗？假设之后会有更多的拥有相同 <code>Shape</code> 的对象，如果我们在 <code>JSObject</code> 上存储一个包含属性名称和属性特性的完整字典的话，那显然会是一种浪费。因为拥有相同 <code>Shape</code> 的对象，它们的属性名称会重复。这回造成大量重复和不必要的内存使用。作为优化，引擎将对象的 <code>Shape</code> 单独地存储。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3a5eeb521a25d5ea0038fa4e38b76d76_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-3a5eeb521a25d5ea0038fa4e38b76d76_b.jpg\"/></figure><p><code>Shape</code> 包含所有的属性名称和属性特性，除了 <code>[[Value]]</code>。不过，<code>Shape</code> 包含了 <code>[[Value]]</code> 在 <code>JSObject</code> 上的偏移量，因此 JavaScript 引擎知道去哪里找到相应的值。 每个拥有相同 <code>Shape</code> 的 <code>JSObject</code> 都指向同一个 <code>Shape</code> 实例。现在，每个 <code>JSObject</code> 只需存储对象的值即可。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-27eb85d2c68fb606e64aebe861ca351b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-27eb85d2c68fb606e64aebe861ca351b_b.jpg\"/></figure><p>当我们有很多个对象时，好处也是显而易见的。不管有多少个对象，只要有相同的 <code>Shape</code>，<code>Shape</code> 和属性信息只需要存储一次。</p><p>所有的 JavaScript 引擎都用 Shapes 来优化，但叫法却不同：</p><ul><li>学术论文称之为 Hidden Classes（容易和 JavaScript 中的 Class 混淆）</li><li>V8 称之为 Maps（容易和 JavaScript 中的 Map 混淆）</li><li>Chakra 称之为 Types（容易和 JavaScript 中的动态类型与 typeof 混淆）</li><li>JavaScriptCore 称之为 Structures</li><li>SpiderMonkey 称之为 Shapes</li></ul><p>在这篇文章中，我们继续称之为 Shapes。</p><h3>过渡链与树（Transition chains and trees）</h3><p>如果一个对象有了一个确定的 <code>Shape</code>,然后又添加了一个属性，这会发生什么呢？JavaScript 引擎如何找到改变后的新 <code>Shape</code>？</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n<span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n<span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"mi\">6</span><span class=\"p\">;</span>\n</code></pre></div><p>在 JavaScript 引擎中，这种 Shapes 结构称之为过渡链。如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3d87fd5e9abbd81384051598ac65c51b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-3d87fd5e9abbd81384051598ac65c51b_b.jpg\"/></figure><p>对象开始时没有任何属性，因此它会指向一个空的 <code>Shape</code>。下一条语句对象添加了一个属性 <code>&#39;x&#39;</code>，属性值为 5，因此对象指向包含属性 <code>&#39;x&#39;</code> 的 <code>Shape</code>，且在 <code>JSObject</code> 中偏移量为 0 的位置添加 5。下一条语句对象添加了一个属性 <code>&#39;y&#39;</code>，属性值为 5，因此对象指向包含属性 <code>&#39;x&#39;</code> 和 <code>&#39;y&#39;</code> 的 <code>Shape</code>，且在 <code>JSObject</code> 中偏移量为 1 的位置添加 6。</p><blockquote> 注意： 属性的添加顺序会影响 <code>Shape</code>。例如，<code>{x: 4, y: 5}</code> 和 <code>{y: 5, x: 4}</code> 有不同的 <code>Shape</code>。<br/> </blockquote><p>我们没有必要让每个 <code>Shape</code> 都存储完整的属性表。相反，每个 <code>Shape</code> 只需要知道新引入的属性即可。例如，在这种情况下，我们没有必要在最后一个 <code>Shape</code> 中存储属性 <code>&#39;x&#39;</code> 的信息，因为它可以在链的上游中被查找到。要达此目的，每个 <code>Shape</code> 都会和先前的 <code>Shape</code> 链接。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-960c873169af5b76834b9c0495c2bc58_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-960c873169af5b76834b9c0495c2bc58_b.jpg\"/></figure><p>如果你在 JavaScript 代码中写了 <code>o.x</code>，JavaScript 引擎会沿着过渡链查找属性 <code>&#39;x&#39;</code>，直到发现引入 <code>&#39;x&#39;</code> 的 <code>Shape</code>。</p><p>但是，如果没法创建过渡链呢？例如，给两个空对象添加不同的属性。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object1</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n<span class=\"nx\">object1</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n<span class=\"k\">const</span> <span class=\"nx\">object2</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n<span class=\"nx\">object2</span><span class=\"p\">.</span><span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"mi\">6</span><span class=\"p\">;</span>\n</code></pre></div><p>这种情况下，不得不进行分支处理，用过渡树（transition tree）取代过渡链。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f7d30794cfd645de8d2f9fb0681b6037_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-f7d30794cfd645de8d2f9fb0681b6037_b.jpg\"/></figure><p>在这里，我们创建了一个空对象 <code>a</code>并给它添加了属性 <code>&#39;x&#39;</code>。最终得到以一个包含单个值的 <code>JSObject</code>和两种 <code>Shape</code>（空的 <code>Shape</code> 和仅有属性 <code>&#39;x&#39;</code> 的 <code>Shape</code>）。</p><p>第二个例子也是以一个空对象 <code>b</code> 开始，但是添加的是属性 <code>&#39;y&#39;</code>。最终得到两条 <code>Shape</code> 链和三个 <code>Shape</code>。</p><p>这是否意味着总是以空 <code>Shape</code> 开头呢？不一定。</p><p>引擎对已经存在属性的对象字面两做了优化。来看两个例子，一个是从空的对象开始添加属性 <code>&#39;x&#39;</code>，一个是已经存在属性 <code>&#39;x&#39;</code> 的对象字面量。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">object1</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n<span class=\"nx\">object1</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n<span class=\"k\">const</span> <span class=\"nx\">object2</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"mi\">6</span> <span class=\"p\">};</span>\n</code></pre></div><p>第一个例子中，我们从空的 <code>Shape</code> 过渡到包含属性 <code>&#39;x&#39;</code> 的 <code>Shape</code>，就如之前所看到的那样。</p><p>对于 <code>object2</code>，它直接生成包含属性 <code>&#39;x&#39;</code> 的对象而不是从空对象开始过渡。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3c15706e96421406e5194122ef1b15a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-3c15706e96421406e5194122ef1b15a4_b.jpg\"/></figure><p>这个包含属性 <code>&#39;x&#39;</code> 的对象，以包含 <code>&#39;x&#39;</code> 的 <code>Shape</code> 开头，省去了空 <code>Shape</code> 这个步骤。至少 V8 和 SpiderMonkey 是这么做的。这种优化缩短了过渡链，使得创建对象更加高效。</p><p>Benedikt 的文章 <a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40bmeurer/surprising-polymorphism-in-react-applications-63015b50abc\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">surprising polymorphism in React applications</a> 讨论了这些微妙之处是如何影响到实际性能的。</p><p>这有一个拥有属性 <code>&#39;x&#39;、</code>&#39;y&#39;<code>、</code>&#39;z&#39;` 的三维点对象的例子。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">point</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n<span class=\"nx\">point</span><span class=\"p\">.</span><span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n<span class=\"nx\">point</span><span class=\"p\">.</span><span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n<span class=\"nx\">point</span><span class=\"p\">.</span><span class=\"nx\">z</span> <span class=\"o\">=</span> <span class=\"mi\">6</span><span class=\"p\">;</span>\n</code></pre></div><p>就如之前所学到的，在内存上，这回创建有三个 <code>Shape</code> 的对象（空 <code>Shape</code> 不计入）。访问对象的属性 <code>&#39;x&#39;</code>，例如，如果你在程序中写下了 <code>point.x</code>，JavaScript 引擎会顺着链表：它会从底部的 <code>Shape</code> 开始，一直向上查找，直到发现引入 <code>&#39;x&#39;</code> 的那个 <code>Shape</code>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4fd2790d86d616a81eda2c2d1c6d23f7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-4fd2790d86d616a81eda2c2d1c6d23f7_b.jpg\"/></figure><p>如果这种操作很频繁，就会显得很慢，尤其是一个对象有很多属性时。检索到需要的属性所花时间是 O（n），即线性的。为了提高检索速度，JavaScript 引擎加入了 <code>ShapeTable</code> 数据结构。<code>ShapeTable</code> 是个字典，它将属性和引入该属性的 <code>Shape</code> 关联起来。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-85fec2dc7849c2395e236b5f31be7019_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-85fec2dc7849c2395e236b5f31be7019_b.jpg\"/></figure><p>且慢，我们又回到了字典查找……这不就是我们在引入 Shapes 之前的方式吗？为什么我们非要整出个 Shapes？</p><p>原因是 Shapes 可以实现另一种称之为内联缓存的优化。</p><h3>内联缓存（Inline Caches (ICs)）</h3><p>ICs 是 JavaScript 快速运行的关键因素。JavaScript 引擎可以利用 ICs 缓存对象的属性信息，从而减少属性查找的开销。</p><p>有个函数 <code>getX</code> ，接受一个对象并加载该对象上的属性 <code>x</code>：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">getX</span><span class=\"p\">(</span><span class=\"nx\">o</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">x</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>如果我们在 JSC（JavaScriptCore） 中运行这个函数，它会生成以下的字节码：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1c7d7e8e714d6143499603d043b98b6f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-1c7d7e8e714d6143499603d043b98b6f_b.jpg\"/></figure><p>第一条指令（<code>get_by_id</code>）是从参数 <code>arg1</code> 中加载属性 <code>x</code>，并将其值存储到 <code>loc0</code> 中。第二条指令是返回 <code>loc0</code> 中存储的值。</p><p>JSC 还在 <code>get_by_id</code> 指令中嵌入了内联缓存，它是由两个未初始化的插槽组成。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9ad219bf2dadbab8cb3ac05269cff018_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-9ad219bf2dadbab8cb3ac05269cff018_b.jpg\"/></figure><p>现在给函数 <code>getX</code> 传入对象 <code>{ x: &#39;a&#39; }</code>。如我们所知，这个对象有一个包含属性 <code>x</code> 的 <code>Shape</code>，这个 <code>Shape</code> 存储了属性 <code>x</code> 的偏移量和特性。当我们第一次执行函数时，<code>get_by_id</code> 指令会查找属性 <code>x</code> 并检索到值被存储在偏移量为 <code>0</code> 位置。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-77dcd0127b51c4a4aa350f478df8e645_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-77dcd0127b51c4a4aa350f478df8e645_b.jpg\"/></figure><p>嵌在 <code>get_by_id</code> 指令中的内联缓存会记住 <code>Shape</code> 和属性的偏移量。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1c91ac23d7062ba313c122374b20f74c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-1c91ac23d7062ba313c122374b20f74c_b.jpg\"/></figure><p>在下次函数执行时，内联缓存会对比 <code>Shape</code>，如果与之前的 <code>Shape</code> 相同，就只需要通过缓存的偏移量加载值。具体来说，如果 JavaScript 引擎发现对象的 <code>Shape</code> 和之前记录的 <code>Shape</code> 一样，那么它就再也不需要去查找属性信息了 ——  属性信息的查找就可以完全跳过。相比每次都去查找属性信息，这样的操作会显著地提升速度。</p><h3>高效存储数组（Storing arrays efficiently）</h3><p>对于数组，使用数组索引作为数组的属性是很常见的，属性对应的值称之为数组元素。为每个数组的每个数组元素存储属性特性是一种铺张浪费的行为。在 JavaScript 引擎中，数组的索引属性默认是可读、可枚举和可配置的，且数组元素是与命名属性分开存储的。</p><p>思考以下这个数组：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">array</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"s1\">&#39;#jsconfeu&#39;</span><span class=\"p\">,</span>\n<span class=\"p\">];</span>\n</code></pre></div><p>引擎存储了一个数组长度为 1 的数组，它指向一个包含偏移量和 <code>length</code> 特性的 <code>Shape</code>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3b2d708e5a1a348504d8cfc525b761d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic1.zhimg.com/v2-3b2d708e5a1a348504d8cfc525b761d8_b.jpg\"/></figure><p>这个之前见过的很相似…… 但是数组元素的值存在哪呢？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c06665091660920d4a8550174607fb09_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic2.zhimg.com/v2-c06665091660920d4a8550174607fb09_b.jpg\"/></figure><p>每个数组都有一个独立的元素备份存储（elements backing store），包含着所有索引属性对应的值。JavaScript 引擎不必为数组元素存储属性特性，因为他们通常是可写、可枚举和可配置的，且数组索引可以替代偏移量的作用。</p><p>如果是不寻常的情况会怎样呢？比如，改变数组元素的属性特性（property attributes）。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Please don’t ever do this!\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">array</span> <span class=\"o\">=</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">defineProperty</span><span class=\"p\">(</span>\n    <span class=\"p\">[],</span>\n    <span class=\"s1\">&#39;0&#39;</span><span class=\"p\">,</span>\n    <span class=\"p\">{</span>\n        <span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Oh noes!!1&#39;</span><span class=\"p\">,</span>\n        <span class=\"nx\">writable</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>\n        <span class=\"nx\">enumerable</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>\n        <span class=\"nx\">configurable</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">);</span>\n</code></pre></div><p>上面的这个代码片段是给对象属性 <code>&#39;0&#39;</code> 的特性设置成非默认值。</p><p>像这种情况，JavaScript 引擎会将整个元素备份存储表示为一个字典，把数组索引和属性特性关联起来。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e0f6ebf0b1d2918c55962b29bf7417c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-e0f6ebf0b1d2918c55962b29bf7417c2_b.jpg\"/></figure><p>即使数组中只有一个元素的属性特性是非默认值，元素备份存储也会进入缓慢低效的模式（从 Elements 模式 到 Dictionary Elements 模式）。避免用 <code>Object.defineProperty</code> 改变数组索引！</p><h2>看点（Take-aways）</h2><p>基于以上的知识，我们可以使用一些 JavaScript 编程技巧来提升性能：</p><ol><li>始终以相同的方式初始化对象，这样就可以复用 <code>Shape</code>。</li><li>不要没事瞎折腾数组元素的属性特性，它们本可以高效地工作。</li></ol>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "JavaScript 引擎", 
                    "tagLink": "https://api.zhihu.com/topics/19856435"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82438631", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 7, 
            "title": "前端架构碎碎念", 
            "content": "<h2>前言</h2><p>最近看了一些关于前端架构相关的书籍和博客，觉得有点自我膨胀了，竟然想对着前端架构这一说法指指点点。从跨入这个行业开始，就觉得架构师就是位于技术金字塔的顶端的那拨人，是引导行业或团队技术走向的那拨人。然而从行业上对前端架构的定义和必备的技能来看，觉得前端架构就是一个伪概念，又或是拔高自己身份的幌子。</p><p>类比于建房子，考虑到人文因素，会有中西风格；考虑到地理位置，会有南北之分；考虑到简易方便，还会有组合式集装箱房屋。设计师会运用自己专业知识并集合各种因素，设计出符合当前环境的房屋。而架构师也是如此，他们需要从业务、技术等角度构造出合理的组织架构。前端技术不断发展演进，从模块化的摸索，到 MV* 的实践，再到当今组件化的盛行。这些技术人不断折腾，不断改进前端架构，使之更符合这个时代。在市场的筛选下，最终也留下了最适合当前的前端技术方案。不过，大部分前端架构师并不具备这种能力，充其量就是经验丰富的包工头，某种前端技术方案的践行者。</p><p>设计师怎么练成的，我们不知道。但是类比包工头，我们还是知道前端 Leader 应该做什么。</p><h2>开工前的前期准备</h2><p>这里的前期准备，指的是从零启动一个项目，我们需要做的准备工作。而最能体现整个项目的技术含量的活估计有大半在这里了。作为一个包工头，不是说我能把砖砌得有多好，而是足够了解现有的资源和工作流，并搭建好基础设施，为日后项目高效推进起个好头。</p><p>在很早以前，数据和视图耦合，那时候没有前端的什么事，最多作为页面仔为后端提供模板，或者说画几个展示用的静态页面。之后 ajax 的兴起，让数据和视图的关系开始松绑，前端在数据的赋能下，迎来了一次大发展。人要与数据交互，必然要通过某个媒介，而前端在获取部分数据的权限后，又反过来促进了人与数据的互动关系。即使后面的 Node，我也认为是前端为争取操作数据权限而做的努力。毕竟，这个年代数据才是王道。</p><p>视图怎么获取数据？视图怎么展示数据？视图怎么更好得获取数据？视图怎么更好得展示数据？（...没想那么多...）</p><h3>架构设计</h3><p>从早期的服务端直出到现在的服务端渲染，视图的渲染兜兜转转貌似又回到的起点。但此非彼，不可同日而语。ajax 被 Google 使用后，随之而来的是前后端的分离。前端应用也是跟随时代而呈现不同的架构设计，比如多页面应用、单页面应用、同构渲染、微前端等。它们的出现是为了解决某些问题而给出的技术方案，所以说即使过时，却依然有其价值。</p><p>多页面应用，相对来说，比较简单。简单的多页面应用，比如静态页面，这里可能压根没 JS 的事。复杂点的多页面应用，可能要引入模板引擎，路由等。要是觉得原生操作 DOM 不方便，可以使用 jQuery。多页面应该在项目启动的时候，会加载需要的资源，由于浏览器缓存策略，第二次加载相同的资源时，可能就不需要重复请求了。在结合一点 MV* 模式，快和单页面应用没什么区别了。只是现在流行的单页面不需要直接操作 DOM ，而是交给框架底层处理了。</p><p>以上的应用说来说去可能都是同一个应用，在某些场景，就需要聚合多个前端应用，有路由分发的方案，有 iframe 作为容器的方案等。</p><h3>前端规范</h3><p>「书同文，车同轨」</p><p>既然是包工头，自然不大可能是一个光杆司令。制定规范，不仅可以使成员代码风格趋于统一，同时也可以使新手养成良好的编码习惯。对于前端来说，HTML、CSS、JS 分别代表了结构层、表现层和行为层。在代码层次上，它们都有自己的一套标准，可以结合各自 lint工具 + Prettier 轻松规范代码。从组件规范角度，还包括 UI 组件规范、模块化规范、项目组件化设计方案等。</p><p>编辑器最好也能够统一下，如果能够摸索出能够提高效率的一系列使用方法，同步给全组成员就更好了。</p><h3>自动化构建</h3><p>都 9102 年，自动化构建已成为现代前端工程不可或缺的一个环节。自动化构建可以做很多事，比如文件编译，资源合并，压缩优化等。构建工具很多，但所做的事基本上是差不多的，读取入口配置文件 ➡ 生成模块依赖图 ➡ 加载模块 ➡ 模块文件编译处理 ➡️ 模块文件合并 ➡️ 文件资源优化 ➡ 输出最终资源。</p><p>不论是生产环境还是开发环境，都需要构建工具的参与。生产环境侧重于性能，比如文件压缩优化，去除无用代码注释等。测试环境侧重于开发体验，比如模块热替换，生成 sourcemap 等。像之前的代码规范，也可以借助构建工具自动化格式化代码，或提示错误。</p><h3>项目代码示例</h3><p>项目在正是启动之前，需要验证程序是否按照自己的预期去执行。验证可行后，并按照自己定义的一系列规范编写示例代码，这样有助于其他成员了解该项目的规范。同时，对内组织技术培训，介绍系统的架构和注意事项。</p><p>其实，技术验证的过程不应该放在整个开发流程中。工作之余，我们可以多接触新的技术和尝试新的架构设计。在未知的领域，我们无法准确评估时间，临时磨枪可能会导致整个项目的延期。</p><h2>开工</h2><p>技术是为业务服务的，项目启动了，意味着开始偿还业务债了。而前端 Leader 职责也开始发生变化，不仅仅从事技术活，还要参与到团队管理、项目管理等非技术活。项目进入正轨后，人人都成为了螺丝工，技术上的难题基本上很少再会遇到。但是这并不代表整个开发过程会变得一帆风顺。</p><h3>沟通协调</h3><p>「凡事有交代，件件有着落，事事有回音」</p><p>不管是普通成员，还是团队 Leader，都应该具备这样的做事风格，对自己和别人都有个交代。</p><p>前端在整个研发队伍中，是一个比较尴尬的存在。尤其在比较重视业务的团队里，好事没捞到，麻烦事却不断找上门。比如页面抛异常，测试伙伴第一个就找前端。产品伙伴不靠谱，频繁找前端。遇到不靠谱的后端小伙伴，联调测试时也会跑来质疑前端。最后可能领导跑来找你谈话，说你们前端团队怎么老是出问题。讲真，这话没法接。感觉前端就是一个接锅侠，时间长了，对团队士气有很大的影响，这也是前端 Leader 需要解决的问题。</p><p>对于产品，需求评审严格把关，对于不合理或不紧急的需求，延迟或降低其优先级。对于测试伙伴，对其进行技术培训，了解开发者工具的简单使用，和常见异常报错分析科普。对于后端，制定相关约束。以上规范要形成文档保存，方便后来者。</p><p>当然诸如此类的问题会有很多，对于问题要敏感并及时发现，分析导致问题的根源，最后对症下药逐步解决问题。事情说得很简单，但事实上，人们习惯于存在问题的现状而不自知或发现问题却习惯于有问题的现状。</p><h3>提升团队能力</h3><p>众人拾柴火焰高，只有大伙儿力往一处使，才能产生 1 + 1 &gt; 2 的效果。可是编码并不是力气活，成员的参差不齐，很大的程度上会拖团队的后退。比如，一个新手的代码提交不规范，很可能导致某些人的哀嚎。</p><p>代码审查，是一个提高自己编码能力的好机会。之前的 Lint 规则可以很好地校正代码风格，而在代码审查中，就可以发现逻辑上的问题或知道可以让代码更出彩的方法。</p><p>代码重构算是一种提升编程能力的方式，不过有很多人对代码重构有着很大的误解，也不见得项目中对重构的重视。重构可以本着小步快走的原则，增加程序的可读性和可维护性。何时去重构？需要重构的标准的是什么？如果程序冗长啰嗦看不懂，那就重构它。如果一段程序过分依赖于注释，那就重构它。如果你想添加新功能，却无从下手，那就重构它。只要是可读性差，可维护性差，你都有理由去重构它。</p><p>代码审查还有一个好处就是，可以帮助我们熟悉业务。如果项目业务很复杂，至少要保证有两个人对同一模块有足够的了解。</p><p>新人培训和技术分享，新人刚接入项目时，有必要对其进行基础的技术培训，如业务培训、技术栈相关知识培训、调试能力培训等，这些都要有相关的文档。这些看着无关紧要的培训，对于新手来说，往往是一大助力。</p><p>技术分享，并不指望一次简单的分享就让所有的成员学会一项技能，不过这对团队的技术视野和团队技术氛围会有很大帮助。对于技术分享的人，有不同的说法，有人主张新人主持分享，这样可以加快新人融入团队，老人也可以一旁补充说明。而有些人，则认为让最擅长的人去做擅长的事。不知道孰好孰坏，不予置评。</p><p>我认为团队能力还应该包括存续能力，也就是即便成员流动快，新到位的成员也能很快接入项目。这就需要各种文档记录，新人培训文档，技术架构文档，业务文档，技术分享文档，开发规范文档，工作交接文档等。</p><h3>前后端联调</h3><p>后端由本地开发环境部署到测试环境，按正常的节奏来，前后端联调会很顺利。然而，实际开发中，联调的占比会很大。主要的原因有，</p><ol><li>前后端沟通效率低，有问题相互质疑。</li><li>后端自测力度不够，考虑不周全。</li><li>接口协议变动频繁。</li><li>接口文档不详实。 ...</li></ol><p>最简单粗暴的方法就是引入接口管理平台，引入绩效考核制度。</p><h3>持续化集成 持续化交付 持续化部署</h3><p>这一块就不是前端自己能够决定的事情了，有条件的话可以自己搭建代码托管平台，使用 gitlab ，现在人家提供一条龙服务，可以尝试一波。</p><h2>结语</h2><p>和代码打交道不可怕，和人打交道也不可怕，可怕的是这个前端 Leader 有想法。</p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }
            ], 
            "comments": [
                {
                    "userName": "大江山岚", 
                    "userLink": "https://www.zhihu.com/people/36ddf904e3fcc0c5204532632326d63b", 
                    "content": "请问关于前端架构方面有哪些书籍和博客可以推荐呢", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "没有呢，不然也不会写这个博文了[捂脸]，真要看架构就不能局限于前端了", 
                            "likes": 0, 
                            "replyToAuthor": "大江山岚"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80764292", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 2, 
            "title": "为强制类型转换正名", 
            "content": "<a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/%25E4%25B8%25BA%25E5%25BC%25BA%25E5%2588%25B6%25E7%25B1%25BB%25E5%259E%258B%25E8%25BD%25AC%25E6%258D%25A2%25E6%25AD%25A3%25E5%2590%258D/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-4dad71953b4f3a5c60f78f9d15539666_180x120.jpg\" data-image-width=\"640\" data-image-height=\"512\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">为强制类型转换正名</a><h2>引子</h2><blockquote>强制类型转换是JavaScript开发人员最头疼的问题之一, 它常被诟病为语言设计上的一个缺陷, 太危险, 应该束之高阁.</blockquote><p>作为开发人员, 往往会遇到或写过涉及到类型转换的代码, 只是我们从来没有意识到.</p><p><b>猜猜看</b>😏:</p><ol><li>作为基本类型值, 为什么我们可以使用相关的属性或方法? eg: <code>&#39;hello&#39;.charAt(0)</code> (参见(#内置类型和内建函数的关系))</li><li><code>a &amp;&amp; (b || c)</code> 这波操作我们知道, 那么 <code>if (a &amp;&amp; (b || c))</code>, 这里又做了哪些操作? (参见(#条件判断))</li><li><code>if (a == 1 &amp;&amp; a== 2) { dosomething }</code>, <b>dosomething</b> 竟然执行了, 什么鬼? (参见(#ToPrimitive))</li><li><code>[] == ![]</code> =&gt; true ?; <code>false == []</code> =&gt; true ?; <code>&#34;0&#34; == false</code> =&gt; true ?(参见(#抽象相等))</li><li><code>if (~indexOf(&#39;a&#39;))</code>, 这波操作熟悉不? (参见(#隐式强制类型转换))</li><li>在<b>String</b> , <b>Number</b> , <b>Boolean</b> 类型之间比较时, 进行的强制类型转换又遵循了哪些规则? (参见(#抽象操作))</li></ol><p>掌握了JavaScript强制类型转换的抽象操作, 以上的问题都是小儿科.</p><p>滑至文章底部可直接看栗子🌰. <i>掘金Markdown部分语法不支持, 可点此阅读<a href=\"https://link.zhihu.com/?target=https%3A//www.yexiaochen.com/%25E4%25B8%25BA%25E5%25BC%25BA%25E5%2588%25B6%25E7%25B1%25BB%25E5%259E%258B%25E8%25BD%25AC%25E6%258D%25A2%25E6%25AD%25A3%25E5%2590%258D/%23more\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">原文</a>.</i></p><p><i>(以下内容是以《你不知道的JavaScript》强制类型转换部分为大纲, 并参照</i> <i><code></code></i>r<i>ef</i>=&#34;<a href=\"https://link.zhihu.com/?target=https%3A//www.ecma-international.org/ecma-262/5.1/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">ecma-international.org/</span><span class=\"invisible\">ecma-262/5.1/</span><span class=\"ellipsis\"></span></a>&#34;&gt;ecma 规范 <i>撰写.)</i></p><hr/><h2>类型</h2><h3>内置类型</h3><p>JavaScript 有七种内置类型. <b>空值</b>: null, <b>未定义</b>: undefined, <b>布尔值</b>: boolean, <b>数字</b>: number, <b>字符串</b>: string, <b>对象</b>: object, <b>符号</b>: symbol. 除 <b>对象</b>:object, 为复杂数据类型, 其它均为基本数据类型.</p><h3>内建函数</h3><p>常用的内建函数: <b>String()</b>, <b>Number()</b>, <b>Boolean()</b>, <b>Array()</b>, <b>Object()</b>, <b>Function()</b>, <b>RegExp()</b>, <b>Date()</b>, <b>Error()</b>, <b>Symbol()</b>.</p><h3>内置类型和内建函数的关系</h3><p>为了便于操作基本类型值, JavaScript提供了封装对象(内建函数), 它们具有各自的基本类型相应的特殊行为. 当读取一个基本类型值的时候, JavaScript引擎会自动对该值进行封装(创建一个相应类型的对象包装它)从而能够调用一些方法和属性操作数据. 这就解释了 <i><b><code>问题 1</code></b></i> .</p><h3>类型检测</h3><p><i><b>typeof</b></i> =&gt; 基本类型的检测均有同名的与之对应. <b>null</b> 除外, null是假值, 也是唯一一个typeof检测会返回 <code>&#39;object&#39;</code> 的基本数据类型值.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">typeof</span> <span class=\"kc\">null</span> <span class=\"c1\">// &#34;object&#34;\n</span><span class=\"c1\"></span>\n<span class=\"kd\">let</span> <span class=\"nx\">a</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">a</span> <span class=\"o\">&amp;&amp;</span> <span class=\"k\">typeof</span> <span class=\"nx\">a</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;object&#39;</span><span class=\"p\">)</span> <span class=\"c1\">// true\n</span></code></pre></div><p>复杂数据类型typeof检测返回 <code>&#39;object&#39;</code>, function(函数)除外. 函数因内部属性[[Call]]使其可被调用, 其实属于可调用对象.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">typeof</span> <span class=\"kd\">function</span><span class=\"p\">(){}</span> <span class=\"c1\">// &#34;function&#34;\n</span></code></pre></div><p><i><b>Object.prototype.toString</b></i> =&gt; 通过typeof检测返回<code>&#39;object&#39;</code>的对象中还可以细分为好多种, 从内建函数就可以知道.它们都包含一个内部属性[[Class]], 一般通过Object.prototype.toString(...)来查看.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">str</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">String</span><span class=\"p\">(</span><span class=\"s1\">&#39;hello&#39;</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">num</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Number</span><span class=\"p\">(</span><span class=\"mi\">123</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Array</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">);</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"nx\">str</span><span class=\"p\">))</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"nx\">num</span><span class=\"p\">))</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">))</span>\n\n<span class=\"c1\">// [object String]\n</span><span class=\"c1\">// [object Number]\n</span><span class=\"c1\">// [object Array]\n</span></code></pre></div><hr/><h2>抽象操作</h2><p>在数据类型转换时, 处理不同的数据转换都有对应的抽象操作(仅供内部使用的操作), 在这里用到的包括 <b>ToPrimitive</b>, <b>ToString</b>, <b>ToNumber</b>, <b>ToBoolean</b> (详见 <code>ecma</code> 规范). 这些抽象操作定义了一些转换规则, 不论是显式强制类型转换, 还是隐式强制类型转换, 无一例外都遵循了这些规则. 这里就解释了 <b><code><i>问题 5</i></code></b> 和 <b><code><i>问题 6</i></code></b> .</p><h3>ToPrimitive</h3><p>该抽象操作是将传入的参数转换为非对象的数据. 当传入的参数为 Object 时, 它会调用内部方法<code>[[DefaultValue]]</code> 遵循一定规则返回非复杂数据类型, 规则 <b>详见(</b> <code><b>ecma</b></code> <b>规范: DefaultValue)</b>. 故 <b>ToString</b>, <b>ToNumber</b>, <b>ToBoolean</b>在处理Object时, 会先经过<b>ToPrimitive</b>处理返回基本类型值.</p><p><b><code>[[DefaultValue]](hint)</code>语法:</b></p><p><code>[[DefaultValue]]</code>的规则会依赖于传入的参数<code>hint</code>, <b>ToString</b>传入的 <code>hint</code> 值为 <code>String</code>, <b>ToNumber</b>传入的 <code>hint</code> 值为 <code>Number</code>.</p><ol><li><code>[[DefaultValue]](String)</code> =&gt; 若 <code>toString</code> 可调用, 且 <code>toString(Obj)</code> 为基本类型值, 则返回该基本类型值. 否则, 若 <code>valueOf</code> 可调用, 且 <code>valueOf(Obj)</code> 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 <code>TypeError</code>.</li><li><code>[[DefaultValue]](Number)</code> =&gt; 该规则正好和上规则调用 <code>toString</code>, <code>valueOf</code> 的顺序相反. 若 <code>valueOf</code> 可调用, 且 <code>valueOf(Obj)</code> 为基本类型值, 则返回该基本类型值. 否则, 若 <code>toString</code> 可调用, 且 <code>toString(Obj)</code> 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 <code>TypeError</code>.</li><li><code>[[DefaultValue]]()</code> =&gt; 未传参时, 按照 <code>hint</code>值为 <code>Number</code> 处理. <code>Date</code> 对象除外, 按照<code>hint</code>值为 <code>String</code> 处理.</li></ol><p>现在我们就用以上的知识点来解释 <i><b><code>问题 3</code></b></i> 是什么鬼.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"nb\">Number</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">valueOf</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">i</span><span class=\"o\">++</span>\n<span class=\"p\">};</span>\n<span class=\"kd\">let</span> <span class=\"nx\">a</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Number</span><span class=\"p\">(</span><span class=\"s2\">&#34;0&#34;</span><span class=\"p\">);</span> <span class=\"c1\">// 字符串强制转换为数字类型是不执行Toprimitive抽象操作的.\n</span><span class=\"c1\"></span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;a_1:&#39;</span><span class=\"p\">,</span> <span class=\"nx\">a</span><span class=\"p\">);</span>\n<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">a</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">a</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;a==1 &amp; a==2&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;i:&#39;</span><span class=\"p\">,</span> <span class=\"nx\">i</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// a==1 &amp; a==2 i: 3\n</span></code></pre></div><p>我们改写了内建函数 <i><b>Number</b></i> 原型上的 <code>valueOf</code> 方法, 并使得一个字符串转换成 <i><b>Number</b></i> 对象, 第一次 <i><b>Object</b></i> 类型和 <i><b>Number</b></i> 类型做比较时, <i><b>Object</b></i> 类型将进行 <i><b>ToPrimitive</b></i> 处理(参见(#抽象相等)), 内部调用了 <i><b>valueOf</b></i>, 返回 <i><b>2</b></i>. 第二次同样的处理方式, 返回 <i><b>3</b></i>.</p><h3>ToString</h3><p>该抽象操作负责处理非字符串到字符串的转换.</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8b8725a0b7f0285d2f4ce64d82b0654a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1804\" data-rawheight=\"642\" class=\"origin_image zh-lightbox-thumb\" width=\"1804\" data-original=\"https://pic3.zhimg.com/v2-8b8725a0b7f0285d2f4ce64d82b0654a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1804&#39; height=&#39;642&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1804\" data-rawheight=\"642\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1804\" data-original=\"https://pic3.zhimg.com/v2-8b8725a0b7f0285d2f4ce64d82b0654a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8b8725a0b7f0285d2f4ce64d82b0654a_b.jpg\"/></figure><h3>ToNumber</h3><p>该抽象操作负责处理非数字到数字的转换.</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b07fd26dcf30aedc625fba429b146bef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1806\" data-rawheight=\"642\" class=\"origin_image zh-lightbox-thumb\" width=\"1806\" data-original=\"https://pic4.zhimg.com/v2-b07fd26dcf30aedc625fba429b146bef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1806&#39; height=&#39;642&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1806\" data-rawheight=\"642\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1806\" data-original=\"https://pic4.zhimg.com/v2-b07fd26dcf30aedc625fba429b146bef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b07fd26dcf30aedc625fba429b146bef_b.jpg\"/></figure><p><b>常见的字符串转换数字:</b></p><ol><li>字符串是空的 =&gt; 转换为0.</li><li>字符串只包含数字 =&gt; 转换为十进制数值.</li><li>字符串包含有效的浮点格式 =&gt; 转换为对应的浮点数值.</li><li>字符串中包含有效的十六进制格式 =&gt; 转换为相同大小的十进制整数值.</li><li>字符串中包含除以上格式之外的符号 =&gt; 转换为 NaN.</li></ol><h3>ToBoolean</h3><p>该抽象操作负责处理非布尔值到布尔值转换.</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-dfdc7390cb587faf6bf3cafa01897b6b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1804\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb\" width=\"1804\" data-original=\"https://pic4.zhimg.com/v2-dfdc7390cb587faf6bf3cafa01897b6b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1804&#39; height=&#39;640&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1804\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1804\" data-original=\"https://pic4.zhimg.com/v2-dfdc7390cb587faf6bf3cafa01897b6b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-dfdc7390cb587faf6bf3cafa01897b6b_b.jpg\"/></figure><p><b>真值</b> &amp; <b>假值</b></p><p>假值(强制类型转换<b>false</b>的值) =&gt; <code>undefined</code>, <code>null</code>, <code>false</code>, <code>+0</code>, <code>-0</code>, <code>NaN</code>, <code>&#34;&#34;</code>. 真值(强制类型转换<b>true</b>的值) =&gt; 除了假值, 都是真值.</p><p><i><b>特殊的存在</b></i></p><p>假值对象 =&gt; documen.all 等. eg: <code>Boolean(window.all)</code> // false</p><hr/><h2>隐式强制类型转换</h2><h3>+/-/!/~</h3><ol><li><b><code>+/- 一元运算符</code></b> =&gt; 运算符会将操作数进行ToNumber处理.</li><li><b><code>!</code></b> =&gt; 会将操作数进行ToBoolean处理.</li><li><b><code>~</code></b> =&gt; (~x)相当于 -(x + 1) eg: ~(-1) ==&gt; 0; ~(0) ==&gt; 1; 在if (...)中作类型转换时, 只有<code>-1</code>时, 才为假值.</li><li><b><code>+加号运算符</code></b> =&gt; 若操作数有String类型, 则都进行ToString处理, 字符串拼接. 否则进行ToNumber处理, 数字加法.</li></ol><h3>条件判断</h3><ol><li><code>if (...)</code>, <code>for(;;;)</code>, <code>while(...)</code>, <code>do...while(...)</code>中的条件判断表达式.</li><li><code>? :</code> 中的条件判断表达式.</li><li><code>||</code> 和 <code>&amp;&amp;</code> 中的中的条件判断表达式.</li></ol><p>以上遵循 <i><b>ToBoolean</b></i> 规则.</p><h3>||和&amp;&amp;</h3><ol><li>返回值是两个操作数的中的一个(且仅一个). 首先对第一个操作数条件判断, 若为非布尔值则进行ToBoolean强制类型转换.再条件判断.</li><li><b><code>||</code></b> =&gt; 条件判断为true, 则返回第一个操作数; 否则, 返回第二个操作数. 相当于 a ? a : b;</li><li><b><code>&amp;&amp;</code></b> =&gt; 条件判断为true, 则返回第二个操作数; 否则, 返回第一个操作数, 相当于 a ? b : a;</li></ol><p>结合条件判断, 解释下 <i><b><code>问题 2</code></b></i></p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">let</span> <span class=\"nx\">a</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span> <span class=\"nx\">b</span> <span class=\"o\">=</span> <span class=\"kc\">undefined</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span> <span class=\"nx\">c</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hello&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">a</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"nx\">b</span> <span class=\"o\">||</span> <span class=\"nx\">c</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n    <span class=\"nx\">dosomething</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">a</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"nx\">b</span> <span class=\"o\">||</span> <span class=\"nx\">c</span><span class=\"p\">)</span> <span class=\"nx\">返回</span> <span class=\"s1\">&#39;hello&#39;</span><span class=\"p\">,</span> <span class=\"nx\">if语句中经Toboolean处理强制类型转换为true</span><span class=\"p\">.</span>\n</code></pre></div><h3>抽象相等</h3><p>这里的知识点是用来解释 <i><b>问题 4</b></i> 的, 也是考验人品的地方. 这下我们要靠实力拼运气.</p><ol><li>同类型的比较.+0 == -0 // true null == null // true undefined == undefined // true NaN == NaN // false, 唯一一个非自反的值</li><li><i><b>null</b></i> 和 <i><b>undefined</b></i> 的比较.null == undefined // true undefined == null // true</li><li><i><b>Number</b></i> 类型和 <i><b>String</b></i> 类型的比较. =&gt; <i><b>String</b></i> 类型要强制类型转换为 <i><b>Number</b></i> 类型, 即 <i><b>ToNumber(String)</b></i> .(参见(#ToNumber))</li><li><i><b>Boolean</b></i> 类型和其它类型的比较. =&gt; <i><b>Boolean</b></i> 类型要强制类型转换为 <i><b>Number</b></i> 类型, 即 <i><b>ToNumber(Boolean)</b></i> .(参见(#ToNumber))</li><li><i><b>Object</b></i> 类型和 <i><b>String</b></i> 类型或 <i><b>Number</b></i> 类型. =&gt; <i><b>Object</b></i> 类型要强制转换为基本类型值, 即 <i><b>ToPrimitive(Object)</b></i> .(参见(#ToPrimitive))</li><li>其它情况, <i><b>false</b></i>.</li></ol><p>回头看看 <i><b>问题 4</b></i> 中的等式. <code>[] == ![]</code>, <code>false == []</code>, <code>&#34;0&#34; == false</code>. <code>[] == ![]</code> =&gt; <code>!</code> 操作符会对操作数进行 <i><b>ToBoolean</b></i> 处理, <code>[]</code> 是真值, <code>!true</code> 则为 <i><b>false</b></i>. 再遵循第 <i><b>4</b></i> 点, <i><b>Boolean</b></i> 类型经过 <i><b>ToNumber</b></i> 转换为 <i><b>Number</b></i> 类型, 则为数值 <code>0</code>. 再遵循第 <i><b>5</b></i> 点, 对 <code>[]</code> 进行 <i><b>ToPrimitive</b></i> 操作, 先后调用 <code>valueOf()</code>, <code>toString()</code>直到返回基本类型, 直到返回 <code>&#34;&#34;</code>. <i>(先[].valueOf() =&gt; [], 非基本类型值; 再[].toString() =&gt; &#34;&#34;, 基本类型值, 返回该基本类型值.)</i>. 再遵循第 <i><b>3</b></i> 点, 对 <code>&#34;&#34;</code> 进行 <i><b>ToNumber</b></i> 处理, 则为数值 <code>0</code>. 到此, <code>0 == 0</code>, 再遵循第 <i><b>1</b></i> 点(其实没写全😌, 详见(详见 <code>ecma</code> 规范: The Abstract Equality Comparison Algorithm)), return true, 完美!😏. <code>false == []</code> =&gt; 同理 <code>[] == ![]</code>. <code>&#34;0&#34; == false</code> =&gt; 同理 <code>[] == ![]</code>.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"p\">[]</span> <span class=\"o\">==</span> <span class=\"o\">!</span><span class=\"p\">[]</span>   <span class=\"c1\">// true\n</span><span class=\"c1\"></span><span class=\"kc\">false</span> <span class=\"o\">==</span> <span class=\"p\">[]</span> <span class=\"c1\">// true\n</span><span class=\"c1\"></span><span class=\"s2\">&#34;0&#34;</span> <span class=\"o\">==</span> <span class=\"kc\">false</span>    <span class=\"c1\">// true\n</span></code></pre></div><hr/><p>over!</p>", 
            "topic": [
                {
                    "tag": "原生 JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19691834"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76620620", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 7, 
            "title": "小程序云开发之始末", 
            "content": "<h2>前言</h2><p>在学习小程序开发时，倒是没觉得有什么阻碍，毕竟前端的最流行的框架已经流行了那么多年了，从某些方面，它们是相似的。本次所开发的功能很简单，但是就整个流程来说却是很漫长的，由于是从零开始开发，所以大部分时间还是花在了产品的构思上和小程序一些奇奇怪怪的问题上。而且，这次的开发只完成了产品预想的 50% 左右，核心的部分基本没有去做。最大的原因可能就是开发体验不好，浪费时间。</p><h2>小程序云开发</h2><p>对于个人开发人员来说，小程序云开发降低了开发门槛，尤其是前端人员的门槛。基于云开发，前端人员可以完成从前端到后台的所有任务。小程序云平台有着 Node环境，所以我们可以把它想象成基于 node 的后台环境。 以爬虫为例，首先在 cloudfunctions 文件夹下创建文件夹 crawler，在该文件夹下面在创建创建相应 <code>crawler.js</code> 、<code>package.json</code> 文件，剩下就可以写些逻辑了。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 云函数入口文件\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">cloud</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;wx-server-sdk&#39;</span><span class=\"p\">)</span>\n<span class=\"k\">const</span> <span class=\"nx\">Crawler</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s2\">&#34;crawler&#34;</span><span class=\"p\">);</span>\n<span class=\"nx\">cloud</span><span class=\"p\">.</span><span class=\"nx\">init</span><span class=\"p\">()</span>\n<span class=\"k\">const</span> <span class=\"nx\">uriArray</span> <span class=\"o\">=</span> <span class=\"p\">[{</span> <span class=\"nx\">uri</span><span class=\"o\">:</span> <span class=\"s1\">&#39;http://www.nows.fun/&#39;</span><span class=\"p\">,</span> <span class=\"nx\">selector</span><span class=\"o\">:</span> <span class=\"s1\">&#39;#sentence&#39;</span> <span class=\"p\">},</span> \n<span class=\"p\">{</span> <span class=\"nx\">uri</span><span class=\"o\">:</span> <span class=\"s1\">&#39;https://www.nihaowua.com/&#39;</span><span class=\"p\">,</span> <span class=\"nx\">selector</span><span class=\"o\">:</span> <span class=\"s1\">&#39;body &gt; div &gt; section &gt; div&#39;</span> <span class=\"p\">},</span> \n<span class=\"p\">{</span> <span class=\"nx\">uri</span><span class=\"o\">:</span> <span class=\"s1\">&#39;https://www.nihaowua.com/home.html&#39;</span><span class=\"p\">,</span> <span class=\"nx\">selector</span><span class=\"o\">:</span> <span class=\"s1\">&#39;body &gt; div &gt; section &gt; div&#39;</span> <span class=\"p\">}];</span>\n\n<span class=\"kd\">let</span> <span class=\"nx\">crawler</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Crawler</span><span class=\"p\">();</span>\n<span class=\"kd\">let</span> <span class=\"nx\">canClick</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">crawlerWebPage</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">canClick</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n  <span class=\"nx\">canClick</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">index</span> <span class=\"o\">=</span> <span class=\"nb\">Math</span><span class=\"p\">.</span><span class=\"nx\">floor</span><span class=\"p\">(</span><span class=\"nb\">Math</span><span class=\"p\">.</span><span class=\"nx\">random</span><span class=\"p\">()</span> <span class=\"o\">*</span> <span class=\"mi\">3</span><span class=\"p\">);</span>\n  <span class=\"kd\">let</span> <span class=\"p\">{</span> <span class=\"nx\">uri</span><span class=\"p\">,</span> <span class=\"nx\">selector</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">uriArray</span><span class=\"p\">[</span><span class=\"nx\">index</span><span class=\"p\">];</span>\n  <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">((</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">crawler</span><span class=\"p\">.</span><span class=\"nx\">direct</span><span class=\"p\">({</span>\n      <span class=\"nx\">uri</span><span class=\"o\">:</span> <span class=\"nx\">uri</span><span class=\"p\">,</span>\n      <span class=\"nx\">retries</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n      <span class=\"nx\">timeout</span><span class=\"o\">:</span> <span class=\"mi\">5000</span><span class=\"p\">,</span>\n      <span class=\"nx\">skipEventRequest</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>\n      <span class=\"nx\">callback</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">,</span> <span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">canClick</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n          <span class=\"kd\">var</span> <span class=\"nx\">$</span> <span class=\"o\">=</span> <span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">$</span><span class=\"p\">;</span>\n          <span class=\"kd\">var</span> <span class=\"nx\">content</span> <span class=\"o\">=</span> <span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"nx\">selector</span><span class=\"p\">).</span><span class=\"nx\">text</span><span class=\"p\">();</span>\n          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;index&#39;</span><span class=\"p\">,</span> <span class=\"nx\">index</span><span class=\"p\">)</span>\n          <span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">content</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">})</span>\n  <span class=\"p\">})</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">exports</span><span class=\"p\">.</span><span class=\"nx\">main</span> <span class=\"o\">=</span> <span class=\"kr\">async</span> <span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">,</span> <span class=\"nx\">content</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">crawlerWebPage</span><span class=\"p\">();</span>\n  <span class=\"k\">return</span> <span class=\"nx\">result</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>云函数创建好了，剩下的就是在小程序中去调用了。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">refresh</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">obj</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">data</span><span class=\"p\">.</span><span class=\"nx\">canClick</span><span class=\"p\">)</span> <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setData</span><span class=\"p\">({</span>\n      <span class=\"nx\">canClick</span><span class=\"o\">:</span> <span class=\"kc\">false</span>\n    <span class=\"p\">})</span>\n    <span class=\"nx\">wx</span><span class=\"p\">.</span><span class=\"nx\">showLoading</span><span class=\"p\">({</span>\n      <span class=\"nx\">title</span><span class=\"o\">:</span> <span class=\"s1\">&#39;加载中&#39;</span><span class=\"p\">,</span>\n    <span class=\"p\">})</span>\n    <span class=\"nx\">wx</span><span class=\"p\">.</span><span class=\"nx\">cloud</span><span class=\"p\">.</span><span class=\"nx\">callFunction</span><span class=\"p\">({</span>\n      <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s2\">&#34;crawler&#34;</span><span class=\"p\">,</span>\n      <span class=\"nx\">success</span><span class=\"o\">:</span> <span class=\"nx\">res</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"nx\">wx</span><span class=\"p\">.</span><span class=\"nx\">hideLoading</span><span class=\"p\">();</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setData</span><span class=\"p\">({</span>\n          <span class=\"nx\">soup</span><span class=\"o\">:</span> <span class=\"nx\">res</span><span class=\"p\">.</span><span class=\"nx\">result</span><span class=\"p\">,</span>\n          <span class=\"nx\">canClick</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n        <span class=\"p\">})</span>\n      <span class=\"p\">},</span>\n      <span class=\"nx\">fail</span><span class=\"o\">:</span> <span class=\"nx\">err</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"nx\">wx</span><span class=\"p\">.</span><span class=\"nx\">hideLoading</span><span class=\"p\">();</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setData</span><span class=\"p\">({</span>\n          <span class=\"nx\">soup</span><span class=\"o\">:</span> <span class=\"s2\">&#34;鸡汤要一口一口喝，你太急啦&#34;</span><span class=\"p\">,</span>\n          <span class=\"nx\">canClick</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n        <span class=\"p\">})</span>\n        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">error</span><span class=\"p\">(</span><span class=\"s1\">&#39;[云函数] [crawler] templateMessage.send 调用失败：&#39;</span><span class=\"p\">,</span> <span class=\"nx\">err</span><span class=\"p\">)</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">})</span>\n  <span class=\"p\">}</span>\n</code></pre></div><h2>小程序中的组件</h2><p>刚开始接触小程序时，给我的感觉像是在开发一个多页面应用。在开发构思的过程中，需要写的逻辑越来越多。于是就想着把这么多的东西拆开，翻了下文档，发现小程序提到自定义组件比较适合。 首先在父组件中配置文件中配置子组件路径，然后自组件也要配置。</p><div class=\"highlight\"><pre><code class=\"language-json\"><span class=\"err\">//</span> <span class=\"err\">father.json</span>\n<span class=\"p\">{</span>\n  <span class=\"nt\">&#34;usingComponents&#34;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">&#34;type-year&#34;</span><span class=\"p\">:</span> <span class=\"s2\">&#34;../../component/type-year/type-year&#34;</span><span class=\"p\">,</span>\n    <span class=\"nt\">&#34;type-month&#34;</span><span class=\"p\">:</span> <span class=\"s2\">&#34;../../component/type-month/type-month&#34;</span><span class=\"p\">,</span>\n    <span class=\"nt\">&#34;type-date&#34;</span><span class=\"p\">:</span> <span class=\"s2\">&#34;../../component/type-date/type-date&#34;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"err\">//</span> <span class=\"err\">children.json</span>\n<span class=\"p\">{</span>\n  <span class=\"nt\">&#34;component&#34;</span><span class=\"p\">:</span> <span class=\"kc\">true</span>\n<span class=\"p\">}</span></code></pre></div><p>剩下的就和 React、Vue 中的自定义组件差不多。</p><p>以上也只是自定义组件，平时还会接触到第三方的组件，比如常用的 UI 组件。通常第三方组件都是使用 npm 包，但是小程序的环境比较特殊，它不是 Node 环境，所以基于 Node 环境的 npm 包也要特殊处理才能够在小程序只能够使用。尽管小程序官方提供了 npm 包转换的方案，但是依然会有很多包不能在小程序中使用，具体可见官方小程序开发文档。</p><h2>小程序中操作节点</h2><p>小程序的渲染层和逻辑层分别由2个线程管理，这和浏览器的环境是不一样的，所以要想操作节点需要使用小程序提供的API，不过在跨组件获取节点时，需要注意一下。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">onLoad</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">height</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">yearChartHeight</span><span class=\"p\">,</span><span class=\"nx\">monthChartHeight</span><span class=\"p\">,</span><span class=\"nx\">componentHeight</span><span class=\"p\">;</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">query</span> <span class=\"o\">=</span> <span class=\"nx\">wx</span><span class=\"p\">.</span><span class=\"nx\">createSelectorQuery</span><span class=\"p\">().</span><span class=\"k\">in</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">);</span> <span class=\"c1\">// Note: 操作节点\n</span><span class=\"c1\"></span>  <span class=\"nx\">query</span><span class=\"p\">.</span><span class=\"nx\">selectAll</span><span class=\"p\">(</span><span class=\"s1\">&#39;#little_target, #target_type, #target_content&#39;</span><span class=\"p\">).</span><span class=\"nx\">boundingClientRect</span><span class=\"p\">(</span>\n    <span class=\"nx\">res</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">res</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nx\">item</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"nx\">height</span><span class=\"p\">[</span><span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"nx\">item</span><span class=\"p\">.</span><span class=\"nx\">id</span><span class=\"si\">}</span><span class=\"sb\">_height`</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">item</span><span class=\"p\">.</span><span class=\"nx\">height</span><span class=\"p\">;</span>\n      <span class=\"p\">})</span>\n      <span class=\"nx\">yearChartHeight</span> <span class=\"o\">=</span> <span class=\"nx\">height</span><span class=\"p\">.</span><span class=\"nx\">little_target_height</span> <span class=\"o\">-</span> <span class=\"nx\">height</span><span class=\"p\">.</span><span class=\"nx\">target_content_height</span> <span class=\"o\">-</span> <span class=\"nx\">height</span><span class=\"p\">.</span><span class=\"nx\">target_type_height</span><span class=\"p\">;</span>\n\n      <span class=\"nx\">componentHeight</span> <span class=\"o\">=</span> <span class=\"nx\">monthChartHeight</span> <span class=\"o\">=</span> <span class=\"nx\">height</span><span class=\"p\">.</span><span class=\"nx\">little_target_height</span> <span class=\"o\">-</span> <span class=\"nx\">height</span><span class=\"p\">.</span><span class=\"nx\">target_type_height</span> <span class=\"o\">-</span> <span class=\"mi\">48</span><span class=\"p\">;</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setData</span><span class=\"p\">({</span>\n        <span class=\"nx\">yearHeight</span><span class=\"o\">:</span> <span class=\"nx\">yearChartHeight</span><span class=\"p\">,</span>\n        <span class=\"nx\">monthHeight</span><span class=\"o\">:</span> <span class=\"nx\">monthChartHeight</span>\n      <span class=\"p\">})</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">).</span><span class=\"nx\">exec</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>上面代码就是通过相关的 API 获取三个节点的数据。</p><h2>小程序中使用 echarts</h2><p>对比了 F2 和 echarts， 发现 echarts 提供的图表更多一些。这两个图表库的使用的方式也不同，F2 是 npm 包，需要转换导入使用。echarts 使用起来就相对简单一些，和上面提到的自定义组件一样，而且 echarts 还可以自定义选择需要图表导出，这样就减小包的体积。 在使用这些图表库时，才明白什么叫做调參工程师，在开发的过程中真的是边看文档边调整参数。在使用 echarts 的过程中，本以为canvas 可以撑开盒子，结果发现需要父元素需要有高度，这也是为什么上面动态计算盒子高度。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c\">&lt;!--</span> <span class=\"nx\">init</span> <span class=\"mi\">1</span> <span class=\"o\">--&gt;</span>\n  <span class=\"o\">&lt;</span><span class=\"nx\">view</span> <span class=\"k\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;chart_wrap&#34;</span> <span class=\"nx\">style</span><span class=\"o\">=</span><span class=\"s2\">&#34;height:{{chartHeight}}px&#34;</span><span class=\"o\">&gt;</span>\n    <span class=\"o\">&lt;</span><span class=\"nx\">ec</span><span class=\"o\">-</span><span class=\"nx\">canvas</span> <span class=\"nx\">id</span><span class=\"o\">=</span><span class=\"s2\">&#34;mychart-dom-bar&#34;</span> <span class=\"nx\">canvas</span><span class=\"o\">-</span><span class=\"nx\">id</span><span class=\"o\">=</span><span class=\"s2\">&#34;mychart-bar&#34;</span> <span class=\"nx\">ec</span><span class=\"o\">=</span><span class=\"s2\">&#34;{{ ec }}&#34;</span><span class=\"o\">&gt;&lt;</span><span class=\"err\">/ec-canvas&gt;</span>\n  <span class=\"o\">&lt;</span><span class=\"err\">/view&gt;</span>\n<span class=\"c\">&lt;!--</span> \n<span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">ec</span><span class=\"o\">:</span> <span class=\"p\">{</span> <span class=\"nx\">onInit</span><span class=\"o\">:</span> <span class=\"nx\">initChart</span> <span class=\"p\">}</span>\n  <span class=\"p\">},</span>\n   <span class=\"o\">--&gt;</span>\n\n<span class=\"c\">&lt;!--</span> <span class=\"nx\">init</span> <span class=\"mi\">2</span><span class=\"o\">--&gt;</span>\n  <span class=\"o\">&lt;</span><span class=\"nx\">view</span> <span class=\"k\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;chart_wrap&#34;</span> <span class=\"nx\">style</span><span class=\"o\">=</span><span class=\"s2\">&#34;height:{{chartHeight}}px&#34;</span><span class=\"o\">&gt;</span>\n    <span class=\"o\">&lt;</span><span class=\"nx\">ec</span><span class=\"o\">-</span><span class=\"nx\">canvas</span> <span class=\"nx\">id</span><span class=\"o\">=</span><span class=\"s2\">&#34;mychart-dom-bar&#34;</span> <span class=\"nx\">canvas</span><span class=\"o\">-</span><span class=\"nx\">id</span><span class=\"o\">=</span><span class=\"s2\">&#34;mychart-bar&#34;</span> <span class=\"nx\">ec</span><span class=\"o\">=</span><span class=\"s2\">&#34;{{ ec }}&#34;</span> <span class=\"nx\">bind</span><span class=\"o\">:</span><span class=\"nx\">init</span><span class=\"o\">=</span><span class=\"s2\">&#34;echartInit&#34;</span><span class=\"o\">&gt;&lt;</span><span class=\"err\">/ec-canvas&gt;</span>\n  <span class=\"o\">&lt;</span><span class=\"err\">/view&gt;</span>\n</code></pre></div><p>在使用的过程中发现，初始化的方式并不惟一，结果也是不一样，这个需要注意一下。</p><h2>小程序的开发体验</h2><p>小程序的开发工具真心不怎么样，从日常 chrome 开发者工具再到小程序的开发者工具，这其中的差距还是很大。而且，我们不能方便随意地使用 npm 包，这在小程序中限制很明显。 反正问题很多。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5189d8dac558db30c993b3b2570b378a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic3.zhimg.com/v2-5189d8dac558db30c993b3b2570b378a_b.jpg\"/></figure><p>over！</p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "小程序开发", 
                    "tagLink": "https://api.zhihu.com/topics/20182216"
                }
            ], 
            "comments": [
                {
                    "userName": "腾讯云云开发", 
                    "userLink": "https://www.zhihu.com/people/67fe9e3c8edd72b7a4f2d4a69b10ce9b", 
                    "content": "<p>开发者工具确实体验不大好，不过相比一年前，已经好用了太多，现在也在不断完善。希望有更多人使用小程序的云开发，享受技术创造的快感~</p><a class=\"comment_sticker\" href=\"https://pic1.zhimg.com/v2-12562ad40366818a1ea39bcecb2599a0.gif\" data-width=\"\" data-height=\"\">[害羞]</a>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "<a class=\"comment_sticker\" href=\"https://pic4.zhimg.com/v2-fa3cb6bc9ec57da84ab53a60f48d0c6f.gif\" data-width=\"\" data-height=\"\">[棒]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "腾讯云云开发"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76619611", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 9, 
            "title": "Node爬虫", 
            "content": "<h2>前言</h2><p>最近一段时间在学习小程序，文档很长，但是对于前端开发者来说，并不是很难。然而在准备实践的时候，却犯难了。虽然只是练手，但起码要做一个有意义的东西。所以，第一时间，就想到利用爬虫来爬取自己想要的内容。在打算实践时，却也发现，由于小程序的的一些限制，要想实现我的想法，太麻烦，对于我来说，有点浪费时间。不过，既然都想到过爬虫了，就趁这次机会练练手。</p><p>通过本次的粗浅的实践，可以将爬虫的过程总结为，获取静态页面或获取接口数据 =&gt; 分析页面结构或分析接口数据 =&gt; 提取数据保存。基于Node的爬虫方式，要么是加载页面，要么是请求API，所以相对来说都很容易实现。</p><h2>puppeteer</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/puppeteer\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">puppeteer</a> 应该算是最简单的方式了，通过模拟用户的行为与浏览器交互，然后我们就可以分析页面抓去需要的信息。puppeteer 文档很详实，而且手把手教学，你想要的功能基本上都能在它的 github 上找到相应的例子。</p><p>puppeteer 是基于 Chromium 的，在安装 puppeteer时，会同时安装 Chromium。而因为众所周知的缘故，整个安装的过程并不是很顺利，文档里提供了不安装 Chromium 的方法，不过，我们也可以使用淘宝的镜像来加快安装时间。</p><div class=\"highlight\"><pre><code class=\"language-powershell\"><span class=\"n\">npm</span> <span class=\"n\">config</span> <span class=\"n\">set</span> <span class=\"n\">puppeteer_download_host</span> <span class=\"n\">https</span><span class=\"err\">:</span><span class=\"p\">//</span><span class=\"n\">npm</span><span class=\"p\">.</span><span class=\"n\">taobao</span><span class=\"p\">.</span><span class=\"n\">org</span><span class=\"p\">/</span><span class=\"n\">mirrors</span></code></pre></div><p>下面通过一个打卡🌰来使用 puppeteer,</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">login</span> <span class=\"o\">=</span> <span class=\"kr\">async</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"nx\">browser</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">puppeteer</span><span class=\"p\">.</span><span class=\"nx\">launch</span><span class=\"p\">({</span> <span class=\"nx\">headless</span><span class=\"o\">:</span> <span class=\"kc\">false</span> <span class=\"p\">});</span>  <span class=\"c1\">// 默认true。置为 false，整个操作过程可视\n</span><span class=\"c1\"></span>  <span class=\"k\">const</span> <span class=\"nx\">page</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">browser</span><span class=\"p\">.</span><span class=\"nx\">newPage</span><span class=\"p\">();</span>\n  <span class=\"kr\">await</span> <span class=\"nx\">page</span><span class=\"p\">.</span><span class=\"kr\">goto</span><span class=\"p\">(</span><span class=\"nx\">logURL</span><span class=\"p\">);</span>  <span class=\"c1\">// 跳转目标网页logURL，默认 load 事件触发\n</span><span class=\"c1\"></span>  <span class=\"kr\">await</span> <span class=\"nx\">page</span><span class=\"p\">.</span><span class=\"nx\">type</span><span class=\"p\">(</span><span class=\"s1\">&#39;#member_number&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;123456&#39;</span><span class=\"p\">)</span>  <span class=\"c1\">// 输入卡号\n</span><span class=\"c1\"></span>  <span class=\"kr\">await</span> <span class=\"nx\">page</span><span class=\"p\">.</span><span class=\"nx\">click</span><span class=\"p\">(</span><span class=\"s1\">&#39;#btn_member_number&#39;</span><span class=\"p\">)</span>  <span class=\"c1\">// 点击确定\n</span><span class=\"c1\"></span>  <span class=\"kr\">await</span> <span class=\"nx\">page</span><span class=\"p\">.</span><span class=\"nx\">waitForSelector</span><span class=\"p\">(</span><span class=\"s1\">&#39;#check_in&#39;</span><span class=\"p\">)</span>  <span class=\"c1\">// 等待签到 Dom 渲染完成\n</span><span class=\"c1\"></span>  <span class=\"kr\">await</span> <span class=\"nx\">page</span><span class=\"p\">.</span><span class=\"nx\">click</span><span class=\"p\">(</span><span class=\"s1\">&#39;#check_in&#39;</span><span class=\"p\">)</span>  <span class=\"c1\">// 点击签到按钮\n</span><span class=\"c1\"></span>  <span class=\"kr\">await</span> <span class=\"nx\">browser</span><span class=\"p\">.</span><span class=\"nx\">close</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>代码流程和用户操作浏览器的流程一致，这种方式相比接下来要说的方式，可以说是傻瓜式操作了。当然 puppeteer 还可以生成截图，性能分析等。</p><h2>接口请求</h2><p>不管是静态还是动态页面的获取，都是通过接口请求来实现的，即通过url向后端服务请求相应的数据。按照之前的爬取流程，要做的就是数据的请求和数据的分析。如果需要保存的话，就要使用存储工具储存数据。</p><p>一般情况下，在 Node 环境中请求数据，我们会使用封装好的 htttp 库，比如 request，axios等。那么分析数据呢？这就要看情况了，如果爬取的是静态页面，返回的是 HTML，这时我们就需要借助 Cheerio 或 JSDOM 来分析页面结构。如果返回的是常见的 JSON，那就很简单了。</p><p>不过本次实践没有通过以上的方式，而是在 github 搜索相关信息时，恰巧看到了 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/bda-research/node-crawler\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">crawler</a>。原理上都是差不多的，而且它也集成了 Cheerio。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">Crawler</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s2\">&#34;crawler&#34;</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">crawlerWebPage</span> <span class=\"o\">=</span> <span class=\"nx\">obj</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"kd\">let</span> <span class=\"p\">{</span><span class=\"nx\">uri</span><span class=\"p\">,</span> <span class=\"nx\">selector</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">obj</span><span class=\"p\">;</span>  <span class=\"c1\">// uri 请求的uri，selector 选择器；\n</span><span class=\"c1\"></span>  <span class=\"nx\">crawler</span><span class=\"p\">.</span><span class=\"nx\">direct</span><span class=\"p\">({</span>\n    <span class=\"nx\">uri</span><span class=\"o\">:</span> <span class=\"nx\">uri</span><span class=\"p\">,</span>\n    <span class=\"nx\">skipEventRequest</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>\n    <span class=\"nx\">callback</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">,</span> <span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n          <span class=\"kd\">var</span> <span class=\"nx\">$</span> <span class=\"o\">=</span> <span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">$</span><span class=\"p\">;</span>\n          <span class=\"kd\">var</span> <span class=\"nx\">content</span> <span class=\"o\">=</span> <span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"nx\">selector</span><span class=\"p\">).</span><span class=\"nx\">text</span><span class=\"p\">();</span>\n            <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">statusCode</span><span class=\"p\">,</span> <span class=\"nx\">content</span><span class=\"p\">,</span> <span class=\"nx\">uri</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">})</span>\n</code></pre></div><p>上面这个也只是 crawler 的简单用法。</p><h2>node-schedule</h2><p>虽然可以爬取了，但是数据并不是一成不变的，所以，更多的时候，我们需要定时重复爬取网页。 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/node-schedule/node-schedule\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">node-schedule</a> 就是用来定义定时任务的。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">schedule</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;node-schedule&#39;</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">loginSchedule</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"nx\">schedule</span><span class=\"p\">.</span><span class=\"nx\">scheduleJob</span><span class=\"p\">({</span>\n    <span class=\"nx\">start</span><span class=\"o\">:</span> <span class=\"nx\">startTime</span><span class=\"p\">,</span>\n    <span class=\"nx\">endTime</span><span class=\"o\">:</span> <span class=\"nx\">endTime</span><span class=\"p\">,</span>\n    <span class=\"nx\">rule</span><span class=\"o\">:</span> <span class=\"nx\">config</span><span class=\"p\">.</span><span class=\"nx\">schedule</span><span class=\"p\">.</span><span class=\"nx\">login</span><span class=\"p\">[</span><span class=\"nx\">loginIndex</span><span class=\"p\">]</span>\n  <span class=\"p\">},</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">now</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Date</span><span class=\"p\">();</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">loginLog</span> <span class=\"o\">=</span> <span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"nx\">now</span><span class=\"si\">}</span><span class=\"sb\"> login successed! /r/n`</span><span class=\"p\">;</span>\n    <span class=\"k\">try</span> <span class=\"p\">{</span>\n      <span class=\"nx\">login</span><span class=\"p\">();</span>\n      <span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">appendFileSync</span><span class=\"p\">(</span><span class=\"s1\">&#39;log.txt&#39;</span><span class=\"p\">,</span> <span class=\"nx\">loginLog</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"kd\">let</span> <span class=\"nx\">loginErrorLog</span> <span class=\"o\">=</span> <span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"nx\">now</span><span class=\"si\">}</span><span class=\"sb\"> - </span><span class=\"si\">${</span><span class=\"nx\">logURL</span><span class=\"si\">}</span><span class=\"sb\"> login failed: </span><span class=\"si\">${</span><span class=\"nx\">error</span><span class=\"p\">.</span><span class=\"nx\">message</span><span class=\"si\">}</span><span class=\"sb\">! /r/n`</span><span class=\"p\">;</span>\n      <span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">appendFileSync</span><span class=\"p\">(</span><span class=\"s1\">&#39;log.txt&#39;</span><span class=\"p\">,</span> <span class=\"nx\">loginErrorLog</span><span class=\"p\">)</span>\n      <span class=\"k\">throw</span> <span class=\"nx\">error</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>定义好相关的规则后，任务就可以按制定的规则执行。</p><h2>pm2</h2><p>以上的任务是可以执行了，可是关闭了命令窗口，进程中断，那么功夫白费。这时候就需要一个工具来管理 node 进程，<a href=\"https://link.zhihu.com/?target=http%3A//pm2.keymetrics.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pm2</a>倒是一个好工具。pm2 不仅支持热加载，还可以监控等功能，很方便很强大。</p><div class=\"highlight\"><pre><code class=\"language-powershell\"><span class=\"c\"># 安装</span>\n<span class=\"n\">npm</span> <span class=\"n\">install</span> <span class=\"n\">pm2</span> <span class=\"n\">-g</span>\n\n<span class=\"c\"># 启动、监听 app.js</span>\n<span class=\"n\">pm2</span> <span class=\"n\">start</span> <span class=\"n\">app</span><span class=\"p\">.</span><span class=\"n\">js</span>  <span class=\"p\">-</span><span class=\"n\">-watch</span>\n\n<span class=\"c\"># 监控</span>\n<span class=\"n\">pm2</span> <span class=\"n\">monit</span>\n\n<span class=\"c\"># 终止</span>\n<span class=\"n\">pm2</span> <span class=\"n\">stop</span>\n\n<span class=\"p\">......</span></code></pre></div><h2>debug</h2><p>在写 Node 应用时，难免磕磕绊绊，学会调试也是很有必要的。本次项目很简单，所以所使用的调试技巧也很粗浅。</p><ul><li>使用 VSCode 提供的调试工具。</li><li>在项目中加入 <code>debugger</code>，执行 <code>node debug --inspect app.js</code>,开启调试模式。</li><li>借助其他调试工具。</li></ul><p><b>over</b></p>", 
            "topic": [
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>登录这个环节其实可以省略的。拿到 cookie 就好了</p>", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "[赞同]登陆后拿到 cookie 后，就可以不用重复这个步骤了。不过我模拟的是打卡签到的流程，每次都要登录", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74558865", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 2, 
            "title": "学习之道有感", 
            "content": "<blockquote>我意识到自己最擅长的既不是象棋也不是太极，我最擅长的是学习之道。</blockquote><p>偶然间听到了《学习之道》这本书，吸引我的并不是这么霸气的书名，而是书里说的一些观念很是契合。好奇之下，买本看看。书中描述的是作者传奇般的经历，与其说是传授他的学习之道，倒不如说把他经历的点点滴滴讲述给大家听。</p><p>书中并没有提出速成的方法，只是事无巨细的讲述自己的经历和感悟。而这些却是本书最重要的，作为一个传奇人物，他的经历是很有参考价值的，就算只是描述日常生活的流水账。此时，能否从书中受益，不再取决于书的内容，而是读者如何看待这本书。而最让我敬佩的是，作者能够体察入微，探究其背后的真相。</p><blockquote>上士闻道，勤而行之；中士闻道，若存若亡；下士闻道，大笑之，不笑不足以为道</blockquote><p>在读书的过程中，我才知道，为什么我会被这本书吸引。原来，作者也是《道德经》的读者，和我这个半吊子，也算是志同道合了。看完这本书，我就预料，能够读懂这书的势必赞不绝口，读不懂此书的也会觉得味同嚼蜡，索然无味。而我个人观点则是，作者把自己感悟融入了生活之中，在描述个人经历的时候，其实就是在诠释什么是学习之道。这也是我觉得作者很厉害的原因，复归自然。</p><blockquote>道之出口，淡乎其无味，视之不足见，听之不足闻</blockquote><p>生活中处处透着大道理，可是看不到，摸不着，听不见，不留痕迹。就如侦探小说里说，之所以主人公能够发现一些线索进而破解案件，是因为发现了不合理的地方。而道法自然，我们在这种环境下成长，也会觉得一切自然而然。我们生气也是自然，我们开心也是自然，以至于我们从来不追究看似自然的背后到底发生了什么。</p><p>而作者还是个孩童时，补充一下，作者很小的时候就已经过着开挂的人生了，在经历挫折时，及时发现自身处境，并从中获益。我们今天能够有幸看到这本书，也正是因为作者敏锐得观察能力。</p><blockquote>知人者智，自知者明。胜人者有力，自胜者强</blockquote><p>在当今这个社会，人们被快节奏的生活压地喘不过气来。我认为所谓的自知，不仅仅指的是个人的能力，还应该包括情绪等。很多人被情绪控制而不自知，而由情绪带来的负面影响又将人带向更坏的处境。</p><p>冥想，作为缓解压力的运动，在当今社会很流行。在冥想时，我们需要感受自身肌肉的情况，然后不断去调节放松。很多初学者在刚开始冥想时，压根不知道自己的肌肉到底是处于什么状态。人的情绪也是如此，我们需要时刻关注自己情绪的变化，最终也可以做到掌控情绪。而作者也多次在对局中，克服消极情绪，最后拿下冠军。</p><p>生气也好，开心也罢，这些都不重要。重要的是，我们需要接纳自己情绪，不抵触。如果放在学习里，那就是放下我们的畏难情绪。其实，阻止我们前行的一直都是我们自己。同时，我们还要做到静如处子，动如脱兔，把自己的注意力用在它被需要的地方。</p><blockquote>天下难事必作于易，天下大事必作于细</blockquote><p>看似简单的事物，也仅仅是因为我们想简单了。<code>不出户，知天下；不窥牖，见天道</code>，还是那句话，生活中处处透着大道理，看似简单的事情，做多了做透了，也可以作出一番成绩。而我们常常观察不到，是因为我们的想法太多，杂念太多，有太多的理所当然。</p><blockquote>五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨</blockquote><p>在古时候，人们还想着修心养性。在这个物欲横流的社会中，我们更应该如此，受诱惑的东西太多，往往导致我们无法追寻本源。你呆的越舒适，你就越觉得理所当然，也就越不能发现容易忽略的细节。</p><p>之前看过一个有趣的报道，人有意识和潜意识之说。在人休息发呆的时候，人的潜意识开始进行知识整合。这也是好多人在知识储备足够的时候会有灵光一现的说法。而现在的科技发达，太多的科技产品占用了我们的生活，这也破坏了原有的整合机制。最后报道给出的结论是，在这种环境下，人类会变得越来越笨。说的貌似挺有道理的，所以说玩手机要适度。</p><p>作者还提到，内化和强化训练。就是不断针对自己不熟悉的领域去强化，进而使其成为身体惯性。讲真，写到这里，其实我已经不记得书中的细节了，虽然才刚看完。书中的内容可以说是干货满满，毕竟作者是以自己的行动去实践并取得了很大的成就。也可以说这本书什么都没说，内容宽泛，更像心理指导。</p><p>最后用一句话总结，<b>面临危机，坦然接受痛苦，直至从容，闲庭信步</b>。</p>", 
            "topic": [
                {
                    "tag": "高效学习", 
                    "tagLink": "https://api.zhihu.com/topics/19580586"
                }, 
                {
                    "tag": "道德经", 
                    "tagLink": "https://api.zhihu.com/topics/20170172"
                }, 
                {
                    "tag": "阅读", 
                    "tagLink": "https://api.zhihu.com/topics/19550564"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74506841", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 2, 
            "title": "剖析排序算法", 
            "content": "<h2>前言</h2><p>排序是计算机中对存储的数据执行最常见的操作之一。在排序算法中绕不开的是循环，只有在深入学习排序算法时，才发现平时不起眼的循环语句不可小觑。</p><p>拿最简单的冒泡排序来说，道理我都懂，可为什么会想到两层嵌套的循环语句？为什么两层循环语句的条件会有所不同？两层循环的关联逻辑是什么？循环在冒泡中扮演着什么角色？循环是通过怎样的逻辑完成冒泡的？等等。这些问题的背后，都值得我们去探究。</p><h2>循环</h2><p>在说正题之前，需要说一个小插曲。由于互联网寒冬，程序员们都有一种危机感。在这场危机中，程序员的筛选条件也变得更加苛刻。无论是前端还是后端，都最好能够熟悉掌握一些基础算法。所以说，刷算法题，也在程序员间流行起来了。我旁边的一同事，就刷到了一个有趣的算法，说是挺有意思的，就让我也尝试一下。讲真，作为一个前端，除了简单处理一下接口数据，还真没有训练过应试般的算法。</p><p>题目大致是这样的，在 n*n 的平面中，以一半的空间螺旋有序排满以1起始若干数字。 画图如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c21767cd2b1e9a65662c417a3b7fd18b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"339\" class=\"content_image\" width=\"254\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;254&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"339\" class=\"content_image lazy\" width=\"254\" data-actualsrc=\"https://pic4.zhimg.com/v2-c21767cd2b1e9a65662c417a3b7fd18b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>随着思考的深入，突然发现，这tm不就是一道数学题么？（原谅我说粗话了） 找出已知，列出未知，关联已知未知，就差列 x、y 了。</p><p>以下以 5*5 为例：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">var</span> <span class=\"nx\">arr</span> <span class=\"o\">=</span> <span class=\"nb\">Array</span><span class=\"p\">.</span><span class=\"nx\">from</span><span class=\"p\">({</span><span class=\"nx\">length</span><span class=\"o\">:</span> <span class=\"mi\">5</span><span class=\"p\">}).</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nx\">item</span> <span class=\"p\">=&gt;</span> <span class=\"p\">([]));</span>\n<span class=\"kd\">var</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"kd\">function</span> <span class=\"nx\">Sort</span><span class=\"p\">(</span><span class=\"nx\">init</span><span class=\"p\">,</span> <span class=\"nx\">length</span><span class=\"p\">){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">m</span> <span class=\"o\">=</span> <span class=\"nx\">init</span><span class=\"p\">,</span> <span class=\"nx\">n</span><span class=\"o\">=</span> <span class=\"nx\">init</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"nx\">m</span> <span class=\"o\">&lt;</span> <span class=\"nx\">length</span><span class=\"p\">){</span>\n        <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">m</span><span class=\"o\">++</span><span class=\"p\">][</span><span class=\"nx\">init</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"o\">--</span><span class=\"nx\">m</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"nx\">n</span> <span class=\"o\">&lt;</span> <span class=\"nx\">length</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"o\">--</span><span class=\"nx\">m</span><span class=\"p\">][</span><span class=\"o\">++</span><span class=\"nx\">n</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"o\">--</span><span class=\"nx\">n</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"nx\">n</span> <span class=\"o\">&gt;</span> <span class=\"nx\">init</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">m</span><span class=\"p\">][</span><span class=\"nx\">n</span><span class=\"o\">--</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">length</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nx\">arr</span><span class=\"p\">;</span>\n    <span class=\"nx\">Sort</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nx\">length</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">Sort</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">),</span> <span class=\"nx\">arr</span><span class=\"p\">)</span>\n</code></pre></div><p>变动的就是未知，找出循环条件，关联已知，这样等式就算列出来了。在这里我把平面想像成平面坐标，m、n 当作 x、y 轴，数组就是坐标点的集合，数字螺旋折转的条件作为循环递归条件，就这样，一个粗糙的算法算是完成了。</p><p>虽然这和本次主题的关系不是很大，但是很受启发，让我觉得程序和数学果然存在着紧密的关系。回到这一小节，以最简单的 for 循环为例。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">let</span> <span class=\"nx\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">];</span>\n<span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">){}</span>\n</code></pre></div><p>以上就是最简单的 for 循环写法，从这个简单的 for 语句，我们能够知道的是，第几次循环<code>i</code>（即当前），循环的次数<code>arr.length</code>及循环的驱动<code>i++</code>。很重要的一点就是，<code>i</code> 是随着循环递增的。循环就是这么简单，也没有什么其他魔力。</p><p>在排序算法中，还有一点需要注意的，那就是数组。在 JavaScript 中，数组元素在内存中并不是连续的。我们可以通过索引来引用相应位置的元素。更重要的是，我们通常操作数组元素的时候，并不是操作数组元素本身，而是该位置上的变量。我们可以想象成，每一个索引位置都是一个变量，然后通过给变量赋值数组元素。</p><p>循环和数组，如果单独使用倒也没什么。如果两者结合，你就会发现，随着循环的次数增加，数组索引也会递增，再结合一些逻辑，就可以把某些元素移动到制定的位置。</p><p>那么，都结合怎样的逻辑呢？</p><h2>冒泡排序</h2><p>冒泡排序逻辑，通过两两比较，把较大的元素赋值给当前位置索引的后一索引位置，然后随着循环增加，当前索引也会递增，最终会把最大值推到末尾。然后把这个过程循环多次，最终把倒数第二大、倒数第三大...移到指定位置。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"826\" data-rawheight=\"257\" data-thumbnail=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"826\" data-original=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;826&#39; height=&#39;257&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"826\" data-rawheight=\"257\" data-thumbnail=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"826\" data-original=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">bubbleSort</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">len</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">len</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">){</span>\n        <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">j</span> <span class=\"o\">&lt;</span> <span class=\"nx\">len</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"nx\">i</span><span class=\"p\">;</span> <span class=\"nx\">j</span><span class=\"o\">++</span><span class=\"p\">){</span>    <span class=\"c1\">// 递增更换当前元素；\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">j</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]){</span>    <span class=\"c1\">// 相邻元素比较；\n</span><span class=\"c1\"></span>                <span class=\"p\">[</span><span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">j</span><span class=\"p\">],</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">j</span><span class=\"p\">]];</span>    <span class=\"c1\">// 位置互换；\n</span><span class=\"c1\"></span>            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nx\">arr</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>选择排序</h2><p>选择排序逻辑，比较当前数组元素，找出最小元素的索引，将该位置的元素移动指定位置。然后多次循环遍历，最终将剩下数组元素中第二小元素、第三小元素...移到指定位置。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"248\" data-thumbnail=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"811\" data-original=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;811&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"248\" data-thumbnail=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"811\" data-original=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">selectionSort</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">len</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">len</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">){</span>\n        <span class=\"kd\">let</span> <span class=\"nx\">minIndex</span> <span class=\"o\">=</span> <span class=\"nx\">i</span><span class=\"p\">;</span>\n        <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">j</span> <span class=\"o\">=</span> <span class=\"nx\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"nx\">j</span> <span class=\"o\">&lt;</span> <span class=\"nx\">len</span><span class=\"p\">;</span> <span class=\"nx\">j</span> <span class=\"o\">++</span><span class=\"p\">){</span>    <span class=\"c1\">// 递增替换当前元素；\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">j</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">minIndex</span><span class=\"p\">]){</span>\n                <span class=\"nx\">minIndex</span> <span class=\"o\">=</span> <span class=\"nx\">j</span><span class=\"p\">;</span>    <span class=\"c1\">// 更新最小元素索引；\n</span><span class=\"c1\"></span>            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"p\">[</span><span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">minIndex</span><span class=\"p\">],</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">],</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">minIndex</span><span class=\"p\">]];</span>    <span class=\"c1\">// 与最小元素互换位置；\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nx\">arr</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>插入排序</h2><p>插入排序逻辑，将当前的数组元素与之前的数组元素比较，并将其插入到适当位置。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"505\" data-thumbnail=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;811&#39; height=&#39;505&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"505\" data-thumbnail=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">insertionSort</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">len</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">len</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">){</span>\n        <span class=\"kd\">let</span> <span class=\"nx\">temp</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span>\n        <span class=\"kd\">let</span> <span class=\"nx\">preIndex</span> <span class=\"o\">=</span> <span class=\"nx\">i</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"nx\">preIndex</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">preIndex</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"nx\">temp</span><span class=\"p\">){</span>\n            <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">preIndex</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">preIndex</span><span class=\"o\">--</span><span class=\"p\">];</span>    <span class=\"c1\">// 该位置元素若小于当前元素，则将其后移动；\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n        <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">preIndex</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">temp</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nx\">arr</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>希尔排序</h2><p>希尔排序算是插入排序的升级版本，插入排序是与之前的数组元素挨个进行比较，而希尔排序是以特定间隔进行多次分组比较，所以说在代码上很相似。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-671bd19a44faf77479d68805a083892c_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"290\" data-thumbnail=\"https://pic1.zhimg.com/v2-671bd19a44faf77479d68805a083892c_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"665\" data-original=\"https://pic1.zhimg.com/v2-671bd19a44faf77479d68805a083892c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;665&#39; height=&#39;290&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"290\" data-thumbnail=\"https://pic1.zhimg.com/v2-671bd19a44faf77479d68805a083892c_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"665\" data-original=\"https://pic1.zhimg.com/v2-671bd19a44faf77479d68805a083892c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-671bd19a44faf77479d68805a083892c_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">shellSort</span><span class=\"p\">(</span><span class=\"nx\">gap</span><span class=\"p\">,</span> <span class=\"nx\">arr</span><span class=\"p\">){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">len</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">gap</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">){</span>    <span class=\"c1\">// 以不同间隔分组比较；\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">j</span> <span class=\"o\">=</span> <span class=\"nx\">gap</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span> <span class=\"nx\">j</span> <span class=\"o\">&lt;</span> <span class=\"nx\">len</span><span class=\"p\">;</span> <span class=\"nx\">j</span><span class=\"o\">++</span><span class=\"p\">){</span>    <span class=\"c1\">// 以间隔的下一索引位置起始；\n</span><span class=\"c1\"></span>            <span class=\"kd\">let</span> <span class=\"nx\">temp</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">j</span><span class=\"p\">];</span>\n            <span class=\"kd\">let</span> <span class=\"nx\">preGapIndex</span> <span class=\"o\">=</span> <span class=\"nx\">j</span> <span class=\"o\">-</span> <span class=\"nx\">gap</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span>\n            <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"nx\">preGapIndex</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">preGapIndex</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"nx\">temp</span><span class=\"p\">){</span>    <span class=\"c1\">// 当前元素与之前固定间隔索引位置元素进行比较；\n</span><span class=\"c1\"></span>                <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">preGapIndex</span> <span class=\"o\">+</span> <span class=\"nx\">gap</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">preGapIndex</span><span class=\"p\">];</span>\n                <span class=\"nx\">preGapIndex</span> <span class=\"o\">=</span> <span class=\"nx\">preGapIndex</span> <span class=\"o\">-</span> <span class=\"nx\">gap</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span>\n            <span class=\"p\">}</span>\n            <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">preGapIndex</span> <span class=\"o\">+</span> <span class=\"nx\">gap</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"nx\">temp</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nx\">arr</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>归并排序</h2><p>归并排序逻辑，使用递归的方式将数组划分为更小的数组对，通过比较重新合成完整的数组。本文采用的是自顶向下的归并排序，还可以使用自底向上的归并排序。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"505\" data-thumbnail=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;811&#39; height=&#39;505&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"505\" data-thumbnail=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">mergeSort</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">len</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">len</span> <span class=\"o\">&lt;</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nx\">arr</span><span class=\"p\">;</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">middle</span> <span class=\"o\">=</span> <span class=\"nb\">Math</span><span class=\"p\">.</span><span class=\"nx\">floor</span><span class=\"p\">(</span><span class=\"nx\">len</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">);</span>    <span class=\"c1\">// 分组；\n</span><span class=\"c1\"></span>    <span class=\"kd\">let</span> <span class=\"nx\">left</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">middle</span><span class=\"p\">);</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">right</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"nx\">middle</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"nx\">merge</span><span class=\"p\">(</span><span class=\"nx\">mergeSort</span><span class=\"p\">(</span><span class=\"nx\">left</span><span class=\"p\">),</span> <span class=\"nx\">mergeSort</span><span class=\"p\">(</span><span class=\"nx\">right</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">function</span> <span class=\"nx\">merge</span><span class=\"p\">(</span><span class=\"nx\">left</span><span class=\"p\">,</span> <span class=\"nx\">right</span><span class=\"p\">){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">len</span> <span class=\"o\">=</span> <span class=\"nx\">left</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">+</span> <span class=\"nx\">right</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"p\">[],</span> <span class=\"nx\">m</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">n</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"nx\">left</span><span class=\"p\">[</span><span class=\"nx\">left</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">Infinity</span><span class=\"p\">;</span>\n    <span class=\"nx\">right</span><span class=\"p\">[</span><span class=\"nx\">right</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">Infinity</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">len</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">){</span>    <span class=\"c1\">// 循环的次数为新数组的长度；\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">left</span><span class=\"p\">[</span><span class=\"nx\">m</span><span class=\"p\">]</span> <span class=\"o\">&lt;=</span> <span class=\"nx\">right</span><span class=\"p\">[</span><span class=\"nx\">n</span><span class=\"p\">]){</span>    <span class=\"c1\">// 比较左右数组元素重新排列组合成新的数组；\n</span><span class=\"c1\"></span>            <span class=\"nx\">result</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">left</span><span class=\"p\">[</span><span class=\"nx\">m</span><span class=\"p\">];</span>\n            <span class=\"nx\">m</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span><span class=\"k\">else</span><span class=\"p\">{</span>\n            <span class=\"nx\">result</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">right</span><span class=\"p\">[</span><span class=\"nx\">n</span><span class=\"p\">];</span>\n            <span class=\"nx\">n</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nx\">result</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>快速排序</h2><p>快速排序逻辑，从数组中选出基准值，将大于基准值的元素移到右侧数组，将小于基准值的元素移到左侧数组，递归循环此操作直到数组为空。然后合并各组数组，最终得到排序后的新数组。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-da6f8e4afb8b9c8adf9567fd2fefca55_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"591\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb\" width=\"591\" data-original=\"https://pic2.zhimg.com/v2-da6f8e4afb8b9c8adf9567fd2fefca55_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;591&#39; height=&#39;458&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"591\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"591\" data-original=\"https://pic2.zhimg.com/v2-da6f8e4afb8b9c8adf9567fd2fefca55_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-da6f8e4afb8b9c8adf9567fd2fefca55_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">quickSort</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">){</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nx\">arr</span><span class=\"p\">;</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">len</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">pivot</span> <span class=\"o\">=</span> <span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>    <span class=\"c1\">// 设置基准值；\n</span><span class=\"c1\"></span>    <span class=\"kd\">let</span> <span class=\"nx\">lesser</span> <span class=\"o\">=</span> <span class=\"p\">[],</span> <span class=\"nx\">greater</span> <span class=\"o\">=</span> <span class=\"p\">[];</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">len</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">){</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"nx\">pivot</span><span class=\"p\">){</span>\n            <span class=\"nx\">lesser</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]);</span>    <span class=\"c1\">// 将小于基准值推至左侧；\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"nx\">greater</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">arr</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]);</span>    <span class=\"c1\">// 将大于基准值推至右侧；\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nx\">quickSort</span><span class=\"p\">(</span><span class=\"nx\">lesser</span><span class=\"p\">).</span><span class=\"nx\">concat</span><span class=\"p\">(</span><span class=\"nx\">pivot</span><span class=\"p\">,</span> <span class=\"nx\">quickSort</span><span class=\"p\">(</span><span class=\"nx\">greater</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><b>over！</b></p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73773366", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 1, 
            "title": "MVC简单实现（DEMO）", 
            "content": "<p>经过之前的<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c4d37c351882546660d3718\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在JavaScript中理解策略模式</a>、<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c53f218f265da2de4504b42\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在JavaScript中理解组合模式</a>、<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c596ced6fb9a049a71243eb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">浅谈MVC/MVP/MVVM模式（概述）</a> 和 较早之前的<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5bfd552e518825773a2ecca0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">进击的观察者模式</a>等文章的铺垫，终于可以把这些理论的东西用于实践了。</p><p>废话不多说，直奔主题。</p><p>(以下代码可见<a href=\"https://link.zhihu.com/?target=https%3A//www.yexiaochen.com/%25E5%2585%25B3%25E4%25BA%258EMVC%25E6%25A8%25A1%25E5%25BC%258F%25E7%25AE%2580%25E5%258D%2595%25E4%25BB%25A3%25E7%25A0%2581%25E5%25AE%259E%25E7%258E%25B0/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">博客原文</a> 或 <a href=\"https://link.zhihu.com/?target=https%3A//codepen.io/yexiaochen/pen/aXWLRz\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">普通实现—codepen</a>、<a href=\"https://link.zhihu.com/?target=https%3A//codepen.io/yexiaochen/pen/MLErQa\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MVC实现-codepen</a>。）</p><blockquote>GoF 并不将 MVC 引述为一种设计模式，而是把它看做是构建一个用户界面的类的集合。按照他们的观点，它实际上是三种经典设计模式的变异组合：观察者模式，策略模式和组合模式。依赖于框架中的 MVC 如何实现，它也可能会使用工厂和模板模式。GoF Book 提到这些模式在使用 MVC 工作时是非常有用的附加功能。</blockquote><p>功能示意:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1f3e94eb31357c669c11fde4ec3a983a_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"744\" data-rawheight=\"401\" data-thumbnail=\"https://pic3.zhimg.com/v2-1f3e94eb31357c669c11fde4ec3a983a_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"744\" data-original=\"https://pic3.zhimg.com/v2-1f3e94eb31357c669c11fde4ec3a983a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;744&#39; height=&#39;401&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"744\" data-rawheight=\"401\" data-thumbnail=\"https://pic3.zhimg.com/v2-1f3e94eb31357c669c11fde4ec3a983a_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"744\" data-original=\"https://pic3.zhimg.com/v2-1f3e94eb31357c669c11fde4ec3a983a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1f3e94eb31357c669c11fde4ec3a983a_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>由一组数据展示三类表格，分别是【stuff，scale】、【stuff，salary】、【stuff，scale，salary】三组视图。另外可以修改指定 stuff 的 scale 或 salary 信息。</p><p>stuffs 信息：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">stuffs</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n  <span class=\"p\">{</span>\n    <span class=\"nx\">stuff</span><span class=\"o\">:</span> <span class=\"s1\">&#39;person_1&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">scale</span><span class=\"o\">:</span> <span class=\"s1\">&#39;甲&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">salary</span><span class=\"o\">:</span> <span class=\"s1\">&#39;6000&#39;</span>\n  <span class=\"p\">},</span>\n  <span class=\"p\">{</span>\n    <span class=\"nx\">stuff</span><span class=\"o\">:</span> <span class=\"s1\">&#39;person_2&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">scale</span><span class=\"o\">:</span> <span class=\"s1\">&#39;乙&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">salary</span><span class=\"o\">:</span> <span class=\"s1\">&#39;5000&#39;</span>\n  <span class=\"p\">},</span>\n  <span class=\"p\">{</span>\n    <span class=\"nx\">stuff</span><span class=\"o\">:</span> <span class=\"s1\">&#39;person_3&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">scale</span><span class=\"o\">:</span> <span class=\"s1\">&#39;丙&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">salary</span><span class=\"o\">:</span> <span class=\"s1\">&#39;9000&#39;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">];</span>\n</code></pre></div><p>常规的写法可以这么来：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-dccfbd13e182b4d7077f50a4c16c065d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2312\" data-rawheight=\"1634\" class=\"origin_image zh-lightbox-thumb\" width=\"2312\" data-original=\"https://pic2.zhimg.com/v2-dccfbd13e182b4d7077f50a4c16c065d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2312&#39; height=&#39;1634&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2312\" data-rawheight=\"1634\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2312\" data-original=\"https://pic2.zhimg.com/v2-dccfbd13e182b4d7077f50a4c16c065d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-dccfbd13e182b4d7077f50a4c16c065d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>职责分配</h2><p>既然说了 MVC 有那么多好处，我们就用 MVC 的模式来改造下我们的代码。</p><p>首先我们先划分下职责。</p><p>Model 负责对数据的处理并返回目标数据，在这个场景下是筛选 stuff、修改stuff 等职责。</p><p>View 负责对目标数据的渲染和处理用户的响应，在这个场景下是各个表格的渲染、change 事件的委托等职责。</p><p>Control 负责协调 Model 和 View，在这个场景下是处理委托、处理数据等职责。</p><p><b>此处的 MVC 实现是针对一个 Model 对应多个 View 的代码实现</b>， 也是为了把观察者模式，策略模式和组合模式模式都用起来。</p><h2>View</h2><p>【stuff，scale】、【stuff，salary】、【stuff，scale，salary】三组视图就是三个 View，每个 View 都可以独立渲染自己的一组视图。结合组合模式，我们我们造些视图的叶对象和分支对象。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-179ba61a8a9a8100731dfa7709b67f46_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1790\" data-rawheight=\"1026\" class=\"origin_image zh-lightbox-thumb\" width=\"1790\" data-original=\"https://pic3.zhimg.com/v2-179ba61a8a9a8100731dfa7709b67f46_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1790&#39; height=&#39;1026&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1790\" data-rawheight=\"1026\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1790\" data-original=\"https://pic3.zhimg.com/v2-179ba61a8a9a8100731dfa7709b67f46_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-179ba61a8a9a8100731dfa7709b67f46_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">html</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">head</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">head</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">body</span><span class=\"p\">&gt;</span>\n    <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">&#34;app&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">body</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">html</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span>\n    <span class=\"k\">const</span> <span class=\"nx\">$APP</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">getElementById</span><span class=\"p\">(</span><span class=\"s1\">&#39;app&#39;</span><span class=\"p\">);</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span></code></pre></div><p>叶对象（此处有两类视图）：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">leafView_1</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n<span class=\"k\">const</span> <span class=\"nx\">renderTable</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"nx\">render</span><span class=\"o\">:</span> <span class=\"nx\">renderTable</span><span class=\"p\">()</span>\n    <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">leafView_2</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">Control</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"nx\">$ONE</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">getElementById</span><span class=\"p\">(</span><span class=\"s1\">&#39;one&#39;</span><span class=\"p\">);</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">$SCALE</span><span class=\"p\">;</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">$SALARY</span><span class=\"p\">;</span>\n    <span class=\"k\">const</span> <span class=\"nx\">renderSearchTable</span> <span class=\"o\">=</span> <span class=\"nx\">params</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">handleModify</span> <span class=\"o\">=</span> <span class=\"nx\">e</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">bindEvent</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"nx\">render</span><span class=\"o\">:</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...}</span>\n    <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>分支对象：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">branchView</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">Control</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">$SEARCH</span><span class=\"p\">,</span> <span class=\"nx\">$ALL</span><span class=\"p\">;</span>\n    <span class=\"k\">const</span> <span class=\"nx\">Views</span> <span class=\"o\">=</span> <span class=\"p\">[];</span>\n    <span class=\"k\">const</span> <span class=\"nx\">addView</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">render</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">handleSearch</span> <span class=\"o\">=</span> <span class=\"nx\">event</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">bindEvent</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...}</span>\n    <span class=\"k\">const</span> <span class=\"nx\">initDOM</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"nx\">initDOM</span><span class=\"p\">();</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"nx\">render</span><span class=\"p\">,</span>\n        <span class=\"nx\">addView</span><span class=\"p\">,</span>\n    <span class=\"p\">};</span>\n<span class=\"p\">};</span>\n</code></pre></div><h2>Model</h2><p>Model 主要是将数据处理成目标数据，并提供 View 注册通知接口。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">Model</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">stuffData</span> <span class=\"o\">=</span> <span class=\"p\">[];</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">filterData</span> <span class=\"o\">=</span> <span class=\"p\">[];</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">Views</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">ajaxFun</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">[...];</span> <span class=\"c1\">// 模拟后台获取数据；\n</span><span class=\"c1\"></span>    <span class=\"k\">const</span> <span class=\"nx\">setStuffData</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">filterStuff</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">setFilterStuff</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">findStuff</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">modifyStuffData</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">register</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">notify</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"nx\">setStuffData</span><span class=\"p\">,</span>\n        <span class=\"nx\">setFilterStuff</span><span class=\"p\">,</span>\n        <span class=\"nx\">modifyStuffData</span>\n        <span class=\"nx\">register</span><span class=\"p\">,</span>\n        <span class=\"nx\">notify</span><span class=\"p\">,</span>\n    <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>Control</h2><p>鉴于此处有多类视图，Model 和 View 之间，我们采用了发布订阅模式而不是观察者模式。Model 需要收集 View，然后在数据改变时候更新视图。同时，View 注入了 Control 了，意味着不同的 Control 就是不同的策略。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">Control</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"nx\">ModelInstance</span> <span class=\"o\">=</span> <span class=\"nx\">Model</span><span class=\"p\">();</span>\n    <span class=\"k\">const</span> <span class=\"nx\">View_1</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">View_2</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">init</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">filter</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">const</span> <span class=\"nx\">modifyStuffInfo</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{...};</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"nx\">init</span><span class=\"p\">,</span>\n        <span class=\"nx\">filter</span><span class=\"p\">,</span>\n        <span class=\"nx\">modifyStuffInfo</span>\n    <span class=\"p\">};</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>MVC 代码实现：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-020fbd8984e66bdcc3940d6a8e7e98c6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1904\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"1904\" data-original=\"https://pic3.zhimg.com/v2-020fbd8984e66bdcc3940d6a8e7e98c6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1904&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1904\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1904\" data-original=\"https://pic3.zhimg.com/v2-020fbd8984e66bdcc3940d6a8e7e98c6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-020fbd8984e66bdcc3940d6a8e7e98c6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>后话</h2><p>就这么简单的一个需求，改成 MVC 模式后就多了 100 多行代码。就如上篇文章所说一样，如果是简单的需求压根没必要这么折腾。不过，改成 MVC 后，它们各自职责也就更加清晰了，对以后的维护也会好些。</p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "MVC", 
                    "tagLink": "https://api.zhihu.com/topics/19583976"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72480082", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 6, 
            "title": "React+Koa+MongoDB+Docker开发环境", 
            "content": "<h2>前言</h2><p>本次博文依然是对 <code>multi-spa-webpack-cli</code> 的扩充和完善。</p><ol><li>集成 <b>mongoose</b>。</li><li>集成 <b>Docker</b> 开发环境。</li></ol><p><code>multi-spa-webpack-cli</code> 已经发布到 npm，只要在 node 环境下安装即可。</p><div class=\"highlight\"><pre><code class=\"language-bash\">npm install multi-spa-webpack-cli -g</code></pre></div><p>使用步骤如下:</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"c1\"># 1. 初始化项目</span>\n\nmulti-spa-webpack-cli init spa-project\n\n<span class=\"c1\"># 2. 进入文件目录</span>\n\n<span class=\"nb\">cd</span> spa-project\n\n<span class=\"c1\"># 未使用 Docker</span>\n<span class=\"c1\"># 3. 打包不变的部分</span>\n\nnpm run build:dll\n\n<span class=\"c1\"># 4. 启动项目（手动打开浏览器：localhost:8090）</span>\n\nnpm start\n\n<span class=\"c1\"># 5. 启动 MongoDB</span>\n\nmongod\n\n<span class=\"c1\"># 6. 启动服务</span>\n\n<span class=\"nb\">cd</span> server\nnpm install\nnpm start\n\n<span class=\"c1\"># 使用 Docker（需安装docker）</span>\n<span class=\"c1\"># 3. 启动项目（手动打开浏览器：localhost:8090）</span>\n\nnpm run docker:dev</code></pre></div><p>从上面的步骤可以看出，Docker 只需要 3 步就可以启动项目了。</p><h2>mongoose</h2><blockquote>mongoose 是在 node.js 环境下对 MongoDB 进行便捷操作的对象模型工具。</blockquote><p>在没开始之前，要先安装 MongoDB。安装 MongoDB 的过程中，可能有些小麻烦，尤其是公司的电脑（谁也不知道电脑里配置了什么东西）。安装过程可参照 【<a href=\"https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/%23install\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官网：安装MongoDB</a>】</p><p>还要知道 MongoDB 的一些概念。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6b301c63250bfdcba44034ba5e5eb46c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1814\" data-rawheight=\"740\" class=\"origin_image zh-lightbox-thumb\" width=\"1814\" data-original=\"https://pic1.zhimg.com/v2-6b301c63250bfdcba44034ba5e5eb46c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1814&#39; height=&#39;740&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1814\" data-rawheight=\"740\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1814\" data-original=\"https://pic1.zhimg.com/v2-6b301c63250bfdcba44034ba5e5eb46c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6b301c63250bfdcba44034ba5e5eb46c_b.jpg\"/></figure><p>数据库服务和客户端：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4eda59e8d65c3a32fba60b10d9929cc7_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1810\" data-rawheight=\"290\" class=\"origin_image zh-lightbox-thumb\" width=\"1810\" data-original=\"https://pic4.zhimg.com/v2-4eda59e8d65c3a32fba60b10d9929cc7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1810&#39; height=&#39;290&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1810\" data-rawheight=\"290\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1810\" data-original=\"https://pic4.zhimg.com/v2-4eda59e8d65c3a32fba60b10d9929cc7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4eda59e8d65c3a32fba60b10d9929cc7_b.png\"/></figure><p>mongoose 相关概念看看官网就好了【<a href=\"https://link.zhihu.com/?target=https%3A//mongoosedoc.top/docs/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mongoose 中文文档</a>】</p><p>用法很简单，定义 Schema，转换成 Model，操作 Model，生成实例。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"cm\">/* model.js */</span>\n<span class=\"k\">const</span> <span class=\"nx\">mongoose</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;mongoose&#39;</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">Schema</span> <span class=\"o\">=</span> <span class=\"nx\">mongoose</span><span class=\"p\">.</span><span class=\"nx\">Schema</span><span class=\"p\">;</span>\n<span class=\"c1\">// 定义 Schema\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">UserSchema</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Schema</span><span class=\"p\">({</span>\n  <span class=\"nx\">username</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"nb\">String</span><span class=\"p\">,</span>\n    <span class=\"nx\">unique</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n    <span class=\"nx\">require</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">password</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"nb\">String</span><span class=\"p\">,</span>\n    <span class=\"nx\">require</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">});</span>\n\n<span class=\"c1\">// 转换成 Model\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">UserModel</span> <span class=\"o\">=</span> <span class=\"nx\">mongoose</span><span class=\"p\">.</span><span class=\"nx\">model</span><span class=\"p\">(</span><span class=\"s1\">&#39;User&#39;</span><span class=\"p\">,</span> <span class=\"nx\">UserSchema</span><span class=\"p\">);</span>\n\n<span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"nx\">UserModel</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* user.js */</span>\n<span class=\"c1\">// 操作 Model\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">user</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">UserModel</span><span class=\"p\">.</span><span class=\"nx\">findOne</span><span class=\"p\">({</span> <span class=\"nx\">username</span> <span class=\"p\">});</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">user</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">try</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// 生成实例\n</span><span class=\"c1\"></span>            <span class=\"kr\">await</span> <span class=\"k\">new</span> <span class=\"nx\">UserModel</span><span class=\"p\">({</span>\n            <span class=\"nx\">username</span><span class=\"p\">,</span>\n            <span class=\"nx\">password</span>\n            <span class=\"p\">}).</span><span class=\"nx\">save</span><span class=\"p\">();</span>\n            <span class=\"nx\">ctx</span><span class=\"p\">.</span><span class=\"nx\">body</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"s2\">&#34;success&#34;</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n            <span class=\"s2\">&#34;message&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;注册成功&#34;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nx\">ctx</span><span class=\"p\">.</span><span class=\"nx\">body</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"s2\">&#34;success&#34;</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>\n            <span class=\"s2\">&#34;message&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;注册失败&#34;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"nx\">ctx</span><span class=\"p\">.</span><span class=\"nx\">body</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"s2\">&#34;success&#34;</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;message&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;用户名已存在&#34;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>Docker</h2><p>由上面的步骤，我们可以看出来，项目启动步骤麻烦，而且在安装 MongoDB 环境时，容易受干扰。</p><p>下面通过 Docker 来构建开发环境，提高开发体验。</p><p>在使用 Docker 之前，先了解下几个概念。</p><ul><li>镜像： 镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</li></ul><blockquote>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</blockquote><p>所以，在生产部署时，确保每一层的纯净，剔除不必要文件。比如开发编译时的文件等（ node_module ）。这样也避免了镜像不必要的臃肿。</p><ul><li>容器：容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。</li></ul><blockquote>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。<br/>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。<br/>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。<br/>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</blockquote><p>开发环境经常对文件修改，就可以利用这里的数据卷绑定宿主目录。</p><ul><li>上下文：传给 Docker 引擎的文件目录。</li></ul><p>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。在构建镜像时，会将上下文复制到 Docker 引擎。然后通过 Docker 客户端发出指令，而指令的执行是在 Docker 引擎中。所以，上下文的范围要合理，范围过大，就会导致文件复制到 Docker 引擎的时间长；范围过小，则会导致无法操作范围外的文件。</p><h2>Docker 部署开发环境</h2><p>部署开发环境其实很简单，只需要配置 Dockerfile 和 docker-compose 即可。相关文档可见：【<a href=\"https://link.zhihu.com/?target=https%3A//www.hacking8.com/docker-practice/image/dockerfile/README.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Dockerfile 指令详解</a>】和【<a href=\"https://link.zhihu.com/?target=https%3A//www.hacking8.com/docker-practice/compose/compose_file.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Compose 模板文件</a>】</p><p>docker-compose 使用的是 YAML 语言，【<a href=\"https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/07/yaml.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">YAML 语言教程</a>】</p><div class=\"highlight\"><pre><code class=\"language-yaml\">version<span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s1\">&#39;3.6&#39;</span><span class=\"w\">\n</span><span class=\"w\">\n</span><span class=\"w\"></span>services<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">  </span>client<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">    </span>container_name<span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">&#34;client&#34;</span><span class=\"w\">\n</span><span class=\"w\">    </span>build<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>context<span class=\"p\">:</span><span class=\"w\"> </span>../<span class=\"w\">\n</span><span class=\"w\">      </span>dockerfile<span class=\"p\">:</span><span class=\"w\"> </span>Dockerfile.client.dev<span class=\"w\">\n</span><span class=\"w\">    </span>volumes<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>-<span class=\"w\"> </span>../src<span class=\"p\">:</span>/app/client/src<span class=\"w\">\n</span><span class=\"w\">    </span>ports<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>-<span class=\"w\"> </span><span class=\"s2\">&#34;8090:8090&#34;</span><span class=\"w\">\n</span><span class=\"w\">    </span>depends_on<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>-<span class=\"w\"> </span>server<span class=\"w\">\n</span><span class=\"w\">\n</span><span class=\"w\">  </span>server<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">    </span>container_name<span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">&#34;server&#34;</span><span class=\"w\">\n</span><span class=\"w\">    </span>build<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>context<span class=\"p\">:</span><span class=\"w\"> </span>../server<span class=\"w\">\n</span><span class=\"w\">      </span>dockerfile<span class=\"p\">:</span><span class=\"w\"> </span>Dockerfile.server.dev<span class=\"w\">\n</span><span class=\"w\">    </span>volumes<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>-<span class=\"w\"> </span>../server<span class=\"p\">:</span>/app/server<span class=\"w\">\n</span><span class=\"w\">    </span>ports<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>-<span class=\"w\"> </span><span class=\"s2\">&#34;8080:8080&#34;</span><span class=\"w\">\n</span><span class=\"w\">    </span>depends_on<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>-<span class=\"w\"> </span>database<span class=\"w\">\n</span><span class=\"w\">\n</span><span class=\"w\">\n</span><span class=\"w\">  </span>database<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">    </span>container_name<span class=\"p\">:</span><span class=\"w\"> </span>mongo<span class=\"w\">\n</span><span class=\"w\">    </span>image<span class=\"p\">:</span><span class=\"w\"> </span>mongo<span class=\"w\">\n</span><span class=\"w\">    </span>volumes<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>-<span class=\"w\"> </span>../data<span class=\"p\">:</span>/data/db<span class=\"w\">\n</span><span class=\"w\">    </span>ports<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">      </span>-<span class=\"w\"> </span><span class=\"s2\">&#34;27017:27017&#34;</span></code></pre></div><p>开发环境需要的就是实时展现效果，前端页面是这样，后端服务亦是如此。 如上文提到，上下文已经提交到镜像，前端项目如何才能够在容器中实现热替换？其实很简单，就是 volumes 这个配置。同理，后端也是，不过还需要 modemon 工具协助。</p><p>在部署时，也要到了一些问题，就是在镜像中，localhost 无法使用，需要用 IP 代替。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 前端项目\n</span><span class=\"c1\"></span><span class=\"cm\">/* webpack.dev.js */</span>\n  <span class=\"nx\">devServer</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">publicPath</span><span class=\"o\">:</span> <span class=\"s1\">&#39;/&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">contentBase</span><span class=\"o\">:</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;..&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dist&#39;</span><span class=\"p\">),</span>\n    <span class=\"nx\">port</span><span class=\"o\">:</span> <span class=\"nx\">APP_CONFIG</span><span class=\"p\">.</span><span class=\"nx\">port</span><span class=\"p\">,</span>\n    <span class=\"nx\">host</span><span class=\"o\">:</span> <span class=\"s1\">&#39;0.0.0.0&#39;</span><span class=\"p\">,</span> <span class=\"c1\">// 需指明\n</span><span class=\"c1\"></span>    <span class=\"nx\">hot</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n    <span class=\"nx\">historyApiFallback</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">index</span><span class=\"o\">:</span> <span class=\"s1\">&#39;/&#39;</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n\n<span class=\"c1\">// 后端项目\n</span><span class=\"c1\"></span><span class=\"cm\">/* config.js */</span>\n<span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"s1\">&#39;database&#39;</span><span class=\"o\">:</span> <span class=\"s1\">&#39;mongodb://database:27017/yexiaochen&#39;</span>  <span class=\"c1\">// 与 docker-compose 中 database 服务名匹配\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "Docker", 
                    "tagLink": "https://api.zhihu.com/topics/19950993"
                }, 
                {
                    "tag": "全栈开发", 
                    "tagLink": "https://api.zhihu.com/topics/20043281"
                }
            ], 
            "comments": [
                {
                    "userName": "简简单单", 
                    "userLink": "https://www.zhihu.com/people/a9e8b01ad028f67c05b7a3b718f5d06c", 
                    "content": "<p>只限于linux系统吧，window系统不兼容</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "不排除这个可能，我是在mac上开发的[捂脸]", 
                            "likes": 0, 
                            "replyToAuthor": "简简单单"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71605785", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 2, 
            "title": "react+redux+react-router-dom脚手架搭建(node服务【可选】)", 
            "content": "<h2>前言</h2><p>之前的 <code>multi-spa-webpack-cli</code> 只是为 React + antd 模板提供了开发时必要的环境，对于实际的开发并没有什么用处。 为了更贴近实际开发，本次 React + antd 模板完善了一些功能。</p><ol><li>封装 <b>fetch</b>，新增请求错误提示；</li><li>集成 <b>react-router-dom</b> 路由管理；</li><li>集成 <b>react-redux</b> 状态管理；</li><li>必不可少的 <b>antd</b> 集成；</li><li><b>node</b> 服务集成（可选）。</li></ol><p>node 服务和 React+antd 模板是没有多大的关系的。本文只是想通过一个简单的登陆逻辑来演示以上的功能，所以 node 服务不是必须的。</p><p><code>multi-spa-webpack-cli</code> 已经发布到 npm，只要在 node 环境下安装即可。</p><div class=\"highlight\"><pre><code class=\"language-ps1con\">npm install multi-spa-webpack-cli -g</code></pre></div><p>使用步骤如下:</p><div class=\"highlight\"><pre><code class=\"language-ps1con\"># 1. 初始化项目\nmulti-spa-webpack-cli init spa-project</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-22b061a53e599f888d2eb980c38f3412_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"910\" data-rawheight=\"276\" class=\"origin_image zh-lightbox-thumb\" width=\"910\" data-original=\"https://pic3.zhimg.com/v2-22b061a53e599f888d2eb980c38f3412_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;910&#39; height=&#39;276&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"910\" data-rawheight=\"276\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"910\" data-original=\"https://pic3.zhimg.com/v2-22b061a53e599f888d2eb980c38f3412_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-22b061a53e599f888d2eb980c38f3412_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-ps1con\"># 2. 进入文件目录\ncd spa-project\n\n# 3. 安装依赖\nnpm install\n\n# 4. 打包不变的部分\nnpm run build:dll\n\n# 5. 启动项目（手动打开浏览器：localhost:8090）\nnpm start\n\n# 6. 启动服务(可选)\ncd server\nnpm install\nnpm start</code></pre></div><p>预览：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f2a9240f2b6ae94c6856fc4bf134335a_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"968\" data-rawheight=\"1104\" data-thumbnail=\"https://pic3.zhimg.com/v2-f2a9240f2b6ae94c6856fc4bf134335a_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"968\" data-original=\"https://pic3.zhimg.com/v2-f2a9240f2b6ae94c6856fc4bf134335a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;968&#39; height=&#39;1104&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"968\" data-rawheight=\"1104\" data-thumbnail=\"https://pic3.zhimg.com/v2-f2a9240f2b6ae94c6856fc4bf134335a_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"968\" data-original=\"https://pic3.zhimg.com/v2-f2a9240f2b6ae94c6856fc4bf134335a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f2a9240f2b6ae94c6856fc4bf134335a_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>封装 fetch</h2><p>现在处理异步的方式，大多数基于 Promise 的。而 fetch 是天然支持 Promise 的，所以无需再手动封装。在 PWA 技术中，已作为一个重要的组成部分在使用。</p><p>fetch 为人诟病的缺点之一，就是不能 Abort 请求。有方案提出提出，通过 Promise.race 的方法来模拟 timeout。实际上该执行的已然执行，只是表象上达到了预期的效果。不过浏览器现以实验性开始支持 AbortController 。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">notification</span> <span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;antd&#39;</span><span class=\"p\">;</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">env</span> <span class=\"o\">=</span> <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">env</span><span class=\"p\">.</span><span class=\"nx\">NODE_ENV</span><span class=\"p\">;</span>\n<span class=\"k\">const</span> <span class=\"nx\">baseURL</span> <span class=\"o\">=</span> <span class=\"nx\">APP_CONFIG</span><span class=\"p\">[</span><span class=\"nx\">env</span><span class=\"p\">].</span><span class=\"nx\">ip</span><span class=\"p\">;</span>\n<span class=\"c1\">// timeout ;\n</span><span class=\"c1\">// const controller = new AbortController();\n</span><span class=\"c1\">// const signal = controller.signal;\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">defaultConfig</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">credentials</span><span class=\"o\">:</span> <span class=\"s1\">&#39;include&#39;</span><span class=\"p\">,</span>\n  <span class=\"nx\">headers</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">Accept</span><span class=\"o\">:</span> <span class=\"s1\">&#39;application/json&#39;</span>\n  <span class=\"p\">},</span>\n  <span class=\"c1\">// signal\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n<span class=\"k\">const</span> <span class=\"nx\">codeMessage</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"mi\">301</span><span class=\"o\">:</span> <span class=\"s1\">&#39;永久移动&#39;</span><span class=\"p\">,</span>\n  <span class=\"mi\">302</span><span class=\"o\">:</span> <span class=\"s1\">&#39;临时移动&#39;</span><span class=\"p\">,</span>\n<span class=\"c1\">// ...\n</span><span class=\"c1\"></span>  <span class=\"mi\">504</span><span class=\"o\">:</span> <span class=\"s1\">&#39;网关超时。&#39;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">checkStatus</span> <span class=\"o\">=</span> <span class=\"nx\">response</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">status</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">200</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">status</span> <span class=\"o\">&lt;</span> <span class=\"mi\">300</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">response</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n  <span class=\"k\">const</span> <span class=\"nx\">errortext</span> <span class=\"o\">=</span> <span class=\"nx\">codeMessage</span><span class=\"p\">[</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">status</span><span class=\"p\">]</span> <span class=\"o\">||</span> <span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">statusText</span><span class=\"p\">;</span>\n  <span class=\"nx\">notification</span><span class=\"p\">.</span><span class=\"nx\">error</span><span class=\"p\">({</span>\n    <span class=\"nx\">message</span><span class=\"o\">:</span> <span class=\"sb\">`请求错误 </span><span class=\"si\">${</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">status</span><span class=\"si\">}</span><span class=\"sb\">: </span><span class=\"si\">${</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">url</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">,</span>\n    <span class=\"nx\">description</span><span class=\"o\">:</span> <span class=\"nx\">errortext</span>\n  <span class=\"p\">});</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"kr\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">Fetch</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">,</span> <span class=\"nx\">config</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">newUrl</span> <span class=\"o\">=</span> <span class=\"nx\">baseURL</span> <span class=\"o\">+</span> <span class=\"nx\">url</span><span class=\"p\">;</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">newConfig</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"p\">...</span><span class=\"nx\">defaultConfig</span><span class=\"p\">,</span>\n    <span class=\"p\">...</span><span class=\"nx\">config</span>\n  <span class=\"p\">};</span>\n  <span class=\"c1\">// const timeoutId = setTimeout(() =&gt; controller.abort(), 5000);\n</span><span class=\"c1\"></span>  <span class=\"k\">if</span> <span class=\"p\">(</span>\n    <span class=\"nx\">newConfig</span><span class=\"p\">.</span><span class=\"nx\">method</span><span class=\"p\">.</span><span class=\"nx\">toLocaleLowerCase</span><span class=\"p\">()</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;post&#39;</span> <span class=\"o\">||</span>\n    <span class=\"nx\">newConfig</span><span class=\"p\">.</span><span class=\"nx\">method</span><span class=\"p\">.</span><span class=\"nx\">toLocaleLowerCase</span><span class=\"p\">()</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;put&#39;</span> <span class=\"o\">||</span>\n    <span class=\"nx\">newConfig</span><span class=\"p\">.</span><span class=\"nx\">method</span><span class=\"p\">.</span><span class=\"nx\">toLocaleLowerCase</span><span class=\"p\">()</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;delete&#39;</span>\n  <span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"nx\">newConfig</span><span class=\"p\">.</span><span class=\"nx\">body</span> <span class=\"k\">instanceof</span> <span class=\"nx\">FormData</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n      <span class=\"nx\">newConfig</span><span class=\"p\">.</span><span class=\"nx\">headers</span><span class=\"p\">[</span><span class=\"s1\">&#39;Content-Type&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;application/json; charset=utf-8&#39;</span><span class=\"p\">;</span>\n      <span class=\"nx\">newConfig</span><span class=\"p\">.</span><span class=\"nx\">body</span> <span class=\"o\">=</span> <span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"nx\">newConfig</span><span class=\"p\">.</span><span class=\"nx\">body</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n  <span class=\"k\">try</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">fetch</span><span class=\"p\">(</span><span class=\"nx\">newUrl</span><span class=\"p\">,</span> <span class=\"nx\">newConfig</span><span class=\"p\">);</span>\n    <span class=\"c1\">// clearTimeout(timeoutId);\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"nx\">checkStatus</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">).</span><span class=\"nx\">json</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">notification</span><span class=\"p\">.</span><span class=\"nx\">error</span><span class=\"p\">({</span>\n      <span class=\"nx\">message</span><span class=\"o\">:</span> <span class=\"sb\">`请求错误 : </span><span class=\"si\">${</span><span class=\"nx\">newUrl</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">,</span>\n      <span class=\"nx\">description</span><span class=\"o\">:</span> <span class=\"nx\">error</span><span class=\"p\">.</span><span class=\"nx\">message</span>\n    <span class=\"p\">});</span>\n    <span class=\"k\">throw</span> <span class=\"nx\">error</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>集成 <b>react-router-dom</b> 路由管理</h2><p>自 raect-router v4 之后，便不再支持集中式管理路由，不过也可以自己手动去实现。React + antd 模板采用的是官网推荐的方式，layouts 目录下的文件用来管理路由。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-03f909053b5074751b372b692051d079_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2746\" data-rawheight=\"1618\" class=\"origin_image zh-lightbox-thumb\" width=\"2746\" data-original=\"https://pic2.zhimg.com/v2-03f909053b5074751b372b692051d079_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2746&#39; height=&#39;1618&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2746\" data-rawheight=\"1618\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2746\" data-original=\"https://pic2.zhimg.com/v2-03f909053b5074751b372b692051d079_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-03f909053b5074751b372b692051d079_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>集成 <b>react-redux</b> 状态管理</h2><p>Redux 作为状态管理工具，除了 React，也可以用在其他地方（意思是说，和 React 没半毛钱关系）。在React中使用时，我们需要借助 React-redux 工具，这样使用起来更加方便。</p><blockquote>严格的单向数据流是 Redux 架构的设计核心。</blockquote><p>redux 数据流向：</p><p>就是把 action（行为） dispatch（丢给）reducer（更新 state）。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9dc9c5bb470aab1a8482356cc824de1f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3840\" data-rawheight=\"2400\" class=\"origin_image zh-lightbox-thumb\" width=\"3840\" data-original=\"https://pic4.zhimg.com/v2-9dc9c5bb470aab1a8482356cc824de1f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;3840&#39; height=&#39;2400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3840\" data-rawheight=\"2400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"3840\" data-original=\"https://pic4.zhimg.com/v2-9dc9c5bb470aab1a8482356cc824de1f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9dc9c5bb470aab1a8482356cc824de1f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>node</b> 服务集成（可选）</h2><p>node 服务登陆采用的是 session 来记录状态。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d4009fb7c9004bb241e428db19e1bced_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3840\" data-rawheight=\"2400\" class=\"origin_image zh-lightbox-thumb\" width=\"3840\" data-original=\"https://pic2.zhimg.com/v2-d4009fb7c9004bb241e428db19e1bced_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;3840&#39; height=&#39;2400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3840\" data-rawheight=\"2400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"3840\" data-original=\"https://pic2.zhimg.com/v2-d4009fb7c9004bb241e428db19e1bced_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d4009fb7c9004bb241e428db19e1bced_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>就这样，一个简单的脚手架宣告完成。</p><p>不过，这才只是个开始。</p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70068048", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 17, 
            "title": "webpack开发环境配置", 
            "content": "<h2>日常吐槽</h2><p>经过不断的调整和测试，关于 react 的 webpack 配置终于新鲜出炉。本次的重点主要集中在开发环境上，生产环境则是使用 webpack 的 production 默认模式。</p><p>本次配置主要有：</p><ol><li><b>eslint+prettier</b>;</li><li><b>optimization.splitChunks</b>;</li><li><b>happypack</b>;</li><li><b>DllReferencePlugin &amp; DllPlugin</b>;</li><li>...</li></ol><h2>文档的重要性</h2><p>讲真，对于初次接触 webpack 的同学，怕的可能不是 webpack 的配置，而是长长的 package.json。依赖那么多，你怎么就知道需要哪些依赖呢。不开玩笑，我还真知道。 webpack 的依赖主要是一些 loader 和 plugins。我们知道单页面引用被打包后，原有的结构基本上不复存在了。而之前引用的图片或字体资源还按照之前的路径查找，肯定是找不到的。那么我们就需要转换工具（顺便转换资源）—— <code>url-loader</code>|<code>file-loader</code>。 大多数人写样式时，喜欢使用 css、less、sass。这时也会有对应的工具 <code>style-loader</code>, <code>css-loader</code>, <code>less-loader</code>。 想要使用 JavaScript 新特性或处理兼容性，就用 <code>babel-loader</code>。以上这些基本上可以应付一些简单的项目。可实际上呢？</p><blockquote>我信你个鬼，你这个糟老头坏的很！</blockquote><p>看文档啊，看官方介绍啊。本次也是通过看 babel 文档，和一些依赖文档来配置 webpack 的，全程无压力，而且很正宗。所以，文档很重要。</p><h2>eslint+prettier</h2><p>如果时团队合作，代码规范是很重要的。可以通过 eslint+prettier 规范。这两个工具各有侧重点，不过官网也提供了两者结合的方案。详细介绍见官网。我个人不习惯创建太多的配置文件，所以都放在了 package.json 文件中。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">//  webpack.common.js\n</span><span class=\"c1\"></span><span class=\"p\">{</span>\n    <span class=\"nx\">enforce</span><span class=\"o\">:</span> <span class=\"s2\">&#34;pre&#34;</span><span class=\"p\">,</span>\n    <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/\\.m?jsx?$/</span><span class=\"p\">,</span>\n    <span class=\"nx\">exclude</span><span class=\"o\">:</span> <span class=\"sr\">/node_modules/</span><span class=\"p\">,</span>\n    <span class=\"nx\">loader</span><span class=\"o\">:</span> <span class=\"s2\">&#34;eslint-loader&#34;</span><span class=\"p\">,</span>\n    <span class=\"nx\">options</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">fix</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n        <span class=\"nx\">cache</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n        <span class=\"nx\">formatter</span><span class=\"o\">:</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s2\">&#34;eslint-friendly-formatter&#34;</span><span class=\"p\">),</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">},</span>\n<span class=\"s2\">&#34;eslintConfig&#34;</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"s2\">&#34;parser&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;babel-eslint&#34;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&#34;env&#34;</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"s2\">&#34;browser&#34;</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;es6&#34;</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;node&#34;</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n    <span class=\"p\">},</span>\n    <span class=\"s2\">&#34;parserOptions&#34;</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"s2\">&#34;ecmaVersion&#34;</span><span class=\"o\">:</span> <span class=\"mi\">6</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;sourceType&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;module&#34;</span>\n    <span class=\"p\">},</span>\n    <span class=\"s2\">&#34;extends&#34;</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n        <span class=\"s2\">&#34;plugin:prettier/recommended&#34;</span>\n    <span class=\"p\">]</span>\n<span class=\"p\">},</span>\n<span class=\"s2\">&#34;prettier&#34;</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"s2\">&#34;singleQuote&#34;</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n    <span class=\"s2\">&#34;semi&#34;</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n<span class=\"p\">},</span>\n</code></pre></div><h2>开发环境</h2><p>开发环境没什么好说的了，简单易配置，官网很详细。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// webpack.dev.js\n</span><span class=\"c1\"></span>\n<span class=\"nx\">plugins</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"c1\">//...\n</span><span class=\"c1\"></span>    <span class=\"k\">new</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">HotModuleReplacementPlugin</span><span class=\"p\">()</span>\n<span class=\"p\">},</span>\n<span class=\"nx\">devtool</span><span class=\"o\">:</span> <span class=\"s2\">&#34;eval-source-map&#34;</span><span class=\"p\">,</span>\n<span class=\"nx\">devServer</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n<span class=\"nx\">contentBase</span><span class=\"o\">:</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;..&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dist&#39;</span><span class=\"p\">),</span>\n<span class=\"nx\">port</span><span class=\"o\">:</span> <span class=\"nx\">APP_CONFIG</span><span class=\"p\">.</span><span class=\"nx\">port</span><span class=\"p\">,</span>\n<span class=\"nx\">hot</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n<span class=\"nx\">open</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// index.js\n</span><span class=\"c1\">// 入口处要配置这些，别忘了。\n</span><span class=\"c1\">// 因为有冒泡的机制，所以在顶端加一个就好。\n</span><span class=\"c1\"></span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">hot</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">hot</span><span class=\"p\">.</span><span class=\"nx\">accept</span><span class=\"p\">(</span><span class=\"s1\">&#39;./views/login/index.js&#39;</span><span class=\"p\">,</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">render</span><span class=\"p\">(</span><span class=\"nx\">App</span><span class=\"p\">)</span> <span class=\"c1\">// 渲染应用\n</span><span class=\"c1\"></span>  <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>optimization.splitChunks</h2><p>这个配置是用来分割包的。在性能优化上，请求数和请求包的大小也是很重要的优化点。请求数量和请求数据大小要控制在合理的范围内。 不过通常情况下，我们会将包分割为内容不变的部分和内容变化的部分。这不仅仅是为了将大的包分割成更小的包，也是为了能够充分利用缓存机制。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// webpack.common.js\n</span><span class=\"c1\"></span><span class=\"nx\">runtimeChunk</span><span class=\"o\">:</span> <span class=\"s1\">&#39;single&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">splitChunks</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">cacheGroups</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">verdor</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n            <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/[\\\\/]node_modules[\\\\/]/</span><span class=\"p\">,</span>\n            <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;verdors&#39;</span><span class=\"p\">,</span>\n            <span class=\"nx\">chunks</span><span class=\"o\">:</span> <span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span>\n            <span class=\"nx\">priority</span><span class=\"o\">:</span> <span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n        <span class=\"nx\">common</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n            <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;common&#39;</span><span class=\"p\">,</span>\n            <span class=\"nx\">chunks</span><span class=\"o\">:</span> <span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span>\n            <span class=\"nx\">minChunks</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n            <span class=\"nx\">priority</span><span class=\"o\">:</span> <span class=\"o\">-</span><span class=\"mi\">20</span><span class=\"p\">,</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>happypack</h2><p>转换文件算是打包过程中比较耗时的事情，通过 happypack 可以将这件事分摊给多个 node 进程，这样就会大大缩短了打包时间（同理，可以考虑使用 <code>thread-loader</code>）。不过进程之间的通信是要开销的，这是一个优化方向，要不要采用，还需要酌情考虑。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// loader\n</span><span class=\"c1\"></span><span class=\"p\">{</span>\n    <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/\\.m?jsx?$/</span><span class=\"p\">,</span>\n    <span class=\"nx\">exclude</span><span class=\"o\">:</span> <span class=\"sr\">/node_modules/</span><span class=\"p\">,</span>\n    <span class=\"nx\">use</span><span class=\"o\">:</span> <span class=\"s1\">&#39;happypack/loader?id=js&#39;</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// plugins\n</span><span class=\"c1\"></span><span class=\"k\">new</span> <span class=\"nx\">HappyPack</span><span class=\"p\">({</span>\n    <span class=\"nx\">id</span><span class=\"o\">:</span> <span class=\"s1\">&#39;js&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">threadPool</span><span class=\"o\">:</span> <span class=\"nx\">happyThreadPool</span><span class=\"p\">,</span>\n    <span class=\"nx\">loaders</span><span class=\"o\">:</span> <span class=\"p\">[{</span>\n    <span class=\"nx\">loader</span><span class=\"o\">:</span> <span class=\"s1\">&#39;babel-loader&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">options</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">cacheDirectory</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n        <span class=\"nx\">presets</span><span class=\"o\">:</span> <span class=\"p\">[[</span><span class=\"s1\">&#39;@babel/preset-env&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n        <span class=\"s2\">&#34;useBuiltIns&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;usage&#34;</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;corejs&#34;</span><span class=\"o\">:</span> <span class=\"mi\">3</span>\n        <span class=\"p\">}],</span> <span class=\"s2\">&#34;@babel/preset-react&#34;</span><span class=\"p\">],</span>\n        <span class=\"nx\">plugins</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"s1\">&#39;@babel/transform-runtime&#39;</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;@babel/plugin-proposal-class-properties&#34;</span><span class=\"p\">,</span> <span class=\"p\">[</span>\n            <span class=\"s2\">&#34;import&#34;</span><span class=\"p\">,</span>\n            <span class=\"p\">{</span>\n            <span class=\"s2\">&#34;libraryName&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;antd&#34;</span><span class=\"p\">,</span>\n            <span class=\"s2\">&#34;style&#34;</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">]</span>\n        <span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n    <span class=\"p\">}]</span>\n<span class=\"p\">})</span>\n</code></pre></div><p>不喜欢单独的 babel 文件，所以 babel 的配置都在这里了。其实，关于 babel 要配置的内容还是挺多的。不过不要怕，babel 的官方文档有详细说明。</p><h2>DllReferencePlugin &amp; DllPlugin</h2><p>之前也提到过，通常我们会使用 <code>optimization.splitChunks</code> 来处理第三方库，将其分割成不变的部分。可是，每次打包的时候都需要重复这一步骤。 这时候我们就想啊，不变的部分打包一次不就可以了么，之后就只打包那些经常变化的部分，这样不就能提高效率了么？是的， <code>DllReferencePlugin &amp; DllPlugin</code> 基本上要做的就是这么一回事。所以，我们会针对这两部分做不同的配置。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// webpack.dll.js\n</span><span class=\"c1\"></span><span class=\"k\">new</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">DllPlugin</span><span class=\"p\">({</span>\n    <span class=\"nx\">context</span><span class=\"o\">:</span> <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">cwd</span><span class=\"p\">(),</span>\n    <span class=\"nx\">path</span><span class=\"o\">:</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;..&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dist&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dll&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;[name]-manifest.json&#39;</span><span class=\"p\">),</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;[name]_[hash]&#39;</span>\n<span class=\"p\">})</span>\n<span class=\"c1\">// webpack.common.js\n</span><span class=\"c1\"></span><span class=\"k\">new</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">DllReferencePlugin</span><span class=\"p\">({</span>\n    <span class=\"nx\">context</span><span class=\"o\">:</span> <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">cwd</span><span class=\"p\">(),</span> \n    <span class=\"nx\">manifest</span><span class=\"o\">:</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;..&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dist&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dll&#39;</span><span class=\"p\">,</span> <span class=\"s2\">&#34;vendor-manifest.json&#34;</span><span class=\"p\">))</span>\n<span class=\"p\">}),</span>\n</code></pre></div><h2>multi-spa-webpack-cli使用说明</h2><p><code>multi-spa-webpack-cli</code> 已经发布到 npm，只要在 node 环境下安装即可。<b>一路按 Enter，全部源码都在里面！！！</b></p><div class=\"highlight\"><pre><code class=\"language-bash\">npm install multi-spa-webpack-cli -g</code></pre></div><p>使用步骤如下:</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"c1\"># 1. 初始化项目</span>\nmulti-spa-webpack-cli init spa-project\n\n<span class=\"c1\"># 2. 进入文件目录</span>\n<span class=\"nb\">cd</span> spa-project\n\n<span class=\"c1\"># 3. 安装依赖</span>\nnpm install\n\n<span class=\"c1\"># 4. 打包不变的部分</span>\nnpm run build:dll\n\n<span class=\"c1\"># 5. 启动项目（手动打开浏览器：localhost:8090）</span>\nnpm start</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "webpack", 
                    "tagLink": "https://api.zhihu.com/topics/20032877"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69289711", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 26, 
            "title": "手写webpack脚手架命令行工具", 
            "content": "<h2>日常吐槽</h2><p>本来想搭建一个webpack脚手架的，于是在搭建的过程中不断地搜集相关资料。可最终的结果是，webpack脚手架没有搭建成，却写出个 CLI 小工具。其实，这也并不是没有原因的。现在流行的框架都推出了自己的脚手架工具，比如，Vue CLI，Create React App 等。脚手架和CLI往往如影随形，这也导致了两者在概念上的混淆。标题为什么这么拗口，其实是为了区分这两个概念。</p><h2>我有一个想法</h2><p>既然被带跑偏了，就只能在跑偏的路上越跑越远吧。</p><blockquote>命令行界面（英语：Command-Line Interface，缩写：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（character user interface, CUI） ———— 维基百科</blockquote><p>使用过 Vue CLI 的同学应该都知道，我们只需要在终端敲几个的命令就可以搭建一个 Vue 的脚手架。如果不使用 CLI 的话，每次创建项目时，都需要配置文件（比如webpack配置文件）、设计结构、技术栈选型等。如果每次从零开始去搭建项目就会很麻烦，所以我们可以把相同的东西抽离成脚手架。以后创建项目时，就可以直接把脚手架复制过来，并以此为基础搭建项目。</p><p>回过头来再看看我们手动搭建项目的过程，从每次从零开始搭建项目到脚手架的复用，这中间有了很大的进步。可即使是复制黏贴，我们依然觉得很麻烦，如果用命令行的方式来取代图形操作，我们就可以更懒一些了。</p><p>回到主题，我本来打算写的webpack脚手架是基于这样的一个想法。➡️ 现在大部分的前端工程，webpack作为打包工具已经成了标配了。而 webpack 的配置是大同小异的，完全可以剥离出一个通用的webpack配置，然后针对个别配置进行修改。本次希望最终实现一个基于webpack适用于不同前端模板（React、Vue、ES+）的脚手架。</p><p>现在脚手架有了，如何<b>自动化</b>去搭建一个项目呢？</p><ol><li>复制或下载脚手架模板。（为了更灵活，上传到GitHub，或发布npm中）。</li><li>根据不同需求，在脚手架模板基础上重新配置webpack、package文件。</li><li>安装依赖。</li></ol><p>以下代码可见<a href=\"https://link.zhihu.com/?target=https%3A//github.com/yexiaochen/multi-spa-webpack-cli\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GitHub</a>。</p><h2>CLI 中的预备工作</h2><p>首先了解一下 <code>#!</code>。文件开头要加上<code>#! /usr/bin/env node</code>。</p><blockquote>在计算领域中，Shebang（也称为 Hashbang ）是一个由井号和叹号构成的字符序列 #! ，其出现在文本文件的第一行的前两个字符。 在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数。 ———— 维基百科<br/>使用 #!/usr/bin/env 脚本解释器名称 是一种常见的在不同平台上都能正确找到解释器的办法。 ———— 维基百科</blockquote><p>然后看看都用到了哪些东西（部分）。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">npm</span> <span class=\"nx\">install</span> <span class=\"nx\">commander</span> <span class=\"nx\">chalk</span> <span class=\"nx\">fs</span><span class=\"o\">-</span><span class=\"nx\">extra</span> <span class=\"nx\">shelljs</span> <span class=\"nx\">inquirer</span> <span class=\"nx\">ora</span> <span class=\"nx\">ejs</span> <span class=\"o\">--</span><span class=\"nx\">save</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">#! /usr/bin/env node\n\n// multi-spa.js\nconst program = require(&#39;commander&#39;);  // 解析命令;\nconst chalk = require(&#39;chalk&#39;);  // 命令行界面输出美颜\nconst fs = require(&#39;fs-extra&#39;);  // fs的拓展;\nconst shell = require(&#39;shelljs&#39;);  // 重新包装了 child_process；\nconst inquirer = require(&#39;inquirer&#39;);  // 交互式问答；\nconst ora = require(&#39;ora&#39;);  // 输出样式美化；\nconst ejs = require(&#39;ejs&#39;);  // 模版引擎；\nconst path = require(&#39;path&#39;);\nconst currentPath = process.cwd();\nlet answersConfig = null;</code></pre></div><h2>命令的解析</h2><p>类似与 Vue 的 <code>vue init</code>，我们也希望自己的 CLI 也能拥有类似的功能。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// package.json\n</span><span class=\"c1\"></span>  <span class=\"s2\">&#34;bin&#34;</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"s2\">&#34;multi-spa-webpack&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;./bin/multi-spa.js&#34;</span>\n  <span class=\"p\">},</span>\n</code></pre></div><p>这样，我们就有了<code>multi-spa-webpack</code>的命令。如果我们想要全局使用，还需要执行下面命令。</p><div class=\"highlight\"><pre><code class=\"language-ps1con\">npm link</code></pre></div><p>接下来就要初始化<code>multi-spa-webpack</code>相关的命令了。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// multi-spa.js\n</span><span class=\"c1\"></span><span class=\"nx\">program</span>\n  <span class=\"p\">.</span><span class=\"nx\">command</span><span class=\"p\">(</span><span class=\"s1\">&#39;init &lt;项目路径&gt; [选项]&#39;</span><span class=\"p\">)</span>\n  <span class=\"p\">.</span><span class=\"nx\">description</span><span class=\"p\">(</span><span class=\"s1\">&#39;指令说明：初始化项目&#39;</span><span class=\"p\">)</span>\n  <span class=\"p\">.</span><span class=\"nx\">action</span><span class=\"p\">(</span><span class=\"kr\">async</span> <span class=\"p\">(</span><span class=\"nx\">appName</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">try</span> <span class=\"p\">{</span>\n      <span class=\"nx\">answersConfig</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">getAnswers</span><span class=\"p\">(</span><span class=\"nx\">appName</span><span class=\"p\">);</span>\n      <span class=\"kd\">let</span> <span class=\"nx\">targetDir</span> <span class=\"o\">=</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">currentPath</span><span class=\"p\">,</span> <span class=\"nx\">appName</span> <span class=\"o\">||</span> <span class=\"s1\">&#39;.&#39;</span><span class=\"p\">);</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">pathExistsSync</span><span class=\"p\">(</span><span class=\"nx\">targetDir</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">program</span><span class=\"p\">.</span><span class=\"nx\">force</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"nx\">GenarateProject</span><span class=\"p\">(</span><span class=\"nx\">appName</span><span class=\"p\">);</span>  <span class=\"c1\">// 创建项目；\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n        <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">red</span><span class=\"p\">(</span><span class=\"sb\">`！当前目录下，</span><span class=\"si\">${</span><span class=\"nx\">appName</span><span class=\"si\">}</span><span class=\"sb\">已存在，请修改名称后重试`</span><span class=\"p\">)).</span><span class=\"nx\">fail</span><span class=\"p\">();</span>\n        <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">exit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n      <span class=\"p\">};</span>\n      <span class=\"nx\">GenarateProject</span><span class=\"p\">(</span><span class=\"nx\">appName</span><span class=\"p\">);</span>  <span class=\"c1\">// 创建项目；\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">red</span><span class=\"p\">(</span><span class=\"sb\">`项目创建失败：</span><span class=\"si\">${</span><span class=\"nx\">error</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">)).</span><span class=\"nx\">fail</span><span class=\"p\">();</span>\n      <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">exit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">});</span>\n<span class=\"nx\">program</span>\n  <span class=\"p\">.</span><span class=\"nx\">arguments</span><span class=\"p\">(</span><span class=\"s1\">&#39;&lt;command&gt;&#39;</span><span class=\"p\">)</span>\n  <span class=\"p\">.</span><span class=\"nx\">action</span><span class=\"p\">((</span><span class=\"nx\">cmd</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">();</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">red</span><span class=\"p\">(</span><span class=\"sb\">`！命令未能解析 &lt;</span><span class=\"si\">${</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">green</span><span class=\"p\">(</span><span class=\"nx\">cmd</span><span class=\"p\">)</span><span class=\"si\">}</span><span class=\"sb\">&gt;`</span><span class=\"p\">));</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">();</span>\n    <span class=\"nx\">program</span><span class=\"p\">.</span><span class=\"nx\">outputHelp</span><span class=\"p\">();</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">();</span>\n  <span class=\"p\">});</span>\n<span class=\"nx\">program</span><span class=\"p\">.</span><span class=\"nx\">parse</span><span class=\"p\">(</span><span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">argv</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">program</span><span class=\"p\">.</span><span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">===</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">();</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">red</span><span class=\"p\">(</span><span class=\"s1\">&#39;！输入的命令有误&#39;</span><span class=\"p\">));</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">();</span>\n  <span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"nx\">program</span><span class=\"p\">.</span><span class=\"nx\">help</span><span class=\"p\">());</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>复制或下载模板</h2><p>在执行<code>multi-spa-webpack init spa-project</code>后，就需要拷贝一份脚手架到本地了。至于脚手架从哪里来，可以放在 github 上（类似 Vue CLI）或 放在 CLI 对应的目录下（类似create-react-app）。</p><p>本文是采用的是从 github 获取脚手架模板的。但是常规的方式，只能下载整个项目，而对于不需要的文件夹或文件，也会同时下载，下载后，只能在本地中删除无关文件了。我这里是从源头上剔除无关文件的下载，这个方法可能会有一些局限性吧（sparse-checkout）。不过两者最终的目的是一样的。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// multi-spa.js\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">DownTemplate</span><span class=\"p\">(</span><span class=\"nx\">projectDir</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"nx\">remote</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;https://github.com/yexiaochen/multi-spa-webpack-cli.git&#39;</span><span class=\"p\">;</span>\n  <span class=\"k\">const</span> <span class=\"p\">{</span> <span class=\"nx\">template</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">answersConfig</span><span class=\"p\">;</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">downTemplateSpinner</span> <span class=\"o\">=</span> <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"s1\">&#39;模板下载中...&#39;</span><span class=\"p\">)).</span><span class=\"nx\">start</span><span class=\"p\">();</span>\n  <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">((</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">shell</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"sb\">`\n</span><span class=\"sb\">      mkdir </span><span class=\"si\">${</span><span class=\"nx\">projectDir</span><span class=\"si\">}</span><span class=\"sb\">\n</span><span class=\"sb\">      cd </span><span class=\"si\">${</span><span class=\"nx\">projectDir</span><span class=\"si\">}</span><span class=\"sb\">\n</span><span class=\"sb\">      git init\n</span><span class=\"sb\">      git remote add -f origin </span><span class=\"si\">${</span><span class=\"nx\">remote</span><span class=\"si\">}</span><span class=\"sb\">\n</span><span class=\"sb\">      git config core.sparsecheckout true\n</span><span class=\"sb\">      echo &#34;template/common&#34; &gt;&gt; .git/info/sparse-checkout\n</span><span class=\"sb\">      echo &#34;template/config&#34; &gt;&gt; .git/info/sparse-checkout\n</span><span class=\"sb\">      echo &#34;template/services&#34; &gt;&gt; .git/info/sparse-checkout\n</span><span class=\"sb\">      echo &#34;template/</span><span class=\"si\">${</span><span class=\"nx\">template</span><span class=\"si\">}</span><span class=\"sb\">&#34; &gt;&gt; .git/info/sparse-checkout\n</span><span class=\"sb\">      echo &#34;.gitignore&#34; &gt;&gt; .git/info/sparse-checkout\n</span><span class=\"sb\">      echo &#34;package.json&#34; &gt;&gt; .git/info/sparse-checkout\n</span><span class=\"sb\">      git pull origin master\n</span><span class=\"sb\">      rm -rf .git\n</span><span class=\"sb\">      mv template/* ./\n</span><span class=\"sb\">      rm -rf template\n</span><span class=\"sb\">      `</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"nx\">downTemplateSpinner</span><span class=\"p\">.</span><span class=\"nx\">stop</span><span class=\"p\">()</span>\n          <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">red</span><span class=\"p\">(</span><span class=\"sb\">`模板下载失败：</span><span class=\"si\">${</span><span class=\"nx\">error</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">)).</span><span class=\"nx\">fail</span><span class=\"p\">()</span>\n          <span class=\"nx\">reject</span><span class=\"p\">()</span>\n        <span class=\"p\">}</span>\n        <span class=\"nx\">downTemplateSpinner</span><span class=\"p\">.</span><span class=\"nx\">stop</span><span class=\"p\">();</span>\n        <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"s1\">&#39;模板下载成功&#39;</span><span class=\"p\">)).</span><span class=\"nx\">succeed</span><span class=\"p\">();</span>\n        <span class=\"nx\">resolve</span><span class=\"p\">();</span>\n      <span class=\"p\">})</span>\n  <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>重新生成配置文件</h2><p>像 webpack、package 等配置文件，也都是包含在脚手架里的，不过这些配置还不能直接拿来用。我们还需要通过交互式问答，来针对性得在现有的基础上重新生成配置文件。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// multi-spa.js\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">getAnswers</span><span class=\"p\">(</span><span class=\"nx\">appName</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"nx\">options</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"p\">{</span>\n      <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"s1\">&#39;input&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;name&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">message</span><span class=\"o\">:</span> <span class=\"s1\">&#39;项目名称&#39;</span><span class=\"p\">,</span>\n      <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"nx\">appName</span><span class=\"p\">,</span>\n    <span class=\"p\">},</span>\n    <span class=\"p\">{</span>\n      <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"s1\">&#39;input&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;description&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">message</span><span class=\"o\">:</span> <span class=\"s1\">&#39;项目描述&#39;</span><span class=\"p\">,</span>\n      <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"s1\">&#39;单页面应用&#39;</span><span class=\"p\">,</span>\n    <span class=\"p\">},</span>\n    <span class=\"p\">{</span>\n      <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"s1\">&#39;confirm&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;eslint&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">message</span><span class=\"o\">:</span> <span class=\"s1\">&#39;是否启用 eslint+pretty&#39;</span><span class=\"p\">,</span>\n      <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n    <span class=\"p\">},</span>\n    <span class=\"p\">{</span>\n      <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;cssPreprocessor&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"s1\">&#39;list&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">message</span><span class=\"o\">:</span> <span class=\"s1\">&#39;CSS 预处理器&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">choices</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n        <span class=\"s2\">&#34;less&#34;</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;sass&#34;</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;none&#34;</span><span class=\"p\">,</span>\n      <span class=\"p\">]</span>\n    <span class=\"p\">},</span>\n    <span class=\"p\">{</span>\n      <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;template&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"s1\">&#39;list&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">message</span><span class=\"o\">:</span> <span class=\"s1\">&#39;选取模板&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">choices</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n        <span class=\"s2\">&#34;react&#34;</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;vue&#34;</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;es&#34;</span>\n      <span class=\"p\">]</span>\n    <span class=\"p\">},</span>\n  <span class=\"p\">];</span>\n  <span class=\"k\">return</span> <span class=\"nx\">inquirer</span><span class=\"p\">.</span><span class=\"nx\">prompt</span><span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在获得特定的需求后，还要把这些数据注入到配置文件中。就是通过模板引擎把数据塞到模板里。这里使用的是 ejs 模版引擎。</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"c\">&lt;!--webpack.common.ejs--&gt;</span>\n<span class=\"err\">&lt;</span>%= answers.cssPreprocessor == &#39;none&#39;\n    ? /\\.css$/ : (answers.cssPreprocessor == &#39;less&#39; ? /\\.less$/ : /\\.scss$/) %&gt;\n\n<span class=\"err\">&lt;</span>%= answers.cssPreprocessor == &#39;none&#39;\n    ? &#39;&#39; : (answers.cssPreprocessor == &#39;less&#39; ? &#39;less-loader&#39; : &#39;sass-loader&#39;) %&gt;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// multi-spa.js\n</span><span class=\"c1\"></span><span class=\"kr\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">GenarateWebpackConfig</span><span class=\"p\">(</span><span class=\"nx\">targetDir</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">try</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"nx\">webpackConfigPath</span> <span class=\"o\">=</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"nx\">currentPath</span><span class=\"si\">}</span><span class=\"sb\">/</span><span class=\"si\">${</span><span class=\"nx\">targetDir</span><span class=\"si\">}</span><span class=\"sb\">/config`</span><span class=\"p\">,</span> <span class=\"s1\">&#39;webpack.common.ejs&#39;</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">webpackConfigTargetPath</span> <span class=\"o\">=</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"nx\">currentPath</span><span class=\"si\">}</span><span class=\"sb\">/</span><span class=\"si\">${</span><span class=\"nx\">targetDir</span><span class=\"si\">}</span><span class=\"sb\">/config`</span><span class=\"p\">,</span> <span class=\"s1\">&#39;webpack.common.js&#39;</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">webpackConfigSpinner</span> <span class=\"o\">=</span> <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"sb\">`配置 webpack 文件...`</span><span class=\"p\">)).</span><span class=\"nx\">start</span><span class=\"p\">();</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">webpackConfig</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">readFile</span><span class=\"p\">(</span><span class=\"nx\">webpackConfigPath</span><span class=\"p\">,</span> <span class=\"s1\">&#39;utf8&#39;</span><span class=\"p\">);</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">generatedWebpackConfig</span> <span class=\"o\">=</span> <span class=\"nx\">ejs</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">(</span><span class=\"nx\">webpackConfig</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">answers</span><span class=\"o\">:</span> <span class=\"nx\">answersConfig</span> <span class=\"p\">});</span>\n    <span class=\"kr\">await</span> <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">all</span><span class=\"p\">([</span>\n      <span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">writeFile</span><span class=\"p\">(</span><span class=\"nx\">webpackConfigTargetPath</span><span class=\"p\">,</span> <span class=\"nx\">generatedWebpackConfig</span><span class=\"p\">),</span>\n      <span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">remove</span><span class=\"p\">(</span><span class=\"nx\">webpackConfigPath</span><span class=\"p\">)</span>\n    <span class=\"p\">])</span>\n    <span class=\"nx\">webpackConfigSpinner</span><span class=\"p\">.</span><span class=\"nx\">stop</span><span class=\"p\">();</span>\n    <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"sb\">`配置 webpack 完成`</span><span class=\"p\">)).</span><span class=\"nx\">succeed</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">red</span><span class=\"p\">(</span><span class=\"sb\">`配置文件失败：</span><span class=\"si\">${</span><span class=\"nx\">error</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">)).</span><span class=\"nx\">fail</span><span class=\"p\">();</span>\n    <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">exit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"kr\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">GenaratePackageJson</span><span class=\"p\">(</span><span class=\"nx\">projectDir</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">try</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"p\">{</span> <span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">description</span><span class=\"p\">,</span> <span class=\"nx\">cssPreprocessor</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">answersConfig</span><span class=\"p\">;</span>\n    <span class=\"k\">const</span> <span class=\"nx\">packageJsonPath</span> <span class=\"o\">=</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"nx\">currentPath</span><span class=\"si\">}</span><span class=\"sb\">/</span><span class=\"si\">${</span><span class=\"nx\">projectDir</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">,</span> <span class=\"s1\">&#39;package.json&#39;</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">packageJsonSpinner</span> <span class=\"o\">=</span> <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"s1\">&#39;配置 package.json 文件...&#39;</span><span class=\"p\">)).</span><span class=\"nx\">start</span><span class=\"p\">();</span>\n    <span class=\"kd\">let</span> <span class=\"kr\">package</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">readJson</span><span class=\"p\">(</span><span class=\"nx\">packageJsonPath</span><span class=\"p\">);</span>\n    <span class=\"kr\">package</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span><span class=\"p\">;</span>\n    <span class=\"kr\">package</span><span class=\"p\">.</span><span class=\"nx\">description</span> <span class=\"o\">=</span> <span class=\"nx\">description</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">cssPreprocessor</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;less&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"kr\">package</span><span class=\"p\">.</span><span class=\"nx\">devDependencies</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"p\">...</span><span class=\"kr\">package</span><span class=\"p\">.</span><span class=\"nx\">devDependencies</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;less-loader&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;^5.0.0&#34;</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">cssPreprocessor</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;sass&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"kr\">package</span><span class=\"p\">.</span><span class=\"nx\">devDependencies</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"p\">...</span><span class=\"kr\">package</span><span class=\"p\">.</span><span class=\"nx\">devDependencies</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;node-sass&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;^4.12.0&#34;</span><span class=\"p\">,</span>\n        <span class=\"s2\">&#34;sass-loader&#34;</span><span class=\"o\">:</span> <span class=\"s2\">&#34;^7.1.0&#34;</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"kr\">await</span> <span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">writeJson</span><span class=\"p\">(</span><span class=\"nx\">packageJsonPath</span><span class=\"p\">,</span> <span class=\"kr\">package</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">spaces</span><span class=\"o\">:</span> <span class=\"s1\">&#39;\\t&#39;</span> <span class=\"p\">});</span>\n    <span class=\"nx\">packageJsonSpinner</span><span class=\"p\">.</span><span class=\"nx\">stop</span><span class=\"p\">();</span>\n    <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"s1\">&#39;package.json 配置完成&#39;</span><span class=\"p\">)).</span><span class=\"nx\">succeed</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">red</span><span class=\"p\">(</span><span class=\"sb\">`配置文件失败：</span><span class=\"si\">${</span><span class=\"nx\">error</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">)).</span><span class=\"nx\">fail</span><span class=\"p\">();</span>\n      <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">exit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"p\">};</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>安装依赖</h2><p>其实配置文件生成后，CLI 就快接近尾声了。剩下就是安装依赖。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// multi-spa.js\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">InstallDependencies</span><span class=\"p\">(</span><span class=\"nx\">targetDir</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"nx\">installDependenciesSpinner</span> <span class=\"o\">=</span> <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"sb\">`安装依赖中...`</span><span class=\"p\">)).</span><span class=\"nx\">start</span><span class=\"p\">();</span>\n  <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">((</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">shell</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"sb\">`\n</span><span class=\"sb\">    cd </span><span class=\"si\">${</span><span class=\"nx\">targetDir</span><span class=\"si\">}</span><span class=\"sb\">\n</span><span class=\"sb\">    npm i\n</span><span class=\"sb\">    `</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"nx\">installDependenciesSpinner</span><span class=\"p\">.</span><span class=\"nx\">stop</span><span class=\"p\">()</span>\n          <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">red</span><span class=\"p\">(</span><span class=\"sb\">`依赖安装失败：</span><span class=\"si\">${</span><span class=\"nx\">error</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">)).</span><span class=\"nx\">fail</span><span class=\"p\">()</span>\n          <span class=\"nx\">reject</span><span class=\"p\">()</span>\n        <span class=\"p\">}</span>\n        <span class=\"nx\">installDependenciesSpinner</span><span class=\"p\">.</span><span class=\"nx\">stop</span><span class=\"p\">();</span>\n        <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"s1\">&#39;依赖安装完成&#39;</span><span class=\"p\">)).</span><span class=\"nx\">succeed</span><span class=\"p\">();</span>\n        <span class=\"nx\">resolve</span><span class=\"p\">();</span>\n      <span class=\"p\">})</span>\n  <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>小结</h2><p>一个粗糙的CLI，就这么完成了。把以上几个方法包装一下，就是本次 CLI 的全部内容了。</p><ol><li>拷贝脚手架。2. 重新生成配置文件。3安装依赖。</li></ol><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// multi-spa.js\n</span><span class=\"c1\"></span><span class=\"kr\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">GenarateProject</span><span class=\"p\">(</span><span class=\"nx\">targetDir</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kr\">await</span> <span class=\"nx\">DownTemplate</span><span class=\"p\">(</span><span class=\"nx\">targetDir</span><span class=\"p\">);</span>\n  <span class=\"kr\">await</span> <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">all</span><span class=\"p\">([</span><span class=\"nx\">GenaratePackageJson</span><span class=\"p\">(</span><span class=\"nx\">targetDir</span><span class=\"p\">).</span><span class=\"nx\">then</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">InstallDependencies</span><span class=\"p\">(</span><span class=\"nx\">targetDir</span><span class=\"p\">);</span>\n  <span class=\"p\">}),</span>\n  <span class=\"nx\">GenarateWebpackConfig</span><span class=\"p\">(</span><span class=\"nx\">targetDir</span><span class=\"p\">)</span>\n  <span class=\"p\">]);</span>\n  <span class=\"nx\">ora</span><span class=\"p\">(</span><span class=\"nx\">chalk</span><span class=\"p\">.</span><span class=\"nx\">cyan</span><span class=\"p\">(</span><span class=\"s1\">&#39;项目创建成功！&#39;</span><span class=\"p\">)).</span><span class=\"nx\">succeed</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>如果想要发布，需要登陆npm ，<code>npm publish</code>。</p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68345092", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 5, 
            "title": "数据结构的JavaScript描述", 
            "content": "<p>《数据结构与算法JavaScript描述》，有一种花了正版的钱买了盗版的书的感觉。花了点时间整理了一下，可以保证都能跑通。<b>对着截图敲一遍，比复制黏贴效果好</b>。</p><h3>列表</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b9fe9d206b2df303a34c8f584dd9b0a9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"588\" data-rawheight=\"3085\" class=\"origin_image zh-lightbox-thumb\" width=\"588\" data-original=\"https://pic2.zhimg.com/v2-b9fe9d206b2df303a34c8f584dd9b0a9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;588&#39; height=&#39;3085&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"588\" data-rawheight=\"3085\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"588\" data-original=\"https://pic2.zhimg.com/v2-b9fe9d206b2df303a34c8f584dd9b0a9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b9fe9d206b2df303a34c8f584dd9b0a9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>栈</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-255e6fad0a1df9fe578d25e1ce4b0f70_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"1393\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-255e6fad0a1df9fe578d25e1ce4b0f70_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;1393&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"1393\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-255e6fad0a1df9fe578d25e1ce4b0f70_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-255e6fad0a1df9fe578d25e1ce4b0f70_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>队列</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c655621029260be1a7e85494f456b815_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"559\" data-rawheight=\"1501\" class=\"origin_image zh-lightbox-thumb\" width=\"559\" data-original=\"https://pic2.zhimg.com/v2-c655621029260be1a7e85494f456b815_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;559&#39; height=&#39;1501&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"559\" data-rawheight=\"1501\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"559\" data-original=\"https://pic2.zhimg.com/v2-c655621029260be1a7e85494f456b815_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c655621029260be1a7e85494f456b815_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>链表</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b55b9d64adce1c1a745562882f6bc7dc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"2365\" class=\"origin_image zh-lightbox-thumb\" width=\"732\" data-original=\"https://pic1.zhimg.com/v2-b55b9d64adce1c1a745562882f6bc7dc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;732&#39; height=&#39;2365&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"2365\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"732\" data-original=\"https://pic1.zhimg.com/v2-b55b9d64adce1c1a745562882f6bc7dc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b55b9d64adce1c1a745562882f6bc7dc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>字典</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-315ca3361f2c4001a73420afd75fc248_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"1429\" class=\"origin_image zh-lightbox-thumb\" width=\"638\" data-original=\"https://pic1.zhimg.com/v2-315ca3361f2c4001a73420afd75fc248_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;638&#39; height=&#39;1429&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"1429\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"638\" data-original=\"https://pic1.zhimg.com/v2-315ca3361f2c4001a73420afd75fc248_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-315ca3361f2c4001a73420afd75fc248_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>散列</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b4660a6035471da0a8b28c8b5eb71d2b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"622\" data-rawheight=\"2563\" class=\"origin_image zh-lightbox-thumb\" width=\"622\" data-original=\"https://pic4.zhimg.com/v2-b4660a6035471da0a8b28c8b5eb71d2b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;622&#39; height=&#39;2563&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"622\" data-rawheight=\"2563\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"622\" data-original=\"https://pic4.zhimg.com/v2-b4660a6035471da0a8b28c8b5eb71d2b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b4660a6035471da0a8b28c8b5eb71d2b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>集合</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7888110d64dc60e5096d0f7c5024a800_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"850\" data-rawheight=\"2473\" class=\"origin_image zh-lightbox-thumb\" width=\"850\" data-original=\"https://pic1.zhimg.com/v2-7888110d64dc60e5096d0f7c5024a800_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;850&#39; height=&#39;2473&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"850\" data-rawheight=\"2473\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"850\" data-original=\"https://pic1.zhimg.com/v2-7888110d64dc60e5096d0f7c5024a800_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7888110d64dc60e5096d0f7c5024a800_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>二叉查找树</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b7127b2d9cf415ae5730e3cb1faeb71d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"791\" data-rawheight=\"3895\" class=\"origin_image zh-lightbox-thumb\" width=\"791\" data-original=\"https://pic2.zhimg.com/v2-b7127b2d9cf415ae5730e3cb1faeb71d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;791&#39; height=&#39;3895&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"791\" data-rawheight=\"3895\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"791\" data-original=\"https://pic2.zhimg.com/v2-b7127b2d9cf415ae5730e3cb1faeb71d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b7127b2d9cf415ae5730e3cb1faeb71d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>图</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6ca4f9e0cf3166bc5765efbb616bd25a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"749\" data-rawheight=\"1897\" class=\"origin_image zh-lightbox-thumb\" width=\"749\" data-original=\"https://pic3.zhimg.com/v2-6ca4f9e0cf3166bc5765efbb616bd25a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;749&#39; height=&#39;1897&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"749\" data-rawheight=\"1897\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"749\" data-original=\"https://pic3.zhimg.com/v2-6ca4f9e0cf3166bc5765efbb616bd25a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6ca4f9e0cf3166bc5765efbb616bd25a_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }, 
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66349682", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 32, 
            "title": "浅尝webpack", 
            "content": "<h2>吐槽一下</h2><p>webpack 自出现时，一直备受青睐。作为强大的打包工具，它只是出现在项目初始或优化的阶段。如果没有参与项目的构建，接触的机会几乎为零。即使是参与了，但也会因为项目的周期短，从网上东拼西凑草草了事。</p><p>纵观网上的 webpack 教程，要么是蜻蜓点水，科普了一些常规配置项；要么是过于深入原理，于实际操作无益。最近一段时间，我把 webpack 的官方文档来来回回地看了几遍，结果发现，真香。中文版的官方文档，通俗易懂，很感谢翻译组的辛勤奉献。看完之后，虽然达不到炉火纯青的地步，但也不会捉襟见肘，疲于应付。</p><p>对于这种工具类的博文，依然沿袭 <a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/%25E7%2594%25A8Type%25E9%25A9%25AF%25E5%258C%2596JavaScript/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">用Type驯化JavaScript</a> 的风格，串联各个概念。至于细节，就是官方文档的事了。</p><p>本文基于 <i><b>webpack v4.31.0</b></i> 版本。</p><h2>Tapable</h2><blockquote>Tapable 是一个小型的库，允许你对一个 javascript 模块添加和应用插件。它可以被继承或混入到其他模块中。类似于 NodeJS 的 EventEmitter 类，专注于自定义事件的触发和处理。除此之外，Tapable 还允许你通过回调函数的参数，访问事件的“触发者(emittee)”或“提供者(producer)”。</blockquote><p>tapable 是 webpack 的核心，webpack 中的很多对象（compile， compilation等）都扩展自tapable，包括 webpack 也是 tapable 的实例。扩展自 tapable 的对象内部会有很多钩子，它们贯穿了 webpack 构建的整个过程。我们可以利用这些钩子，在其被触发时，做一些我们想做的事情。</p><p>抛开 webpack 不谈，先看看 tapable 的简单使用。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Main.js\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"p\">{</span>\n  <span class=\"nx\">SyncHook</span>\n<span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s2\">&#34;tapable&#34;</span><span class=\"p\">);</span>\n<span class=\"k\">class</span> <span class=\"nx\">Main</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">hooks</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n      <span class=\"nx\">init</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"nx\">SyncHook</span><span class=\"p\">([</span><span class=\"s1\">&#39;init&#39;</span><span class=\"p\">])</span>\n    <span class=\"p\">};</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">plugins</span> <span class=\"o\">=</span> <span class=\"nx\">options</span><span class=\"p\">.</span><span class=\"nx\">plugins</span><span class=\"p\">;</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">init</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">init</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">beforeInit</span><span class=\"p\">();</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">Array</span><span class=\"p\">.</span><span class=\"nx\">isArray</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">plugins</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">plugins</span><span class=\"p\">.</span><span class=\"nx\">forEach</span><span class=\"p\">(</span><span class=\"nx\">plugin</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"nx\">plugin</span><span class=\"p\">.</span><span class=\"nx\">apply</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">);</span>\n      <span class=\"p\">})</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">hooks</span><span class=\"p\">.</span><span class=\"nx\">init</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"s1\">&#39;初始化中。。。&#39;</span><span class=\"p\">);</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">afterInit</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">beforeInit</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;初始化前。。。&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">afterInit</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;初始化后。。。&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"nx\">Main</span><span class=\"p\">;</span>\n<span class=\"c1\">// MyPlugin.js\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">MyPlugin</span> <span class=\"p\">{</span>\n  <span class=\"nx\">apply</span><span class=\"p\">(</span><span class=\"nx\">main</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">main</span><span class=\"p\">.</span><span class=\"nx\">hooks</span><span class=\"p\">.</span><span class=\"nx\">init</span><span class=\"p\">.</span><span class=\"nx\">tap</span><span class=\"p\">(</span><span class=\"s1\">&#39;MyPlugin&#39;</span><span class=\"p\">,</span> <span class=\"nx\">param</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;init 钩子，做些啥；&#39;</span><span class=\"p\">,</span> <span class=\"nx\">param</span><span class=\"p\">);</span>\n    <span class=\"p\">});</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"nx\">MyPlugin</span><span class=\"p\">;</span>\n<span class=\"c1\">// index.js\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">Main</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;./Main&#39;</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">MyPlugin</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;./MyPlugin&#39;</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span> <span class=\"nx\">myPlugin</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">MyPlugin</span><span class=\"p\">();</span>\n<span class=\"k\">new</span> <span class=\"nx\">Main</span><span class=\"p\">({</span> <span class=\"nx\">plugins</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"nx\">myPlugin</span><span class=\"p\">]</span> <span class=\"p\">});</span>\n\n<span class=\"c1\">// 初始化前。。。\n</span><span class=\"c1\">// init 钩子，做些啥; 初始化中。。。\n</span><span class=\"c1\">// 初始化后。。。\n</span></code></pre></div><p>理解起来很简单，就是在 <code>init</code> 处触发钩子，<code>this.hooks.init.call(params)</code> 类似于我们熟悉的 <code>EventEmitter.emit(&#39;init&#39;, params)</code>。<code>main.hooks.init.tap</code> 类似于 <code>EventEmitter.on(&#39;init&#39;, callback)</code>，在 <code>init</code>钩子上绑定一些我们想做的事情。在后面将要说的 webpack 自定义插件，就是在 webpack 中的某个钩子处，插入自定义的事。</p><h2>理清概念</h2><ul><li><b>依赖图</b> 在单页面应用中，只要有一个入口文件，就可以把散落在项目下的各个文件整合到一起。何谓依赖，当前文件需要什么，什么就是当前文件的依赖。依赖引入的形式有如下：<br/></li><ul><li>ES2015 <code>import</code> 语句</li><li>CommonJS <code>require()</code> 语句</li><li>AMD <code>define</code> 和 <code>require</code> 语句</li><li>样式(<code>url(...)</code>)或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接</li></ul><li><b>入口(entry)</b> 入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图（dependency graph）的开始。</li><li><b>输出(output)</b> output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</li><li><b>模块(module)</b> 决定了如何处理项目中的不同类型的模块。比如设置 loader，处理各种模块。设置 noParse，忽略无需 webpack 解析的模块。</li><li><b>解析(resolve)</b> 设置模块如何被解析。引用依赖时，需要知道依赖间的路径关系，应遵循何种解析规则。比如给路径设置别名（alias），解析模块的搜索目录（modules），解析 loader 包路径（resolveLoader）等。</li><li><b>外部扩展(externals)</b> 防止将某些 import 的包（package）打包到 bundle 中，而是在运行时（runtime）再去从外部获取这些扩展依赖。比如说，项目中引用了 jQuery 的CDN资源，在使用 <code>import $ from &#39;jquery&#39;;</code>时，webpack 会把 jQuery 打包进 bundle，其实这是没有必要的，此时需要配置 <code>externals: {jquery: &#39;jQuery&#39;}</code>，将其剔除 bundle。</li><li><b>插件(plugins)</b> 用于以各种方式自定义 webpack 构建过程。可以利用 webpack 中的钩子，做些优化或者搞些小动作。</li><li><b>开发设置(devServer)</b> 顾名思义，就是开发时用到的选项。比如，开发服务根路径（contentBase），模块热替换（hot，需配合 <code>HotModuleReplacementPlugin</code> 使用），代理（proxy）等。</li><li><b>模式(mode)</b> 提供 mode 配置选项，告知 webpack 使用相应环境的内置优化。具体可见 <a href=\"https://link.zhihu.com/?target=https%3A//webpack.docschina.org/concepts/mode/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">模式(mode)</a></li><li><b>优化(optimization)</b> 从 webpack 4 开始，会根据你选择的 mode 来执行不同的优化，不过所有的优化还是可以手动配置和重写。比如，<code>CommonsChunkPlugin</code>被 <code>optimization.splitChunks</code> 取代。</li></ul><p>webpack 差不多就是这几个配置项，搞清楚这几个概念，上手还是比较容易的。</p><h2>代码分离</h2><p>现在的前端项目越来越复杂，如果最终导出为一个 bundle，会极大地影响加载速度。切割 bundle，控制资源加载优先级，按需加载或并行加载，合理应用就会大大缩短加载时间。官方文档提供了三种常见的代码分离方法：</p><ul><li><b>入口起点</b> 配置多个入口文件，然后将最终生成的过个 bundle 出入到 HTML 中。不过如果这两个文件中存在相同的模块，这就意味着相同的模块被加载了两次。此时，我们就需要提取出重复的模块。</li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// webpack.config.js \n</span><span class=\"c1\"></span><span class=\"nx\">entry</span><span class=\"o\">:</span> <span class=\"p\">{</span>     <span class=\"nx\">index</span><span class=\"o\">:</span> <span class=\"s1\">&#39;./src/index.js&#39;</span><span class=\"p\">,</span>     <span class=\"nx\">vendor</span><span class=\"o\">:</span> <span class=\"s1\">&#39;./src/vendor.js&#39;</span> <span class=\"p\">}</span>\n<span class=\"nx\">output</span><span class=\"o\">:</span> <span class=\"p\">{</span>     <span class=\"nx\">filename</span><span class=\"o\">:</span> <span class=\"s1\">&#39;[name].bundle.js&#39;</span><span class=\"p\">,</span> <span class=\"p\">},</span>\n<span class=\"nx\">plugins</span><span class=\"o\">:</span> <span class=\"p\">[</span> <span class=\"k\">new</span> <span class=\"nx\">HtmlWebpackPlugin</span><span class=\"p\">({</span>     <span class=\"nx\">chunks</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"s1\">&#39;vendor&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;index&#39;</span><span class=\"p\">]</span> <span class=\"p\">})</span> <span class=\"p\">]</span>\n</code></pre></div><ul><li><b>防止重复</b> 在 webpack 老的版本中，<code>CommonsChunkPlugin</code> 常用来提取公共的模块。新版本中 <code>SplitChunksPlugin</code> 取而代之，可以通过 <code>optimization.splitChunks</code> 设置，多见于多页面应用。</li><li><b>动态导入</b> 就是在需要时再去加载模块，而不是一股脑的全部加载。webpack 还提供了预取和预加载的方式。非入口 chunk，我们可以通过 chunkFilename 为其命名。常见的如，vue 路由动态导入。</li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// webpack.config.js \n</span><span class=\"c1\"></span><span class=\"nx\">output</span><span class=\"o\">:</span> <span class=\"p\">{</span>   <span class=\"nx\">chunkFilename</span><span class=\"o\">:</span> <span class=\"s1\">&#39;[name].bundle.js&#39;</span><span class=\"p\">,</span> <span class=\"p\">}</span> \n<span class=\"c1\">// index.js \n</span><span class=\"c1\"></span><span class=\"k\">import</span><span class=\"p\">(</span><span class=\"cm\">/* webpackChunkName: &#34;someJs&#34; */</span> <span class=\"s1\">&#39;someJs&#39;</span><span class=\"p\">);</span> \n<span class=\"k\">import</span><span class=\"p\">(</span><span class=\"cm\">/* webpackPrefetch: true */</span> <span class=\"s1\">&#39;someJs&#39;</span><span class=\"p\">);</span> \n<span class=\"k\">import</span><span class=\"p\">(</span><span class=\"cm\">/* webpackPreload: true */</span> <span class=\"s1\">&#39;someJs&#39;</span><span class=\"p\">);</span>\n</code></pre></div><h2>缓存</h2><p>基于浏览器的缓存策略，我们知道如果本地缓存命中，则无需再次请求资源。对于改动不频繁或基本不会再做改动的模块，可以剥离出来。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// webpack.config.js\n</span><span class=\"c1\"></span>  <span class=\"nx\">output</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">filename</span><span class=\"o\">:</span> <span class=\"s1\">&#39;[name].[contenthash].js&#39;</span><span class=\"p\">,</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>按照我们的想法，只要模块的内容没有变化，对应的名字也就不会发生变化，这样缓存就会起作用了。事实上并非如此，webpack 打包后的文件，并非只有用户自己的代码，还包括管理用户代码的代码，如 runtime 和 manifest。</p><p>模块依赖间的整合并不是简单的代码拼接，其中包括模块的加载和解析逻辑。注入的 runtime 和 manifest 在每次构建后都会发生变化。这就导致了即使用户代码没有变化，某些 hash 还是发生了改变。通过 <code>optimization.runtimeChunk</code> 提取 runtime 代码。通过 <code>optimization.splitChunks</code> 剥离第三方库。比如， react，react-dom。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"c1\">//...\n</span><span class=\"c1\"></span>  <span class=\"nx\">optimization</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n  <span class=\"nx\">runtimeChunk</span><span class=\"o\">:</span> <span class=\"s1\">&#39;single&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">splitChunks</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">cacheGroups</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">vendor</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n          <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/</span><span class=\"p\">,</span>\n          <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;vendor&#39;</span><span class=\"p\">,</span>\n          <span class=\"nx\">chunks</span><span class=\"o\">:</span> <span class=\"s1\">&#39;all&#39;</span><span class=\"p\">,</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>最后使用 <code>HashedModuleIdsPlugin</code> 来消除因模块 ID 变动带来的影响。</p><h2>loader</h2><p>loader 用于对模块的源代码进行转换。loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 loader API，并通过 this 上下文访问。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// loader API;\n</span><span class=\"c1\"></span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">callback</span><span class=\"p\">(</span>\n  <span class=\"nx\">err</span><span class=\"o\">:</span> <span class=\"nb\">Error</span> <span class=\"o\">|</span> <span class=\"kc\">null</span><span class=\"p\">,</span>\n  <span class=\"nx\">content</span><span class=\"o\">:</span> <span class=\"nx\">string</span> <span class=\"o\">|</span> <span class=\"nx\">Buffer</span><span class=\"p\">,</span>\n  <span class=\"nx\">sourceMap</span><span class=\"o\">?:</span> <span class=\"nx\">SourceMap</span><span class=\"p\">,</span>\n  <span class=\"nx\">meta</span><span class=\"o\">?:</span> <span class=\"nx\">any</span>\n<span class=\"p\">);</span>\n<span class=\"c1\">// sync loader\n</span><span class=\"c1\"></span><span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">content</span><span class=\"p\">,</span> <span class=\"nx\">map</span><span class=\"p\">,</span> <span class=\"nx\">meta</span><span class=\"p\">){</span>\n  <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">callback</span><span class=\"p\">(</span><span class=\"kc\">null</span><span class=\"p\">,</span> <span class=\"nx\">syncOperation</span><span class=\"p\">(</span><span class=\"nx\">content</span><span class=\"p\">,</span> <span class=\"nx\">map</span><span class=\"p\">,</span> <span class=\"nx\">meta</span><span class=\"p\">));</span>\n  <span class=\"k\">return</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// async loader\n</span><span class=\"c1\"></span><span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">content</span><span class=\"p\">,</span> <span class=\"nx\">map</span><span class=\"p\">,</span> <span class=\"nx\">meta</span><span class=\"p\">){</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">callback</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"kr\">async</span><span class=\"p\">();</span>\n  <span class=\"nx\">asyncOperation</span><span class=\"p\">(</span><span class=\"nx\">content</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">,</span> <span class=\"nx\">result</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"nx\">callback</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>\n    <span class=\"nx\">callback</span><span class=\"p\">(</span><span class=\"kc\">null</span><span class=\"p\">,</span> <span class=\"nx\">result</span><span class=\"p\">,</span> <span class=\"nx\">map</span><span class=\"p\">,</span> <span class=\"nx\">meta</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span><span class=\"p\">;</span>\n  <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>多个 loader 串行时，在从右向左执行 loader 之前，会向从左到右调用 loader 上的 pitch 方法。如果在 pitch 中返回了结果，则会跳过后续 loader。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"o\">|-</span> <span class=\"nx\">a</span><span class=\"o\">-</span><span class=\"nx\">loader</span> <span class=\"sb\">`pitch`</span>\n  <span class=\"o\">|-</span> <span class=\"nx\">b</span><span class=\"o\">-</span><span class=\"nx\">loader</span> <span class=\"sb\">`pitch`</span>\n    <span class=\"o\">|-</span> <span class=\"nx\">c</span><span class=\"o\">-</span><span class=\"nx\">loader</span> <span class=\"sb\">`pitch`</span>\n      <span class=\"o\">|-</span> <span class=\"nx\">requested</span> <span class=\"nx\">module</span> <span class=\"nx\">is</span> <span class=\"nx\">picked</span> <span class=\"nx\">up</span> <span class=\"nx\">as</span> <span class=\"nx\">a</span> <span class=\"nx\">dependency</span>\n    <span class=\"o\">|-</span> <span class=\"nx\">c</span><span class=\"o\">-</span><span class=\"nx\">loader</span> <span class=\"nx\">normal</span> <span class=\"nx\">execution</span>\n  <span class=\"o\">|-</span> <span class=\"nx\">b</span><span class=\"o\">-</span><span class=\"nx\">loader</span> <span class=\"nx\">normal</span> <span class=\"nx\">execution</span>\n<span class=\"o\">|-</span> <span class=\"nx\">a</span><span class=\"o\">-</span><span class=\"nx\">loader</span> <span class=\"nx\">normal</span> <span class=\"nx\">execution</span>\n\n<span class=\"c\">&lt;!--</span> <span class=\"nx\">pitch</span> <span class=\"nx\">中返回结果</span> <span class=\"o\">--&gt;</span>\n\n<span class=\"o\">|-</span> <span class=\"nx\">a</span><span class=\"o\">-</span><span class=\"nx\">loader</span> <span class=\"sb\">`pitch`</span>\n  <span class=\"o\">|-</span> <span class=\"nx\">b</span><span class=\"o\">-</span><span class=\"nx\">loader</span> <span class=\"sb\">`pitch`</span> <span class=\"nx\">returns</span> <span class=\"nx\">a</span> <span class=\"nx\">module</span>\n<span class=\"o\">|-</span> <span class=\"nx\">a</span><span class=\"o\">-</span><span class=\"nx\">loader</span> <span class=\"nx\">normal</span> <span class=\"nx\">execution</span>\n</code></pre></div><h2>plugins</h2><p>webpack 的自定义插件和本文开头 Tapable 中的差不多。webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。钩子有同步的，也有异步的，这需要根据 webpack 提供的 API 文档。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 官方例子\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">FileListPlugin</span> <span class=\"p\">{</span>\n  <span class=\"nx\">apply</span><span class=\"p\">(</span><span class=\"nx\">compiler</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// emit 是异步 hook，使用 tapAsync 触及它，还可以使用 tapPromise/tap(同步)\n</span><span class=\"c1\"></span>    <span class=\"nx\">compiler</span><span class=\"p\">.</span><span class=\"nx\">hooks</span><span class=\"p\">.</span><span class=\"nx\">emit</span><span class=\"p\">.</span><span class=\"nx\">tapAsync</span><span class=\"p\">(</span><span class=\"s1\">&#39;FileListPlugin&#39;</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">compilation</span><span class=\"p\">,</span> <span class=\"nx\">callback</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 在生成文件中，创建一个头部字符串：\n</span><span class=\"c1\"></span>      <span class=\"kd\">var</span> <span class=\"nx\">filelist</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;In this build:\\n\\n&#39;</span><span class=\"p\">;</span>\n      <span class=\"c1\">// 遍历所有编译过的资源文件，\n</span><span class=\"c1\"></span>      <span class=\"c1\">// 对于每个文件名称，都添加一行内容。\n</span><span class=\"c1\"></span>      <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">var</span> <span class=\"nx\">filename</span> <span class=\"k\">in</span> <span class=\"nx\">compilation</span><span class=\"p\">.</span><span class=\"nx\">assets</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">filelist</span> <span class=\"o\">+=</span> <span class=\"s1\">&#39;- &#39;</span> <span class=\"o\">+</span> <span class=\"nx\">filename</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;\\n&#39;</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n      <span class=\"c1\">// 将这个列表作为一个新的文件资源，插入到 webpack 构建中：\n</span><span class=\"c1\"></span>      <span class=\"nx\">compilation</span><span class=\"p\">.</span><span class=\"nx\">assets</span><span class=\"p\">[</span><span class=\"s1\">&#39;filelist.md&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"nx\">source</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n          <span class=\"k\">return</span> <span class=\"nx\">filelist</span><span class=\"p\">;</span>\n        <span class=\"p\">},</span>\n        <span class=\"nx\">size</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n          <span class=\"k\">return</span> <span class=\"nx\">filelist</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">};</span>\n      <span class=\"nx\">callback</span><span class=\"p\">();</span>\n    <span class=\"p\">});</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"nx\">FileListPlugin</span><span class=\"p\">;</span>\n</code></pre></div><ul><li>ProvidePlugin 自动加载模块，无需处处引用。有点类似 <code>expose-loader</code>。   </li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// webpack.config.js \n</span><span class=\"c1\"></span><span class=\"k\">new</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">ProvidePlugin</span><span class=\"p\">({</span>   <span class=\"nx\">$</span><span class=\"o\">:</span> <span class=\"s1\">&#39;jquery&#39;</span><span class=\"p\">,</span> <span class=\"p\">})</span> \n<span class=\"c1\">// some.js \n</span><span class=\"c1\"></span><span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"s1\">&#39;#item&#39;</span><span class=\"p\">);</span>\n</code></pre></div><ul><li>DllPlugin 将基础模块打包进动态链接库，当依赖的模块存在于动态链接库中时，无需再次打包，而是直接从动态链接库中获取。DLLPlugin 负责打包出动态链接库，DllReferencePlugin 负责从主要配置文件中引入 DllPlugin 插件打包好的动态链接库文件。<br/></li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// webpack-dll-config.js \n</span><span class=\"c1\">// 先执行该配置文件 \n</span><span class=\"c1\"></span><span class=\"nx\">output</span><span class=\"o\">:</span> <span class=\"p\">{</span>   <span class=\"nx\">path</span><span class=\"o\">:</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"s2\">&#34;dist&#34;</span><span class=\"p\">),</span>   \n<span class=\"nx\">filename</span><span class=\"o\">:</span> <span class=\"s2\">&#34;MyDll.[name].js&#34;</span><span class=\"p\">,</span>   <span class=\"nx\">library</span><span class=\"o\">:</span> <span class=\"s2\">&#34;[name]_[hash]&#34;</span> <span class=\"p\">},</span> \n<span class=\"nx\">plugins</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"k\">new</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">DllPlugin</span><span class=\"p\">({</span><span class=\"nx\">path</span><span class=\"o\">:</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"s2\">&#34;dist&#34;</span><span class=\"p\">,</span> <span class=\"s2\">&#34;[name]-manifest.json&#34;</span><span class=\"p\">),</span> <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s2\">&#34;[name]_[hash]&#34;</span><span class=\"p\">})]</span> \n<span class=\"c1\">// webpack-config.js \n</span><span class=\"c1\">// 后执行该配置文件 \n</span><span class=\"c1\"></span><span class=\"nx\">plugins</span><span class=\"o\">:</span> <span class=\"p\">[</span>   <span class=\"k\">new</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">DllReferencePlugin</span><span class=\"p\">({</span>     <span class=\"nx\">manifest</span><span class=\"o\">:</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s2\">&#34;../dll/dist/alpha-manifest.json&#34;</span><span class=\"p\">)</span>   <span class=\"p\">}),</span> <span class=\"p\">]</span>\n</code></pre></div><ul><li>HappyPack 启动子进程处理任务，充分利用资源。不过进程间的通讯比较耗资源，要酌情处理。<br/></li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">HappyPack</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;happypack&#39;</span><span class=\"p\">);</span> \n<span class=\"c1\">// loader \n</span><span class=\"c1\"></span><span class=\"p\">{</span>   <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/\\.js$/</span><span class=\"p\">,</span>   <span class=\"nx\">use</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"s1\">&#39;happypack/loader?id=babel&#39;</span><span class=\"p\">],</span>   <span class=\"nx\">exclude</span><span class=\"o\">:</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;node_modules&#39;</span><span class=\"p\">),</span> <span class=\"p\">},</span> \n<span class=\"c1\">// plugins \n</span><span class=\"c1\"></span><span class=\"k\">new</span> <span class=\"nx\">HappyPack</span><span class=\"p\">({</span>   <span class=\"nx\">id</span><span class=\"o\">:</span> <span class=\"s1\">&#39;babel&#39;</span><span class=\"p\">,</span>   <span class=\"nx\">loaders</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"s1\">&#39;babel-loader?cacheDirectory&#39;</span><span class=\"p\">],</span> <span class=\"p\">}),</span>\n</code></pre></div><ul><li>webpack-bundle-analyzer<br/>webpack 打包后的分析工具。</li></ul><p>webpack 告一段落，浅尝辄止。</p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }, 
                {
                    "tag": "webpack", 
                    "tagLink": "https://api.zhihu.com/topics/20032877"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>emmm.....感觉是不是研究的太深了</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "可能吧，知道的越多越好，不要怕[机智]", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "林志鹏", 
                    "userLink": "https://www.zhihu.com/people/4324e37aac091e55f1054d596b41bce6", 
                    "content": "看到tapable决定收藏一下，重要的点基本都提到了，美中不足就是还是写的太简略。期待出系列文章 <a class=\"comment_sticker\" href=\"https://pic4.zhimg.com/v2-db92f653a2ec17ea3ff309d6d56e8507.gif\" data-sticker-id=\"980770591112015872\"> [吃瓜]</a>", 
                    "likes": 2, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "写得再细就成官方文档了，强烈推荐看一波官方文档[机智]", 
                            "likes": 0, 
                            "replyToAuthor": "林志鹏"
                        }, 
                        {
                            "userName": "林志鹏", 
                            "userLink": "https://www.zhihu.com/people/4324e37aac091e55f1054d596b41bce6", 
                            "content": "官方文档我都翻烂了，好多东西是没有的，只能找各种插件看源码这样子才能维持的了生活这样子", 
                            "likes": 0, 
                            "replyToAuthor": "曉宸"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "这么复杂还简单？没有听错吧", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "是不简单，所以才浅尝啊。万事无他，唯手熟尔。多看文档就好了[看看你]", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65270400", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 0, 
            "title": "循序渐进之异步编程（三）", 
            "content": "<h2>回顾</h2><p>所谓的异步，就是程序的一部分现在进行，而另一部分则在将来运行。异步处理的重点就是如何处理将来运行的那一部分。</p><p>回调是 <b>JavaScript</b> 中最基本的异步模式，就是事先约定好将来要做的事然后回头调用。简单直接，但也存在不信任、调用嵌套过深等问题。对于编写代码、维护代码的我们而言，人类的大脑还是习惯于线性的处理方式。</p><p>基于回调的异步模式所存在的问题促使着我们寻求一种机制来保证回调的可信任，同时能更好的表达异步。这时候 <b>Promise</b> 出现了，<b>Promise</b> 的出现，并非要取代回调。而是把回调转交给了一个位于我们和其它工具之间的可信任的中介机制。<b>Promise</b> 链也提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步 <b>JavaScript</b> 代码。</p><h2>生成器</h2><blockquote><b>Promise</b> 虽然有序、可靠地管理回调，但是我们还是希望如同步般表达异步。</blockquote><p>我们已经知道生成器是作为生产迭代器的工厂函数，同时我们还要知道生成器也是一个消息传递系统。</p><h3>为什么是生成器</h3><p>在生成器出现之前，程序代码一旦执行，就没有停下来的时候，直到程序结束🔚。然而在生成器里代码是可以暂停的，而且还可以和生成器之外通信☎️，通信结束后又可以恢复执行。回想一下之前的异步流程控制，我们一直在想方设法使得异步任务能够同步表达。现在，我们可以借助生成器来实现这一想法💡。</p><p>了解了生成器的特性之后，我们就应该知道，当生成器在执行一个异步任务时，完全可以把异步任务放在生成器外部执行，待异步任务执行结束后再返回🔙生成器恢复执行。要知道，生成器暂停的只是内部的状态，程序的其余部分还是正常运行的。这样的话，生成器内部的所有代码看起来都是同步表达了。</p><p>同时我们也要注意到，生成器不过是一种新🆕的表达方式，和异步还是同步没有半毛钱💰关系。既然没有关系，那在异步模式选择上就更无所谓了。考虑到异步系列文章是渐进式的，所以我们就用 <code>Promise + 生成器</code> 模式来表达异步。</p><h3>生成器与Promise的结合</h3><p>在异步流程控制方面，生成器是由两部分组成的。一部分是生成器内部代码以同步的方式表达任务，另一部分是由生成器生成的迭代器处理异步。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"kr\">async</span> <span class=\"o\">=</span> <span class=\"nx\">n</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">(</span><span class=\"nx\">resolve</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"nx\">setTimeout</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n            <span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"sb\">`第</span><span class=\"si\">${</span><span class=\"nx\">n</span><span class=\"si\">}</span><span class=\"sb\">个异步任务`</span><span class=\"p\">)</span>\n        <span class=\"p\">},</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"p\">})</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">generator</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"o\">*</span><span class=\"nx\">generator</span><span class=\"p\">(){</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response_1</span> <span class=\"o\">=</span> <span class=\"k\">yield</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response_2</span> <span class=\"o\">=</span> <span class=\"k\">yield</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response_3</span> <span class=\"o\">=</span> <span class=\"k\">yield</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;response_1: %s;response_2: %s;response_3: %s;&#39;</span><span class=\"p\">,</span><span class=\"nx\">response_1</span><span class=\"p\">,</span><span class=\"nx\">response_2</span><span class=\"p\">,</span><span class=\"nx\">response_3</span><span class=\"p\">);</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">gen</span> <span class=\"o\">=</span> <span class=\"nx\">generator</span><span class=\"p\">();</span>\n<span class=\"k\">const</span> <span class=\"nx\">gen_1</span> <span class=\"o\">=</span> <span class=\"nx\">generator</span><span class=\"p\">();</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;gen_next_1: %s; gen_next_2: %s; gen_next_3: %s;&#39;</span><span class=\"p\">,</span> <span class=\"nx\">gen_1</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">().</span><span class=\"nx\">value</span><span class=\"p\">,</span> <span class=\"nx\">gen_1</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">().</span><span class=\"nx\">value</span><span class=\"p\">,</span> <span class=\"nx\">gen_1</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">().</span><span class=\"nx\">value</span><span class=\"p\">);</span>\n<span class=\"nx\">gen</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">().</span><span class=\"nx\">value</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">yield_1</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;yield_1: %s;&#39;</span><span class=\"p\">,</span> <span class=\"nx\">yield_1</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"nx\">gen</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">(</span><span class=\"nx\">yield_1</span><span class=\"p\">).</span><span class=\"nx\">value</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">yield_2</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;yield_2: %s;&#39;</span><span class=\"p\">,</span> <span class=\"nx\">yield_2</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nx\">gen</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">(</span><span class=\"nx\">yield_2</span><span class=\"p\">).</span><span class=\"nx\">value</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">yield_3</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n            <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;yield_3: %s&#39;</span><span class=\"p\">,</span> <span class=\"nx\">yield_3</span><span class=\"p\">);</span>\n            <span class=\"k\">return</span> <span class=\"nx\">gen</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">(</span><span class=\"nx\">yield_3</span><span class=\"p\">);</span>\n        <span class=\"p\">})</span>\n    <span class=\"p\">})</span>\n<span class=\"p\">});</span>\n\n<span class=\"c1\">// gen_next_1: [object Promise]; gen_next_2: [object Promise]; gen_next_3: [object Promise];\n</span><span class=\"c1\">// yield_1: 第1个异步任务;\n</span><span class=\"c1\">// yield_2: 第2个异步任务;\n</span><span class=\"c1\">// yield_3: 第3个异步任务\n</span><span class=\"c1\">// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;\n</span></code></pre></div><p>如果只看 <b>generator</b> 函数这块，函数内部的写法和同步无异。<b>gen</b> 和 <b>gen_1</b> 都是同一生成器的实例。</p><p>如前文所述，理解这块代码还是要从两方面入手 ———— 迭代和消息传递。迭代属性在此不再赘述，现在重点是消息传递的属性。在生成器中，生成器函数被调用后并未立即执行，而是构造了一个迭代器。而生成器正是靠着 <code>yield/next</code> 来完成生成器内外部的双向通信。</p><p>在生成器内部，<b>yield</b> 是用来暂停（完全保持其状态）和向外部传递数据的关键字/表达式（初始时函数也是处于未执行状态）。在生成器外部，next 具有恢复生成器和向生成器内部传递数据的能力。</p><p>混沌初始（<code>gen</code> 造出来了），盘古开天辟地（第一个 <code>next()</code> 执行），天地初成，继女娲造人后，一切欣欣向荣。共工和祝融两个调皮蛋撞坏了不周山，给女娲出了一个难题（<code>yield</code>），华夏史驻此不前。女娲向上天求助（<code>yield async(1)</code>），上天回应了并送来了五彩石（<code>yield_1</code>）,女娲顺利补天，华夏史再次启程（<code>next(yield_1)</code>）。</p><p>然而好景不长，华夏部落经常受到蚩尤部落骚扰侵犯，蚩尤的存在再次阻碍了华夏史的前行（<code>yield</code>）。黄帝无奈向其师求助（<code>yield async(2)</code>），九天玄女授其兵法（<code>yield_2</code>）,黄帝顺利杀蚩尤，华夏史再次启程（<code>next(yield_2)</code>）。</p><p>然而好景不长，中原地带洪水泛滥，华夏史再次受阻（<code>yield</code>）。夏禹无奈向太上老君求助（<code>yield async(3)</code>）,太上老君赠其神铁（<code>yield_3</code>）,夏禹顺利治水，华夏史再次启程（<code>next (yield_3)</code>）。</p><p>实在编不下去了，还好结束了。😓 代码运行过程大抵如此。生成器内部生成一个数据，然后抛给迭代器消费，迭代器又把执行结果甩给了生成器。就是这么简单，别想的太复杂就行。</p><p>所谓的消息双向传递，指的不仅仅是正常情况下生成器内外部的数据。对于异常错误，生成器内外部也可以双向捕捉。因为生成器内部的暂停，是保留了其上下文的，所以 <code>try...catch</code> 又可以一展身手了。</p><h2>生成器自执行 &amp; async/await</h2><p><code>Promise + 生成器</code> 来表达异步算是实现了，然而我们也应该注意到在用迭代器控制生成器的那部分太过繁琐。 如果能够封装下就好了， 如下：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">generator_wrap</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">generator</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"nx\">args</span> <span class=\"o\">=</span> <span class=\"p\">[...</span><span class=\"nx\">arguments</span><span class=\"p\">].</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">gen</span> <span class=\"o\">=</span> <span class=\"nx\">generator</span><span class=\"p\">.</span><span class=\"nx\">apply</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"nx\">args</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">((</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"k\">const</span> <span class=\"nx\">handleNext</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"nx\">handleNext</span><span class=\"p\">(</span><span class=\"k\">yield</span><span class=\"p\">){</span>\n            <span class=\"kd\">let</span> <span class=\"nx\">next</span><span class=\"p\">;</span>\n            <span class=\"k\">try</span> <span class=\"p\">{</span>\n                <span class=\"nx\">next</span> <span class=\"o\">=</span> <span class=\"nx\">gen</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">(</span><span class=\"k\">yield</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"nx\">reject</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">next</span><span class=\"p\">.</span><span class=\"nx\">done</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">next</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">next</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">).</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"k\">yield</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n                    <span class=\"nx\">handleNext</span><span class=\"p\">(</span><span class=\"k\">yield</span><span class=\"p\">);</span>\n                <span class=\"p\">},</span> <span class=\"nx\">error</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n                    <span class=\"nx\">gen</span><span class=\"p\">.</span><span class=\"k\">throw</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>\n                <span class=\"p\">})</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">};</span>\n        <span class=\"nx\">handleNext</span><span class=\"p\">();</span>\n    <span class=\"p\">})</span>\n<span class=\"p\">};</span>\n<span class=\"c1\">// ———————————— 手动分割线 ————————————\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">generator</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"o\">*</span><span class=\"nx\">generator</span><span class=\"p\">(){</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response_1</span> <span class=\"o\">=</span> <span class=\"k\">yield</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response_2</span> <span class=\"o\">=</span> <span class=\"k\">yield</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response_3</span> <span class=\"o\">=</span> <span class=\"k\">yield</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;response_1: %s;response_2: %s;response_3: %s;&#39;</span><span class=\"p\">,</span><span class=\"nx\">response_1</span><span class=\"p\">,</span><span class=\"nx\">response_2</span><span class=\"p\">,</span><span class=\"nx\">response_3</span><span class=\"p\">);</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">generator_wrap</span><span class=\"p\">(</span><span class=\"nx\">generator</span><span class=\"p\">);</span>\n<span class=\"c1\">// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;\n</span></code></pre></div><p>不看 <b>generator_wrap</b> 函数，只看分割线以下的部分。至此，异步流程的表达越来越接近理想中的模样了。但 <b>generator_wrap</b> 函数还是需要自己手动封装，不过现在不用啦😄</p><p><b>ES2017</b> 推出了 <code>async/await</code> ，我们不用再自己去管理生成器，简单、强大、方便的 <code>async/await</code> 为我们处理了一切。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">awati_async</span> <span class=\"o\">=</span> <span class=\"kr\">async</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response_1</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response_2</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"k\">const</span> <span class=\"nx\">response_3</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;response_1: %s;response_2: %s;response_3: %s;&#39;</span><span class=\"p\">,</span> <span class=\"nx\">response_1</span><span class=\"p\">,</span> <span class=\"nx\">response_2</span><span class=\"p\">,</span> <span class=\"nx\">response_3</span><span class=\"p\">);</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">awati_async</span><span class=\"p\">();</span>\n<span class=\"c1\">// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;\n</span></code></pre></div><p>至此，关于 JavaScript 的异步表达暂时告一段落了👋。</p><p>参考资料：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">迭代器和生成器</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.kancloud.cn/kancloud/you-dont-know-js-async-performance\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">你不知道的 JavaScript （中卷）</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.kancloud.cn/kancloud/you-dont-know-js-es6-beyond\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">你不知道的 JavaScript （下卷）</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/%23docs/generator-async\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Generator 函数的异步应用</a></p>", 
            "topic": [
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64315406", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 5, 
            "title": "从迭代器模式到迭代协议", 
            "content": "<h2>迭代器模式</h2><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。</p><p>迭代器分为内部迭代器和外部迭代器。内部迭代器只需一次初始调用，而外部迭代器必须显式地请求迭代下一个元素，这样我们就可以手动控制迭代过程。</p><p>实现一个内部迭代器：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nb\">Array</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">innerIterator</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">callback</span><span class=\"p\">){</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">len</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">len</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">callback</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">callback</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">],</span> <span class=\"k\">this</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">],</span> <span class=\"nx\">i</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">].</span><span class=\"nx\">innerIterator</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">,</span> <span class=\"nx\">index</span><span class=\"p\">){</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;item:&#39;</span><span class=\"p\">,</span> <span class=\"nx\">item</span><span class=\"p\">,</span> <span class=\"s1\">&#39;index:&#39;</span><span class=\"p\">,</span> <span class=\"nx\">index</span><span class=\"p\">)</span>\n<span class=\"p\">})</span>\n<span class=\"c1\">// item: 1 index: 0\n</span><span class=\"c1\">// item: 2 index: 1\n</span><span class=\"c1\">// item: 3 index: 2\n</span></code></pre></div><p>实现一个外部迭代器：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nb\">Array</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">outerInterator</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">index</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"p\">{</span>\n            <span class=\"nx\">next</span><span class=\"o\">:</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"nx\">index</span> <span class=\"o\">&lt;</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">?</span>\n                <span class=\"p\">{</span><span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"k\">this</span><span class=\"p\">[</span><span class=\"nx\">index</span><span class=\"o\">++</span><span class=\"p\">],</span> <span class=\"nx\">done</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">}</span><span class=\"o\">:</span>\n                <span class=\"p\">{</span><span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"kc\">undefined</span><span class=\"p\">,</span> <span class=\"nx\">done</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">iterator</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">].</span><span class=\"nx\">outerInterator</span><span class=\"p\">();</span>\n\n<span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">next</span><span class=\"p\">;</span> <span class=\"p\">(</span><span class=\"nx\">next</span> <span class=\"o\">=</span> <span class=\"nx\">iterator</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">())</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"nx\">next</span><span class=\"p\">.</span><span class=\"nx\">done</span><span class=\"p\">;)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;item&#39;</span><span class=\"p\">,</span> <span class=\"nx\">next</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// item 1\n</span><span class=\"c1\">// item 2\n</span><span class=\"c1\">// item 3\n</span></code></pre></div><h2>迭代协议</h2><p>了解了迭代器模式，再来看看 ES6 中补充的迭代协议。可迭代（iterable）协议和迭代器（iterator）协议。</p><p>可迭代协议：</p><p>一个可迭代对象（或其原型上），必须有一个 <code>Symbol.iterator</code> 的属性，该属性所对应的值为返回一个对象的无參函数，被返回对象符合迭代器协议。当可迭代对象需要迭代时，调用该方法。</p><p>一些数据类型内置了 <code>@@iterator</code> 方法，有自己默认的迭代行为。（<b>String</b>, <b>Array</b>, <b>TypedArray</b>, <b>Map</b> , <b>Set</b> 等都是内置可迭代对象， 因为它们的原型对象都有一个 <code>@@iterator</code> 方法.）（<i><code>[Symbol.iterator]</code>、<code>@@iterator</code></i> <i>可以认为是一回事</i>）</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">let</span> <span class=\"nx\">iterator</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;hi&#39;</span><span class=\"p\">)[</span><span class=\"nx\">Symbol</span><span class=\"p\">.</span><span class=\"nx\">iterator</span><span class=\"p\">]()</span>\n<span class=\"kd\">var</span> <span class=\"nx\">a</span> <span class=\"o\">=</span> <span class=\"nx\">iterator</span><span class=\"p\">.</span><span class=\"nx\">next</span><span class=\"p\">();</span>\n<span class=\"c1\">// a { value: &#39;h&#39;, done: false }\n</span></code></pre></div><p>迭代器协议：</p><p>一个迭代器必须实现了 <code>next()</code> 方法，该方法是返回一个对象的无參函数。被返回的对象有两个必要的属性：done 和 value。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nb\">Array</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">Iteration</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">index</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"p\">{</span>\n            <span class=\"p\">[</span><span class=\"nx\">Symbol</span><span class=\"p\">.</span><span class=\"nx\">iterator</span><span class=\"p\">](){</span><span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">},</span>\n            <span class=\"nx\">next</span><span class=\"o\">:</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"nx\">index</span> <span class=\"o\">&lt;</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">?</span>\n                <span class=\"p\">{</span><span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"k\">this</span><span class=\"p\">[</span><span class=\"nx\">index</span><span class=\"o\">++</span><span class=\"p\">],</span> <span class=\"nx\">done</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">}</span><span class=\"o\">:</span>\n                <span class=\"p\">{</span><span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"kc\">undefined</span><span class=\"p\">,</span> <span class=\"nx\">done</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"kd\">let</span> <span class=\"nx\">Iteration</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">].</span><span class=\"nx\">Iteration</span><span class=\"p\">();</span>\n<span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">value</span> <span class=\"k\">of</span> <span class=\"nx\">Iteration</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// value 2\n</span><span class=\"c1\">// value 3\n</span><span class=\"c1\">// value 4\n</span></code></pre></div><p>不能发现，Iteration 同时满足可迭代协议和迭代协议。又因为是可迭代的，<code>for...of</code> 是可以直接使用，而且这个和外部迭代器十分相似。</p><p>一旦一种数据结构有了 <code>@@iterator</code> 方法后， 就认为是可迭代的。ES6 中许多新的方法就是基于此的 <code>解构赋值</code>、<code>扩展运算符</code>、<code>yield*</code>，还有 <code>for..of</code>、<code>Array.from()</code>等。</p><p>知道了以上知识，也就知道了为什么对象不可以直接使用 <code>for...of</code> 了。不过我们可以在对象原型上添加 <code>@@iterator</code> 方法，使之成为可迭代的。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">Iteration</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(){</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">keys</span> <span class=\"o\">=</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">keys</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">),</span> <span class=\"nx\">index</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span><span class=\"p\">{</span>\n            <span class=\"p\">[</span><span class=\"nx\">Symbol</span><span class=\"p\">.</span><span class=\"nx\">iterator</span><span class=\"p\">](){</span><span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">},</span>\n            <span class=\"nx\">next</span><span class=\"o\">:</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n                <span class=\"kd\">let</span> <span class=\"nx\">current</span> <span class=\"o\">=</span> <span class=\"nx\">index</span><span class=\"o\">++</span><span class=\"p\">;</span>\n                <span class=\"k\">return</span> <span class=\"nx\">current</span> <span class=\"o\">&lt;</span> <span class=\"nx\">keys</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"o\">?</span>\n                <span class=\"p\">{</span><span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"nx\">keys</span><span class=\"p\">[</span><span class=\"nx\">current</span><span class=\"p\">],</span> <span class=\"k\">this</span><span class=\"p\">[</span><span class=\"nx\">keys</span><span class=\"p\">[</span><span class=\"nx\">current</span><span class=\"p\">]]],</span> <span class=\"nx\">done</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">}</span><span class=\"o\">:</span>\n                <span class=\"p\">{</span><span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"kc\">undefined</span><span class=\"p\">,</span> <span class=\"nx\">done</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">};</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">iterator</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;a&#39;</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">&#39;c&#39;</span><span class=\"o\">:</span> <span class=\"mi\">3</span><span class=\"p\">}.</span><span class=\"nx\">Iteration</span><span class=\"p\">();</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">]</span> <span class=\"k\">of</span> <span class=\"nx\">iterator</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;key:&#39;</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"s1\">&#39;value:&#39;</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// key: a value: 1\n</span><span class=\"c1\">// key: b value: 2\n</span><span class=\"c1\">// key: c value: 3\n</span></code></pre></div><h2>生成器</h2><p>像以上的的对象都是我们自己手动实现的，符合可迭代协议和迭代协议的对象。看起来很麻烦，还好这些工作已经有函数替我们做了，那就是生成器函数。</p><p>生成器函数是可以作为迭代器工厂的函数，当它被执行时会返回一个新的 Generator 对象，该对象符合可迭代协议和迭代器协议。</p><p>现在我们用生成器函数使得对象符合迭代协议：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">Iteration</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"o\">*</span><span class=\"p\">(){</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">]</span> <span class=\"k\">of</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">entries</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">)){</span>\n        <span class=\"k\">yield</span> <span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">]</span> <span class=\"k\">of</span> <span class=\"p\">{</span><span class=\"s1\">&#39;a&#39;</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">&#39;c&#39;</span><span class=\"o\">:</span> <span class=\"mi\">3</span><span class=\"p\">}.</span><span class=\"nx\">Iteration</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;key:&#39;</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"s1\">&#39;value:&#39;</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// key: a value: 1\n</span><span class=\"c1\">// key: b value: 2\n</span><span class=\"c1\">// key: c value: 3\n</span></code></pre></div><p>在这里生成器函数只是作为生产迭代器的工厂而已，其实它还是消息双向传递系统。也正是这些特性的存在，使得异步流程控制又向前迈了一大步。</p>", 
            "topic": [
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63780333", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 4, 
            "title": "TypeScript+React练手小项目", 
            "content": "<p>在写 <a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/%25E5%2585%25B3%25E4%25BA%258EMVC%25E6%25A8%25A1%25E5%25BC%258F%25E7%25AE%2580%25E5%258D%2595%25E4%25BB%25A3%25E7%25A0%2581%25E5%25AE%259E%25E7%258E%25B0/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">关于MVC模式简单代码实现</a> 的过程中，觉得最麻烦的就是操作 DOM。所以这次升级了，打算用 React。用过 React 的同学都知道，React 在更新视图时，必须要通过 <code>setState</code> 方式改变状态，这一过程是需要我们主动调用的。而 Vue 是通过对 <code>data</code> 下的变量赋值直接更新了视图，Vue 之所以这么简单，是因为采用了数据劫持的方式。所以，这次的目的就是在 React 的基础上实现和 Vue 类似的效果。</p><p><br/>实现思路就是利用高阶组件里的反向继承对包裹组件的 <code>state</code> 劫持。这是一个练手的小项目，没考虑那么多😂。为什么这么无聊，那是因为之前写了 <a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/%25E7%2594%25A8Type%25E9%25A9%25AF%25E5%258C%2596JavaScript/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">用Type驯化JavaScript</a> 这篇文章，所以就捣鼓出这么一个玩意。</p><p><br/><b>所有代码可见<a href=\"https://link.zhihu.com/?target=https%3A//github.com/yexiaochen/mvvm_react_typescript\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">github</a>。</b><br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-019b6d8183cb878a7ea0f4524cff5226_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"579\" data-rawheight=\"771\" data-thumbnail=\"https://pic3.zhimg.com/v2-019b6d8183cb878a7ea0f4524cff5226_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"579\" data-original=\"https://pic3.zhimg.com/v2-019b6d8183cb878a7ea0f4524cff5226_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;579&#39; height=&#39;771&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"579\" data-rawheight=\"771\" data-thumbnail=\"https://pic3.zhimg.com/v2-019b6d8183cb878a7ea0f4524cff5226_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"579\" data-original=\"https://pic3.zhimg.com/v2-019b6d8183cb878a7ea0f4524cff5226_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-019b6d8183cb878a7ea0f4524cff5226_b.gif\"/></figure><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Mvvm.tsx\n</span><span class=\"c1\"></span><span class=\"p\">......</span>\n<span class=\"k\">const</span> <span class=\"nx\">hocExtends</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">WrapperComponent</span><span class=\"o\">:</span> <span class=\"nx\">ComponentClass</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">(</span>\n <span class=\"k\">class</span> <span class=\"k\">extends</span> <span class=\"nx\">WrapperComponent</span> <span class=\"p\">{</span>\n <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"o\">:</span> <span class=\"nx\">any</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"k\">super</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n <span class=\"nx\">render</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n <span class=\"kd\">let</span> <span class=\"nx\">self</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">;</span>\n <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">state</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Proxy</span><span class=\"p\">({</span> <span class=\"p\">...</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">state</span> <span class=\"p\">},</span> <span class=\"p\">{</span>\n <span class=\"nx\">get</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">target</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"k\">return</span> <span class=\"nx\">Reflect</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"nx\">target</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">);</span>\n        <span class=\"p\">},</span>\n <span class=\"nx\">set</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">target</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">any</span> <span class=\"p\">{</span>\n <span class=\"nx\">self</span><span class=\"p\">.</span><span class=\"nx\">setState</span><span class=\"p\">({</span>\n            <span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">]</span><span class=\"o\">:</span> <span class=\"nx\">value</span>\n          <span class=\"p\">})</span>\n <span class=\"k\">return</span> <span class=\"nx\">Reflect</span><span class=\"p\">.</span><span class=\"nx\">set</span><span class=\"p\">(</span><span class=\"nx\">target</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">})</span>\n <span class=\"k\">return</span> <span class=\"k\">super</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n\n<span class=\"p\">......</span>\n<span class=\"nx\">filterSearchStuff</span><span class=\"p\">(</span><span class=\"nx\">searchStuff</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"k\">void</span> <span class=\"p\">{</span>\n <span class=\"k\">const</span> <span class=\"p\">{</span> <span class=\"nx\">stuffData</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">;</span>\n <span class=\"kd\">let</span> <span class=\"nx\">stuffItem</span><span class=\"o\">:</span> <span class=\"nx\">IStuff</span> <span class=\"o\">=</span> <span class=\"nx\">stuffData</span><span class=\"p\">.</span><span class=\"nx\">find</span><span class=\"p\">((</span><span class=\"nx\">item</span><span class=\"o\">:</span> <span class=\"nx\">IStuff</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">item</span><span class=\"p\">.</span><span class=\"nx\">stuff</span> <span class=\"o\">===</span> <span class=\"nx\">searchStuff</span><span class=\"p\">)</span>\n <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">stuffItem</span> <span class=\"o\">=</span> <span class=\"nx\">stuffItem</span><span class=\"p\">;</span>\n <span class=\"c1\">// this.setState({\n</span><span class=\"c1\"></span> <span class=\"c1\">//   stuffItem\n</span><span class=\"c1\"></span> <span class=\"c1\">// })\n</span><span class=\"c1\"></span>  <span class=\"p\">}</span>\n<span class=\"p\">......</span>\n</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }, 
                {
                    "tag": "TypeScript", 
                    "tagLink": "https://api.zhihu.com/topics/19766226"
                }, 
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63175443", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 5, 
            "title": "记不住的继承方式", 
            "content": "<blockquote>都说程序员是这个世界上最懒的人, 能躺着绝不坐着, 全干着复制黏贴的活.<br/>‘什么, 你说这套逻辑之前写过?!?! 速速把代码呈上来!!!’.<br/>最懒的人往往信奉着‘拿来主义’. 若只是简单的复制黏贴, 就会显得没有逼格.</blockquote><p>在 <i><b>JavaScript</b></i> 中, 重复用到的逻辑我们会用函数包装起来, 在合适且需要的情况下, 调用该函数即可. 而 <i><b>apply</b></i>, <i><b>call</b></i>, <i><b>new</b></i> 等方法也拓宽了函数的使用场景.</p><p>除了这种借来的, 我们还有继承来的. 这就是常说的原型继承. 当对象本身没有要查询的属性或方法时, 它会沿着原型链查找, 找到了就会拿来使用. 这种&#39;无&#39;中生有的事, 不妨了解一下.</p><h2>预备知识</h2><ul><li>默认情况下, 所有的原型对象都会自动获得一个 <i><b>constructor</b></i> (构造函数)属性, 这个属性是一个指向 <i><b>prototype</b></i> 属性所在函数的指针. 构造函数的原型 <i><b>prototype</b></i> 上 <i><b>constructor</b></i> 的初始值是构造函数本身. 即,</li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nb\">Function</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">constructor</span> <span class=\"o\">===</span> <span class=\"nb\">Function</span> <span class=\"c1\">// true\n</span></code></pre></div><ul><li>由构造函数构造出来的实例本身没有 <i><b>constructor</b></i> 属性, 不过可以通过原型链继承这个属性.</li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 以下person的constructor属性继承自Person.prototype \n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">Person</span><span class=\"p\">()</span> <span class=\"p\">{}</span> <span class=\"nx\">Person</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">constructor</span> <span class=\"o\">===</span> <span class=\"nx\">Person</span> <span class=\"c1\">// true \n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">person</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Person</span><span class=\"p\">();</span> <span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">constructor</span> <span class=\"o\">===</span> <span class=\"nx\">Person</span> <span class=\"c1\">// true\n</span><span class=\"c1\"></span><span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">hasOwnProperty</span><span class=\"p\">(</span><span class=\"s1\">&#39;constructor&#39;</span><span class=\"p\">)</span> <span class=\"o\">===</span> <span class=\"kc\">false</span> <span class=\"c1\">// true \n</span><span class=\"c1\"></span><span class=\"nx\">person_1</span><span class=\"p\">.</span><span class=\"nx\">constructor</span> <span class=\"o\">===</span> <span class=\"nx\">Person</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">constructor</span> <span class=\"c1\">// true\n</span></code></pre></div><ul><li>简单数据类型和复杂数据类型赋值传参的区别.<br/><i><b>JavaScript</b></i> 中变量不可能成为只想另一个变量的引用. 引用指向的是值. 复杂数据类型的引用指向的都是同一个值.它们相互之间没有引用/指向关系. 一旦值发生变化, 指向该值的多个引用将共享这个变化.</li><li><i><b>new</b></i>, <i><b>apply</b></i>, <i><b>call</b></i> 的函数调用模式.<br/>三者的共同点都是都是指定调用函数的 <i><b>this</b></i> 值. 这使得同一个函数可以在不同的语境下正确执行. <i><b>new</b></i> 更为复杂一些. 可大致模拟为,</li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"k\">new</span><span class=\"p\">(</span><span class=\"nx\">constructor</span><span class=\"p\">,</span> <span class=\"nx\">arguments</span><span class=\"p\">)</span> <span class=\"p\">{</span>     \n  <span class=\"kd\">let</span> <span class=\"nx\">instance</span> <span class=\"o\">=</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">create</span><span class=\"p\">(</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">)</span> <span class=\"c1\">// 姑且称之为 new 的特性一     \n</span><span class=\"c1\"></span>  <span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">apply</span><span class=\"p\">(</span><span class=\"nx\">instance</span><span class=\"p\">,</span> <span class=\"nx\">arguments</span><span class=\"p\">)</span>  <span class=\"c1\">// 姑且称之为 new 的特性二     \n</span><span class=\"c1\"></span>  <span class=\"k\">return</span> <span class=\"nx\">instance</span> \n<span class=\"p\">}</span>\n</code></pre></div><blockquote>很明显, <i><b>new</b></i> 的操作中包涵了 <i><b>apply</b></i>, <i><b>call</b></i> 要做的事. 在此大胆猜测一下, 在实现继承的过程中, 一旦同时出现 <i><b>new</b></i> 和 <i><b>apply</b></i>或 <i><b>call</b></i>, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.</blockquote><h2>不着痕迹的拿来主义</h2><blockquote>&#39;各单位请注意, 下面到我表演的时候了&#39;<br/>&#39;上道具!&#39;</blockquote><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Animal</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">species</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;animal&#39;</span>\n<span class=\"kd\">function</span> <span class=\"nx\">Leo</span><span class=\"p\">()</span> <span class=\"p\">{}</span> <span class=\"c1\">// 我是头小狮子\n</span></code></pre></div><p>想要无中生有, 那是不可能的😏, 所以我们准备了模板 <i><b>Animal</b></i>. <i><b>Animal</b></i> 有的东西, <i><b>Leo</b></i> 也想拥有.</p><p>而且 <i><b>Animal</b></i> 能用地东西也同样适用于 <i><b>Leo</b></i>. 所以, 我们期待 <i><b>Leo</b></i> 最终长成这个样子.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Leo</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">species</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;animal&#39;</span>\n</code></pre></div><blockquote>&#39;就长这副熊样!? 这和简单的复制黏贴有什么区别!? 这和咸鱼又有什么区别!？ 说好的逼格呢！？&#39;</blockquote><p>观察一下 <i><b>Leo</b></i>, <i><b>Leo</b></i> 构造函数内部逻辑和 <i><b>Animal</b></i> 构造函数的内部逻辑如出一辙. 既然都是一样的, 为什么不能借来用用呢? 改造一下,</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Animal</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">species</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;animal&#39;</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">Leo</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"nx\">name</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这种在构造函数内部借函数而不借助原型继承的方式被称之为 <b>借用构造函数式继承</b>.</p><p>把属性和方法放在构造函数内部的定义, 使得每个构造出来的实例都有自己的属性和方法. 而对一些需要实例间共享的属性或方法却是没辙.</p><p>当然了, 我们本来就没打算止步于此. 构造函数内部可以靠借, 那原型上呢? 如何让 <i><b>Leo</b></i> 的原型上能和 <i><b>Animal</b></i> 的原型保持一致呢?</p><blockquote>&#39;这不是废话么? 我除了会借, 我还会继承啊, 原型继承啊!!!&#39;</blockquote><p>关于原型链, 我们已经知道是怎么一回事了(不知道的可参考<a href=\"https://link.zhihu.com/?target=https%3A//www.yexiaochen.com/%25E4%25BB%258EFunction%25E5%2585%25A5%25E6%2589%258B%25E5%258E%259F%25E5%259E%258B%25E9%2593%25BE/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从Function入手原型链</a>).</p><p>原型继承就是通过原型链实现了对象本身没有的属性访问和方法调用. 利用这个特性, 我们可以在原型上做些手脚.</p><p><b>思路一</b>: 可以使得 <b><i>Leo</i></b> 的 <b><i>prototype</i></b> 直接指向 <b><i>Animal</i></b> 的 <b><i>prototype</i></b>.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Animal</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">species</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;animal&#39;</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">Leo</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"nx\">name</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span> <span class=\"o\">=</span> <span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span>\n</code></pre></div><p>这里有一点需要注意的, <code>Leo.prototype = Animal.prototype</code> 这种写法就等于完全覆写了 <i><b>Leo</b></i> 的原型, <code>Leo.prototype.constructor</code> 将和 <code>Animal.prototype.constructor</code> 保持一致, 这会使得一些等式显得诡异.</p><p>不信, 请看:</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">constructor</span> <span class=\"o\">===</span> <span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">constructor</span> <span class=\"o\">===</span> <span class=\"nx\">Animal</span>\n</code></pre></div><p>针对这种情况, 我们往往会做一些修正:</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 接上例代码省略\n</span><span class=\"c1\"></span><span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span> <span class=\"o\">=</span> <span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">constructor</span> <span class=\"o\">=</span> <span class=\"nx\">Leo</span>\n</code></pre></div><p>即使修正好了, 可是还有个大问题.</p><p>那就是, 如果想给 <i><b>Leo</b></i> 原型添加属性或方法, 将会影响到 <i><b>Animal</b></i>, 进而会影响到所有 <i><b>Animal</b></i> 的实例. 毕竟它们的原型之间已经画了等号.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 接上例代码省略\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">Dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Animal</span><span class=\"p\">(</span><span class=\"s1\">&#39;dog&#39;</span><span class=\"p\">)</span>\n<span class=\"nx\">Dog</span><span class=\"p\">.</span><span class=\"nx\">sayName</span>  <span class=\"c1\">// undefined\n</span><span class=\"c1\"></span><span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">sayName</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Dog</span><span class=\"p\">.</span><span class=\"nx\">sayName</span><span class=\"p\">()</span>   <span class=\"c1\">//  dog\n</span></code></pre></div><blockquote>&#39;我只想偷个懒, 没想过要捣乱啊😲!!!&#39;</blockquote><p>为了消除这种影响, 我们需要一个中间纽带过渡. 还好我们知道 <i><b>new</b></i> 可以用来修改原型链.</p><p><b>思路二</b>: <b><i>Leo</i></b> 的 <b><i>prototype</i></b> 指向 <b><i>Animal</i></b> 的实例.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Animal</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">species</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;animal&#39;</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">Leo</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"nx\">name</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Animal</span><span class=\"p\">()</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">contructor</span> <span class=\"o\">=</span> <span class=\"nx\">Leo</span>\n</code></pre></div><p>这种在构造函数内部借函数同时又借助原型继承的方式被称之为 <b>组合继承</b>. <b><i>Leo</i></b> 换个角度其实长这样:</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Leo</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">constructor</span><span class=\"o\">:</span> <span class=\"nx\">Leo</span><span class=\"p\">,</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"kc\">undefined</span><span class=\"p\">,</span>\n    <span class=\"nx\">__proto__</span><span class=\"o\">:</span> <span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在这种继承模式中, <i><b>Leo</b></i> 的实例可以有自己的属性和方法, 实例之间又可以通过 <i><b>prototype</b></i> 来共享属性和方法却不会影响 <i><b>Animal</b></i>, 还可以通过 <i><b><code>_proto_</code></b></i> 追溯到 <i><b>Animal.prototype</b></i>.</p><p>一切都很完美👏. 不过还记得文章开始时所说的么</p><blockquote>在实现继承的过程中, 一旦同时出现 <i><b>new</b></i> 和 <i><b>apply</b></i> 或 <i><b>call</b></i>, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.</blockquote><p><i><b>Animal</b></i> 被调用了两次, 第一次是 <i><b>Leo</b></i> 构造函数内部作为一个普通函数被调用, 第二次是被作为构造函数构造一个实例充当 <i><b>Leo</b></i>的原型.</p><p><i><b>Animal</b></i> 内部定义的属性和方法同时出现在 <i><b>Leo</b></i> 的原型和 <i><b>Leo</b></i> 的实例上. 实例上有的东西就不会再到原型上查找. 反之, 实例上没有的东西才会到原型上查找. 显然, 有多余的存在.</p><blockquote>&#39;这不是最优解, 我要最好的! 下一个!&#39;</blockquote><p><b>思路三</b>: 既然有重复, 那就去其一呗. 既然 <b><i>new</i></b> 比 <b><i>call</i></b> 和 <b><i>apply</i></b> 厉害, 那就留着 <b><i>new</i></b> 吧.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Animal</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">species</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;animal&#39;</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">Leo</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Animal</span><span class=\"p\">()</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">contructor</span> <span class=\"o\">=</span> <span class=\"nx\">Leo</span>\n</code></pre></div><p>这种在构造函数内部不借函数只借助原型继承的方式被称之为 <b>原型链继承</b>.</p><p>经过这么一折腾, 发现不好的地方有增无减. 实例没了自己的属性和方法了, 连 <i><b>Animal</b></i> 构造函数内部定义的属性方法都可以在实例间共享了(<i>思路二也存在这个问题</i>), 而且参数也不给传了.</p><blockquote>&#39;我要的不多, 能轻点折腾不, 心脏不好&#39;</blockquote><p>回到 <b>思路二</b>, 那就删了 <b><i>new</i></b> 吧.</p><p><b>思路四</b>: 接上 <b>思路二</b>, 删了 <b><i>new</i></b>, 那只能在原型上做调整了.</p><p>我们从一开始就只是希望 <i><b>Leo</b></i> 的 <i><b>prototype</b></i> 指向 <i><b>Animal</b></i> 的 <i><b>prototype</b></i>, 不多不少且不会出现 <b>思路一</b> 的坏影响.</p><p>既然不能直接在两者之间画等号, 就造一个过渡纽带呗. 能够关联起原型链的不只有 <i><b>new</b></i>, <i><b>Object.create()</b></i> 也是可以的.</p><p>创建一个 <i><b><code>_proto_</code></b></i> 指向 <i><b>Animal.prototype</b></i> 的对象充当 <i><b>Leo</b></i> 的原型不就解决问题了么.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Animal</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">species</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;animal&#39;</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">Leo</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"nx\">name</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span> <span class=\"o\">=</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">create</span><span class=\"p\">(</span><span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">)</span>\n<span class=\"nx\">Leo</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">contructor</span> <span class=\"o\">=</span> <span class=\"nx\">Leo</span>\n</code></pre></div><p>这种在构造函数内部借函数同时又间接借助原型继承的方式被称之为 <b>寄生组合式继承</b>.</p><p>这种模式完美解决了 <b>思路二</b> 的弊端. 算是较为理想的继承模式吧.</p><blockquote>&#39;确认过眼神, 你才我想要的!&#39;</blockquote><p>以上还是只是构造函数间的继承, 还有基于已存在对象的继承, 譬如, <b>原型式继承</b> 和 <b>寄生式继承等</b>.</p><p>讲真, 说了辣么多, 我还真没记住 <b>借用构造函数式继承</b>, <b>组合继承</b>, <b>原型链继承</b>, <b>寄生组合式继承</b>, <b>原型式继承</b>, <b>寄生式继承等</b>.</p><blockquote>&#39;你没记住这么多模式, 那你都记住什么了&#39;</blockquote><p>答曰: 要想很好得继承, 一靠朋友, 二靠拼爹.</p><blockquote>&#39;这孩子是不是傻? 这都什么年代了? 再说了, 就没人告诉你你家里有矿???&#39;</blockquote><p><b>思路五</b>: <b><i>ES6</i></b> 引入了 <b><i>Class</i></b>（类）这个概念，通过 <b><i>class</i></b> 关键字，可以定义类, <b><i>Class</i></b> 实质上是 <b><i>JavaScript</i></b> 现有的基于原型的继承的语法糖. <b><i>Class</i></b> 可以通过extends关键字实现继承. 我们可以对 <b><i>思路四</i></b> 来个华丽变身.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Animal</span> <span class=\"p\">{</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">Animal</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">species</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;animal&#39;</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">Leo</span> <span class=\"k\">extends</span> <span class=\"nx\">Animal</span> <span class=\"p\">{</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">super</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>经过这么一处理后行为上和 <i><b>思路四</b></i> 基本没什么区别, <code>constructor(){}</code> 充当了之前的构造函数, <code>super()</code> 作为函数调用扮演着 <code>Animal.call(this, name)</code> 的角色(<i>还可以表示父类</i>). 最重要的是 <i><b>Leo</b></i> 的 <i><b><code>_proto_</code></b></i> 也指向了 <i><b>Animal</b></i>.</p><blockquote>&#39;矿多基因好, 啧啧啧, 我都快要喜欢上我自己了😏.&#39;</blockquote>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62666613", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 18, 
            "title": "用Type驯化JavaScript", 
            "content": "<p><b>阅前必知：本文属于总结性文章，阅读前，TypeScript 官方文档应有查阅过。</b></p><blockquote>TypeScript 具有类型系统，且是 JavaScript 的超集。它可以编译成普通的 JavaScript 代码。TypeScript 支持任意浏览器，任意环境，任意系统并且是开源的。</blockquote><p>作为弱类型、动态型语言，JavaScript 就像未驯化的野马一样。每个人都能上去坐两下，但是真正能够驾驭的只能是个中好手。</p><p>近几年，前端经历了快速的发展已经不再是以前随便玩玩的小玩意了。面对越来越大型、越来越持久的项目来说，这种宽松的方式反而成了阻碍。</p><blockquote>东西做大了，随之而来的就是各种规矩</blockquote><p>规矩是从经验中总结，同时也是为了朝更好的方向发展，就比如编程里的设计原则和设计模式。「Man maketh manners」，记得王牌特工里，主角们在教育别人的时候总喜欢说这么一句话，「不知礼，无以立也」。</p><p>在 TypeScript 里，「礼」就是 Type，Type 就是规矩。Typescript 通过类型注解提供编译时的静态类型检查，提前发现错误，同时也提高了代码的可读性和可维护性。</p><blockquote>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式</blockquote><p>在 JavaScript 里，变量用于在特定时间存储特定值，其值及数据类型可以在脚本的生命周期内改变。</p><p>而在 TypeScript 中，标识符（变量、函数、类、属性的名字，或者函数参数）在其定义时就指定了类型（或类型推论出）。在编译阶段，若出现了期望之外的类型，TypeScript 将会提示抛错（虽然有时候并不会影响程序的正常运行）。</p><p>在 TypeScript 中，通过 <code>: 类型</code> 的方式为标识符添加类型注解。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">let</span> <span class=\"nx\">isDone</span><span class=\"o\">:</span> <span class=\"kr\">boolean</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"p\">;</span>    <span class=\"c1\">// boolean；\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">decLiteral</span><span class=\"o\">:</span> <span class=\"nx\">number</span> <span class=\"o\">=</span> <span class=\"mi\">6</span><span class=\"p\">;</span>    <span class=\"c1\">// number；\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;bob&#34;</span><span class=\"p\">;</span>    <span class=\"c1\">// string；\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">list</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">];</span>    <span class=\"c1\">// Array&lt;number&gt;;\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">list</span><span class=\"o\">:</span> <span class=\"nb\">Array</span><span class=\"o\">&lt;</span><span class=\"nx\">number</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">];</span>    <span class=\"c1\">// Array&lt;number&gt;;\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"nx\">string</span><span class=\"p\">,</span> <span class=\"nx\">number</span><span class=\"p\">];</span>    <span class=\"c1\">// tuple;\n</span><span class=\"c1\"></span><span class=\"kr\">enum</span> <span class=\"nx\">Color</span> <span class=\"p\">{</span><span class=\"nx\">Red</span><span class=\"p\">,</span> <span class=\"nx\">Green</span><span class=\"p\">,</span> <span class=\"nx\">Blue</span><span class=\"p\">}</span>    <span class=\"c1\">// enum;\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">notSure</span><span class=\"o\">:</span> <span class=\"nx\">any</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>    <span class=\"c1\">// any;\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">warnUser</span><span class=\"p\">()</span><span class=\"o\">:</span> <span class=\"k\">void</span> <span class=\"p\">{</span>    <span class=\"c1\">// void;\n</span><span class=\"c1\"></span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">&#34;This is my warning message&#34;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">u</span><span class=\"o\">:</span> <span class=\"kc\">undefined</span> <span class=\"o\">=</span> <span class=\"kc\">undefined</span><span class=\"p\">;</span>    <span class=\"c1\">// undefined;\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">n</span><span class=\"o\">:</span> <span class=\"kc\">null</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"p\">;</span>    <span class=\"c1\">// null;\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">error</span><span class=\"p\">(</span><span class=\"nx\">message</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">never</span> <span class=\"p\">{</span>    <span class=\"c1\">// never;\n</span><span class=\"c1\"></span><span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"nx\">message</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">obj</span><span class=\"o\">:</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>    <span class=\"c1\">// object\n</span></code></pre></div><p>在 TypeScript 中，数组（Array）是合并了相同类型的对象，而元组（tuple）合并了不同类型的对象。（<code>Array&lt;any&gt;</code>,也可以合并不同类型的数据）</p><blockquote>类型注解中的类型就是以上的那些类型么？</blockquote><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查，它有时被称做「鸭式辨型法」或「结构性子类型化」。上面的只是基础类型，它们是填充结构的基本单位而已。在 TypeScript 里，类型不应该还停留在 JavaScript 数据类型的层面上，还应包括基础类型的组合结构化。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">let</span> <span class=\"nx\">str</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Hello&#39;</span><span class=\"p\">;</span>    <span class=\"c1\">// 字符串字面量类型；\n</span><span class=\"c1\"></span><span class=\"nx\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Hi&#39;</span>    <span class=\"c1\">// error；\n</span><span class=\"c1\"></span>\n<span class=\"kd\">let</span> <span class=\"nx\">something</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Hello&#39;</span> <span class=\"o\">|</span> <span class=\"mi\">1</span><span class=\"p\">;</span>    <span class=\"c1\">// 联合类型；\n</span><span class=\"c1\"></span><span class=\"nx\">something</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>    <span class=\"c1\">// ok；\n</span><span class=\"c1\"></span>\n<span class=\"kd\">let</span> <span class=\"nx\">obj</span><span class=\"o\">:</span> <span class=\"p\">{</span><span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">};</span>    <span class=\"c1\">// 对象字面量\n</span><span class=\"c1\"></span><span class=\"nx\">obj</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s2\">&#34;夜曉宸&#34;</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"mi\">18</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>换句话说，在定义标识符的时候，用一个类型模板来描述标识符的结构和内部类型组成。即类型模板就是标识符期望的样子。</p><blockquote>代码是给人看的，顺便是给机器运行的</blockquote><p>都说好的代码就该这样。但是在 TypeScript 里，这两句话可以颠倒下顺序。代码是给机器运行的，顺便是给人看的。 在谈到 TypeScript 的好处时，有一条很重要，增强了编译器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。</p><p>而这些也得益于标识符的类型的精确划分或表述，所以想写好 Typescript 代码，就应该精确描述标识符的类型，而不是随处安放的 <code>any</code>。</p><blockquote>表述复杂结构最常用的方式 ———— 接口</blockquote><p>接口是 JavaScript 中没有的东西，是一个非常灵活的概念，可以抽象行为，也可以描述「对象的形状」。 对于需要复用的结构类型，就可以使用接口的方式，而不是对象字面量内联式注解。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kr\">interface</span> <span class=\"nx\">Iperson</span> <span class=\"p\">{</span>    <span class=\"c1\">// 对象\n</span><span class=\"c1\"></span>    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">,</span>\n    <span class=\"nx\">sayHi</span><span class=\"p\">()</span><span class=\"o\">:</span> <span class=\"k\">void</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">obj</span><span class=\"o\">:</span> <span class=\"nx\">Iperson</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s2\">&#34;夜曉宸&#34;</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"mi\">18</span><span class=\"p\">,</span>\n    <span class=\"nx\">sayHi</span><span class=\"o\">:</span> <span class=\"p\">()=&gt;</span> <span class=\"p\">{}</span>\n<span class=\"p\">}</span>\n\n<span class=\"cm\">/* ——————人工分割线—————— */</span>\n\n<span class=\"kr\">interface</span> <span class=\"nx\">Iperson</span> <span class=\"p\">{</span>    <span class=\"c1\">// 函数类型\n</span><span class=\"c1\"></span>    <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">string</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">person</span><span class=\"o\">:</span> <span class=\"nx\">Iperson</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\">,</span><span class=\"si\">${</span><span class=\"nx\">age</span><span class=\"si\">}</span><span class=\"sb\">`</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">person</span><span class=\"p\">(</span><span class=\"s1\">&#39;夜曉宸&#39;</span><span class=\"p\">,</span> <span class=\"mi\">18</span><span class=\"p\">);</span>\n\n<span class=\"cm\">/* ——————人工分割线—————— */</span>\n\n<span class=\"kr\">interface</span> <span class=\"nx\">Iperson</span> <span class=\"p\">{</span>    <span class=\"c1\">// 构造函数\n</span><span class=\"c1\"></span>    <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">person</span><span class=\"o\">:</span> <span class=\"nx\">Iperson</span> <span class=\"o\">=</span> <span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span><span class=\"p\">;</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">age</span> <span class=\"o\">=</span> <span class=\"nx\">age</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">new</span> <span class=\"nx\">person</span><span class=\"p\">(</span><span class=\"s1\">&#39;夜曉宸&#39;</span><span class=\"p\">,</span> <span class=\"mi\">18</span><span class=\"p\">);</span>\n\n<span class=\"cm\">/* ——————人工分割线—————— */</span>\n\n<span class=\"kr\">interface</span> <span class=\"nx\">Iperson</span> <span class=\"p\">{</span>    <span class=\"c1\">// 类实现接口\n</span><span class=\"c1\"></span>    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n<span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"kr\">implements</span> <span class=\"nx\">Iperson</span><span class=\"p\">{</span>\n    <span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;夜曉宸&#39;</span>\n    <span class=\"nx\">age</span> <span class=\"o\">=</span> <span class=\"mi\">18</span>\n<span class=\"p\">}</span>\n<span class=\"k\">new</span> <span class=\"nx\">Person</span><span class=\"p\">()</span>\n\n<span class=\"cm\">/* ——————人工分割线—————— */</span>\n\n<span class=\"kr\">interface</span> <span class=\"nx\">Iperson</span> <span class=\"p\">{</span>    <span class=\"c1\">// 混合类型\n</span><span class=\"c1\"></span>    <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">Person</span><span class=\"p\">()</span><span class=\"o\">:</span> <span class=\"nx\">Iperson</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">me</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"nx\">Iperson</span><span class=\"o\">&gt;</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">string</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\">, </span><span class=\"si\">${</span><span class=\"nx\">age</span><span class=\"si\">}</span><span class=\"sb\">`</span>\n    <span class=\"p\">}</span>\n    <span class=\"nx\">me</span><span class=\"p\">.</span><span class=\"nx\">age</span> <span class=\"o\">=</span> <span class=\"mi\">18</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"nx\">me</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span> <span class=\"nx\">person</span> <span class=\"o\">=</span> <span class=\"nx\">Person</span><span class=\"p\">();</span>\n<span class=\"nx\">person</span><span class=\"p\">(</span><span class=\"s1\">&#39;夜曉宸&#39;</span><span class=\"p\">,</span> <span class=\"mi\">18</span><span class=\"p\">)</span>\n<span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">age</span>\n\n</code></pre></div><p>以上是接口在对象、普通函数、构造函数、类上的表现。对于接口的属性，还可以做到精确控制，如可选属性、任意属性、只读属性等。</p><p>最后，接口间可以继承，接口还可以继承类。当接口继承类时，它会继承类的成员但不包括其实现，但是若继承了拥有私有或受保护的成员类时，这个接口只能由这个类或其子类来实现了，这个和类的访问修饰符的特点有关系。</p><p>说完接口，就要说说类了，因为它们有多相似的地方，比如充当对象的类型模板，继承成员等。</p><blockquote>类到底是什么呢？</blockquote><p>ES6 引入了 Class（类）这个概念，通过 class 关键字，可以定义类, Class 实质上是 JavaScript 现有的基于原型的继承的语法糖. Class 可以通过extends关键字实现继承。TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n    <span class=\"kr\">static</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span> <span class=\"o\">=</span> <span class=\"mi\">18</span><span class=\"p\">;</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"kr\">public</span> <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span> <span class=\"kr\">public</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"p\">}</span>\n    <span class=\"nx\">sayHi</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"sb\">`Hi,</span><span class=\"si\">${</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\">`</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"cm\">/* —————— 分割线 —————— */</span>\n<span class=\"kd\">var</span> <span class=\"nx\">Person</span> <span class=\"o\">=</span> <span class=\"cm\">/** @class */</span> <span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">function</span> <span class=\"nx\">Person</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span><span class=\"p\">;</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">age</span> <span class=\"o\">=</span> <span class=\"nx\">age</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"nx\">Person</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">sayHi</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"s2\">&#34;Hi,&#34;</span> <span class=\"o\">+</span> <span class=\"nx\">name</span><span class=\"p\">;</span>\n    <span class=\"p\">};</span>\n    <span class=\"nx\">Person</span><span class=\"p\">.</span><span class=\"nx\">age</span> <span class=\"o\">=</span> <span class=\"mi\">18</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"nx\">Person</span><span class=\"p\">;</span>\n<span class=\"p\">}());</span>\n</code></pre></div><p>TypeScript 编译后，可以看出来，类其实就是一个函数而已。</p><p>在 ES6 之前，通过构造函数的方式 <code>new</code> 出对象，造出的对象拥有和共享了构造函数内部绑定的属性方法及原型上的属性方法。TypeScript 里的接口描述的类类型就是类的实例部分应该遵循的类型模板。作为类的静态部分 ———— 构造函数，函数也应该有自己的属性特征。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kr\">interface</span> <span class=\"nx\">static_person</span> <span class=\"p\">{</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">,</span>\n    <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kr\">interface</span> <span class=\"nx\">instance_person</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">,</span>\n    <span class=\"nx\">say</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">string</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span> <span class=\"nx\">person</span><span class=\"o\">:</span> <span class=\"nx\">static_person</span> <span class=\"o\">=</span> <span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"kr\">implements</span> <span class=\"nx\">instance_person</span><span class=\"p\">{</span>\n    <span class=\"kr\">static</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span> <span class=\"o\">=</span> <span class=\"mi\">18</span><span class=\"p\">;</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"kr\">public</span> <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span> <span class=\"kr\">public</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"p\">}</span>\n    <span class=\"nx\">say</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"sb\">`Hi,</span><span class=\"si\">${</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\">`</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">new</span> <span class=\"nx\">person</span><span class=\"p\">(</span><span class=\"s1\">&#39;夜曉宸&#39;</span><span class=\"p\">,</span><span class=\"mi\">18</span><span class=\"p\">)</span>\n</code></pre></div><p>由以上代码可以看出，类的静态部分和动态部分都有各自的类型模板。若是想要将类自身作为类型模板又该如何做呢？最简单的方法就是 <code>typeof 类</code> 的方式。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n  <span class=\"kr\">static</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span> <span class=\"o\">=</span> <span class=\"mi\">18</span><span class=\"p\">;</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"kr\">public</span> <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span> <span class=\"kr\">public</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n    <span class=\"nx\">say</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"sb\">`Hi,</span><span class=\"si\">${</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\">`</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">class</span> <span class=\"nx\">Man</span> <span class=\"p\">{</span>\n    <span class=\"kr\">static</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"kr\">public</span> <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">,</span> <span class=\"kr\">public</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n    <span class=\"kr\">public</span> <span class=\"nx\">sex</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;man&#39;</span><span class=\"p\">;</span>\n    <span class=\"nx\">say</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">){</span><span class=\"k\">return</span> <span class=\"sb\">`Hi, </span><span class=\"si\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">sex</span><span class=\"si\">}</span><span class=\"sb\">,</span><span class=\"si\">${</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">man</span><span class=\"o\">:</span> <span class=\"k\">typeof</span> <span class=\"nx\">Person</span> <span class=\"o\">=</span> <span class=\"nx\">Man</span><span class=\"p\">;</span>\n<span class=\"k\">new</span> <span class=\"nx\">man</span><span class=\"p\">(</span><span class=\"s1\">&#39;夜曉宸&#39;</span><span class=\"p\">,</span> <span class=\"mi\">18</span><span class=\"p\">)</span>\n</code></pre></div><p>类静态部分、类实例部分和类自身，它们都有自己需要遵循的类型模板。知道了其中的区别，也就能更好得理解类作为接口使用、接口继承类等用法了。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n  <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n  <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kr\">interface</span> <span class=\"nx\">Man</span> <span class=\"k\">extends</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n  <span class=\"nx\">sex</span><span class=\"o\">:</span> <span class=\"s1\">&#39;man&#39;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span> <span class=\"nx\">man</span><span class=\"o\">:</span> <span class=\"nx\">Man</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;夜曉宸&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"mi\">18</span><span class=\"p\">,</span>\n    <span class=\"nx\">sex</span><span class=\"o\">:</span> <span class=\"s1\">&#39;man&#39;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>除了结构上的约束，类也通过访问修饰符对其成员做了约束，包括 public，private，protected，readonly等。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n  <span class=\"kr\">private</span> <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n  <span class=\"kr\">protected</span> <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kr\">interface</span> <span class=\"nx\">SayPerson</span> <span class=\"k\">extends</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n  <span class=\"nx\">sayHi</span><span class=\"p\">()</span><span class=\"o\">:</span> <span class=\"nx\">string</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">Human</span> <span class=\"k\">extends</span> <span class=\"nx\">Person</span> <span class=\"kr\">implements</span> <span class=\"nx\">SayPerson</span> <span class=\"p\">{</span>\n  <span class=\"nx\">sayHi</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"sb\">`Hi, </span><span class=\"si\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">age</span><span class=\"si\">}</span><span class=\"sb\">`</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>知道了访问修饰符的特点，也就明白之前说过的「当接口继承类时，它会继承类的成员但不包括其实现，但是若继承了拥有私有或受保护的成员类时，这个接口只能由这个类或其子类来实现了」。</p><blockquote>如果一个标识符的类型不确定，该如何？</blockquote><p>对于一个内部逻辑相差不大，入參类型不同的函数来说，没必要因为参数类型不同而重复大部分代码，这时就需要一个类型变量来代替。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"cm\">/* 范型函数 */</span>\n<span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n    <span class=\"nx\">className</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;person&#39;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">class</span> <span class=\"nx\">Human</span> <span class=\"p\">{</span>\n    <span class=\"nx\">classname</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;human&#39;</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">function</span> <span class=\"nx\">create</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">Class</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">T</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"nx\">T</span><span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nx\">Class</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">create</span><span class=\"p\">(</span><span class=\"nx\">Person</span><span class=\"p\">).</span><span class=\"nx\">className</span>\n\n<span class=\"cm\">/* 范型接口 */</span>\n<span class=\"kr\">interface</span> <span class=\"nx\">Creat</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">{</span>\n    <span class=\"p\">(</span><span class=\"nx\">Class</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">T</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"nx\">T</span>\n<span class=\"p\">}</span>\n<span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n    <span class=\"nx\">className</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;person&#39;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">class</span> <span class=\"nx\">Human</span> <span class=\"p\">{</span>\n    <span class=\"nx\">classname</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;human&#39;</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">function</span> <span class=\"nx\">create</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">Class</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">T</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"nx\">T</span><span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nx\">Class</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">person</span><span class=\"o\">:</span> <span class=\"nx\">Creat</span><span class=\"o\">&lt;</span><span class=\"nx\">Person</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"nx\">create</span><span class=\"p\">;</span>\n\n<span class=\"nx\">person</span><span class=\"p\">(</span><span class=\"nx\">Person</span><span class=\"p\">)</span>    <span class=\"c1\">// OK\n</span><span class=\"c1\"></span><span class=\"nx\">person</span><span class=\"p\">(</span><span class=\"nx\">Human</span><span class=\"p\">)</span>    <span class=\"c1\">// Error\n</span></code></pre></div><p>注意了，类型变量表示的是类型，而不是值。类型变量里塞的可能是任意一个类型，但根据场景，我们最好能够更加精确的描述标识符的类型。应了上面的一句话，「想写好 Typescript 代码，就应该精确描述标识符的类型，而不是随处安放的 <code>any</code>」。所以对于泛型，我们也可以做些约束，即，泛型约束。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n  <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n  <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kr\">interface</span> <span class=\"nx\">Man</span> <span class=\"k\">extends</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n  <span class=\"nx\">sex</span><span class=\"o\">:</span> <span class=\"s1\">&#39;man&#39;</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">function</span> <span class=\"nx\">getProperty</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"p\">,</span> <span class=\"nx\">K</span> <span class=\"k\">extends</span> <span class=\"nx\">keyof</span> <span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">obj</span><span class=\"o\">:</span> <span class=\"nx\">T</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"o\">:</span> <span class=\"nx\">K</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">any</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"nx\">obj</span><span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">]</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">man</span><span class=\"o\">:</span> <span class=\"nx\">Man</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;夜曉宸&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"mi\">18</span><span class=\"p\">,</span>\n    <span class=\"nx\">sex</span><span class=\"o\">:</span> <span class=\"s1\">&#39;man&#39;</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">getProperty</span><span class=\"p\">(</span><span class=\"nx\">man</span><span class=\"p\">,</span> <span class=\"s1\">&#39;sex&#39;</span><span class=\"p\">)</span>\n</code></pre></div><p>用类型变量来注释标识符的类型有时会觉得还是不够精确。</p><blockquote>知道标识符的可能类型，然后组合起来</blockquote><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Man</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>\n    <span class=\"nx\">study</span><span class=\"p\">()</span><span class=\"o\">:</span><span class=\"nx\">string</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">class</span> <span class=\"nx\">Women</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>\n    <span class=\"nx\">sing</span><span class=\"p\">()</span><span class=\"o\">:</span><span class=\"nx\">string</span><span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"kd\">function</span> <span class=\"nx\">instance</span><span class=\"p\">(</span><span class=\"nx\">Class</span><span class=\"o\">:</span> <span class=\"nx\">Man</span> <span class=\"o\">|</span> <span class=\"nx\">Women</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"o\">&lt;</span><span class=\"nx\">Man</span><span class=\"o\">&gt;</span><span class=\"nx\">Class</span><span class=\"p\">).</span><span class=\"nx\">study</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"nx\">Man</span><span class=\"o\">&gt;</span><span class=\"nx\">Class</span><span class=\"p\">).</span><span class=\"nx\">study</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"nx\">Women</span><span class=\"o\">&gt;</span><span class=\"nx\">Class</span><span class=\"p\">).</span><span class=\"nx\">sing</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">man</span><span class=\"o\">:</span><span class=\"nx\">Man</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;夜曉宸&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"mi\">18</span><span class=\"p\">,</span>\n    <span class=\"nx\">study</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"s1\">&#39;我爱学习&#39;</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">women</span><span class=\"o\">:</span> <span class=\"nx\">Women</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;godness&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"mi\">17</span><span class=\"p\">,</span>\n    <span class=\"nx\">sing</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"s1\">&#39;我爱唱歌&#39;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">instance</span><span class=\"p\">(</span><span class=\"nx\">man</span><span class=\"p\">)</span>    <span class=\"c1\">// 我爱学习\n</span><span class=\"c1\"></span><span class=\"nx\">instance</span><span class=\"p\">(</span><span class=\"nx\">women</span><span class=\"p\">)</span>    <span class=\"c1\">// 我爱唱歌\n</span></code></pre></div><p>有交叉类型、联合类型等，而类型命名则是更灵活的类型组织方式。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 官网🌰\n</span><span class=\"c1\"></span><span class=\"nx\">type</span> <span class=\"nx\">Name</span> <span class=\"o\">=</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n<span class=\"nx\">type</span> <span class=\"nx\">NameResolver</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">string</span><span class=\"p\">;</span>\n<span class=\"nx\">type</span> <span class=\"nx\">NameOrResolver</span> <span class=\"o\">=</span> <span class=\"nx\">Name</span> <span class=\"o\">|</span> <span class=\"nx\">NameResolver</span><span class=\"p\">;</span>\n<span class=\"kd\">function</span> <span class=\"nx\">getName</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"o\">:</span> <span class=\"nx\">NameOrResolver</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">Name</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">typeof</span> <span class=\"nx\">n</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;string&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nx\">n</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nx\">n</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>类型多了之后，有时候需要对某一类型做特别处理，于是有类型断言 （<code>&lt;类型&gt;</code>） 和类型守卫（<code>typeof</code>, <code>instanceof</code>, <code>in</code>等）。</p><p>还可以通过条件判断来选择哪种类型。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 官网🌰\n</span><span class=\"c1\"></span><span class=\"nx\">declare</span> <span class=\"kd\">function</span> <span class=\"nx\">f</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span> <span class=\"k\">extends</span> <span class=\"kr\">boolean</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"o\">:</span> <span class=\"nx\">T</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">T</span> <span class=\"k\">extends</span> <span class=\"kc\">true</span> <span class=\"o\">?</span> <span class=\"nx\">string</span> <span class=\"o\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>\n<span class=\"c1\">// Type is &#39;string | number\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"nb\">Math</span><span class=\"p\">.</span><span class=\"nx\">random</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span>\n</code></pre></div><p>当然了，以上代码好多的标识符是没有必要添加类型注解的。</p><blockquote>类型推断，即，类型是在哪里如何被推断的</blockquote><p>类型注解也不是越多越好，即使有些地方你不添加类型注解，TypeScript 也会通过上下文归类等方式找到最佳通用类型。</p>", 
            "topic": [
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "TypeScript", 
                    "tagLink": "https://api.zhihu.com/topics/19766226"
                }
            ], 
            "comments": [
                {
                    "userName": "addamx", 
                    "userLink": "https://www.zhihu.com/people/8f763e1ea87a82390501b380c20d6515", 
                    "content": "概括得真好，前几天看handbook看得我有点乱，现在清晰了许多。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "<p>官方文档各知识点间内容有交叉，多看几遍才理得清😂</p>", 
                            "likes": 0, 
                            "replyToAuthor": "addamx"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62069910", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 13, 
            "title": "观察者模式，从未如此简单", 
            "content": "<h2>商品信息改变带来的烦恼</h2><blockquote>Talk is cheap. Show me the code. (译: 屁话少说, 放码过来)</blockquote><p><i>以下所有代码参见<a href=\"https://link.zhihu.com/?target=https%3A//codepen.io/yexiaochen/pen/rQmYQJ%3Feditors%3D0110\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Design pattern transformation</a>.</i></p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 商品的信息: 价格 &amp; 折扣\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">data</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">price</span><span class=\"o\">:</span> <span class=\"mi\">100</span><span class=\"p\">,</span>\n    <span class=\"nx\">discount</span><span class=\"o\">:</span> <span class=\"mf\">0.8</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 顾客信息: 是否为会员 &amp; 购买数量 &amp; 总消费 &amp; 购买时间戳\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">customer</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">&#34;VIP&#34;</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n    <span class=\"s2\">&#34;quantity&#34;</span><span class=\"o\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>\n    <span class=\"s2\">&#34;total&#34;</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 总消费计算方式\n</span><span class=\"c1\"></span><span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">info</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">VIP</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"nx\">data</span><span class=\"p\">.</span><span class=\"nx\">price</span> <span class=\"o\">*</span> <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">quantity</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"nx\">data</span><span class=\"p\">.</span><span class=\"nx\">price</span> <span class=\"o\">*</span> <span class=\"nx\">data</span><span class=\"p\">.</span><span class=\"nx\">discount</span> <span class=\"o\">*</span> <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">quantity</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">total</span><span class=\"p\">(</span><span class=\"nx\">customer</span><span class=\"p\">);</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;customer&#39;</span><span class=\"p\">,</span> <span class=\"nx\">customer</span><span class=\"p\">);</span>\n<span class=\"c1\">// customer { VIP: true, quantity: 10, total: 800 }\n</span></code></pre></div><p>从代码中很容易看得出来, 我们就是想实现一个简单的计费功能. 可现实中, 商品的价格可能并不是一成不变的.</p><blockquote>data.price = 200</blockquote><p>价格变动后, 我们需要及时地获取总消费, 那么就必须重新调用下 <b>total</b> 计费.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">total</span><span class=\"p\">(</span><span class=\"nx\">customer</span><span class=\"p\">);</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;customer&#39;</span><span class=\"p\">,</span> <span class=\"nx\">customer</span><span class=\"p\">);</span>\n<span class=\"c1\">// customer { VIP: true, quantity: 10, total: 1600 }\n</span></code></pre></div><p>这是一个大数据时代, 任何数据都有价值. 现在, 我们还想要每次购买时的时间点.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">customer</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">&#34;VIP&#34;</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n    <span class=\"s2\">&#34;quantity&#34;</span><span class=\"o\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>\n    <span class=\"s2\">&#34;total&#34;</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n<span class=\"o\">+</span>   <span class=\"s2\">&#34;timeStamp&#34;</span><span class=\"o\">:</span> <span class=\"mi\">0</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 获取购买时间\n</span><span class=\"c1\"></span><span class=\"nx\">purchaseTime</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">info</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">timeStamp</span> <span class=\"o\">=</span> <span class=\"nb\">Date</span><span class=\"p\">.</span><span class=\"nx\">now</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>于是, 我们需要执行的函数就多了一个.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">total</span><span class=\"p\">(</span><span class=\"nx\">customer</span><span class=\"p\">)</span>\n<span class=\"nx\">purchaseTime</span><span class=\"p\">(</span><span class=\"nx\">customer</span><span class=\"p\">)</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;customer&#39;</span><span class=\"p\">,</span> <span class=\"nx\">customer</span><span class=\"p\">)</span>\n<span class=\"c1\">// { VIP: true, quantity: 10, total: 1600, timeStamp: 1542293676297 }\n</span></code></pre></div><p>如果我们的需求还有很多, 而且不只一个 <b>customer</b> 呢. 那么, 每次价格变化我们需要执行很多步骤, 每次啊, 麻烦得很.</p><div class=\"highlight\"><pre><code class=\"language-diff\"><span class=\"gi\">+    const customer1 = {\n</span><span class=\"gi\">+    &#34;VIP&#34;: false,\n</span><span class=\"gi\">+    &#34;quantity&#34;: 8,\n</span><span class=\"gi\">+    &#34;total&#34;: 0,\n</span><span class=\"gi\">+    &#34;timeStamp&#34;: 0\n</span><span class=\"gi\">+    }\n</span><span class=\"gi\"></span>\n    total(customer)\n    purchaseTime(customer)\n    func(customer)\n    ...\n    funcN(customer1)\n    total(customer1)\n    purchaseTime(customer1)\n    func(customer1)\n    ...\n    funcN(customer)\n    ...\n    funcN(customerN)\n</code></pre></div><p>现在我们就对上面的代码进行观察者模式改造.</p><h2>用观察者模式改造</h2><p>从上面的例子中🌰🀄️不难看出, 每次价格变化时, 我们都需要重复调用满足需求的方法. 不妨想想, 如果我们把这些方法存储起来, 等到价格变化时再去统一调用, 岂不是很方便. </p><p>那么问题来了, 这和之前所说的观察者模式(<a href=\"https://link.zhihu.com/?target=https%3A//yexiaochen.github.io/%25E4%25BB%258E%25E8%25A7%2582%25E5%25AF%259F%25E8%2580%2585%25E6%25A8%25A1%25E5%25BC%258F%25E8%25AF%25B4%25E8%25B5%25B7/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从观察者模式说起</a>)有什么区别呢? 在此, 我们试着用观察者模式改造下. </p><p>首先，观察者模式都是一个套路. 先一个类维护一个列表, 对列表有增删和通知更新功能. 另一个类则是提供了更新接口.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 观察目标类\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Subject</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">observerList</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">addObserver</span><span class=\"p\">(</span><span class=\"nx\">observer</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">observerList</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">observer</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">notify</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">observerList</span><span class=\"p\">.</span><span class=\"nx\">forEach</span><span class=\"p\">(</span><span class=\"nx\">observer</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">observer</span><span class=\"p\">.</span><span class=\"nx\">update</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">)</span>\n    <span class=\"p\">})</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 观察者类\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Observer</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">fn</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">update</span> <span class=\"o\">=</span> <span class=\"nx\">fn</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>接着, 把我们想要调用的方法包装一下, 存储起来.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 将要重复使用的包装一下\n</span><span class=\"c1\"></span><span class=\"nx\">observer1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Observer</span><span class=\"p\">(</span><span class=\"nx\">total</span><span class=\"p\">)</span>\n<span class=\"nx\">observer2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Observer</span><span class=\"p\">(</span><span class=\"nx\">purchaseTime</span><span class=\"p\">)</span>\n\n<span class=\"c1\">// 存起来\n</span><span class=\"c1\"></span><span class=\"kd\">let</span> <span class=\"nx\">subject</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Subject</span><span class=\"p\">()</span>\n<span class=\"nx\">subject</span><span class=\"p\">.</span><span class=\"nx\">addObserver</span><span class=\"p\">(</span><span class=\"nx\">observer1</span><span class=\"p\">)</span>\n<span class=\"nx\">subject</span><span class=\"p\">.</span><span class=\"nx\">addObserver</span><span class=\"p\">(</span><span class=\"nx\">observer2</span><span class=\"p\">)</span>\n</code></pre></div><p>每次价格改变时, 只需要通知一下即可.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 调整商品价格\n</span><span class=\"c1\"></span><span class=\"nx\">data</span><span class=\"p\">.</span><span class=\"nx\">price</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n<span class=\"nx\">subject</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">(</span><span class=\"nx\">customer</span><span class=\"p\">)</span>\n<span class=\"nx\">subject</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">(</span><span class=\"nx\">customer1</span><span class=\"p\">)</span>\n</code></pre></div><p>改造结束. 初看起来, 可能变得繁琐了. 但是, 遇到复杂的情况, 这不失是一个好办法. 接下来, 我们看看结合 <code>Objec.defineProperty</code> 会有什么惊喜.</p><h2>与Objec.defineProperty结合</h2><p>支付宝的花呗都可以自己还钱了🤣, 我们为什么还要别人管着😏. </p><p>大家都知道经过 <code>Objec.defineProperty</code> 处理的对象, 在设置和获取对象属性的时候, 会自动触发响应 <code>set</code> 和 <code>get</code> 方法. 利用这一点, 我们就可以做到生活自理了.</p><p> 熟悉的配方, 熟悉的味道. 熟悉的套路我们不妨再走一遍.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 观察目标类\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Dependency</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">watcherList</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">addObserver</span><span class=\"p\">(</span><span class=\"nx\">observer</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">watcherList</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">observer</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">notify</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">watcherList</span><span class=\"p\">.</span><span class=\"nx\">forEach</span><span class=\"p\">(</span><span class=\"nx\">watcher</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">watcher</span><span class=\"p\">.</span><span class=\"nx\">update</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">)</span>\n    <span class=\"p\">})</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 观察类\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Watcher</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">fn</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">update</span> <span class=\"o\">=</span> <span class=\"nx\">fn</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>我们此行的目的, 是要在 <code>data.price</code> 或 <code>data.discount</code> 改变时, 程序能够自动触发, 得到我们想要的结果. 换句话说, 通知更新的时机是在设置 <code>data.price</code> 或 <code>data.discount</code> 的时候.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">keys</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">).</span><span class=\"nx\">forEach</span><span class=\"p\">(</span><span class=\"nx\">key</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">value</span> <span class=\"o\">=</span> <span class=\"nx\">data</span><span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">]</span>\n    <span class=\"k\">const</span> <span class=\"nx\">dep</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Dependency</span><span class=\"p\">()</span>\n    <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">defineProperty</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n        <span class=\"nx\">set</span><span class=\"p\">(</span><span class=\"nx\">newVal</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nx\">value</span> <span class=\"o\">=</span> <span class=\"nx\">newVal</span>\n            <span class=\"nx\">dep</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">()</span>\n        <span class=\"p\">},</span>\n        <span class=\"nx\">get</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"nx\">value</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">})</span>\n<span class=\"p\">})</span>\n</code></pre></div><p>对象的每个属性都给了一个依赖实例, 管理自己的依赖. 考虑到 <b>customer</b> 有很多个, 需要通知到位. </p><p>另外, 添加依赖和管理依赖, 前者是因, 后者是果. 在管理之前我们需要想好怎么添加依赖. </p><p>回头看一看.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 总消费计算方式\n</span><span class=\"c1\"></span><span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">info</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">VIP</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"nx\">data</span><span class=\"p\">.</span><span class=\"nx\">price</span> <span class=\"o\">*</span> <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">quantity</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">total</span> <span class=\"o\">=</span> <span class=\"nx\">data</span><span class=\"p\">.</span><span class=\"nx\">price</span> <span class=\"o\">*</span> <span class=\"nx\">data</span><span class=\"p\">.</span><span class=\"nx\">discount</span> <span class=\"o\">*</span> <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">quantity</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 获取购买时间\n</span><span class=\"c1\"></span><span class=\"nx\">purchaseTime</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">info</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">info</span><span class=\"p\">.</span><span class=\"nx\">timeStamp</span> <span class=\"o\">=</span> <span class=\"nb\">Date</span><span class=\"p\">.</span><span class=\"nx\">now</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>我们发现, <b>total</b> 函数依赖于 <code>data.price</code> 或 <code>data.discount</code> 的. 如果我们在获取属性时去添加依赖倒是一个好时机.</p><div class=\"highlight\"><pre><code class=\"language-diff\">class Dependency {\n    // 省略\n}\n<span class=\"gi\">+   Dependency.targey = null;\n</span><span class=\"gi\"></span>\nclass Watcher {\n    constructor(fn, key) {\n        this.update = fn\n<span class=\"gi\">+        this.key = key\n</span><span class=\"gi\">+        this.value = this.getter()\n</span><span class=\"gi\"></span>    }\n<span class=\"gi\">+    getter() {\n</span><span class=\"gi\">+        Dependency.targey = this;\n</span><span class=\"gi\">+        // 触发下面的get()\n</span><span class=\"gi\">+        this.value = data[this.key];\n</span><span class=\"gi\">+        Dependency.targey = null;\n</span><span class=\"gi\">+    }\n</span><span class=\"gi\"></span>}\n\nObject.keys(data).forEach(key =&gt; {\n    let value = data[key]\n    const dep = new Dependency()\n    Object.defineProperty(data, key, {\n        set(newVal) {\n            value = newVal\n            dep.notify()\n        },\n        get() {\n<span class=\"gi\">+            if (Dependency.targey) {\n</span><span class=\"gi\">+                dep.addObserver(Dependency.targey)\n</span><span class=\"gi\">+            }\n</span><span class=\"gi\"></span>            return value\n        }\n    })\n})\n</code></pre></div><p>然而 <b>purchaseTime</b> 方法里并没有 <code>data.price</code> 或 <code>data.discount</code> 可以设置. 所以这个方法行不通. 那么, 干脆紧接着依赖实例去添加依赖吧. 同时考虑到多个 <b>customer</b>, 我们封装下.</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 与defineProperty结合\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">defineReactive</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">,</span> <span class=\"nx\">watcherList</span><span class=\"p\">,</span> <span class=\"nx\">funcList</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">keys</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">).</span><span class=\"nx\">forEach</span><span class=\"p\">(</span><span class=\"nx\">key</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">value</span> <span class=\"o\">=</span> <span class=\"nx\">data</span><span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">]</span>\n    <span class=\"k\">const</span> <span class=\"nx\">dep</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Dependency</span><span class=\"p\">()</span>\n    <span class=\"nx\">funcList</span><span class=\"p\">.</span><span class=\"nx\">forEach</span><span class=\"p\">(</span><span class=\"nx\">func</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">dep</span><span class=\"p\">.</span><span class=\"nx\">addObserver</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">Watcher</span><span class=\"p\">(</span><span class=\"nx\">func</span><span class=\"p\">))</span>\n    <span class=\"p\">})</span>\n    <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">defineProperty</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n      <span class=\"nx\">set</span><span class=\"p\">(</span><span class=\"nx\">newVal</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">value</span> <span class=\"o\">=</span> <span class=\"nx\">newVal</span>\n        <span class=\"nx\">watcherList</span><span class=\"p\">.</span><span class=\"nx\">forEach</span><span class=\"p\">(</span><span class=\"nx\">watcher</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n          <span class=\"nx\">dep</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">(</span><span class=\"nx\">watcher</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n      <span class=\"p\">},</span>\n      <span class=\"nx\">get</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nx\">value</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">})</span>\n  <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">defineReactive</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"nx\">customer</span><span class=\"p\">,</span> <span class=\"nx\">customer1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"nx\">total</span><span class=\"p\">,</span> <span class=\"nx\">purchaseTime</span><span class=\"p\">])</span>\n</code></pre></div><p>大功告成, 价格变动时, 我们就会自动获取到想要的结果了. </p><p>我都能自理了, 你花呗为嘛还不能自己还钱呢😒</p><p><b>观察者模式系列:</b></p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//www.yexiaochen.com/%25E4%25BB%258E%25E8%25A7%2582%25E5%25AF%259F%25E8%2580%2585%25E6%25A8%25A1%25E5%25BC%258F%25E8%25AF%25B4%25E8%25B5%25B7/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从观察者模式说起</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.yexiaochen.com/%25E8%25BF%259B%25E5%2587%25BB%25E7%259A%2584%25E8%25A7%2582%25E5%25AF%259F%25E8%2580%2585%25E6%25A8%25A1%25E5%25BC%258F/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">进击的观察者模式</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.yexiaochen.com/%25E8%25A7%2582%25E5%25AF%259F%25E8%2580%2585%25E6%25A8%25A1%25E5%25BC%258F%25E5%2586%258D%25E6%25AC%25A1%25E8%25BF%259B%25E9%2598%25B6/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">观察者模式再次进阶-发布/订阅</a></li></ul>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }, 
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }
            ], 
            "comments": [
                {
                    "userName": "呵呵哒", 
                    "userLink": "https://www.zhihu.com/people/39a3bcb9da54b1a65eab6cd51476042d", 
                    "content": "这篇文章应该改为从vue源码看观察者模式[机智]", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "这话我不敢说，因为我没看过vue源码[捂脸]", 
                            "likes": 0, 
                            "replyToAuthor": "呵呵哒"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61018434", 
            "userName": "曉宸", 
            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
            "upvote": 157, 
            "title": "从前端角度彻底搞懂 DIP、IoC、DI、JS", 
            "content": "<p>在这个标题中，除了 <b>JS</b> 是乱入之外，其它的几个词汇都是存在一个共同点的，那就是依赖。</p><blockquote>那么，依赖是什么呢？</blockquote><p>比如，现在我正在写这篇博客文，但是我得在电脑上编辑，电脑便是我完成这件事的依赖。而在代码中，最直观的体现是模块之间的依赖。如某个模块依赖另外一个模块，那么另外的那个模块就是该模块的依赖。其实在上篇博客文章《<a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/JaVaScript%25E4%25B8%25AD%25E7%259A%2584%25E6%25A8%25A1%25E5%259D%2597/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JaVaScript中的模块</a>》中，我们也手写了一个模块依赖管理器。</p><p>依赖这个理解起来很简单，但这不代表可以随意的依赖。在写模块的时候，讲究个高内聚低耦合，以提高模块的可拓展性和可维护性。模块依赖了谁，怎么去依赖，都关乎了最终模块的好与坏。</p><p>还好在编程界有着提高代码质量的金科玉律，我们可以用理论来指导实践，写出更好的代码。</p><h2>依赖反转原则</h2><blockquote>依赖反转原则（Dependency inversion principle，DIP），是一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。———— 维基百科</blockquote><p>该原则规定：</p><ol><li>高层次的模块不应该依赖与低层次的模块，两者都应该依赖于抽象接口。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li></ol><p>现在用一个例子来解释一波。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Ajax.js\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Ajax</span> <span class=\"p\">{</span>\n  <span class=\"nx\">get</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Ajax</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// main.js\n</span><span class=\"c1\"></span><span class=\"k\">import</span> <span class=\"nx\">Ajax</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Ajax&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">class</span> <span class=\"nx\">Main</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">()</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">render</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">content</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">Ajax</span><span class=\"p\">()).</span><span class=\"nx\">get</span><span class=\"p\">();</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;content from&#39;</span><span class=\"p\">,</span> <span class=\"nx\">content</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">new</span> <span class=\"nx\">Main</span><span class=\"p\">();</span>\n</code></pre></div><p>刚开始的时候，我们基于 <b>XMLHttpRequest</b> 对象，封装了 Ajax 用于请求数据。后来 <b>fetch</b> 出来了，我们打算跟上时代的脚步，封装 <b>fetch</b> 以取代 <b>Ajax</b>。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Fetch.js\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Fetch</span> <span class=\"p\">{</span>\n  <span class=\"nx\">fetch</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Fetch</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// main.js\n</span><span class=\"c1\"></span><span class=\"k\">import</span> <span class=\"nx\">Fetch</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Fetch&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">class</span> <span class=\"nx\">Main</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">render</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">content</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">Fetch</span><span class=\"p\">()).</span><span class=\"nx\">fetch</span><span class=\"p\">();</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;content from&#39;</span><span class=\"p\">,</span> <span class=\"nx\">content</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">new</span> <span class=\"nx\">Main</span><span class=\"p\">();</span>\n</code></pre></div><p>从以上可以看出来，整个替代过程很麻烦，我们需要找出封装请求模块（<b>Ajax</b>、<b>Fetch</b>）的所有引用，然后替换掉。又由于 <b>Ajax</b>、<b>Fetch</b> 的方法命名也是不同，所以也需要对应地做更改。</p><p>这就是传统的处理依赖关系的方式。在这里 <b>Main</b> 是高层次模块，<b>Ajax</b>、<b>Fetch</b> 是低层次模块。依赖关系创建于高层次模块，且高层次模块直接依赖低层次模块，这种依赖关系限制了高层次模块的复用性。</p><p>依赖反转原则则颠倒这种依赖关系，并以上面提到的两个规定作为指导思想。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Service.js\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Service</span> <span class=\"p\">{</span>\n  <span class=\"nx\">request</span><span class=\"p\">(){</span>\n    <span class=\"k\">throw</span> <span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\"> 没有实现 request 方法！`</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">class</span> <span class=\"nx\">Ajax</span> <span class=\"k\">extends</span> <span class=\"nx\">Service</span> <span class=\"p\">{</span>\n  <span class=\"nx\">request</span><span class=\"p\">(){</span>\n      <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Ajax</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Main.js\n</span><span class=\"c1\"></span><span class=\"k\">import</span> <span class=\"nx\">Service</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Service.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">class</span> <span class=\"nx\">Main</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">render</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">content</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">Service</span><span class=\"p\">).</span><span class=\"nx\">request</span><span class=\"p\">();</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;content from&#39;</span><span class=\"p\">,</span> <span class=\"nx\">content</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">new</span> <span class=\"nx\">Main</span><span class=\"p\">();</span>\n</code></pre></div><p>在这里我们把共同依赖的 <b>Service</b> 作为抽象接口，它就是高层次模块与低层次模块需要共同遵守的契约。在高层次模块中，它会默认 <b>Service</b> 会有 <b>request</b> 方法用来请求数据。在低层次模块中，它会遵从 <b>Service</b> 复写应该存在的方法。这在《<a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/%25E5%259C%25A8JavaScript%25E4%25B8%25AD%25E5%25B0%259D%25E8%25AF%2595%25E7%25BB%2584%25E5%2590%2588%25E6%25A8%25A1%25E5%25BC%258F/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在JavaScript中尝试组合模式</a>》中，无论分支对象还是叶对象都实现 <code>expense()</code> 方法的道理差不多。</p><p>即使后来需要封装 <b>axios</b> 取代 <b>fetch</b>，我们也只需要在 <b>Service.js</b> 中修改即可。</p><p>再次回顾下传统的依赖关系。</p><blockquote>依赖关系创建于高层次模块，且高层次模块直接依赖低层次模块。</blockquote><p>经过以上的折腾，我们充其量只是解决了高层次模块直接依赖低层次模块的问题。那么依赖关系创建于高层次模块的问题呢？</p><h2>控制反转</h2><p>如果说依赖反转原则告诉我们该依赖谁，那么控制反转则告诉们谁应该来控制依赖。</p><p>像上面的 <b>Main</b> 模块，它依赖 <b>Service</b> 模块。为了获得 <b>Service</b> 实例的引用，<b>Main</b> 在内部靠自身 <code>new</code> 出了一个 <b>Service</b> 实例。这样明显地引用其它模块，无异加大了模块间的耦合。</p><blockquote>控制反转（Inversion of Control，IoC），通过控制反转，对象在被创建的时候，有一个控制系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。可以说，依赖被注入到对象中。———— 维基百科</blockquote><p>这些话的意思就是将依赖对象的创建和绑定转移到被依赖对象类的外部来实现。实现控制反转最常见的方式是依赖注入，还有一种方式依赖查找。</p><h3>依赖注入</h3><blockquote>依赖注入（Dependency Injection，DI），在软件工程中，依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端）。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务将会变成客户端的状态的一部分。传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。</blockquote><p>没看懂？没关系。这句话讲的是，把过程放在外面，将结果带入内部。在《<a href=\"https://link.zhihu.com/?target=http%3A//www.yexiaochen.com/JaVaScript%25E4%25B8%25AD%25E7%259A%2584%25E6%25A8%25A1%25E5%259D%2597/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JaVaScript中的模块</a>》中，我们已经用到过依赖注入，就是<code>对于依赖模块的模块，则把依赖作为参数使用</code>。</p><p>所以我们再次改造下，</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Service.js\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Service</span> <span class=\"p\">{</span>\n  <span class=\"nx\">request</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">throw</span> <span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\"> 没有实现 request 方法！`</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">class</span> <span class=\"nx\">Ajax</span> <span class=\"k\">extends</span> <span class=\"nx\">Service</span> <span class=\"p\">{</span>\n  <span class=\"nx\">request</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Ajax</span><span class=\"p\">;</span>\n<span class=\"c1\">// Main.js\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Main</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">Service</span> <span class=\"o\">=</span> <span class=\"nx\">options</span><span class=\"p\">.</span><span class=\"nx\">Service</span><span class=\"p\">;</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">render</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">content</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">Service</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">();</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;content from&#39;</span><span class=\"p\">,</span> <span class=\"nx\">content</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Main</span><span class=\"p\">;</span>\n<span class=\"c1\">// index.js\n</span><span class=\"c1\"></span><span class=\"k\">import</span> <span class=\"nx\">Service</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Service.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"nx\">Main</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Main.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">new</span> <span class=\"nx\">Main</span><span class=\"p\">({</span>\n  <span class=\"nx\">Service</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"nx\">Service</span><span class=\"p\">()</span>\n<span class=\"p\">})</span>\n</code></pre></div><p>在 <b>Main</b> 模块中, <b>Service</b> 的实例化是在外部完成，并在 <code>index.js</code> 中注入。相比上一次，改动后的代码并没有看出带来多大的好处。如果我们再增加一个模块呢？</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Router</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">init</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">init</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Router::init&#39;</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Router</span><span class=\"p\">;</span>\n<span class=\"err\">#</span> <span class=\"nx\">Main</span><span class=\"p\">.</span><span class=\"nx\">js</span>\n<span class=\"o\">+</span>   <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">Service</span> <span class=\"o\">=</span> <span class=\"nx\">options</span><span class=\"p\">.</span><span class=\"nx\">Router</span><span class=\"p\">;</span>\n\n<span class=\"err\">#</span> <span class=\"nx\">index</span><span class=\"p\">.</span><span class=\"nx\">js</span>\n<span class=\"o\">+</span>   <span class=\"k\">import</span> <span class=\"nx\">Router</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Router.js&#39;</span>\n    <span class=\"k\">new</span> <span class=\"nx\">Main</span><span class=\"p\">({</span>\n<span class=\"o\">+</span>        <span class=\"nx\">Router</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"nx\">Service</span><span class=\"p\">()</span>\n    <span class=\"p\">})</span>\n</code></pre></div><p>若是内部实例化就不好处理了。可换成依赖注入后，这个问题就很好解决了。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// utils.js\n</span><span class=\"c1\"></span><span class=\"k\">export</span> <span class=\"k\">const</span> <span class=\"nx\">toOptions</span> <span class=\"o\">=</span> <span class=\"nx\">params</span> <span class=\"p\">=&gt;</span>\n  <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">entries</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">).</span><span class=\"nx\">reduce</span><span class=\"p\">((</span><span class=\"nx\">accumulator</span><span class=\"p\">,</span> <span class=\"nx\">currentValue</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">accumulator</span><span class=\"p\">[</span><span class=\"nx\">currentValue</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">currentValue</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]()</span>\n    <span class=\"k\">return</span> <span class=\"nx\">accumulator</span><span class=\"p\">;</span>\n  <span class=\"p\">},</span> <span class=\"p\">{});</span>\n\n<span class=\"c1\">// Main.js\n</span><span class=\"c1\"></span><span class=\"k\">class</span> <span class=\"nx\">Main</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">assign</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"nx\">options</span><span class=\"p\">);</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">render</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">content</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">Service</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">();</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;content from&#39;</span><span class=\"p\">,</span> <span class=\"nx\">content</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Main</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// index.js\n</span><span class=\"c1\"></span><span class=\"k\">import</span> <span class=\"nx\">Service</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Service.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"nx\">Router</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Router.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"nx\">Main</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Main.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">toOptions</span> <span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./utils.js&#39;</span>\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * toOptions 转换成参数形式\n</span><span class=\"cm\"> * @params {Object} 类\n</span><span class=\"cm\"> * @return {Object} {Service: Service实例, Router: Router实例}\n</span><span class=\"cm\"> */</span>\n<span class=\"k\">const</span> <span class=\"nx\">options</span> <span class=\"o\">=</span> <span class=\"nx\">toOptions</span><span class=\"p\">({</span><span class=\"nx\">Service</span><span class=\"p\">,</span> <span class=\"nx\">Router</span><span class=\"p\">});</span>\n<span class=\"k\">new</span> <span class=\"nx\">Main</span><span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">);</span>\n</code></pre></div><p>因为依赖注入把依赖的引用从外部引入，所以这里使用 <code>Object.assign(this, options)</code> 方式，把依赖全部加到了 <b>this</b> 上。即使再增加模块，也只需要在 <code>index.js</code> 中引入即可。</p><p>到了这里，<b>DIP</b>、<b>IoC</b>、<b>DI</b> 的概念应该有个清晰的认识了。然后我们再结合实际，加个功能再次巩固以下。</p><p>作为一个功能独立的模块，一般都有个初始化的过程。</p><p>现在我们要做的是遵守一个初始化的约定，定义一个抽象接口，</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Interface.js\n</span><span class=\"c1\"></span><span class=\"k\">export</span> <span class=\"k\">class</span> <span class=\"nx\">Service</span> <span class=\"p\">{</span>\n  <span class=\"nx\">request</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">throw</span> <span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\"> 没有实现 request 方法！`</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">class</span> <span class=\"nx\">Init</span> <span class=\"p\">{</span>\n  <span class=\"nx\">init</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">throw</span> <span class=\"sb\">`</span><span class=\"si\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\"> 没有实现 init 方法！`</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// Service.js\n</span><span class=\"c1\"></span><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">Init</span><span class=\"p\">,</span> <span class=\"nx\">Service</span> <span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Interface.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">mix</span> <span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./utils.js&#39;</span>\n<span class=\"k\">class</span> <span class=\"nx\">Ajax</span> <span class=\"k\">extends</span> <span class=\"nx\">mix</span><span class=\"p\">(</span><span class=\"nx\">Init</span><span class=\"p\">,</span> <span class=\"nx\">Service</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">super</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">init</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Service::init&#39;</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">request</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Ajax</span><span class=\"p\">;</span>\n</code></pre></div><p><b>Main</b>、<b>Service</b>、<b>Router</b> 都依赖 <b>Init</b> 接口（在这里就是一种协定），<b>Service</b> 模块比较特殊，所以做了 <b>Mixin</b> 处理。要做到统一初始化，<b>Main</b> 还需要做些事。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Main.js\n</span><span class=\"c1\"></span><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">Init</span> <span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Interface.js&#39;</span>\n<span class=\"k\">class</span> <span class=\"nx\">Main</span> <span class=\"k\">extends</span> <span class=\"nx\">Init</span> <span class=\"p\">{</span>\n  <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">super</span><span class=\"p\">();</span>\n    <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">assign</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"nx\">options</span><span class=\"p\">);</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">options</span> <span class=\"o\">=</span> <span class=\"nx\">options</span><span class=\"p\">;</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">init</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"p\">(</span><span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">values</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">options</span><span class=\"p\">)).</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nx\">item</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">item</span><span class=\"p\">.</span><span class=\"nx\">init</span><span class=\"p\">());</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Main::init&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"nx\">render</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">content</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">Service</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">();</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;content from&#39;</span><span class=\"p\">,</span> <span class=\"nx\">content</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Main</span><span class=\"p\">;</span>\n</code></pre></div><p>至此，结束</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// index.js\n</span><span class=\"c1\"></span><span class=\"k\">import</span> <span class=\"nx\">Service</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Service.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"nx\">Router</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Router.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"nx\">Main</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./Main.js&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">toOptions</span> <span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./utils.js&#39;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * toOptions\n</span><span class=\"cm\"> * 转换成参数形式\n</span><span class=\"cm\"> * @params {Object} 类\n</span><span class=\"cm\"> * @return {Object}\n</span><span class=\"cm\"> * {\n</span><span class=\"cm\"> *    Service: Service实例,\n</span><span class=\"cm\"> *    Router: Router实例\n</span><span class=\"cm\"> * }\n</span><span class=\"cm\"> */</span>\n<span class=\"k\">const</span> <span class=\"nx\">options</span> <span class=\"o\">=</span> <span class=\"nx\">toOptions</span><span class=\"p\">({</span> <span class=\"nx\">Service</span><span class=\"p\">,</span> <span class=\"nx\">Router</span> <span class=\"p\">});</span>\n\n<span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">Main</span><span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">)).</span><span class=\"nx\">init</span><span class=\"p\">();</span>\n\n<span class=\"c1\">//  content from Ajax\n</span><span class=\"c1\">//  Service::init\n</span><span class=\"c1\">//  Router::init\n</span><span class=\"c1\">//  Main::init\n</span></code></pre></div><p>以上所有示例可见<a href=\"https://link.zhihu.com/?target=https%3A//github.com/yexiaochen/DIP\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GitHub</a>。</p>", 
            "topic": [
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }
            ], 
            "comments": [
                {
                    "userName": "朕非圣贤", 
                    "userLink": "https://www.zhihu.com/people/92ecd429863652e2576e0a402d5c9eb5", 
                    "content": "首赞，首评，顺带手动三连，建议知乎以后双击功能添加上。哈哈哈", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "<a class=\"comment_sticker\" href=\"https://pic3.zhimg.com/v2-6eeb544aa5ce6be1e6a6add75e436746.gif\" data-width=\"\" data-height=\"\">[哈哈]</a>", 
                            "likes": 1, 
                            "replyToAuthor": "朕非圣贤"
                        }
                    ]
                }, 
                {
                    "userName": "「已注销」", 
                    "userLink": "https://www.zhihu.com/people/07064391353c4edfb693488768960065", 
                    "content": "很容易看懂。谢谢分享", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "<a href=\"https://pic3.zhimg.com/v2-6eeb544aa5ce6be1e6a6add75e436746.gif\" class=\"comment_sticker\" data-width=\"0\" data-height=\"0\" data-sticker-id=\"951517104676491264\">[哈哈]</a>", 
                            "likes": 1, 
                            "replyToAuthor": "「已注销」"
                        }
                    ]
                }, 
                {
                    "userName": "颜生", 
                    "userLink": "https://www.zhihu.com/people/3bf741dd54a4319e718d11fcaeb0f57a", 
                    "content": "马克", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "<a href=\"https://pic3.zhimg.com/v2-6eeb544aa5ce6be1e6a6add75e436746.gif\" class=\"comment_sticker\" data-width=\"0\" data-height=\"0\" data-sticker-id=\"951517104676491264\">[哈哈]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "颜生"
                        }
                    ]
                }, 
                {
                    "userName": "没有故事的羊小咩", 
                    "userLink": "https://www.zhihu.com/people/fce1e804a50d90c671243d6fca237cda", 
                    "content": "<p>通俗易懂</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "<a href=\"https://pic3.zhimg.com/v2-6eeb544aa5ce6be1e6a6add75e436746.gif\" class=\"comment_sticker\" data-width=\"0\" data-height=\"0\" data-sticker-id=\"951517104676491264\">[哈哈]</a>", 
                            "likes": 1, 
                            "replyToAuthor": "没有故事的羊小咩"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "本质上都是干一种事，那就是依赖解耦，那些人造了一堆名词概念～", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "曉宸", 
                            "userLink": "https://www.zhihu.com/people/0143390ef10b928cd675db4c322045e8", 
                            "content": "是的，其实项目中好多地方已经用上了，却不知道还有这样的叫法<a href=\"https://pic3.zhimg.com/v2-6eeb544aa5ce6be1e6a6add75e436746.gif\" class=\"comment_sticker\" data-width=\"0\" data-height=\"0\" data-sticker-id=\"951517104676491264\">[哈哈]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1072861698884673536"
}
