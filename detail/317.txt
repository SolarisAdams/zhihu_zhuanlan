{
    "title": "Notes on Data Science", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/xu-bing-11-45", 
        "https://www.zhihu.com/people/rongshan-13", 
        "https://www.zhihu.com/people/evan-22-60", 
        "https://www.zhihu.com/people/jerry-72-49", 
        "https://www.zhihu.com/people/xiao-yao-zi-qing-73", 
        "https://www.zhihu.com/people/lan-lan-lan-lan-96-82", 
        "https://www.zhihu.com/people/liu-fei-94-95", 
        "https://www.zhihu.com/people/wang-ming-feng-44", 
        "https://www.zhihu.com/people/xu-ming-ming-78-15"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/80236325", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 1, 
            "title": "celery原理初探", 
            "content": "<h3><b>消费者模型</b></h3><p>celery是一个分布式任务队列，架构是比较典型的消费者模型，如下图所示。绿色的是生产者，是发布任务的客户端。蓝色的是消费者，每一个消费者有一个主进程负责调度任务，同时有一个或多个子进程负责执行任务。client和worker之间的消息传递通过红色的broker，celery的broker依赖于第三方的消息队列，如redis、rabbitMQ等。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a0aa6455b4ab29a4bf81611ab558aa76_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1446\" data-rawheight=\"418\" class=\"origin_image zh-lightbox-thumb\" width=\"1446\" data-original=\"https://pic3.zhimg.com/v2-a0aa6455b4ab29a4bf81611ab558aa76_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1446&#39; height=&#39;418&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1446\" data-rawheight=\"418\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1446\" data-original=\"https://pic3.zhimg.com/v2-a0aa6455b4ab29a4bf81611ab558aa76_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a0aa6455b4ab29a4bf81611ab558aa76_b.jpg\"/></figure><h3><b>application</b></h3><p>worker端主要负责从broker拉取任务，并分配给子进程，client端则主要负责将任务发送到broker。这两部分功能封装在了同一个类里：<code>Celery</code>。不论是worker端还是client端，都需要实例化这个类，并且配置好相应的broker。这个类的实例叫做application。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">from</span> <span class=\"nn\">celery</span> <span class=\"kn\">import</span> <span class=\"n\">Celery</span>\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Celery</span><span class=\"p\">()</span>\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">broker_url</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;redis://120.0.0.1:6379/0&#39;</span></code></pre></div><p>application最重要的配置之一就是broker的配置，broker配置相同的applicatio即使在不同的主机上也可以互相传递信息。默认参数下，配置相同的application会读写broker中的同一个队列。</p><h3><b>task</b></h3><p>任务最基本的形式就是函数，任务发布最直接的想法就是client将要执行的相关函数代码打包，发布到broker。分布式计算框架spark就是使用这种方式。2.0之前的celery也支持这种任务发布的方式：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">from</span> <span class=\"nn\">celery.execute</span> <span class=\"kn\">import</span> <span class=\"n\">apply_async</span>\n<span class=\"k\">def</span> <span class=\"nf\">hello</span><span class=\"p\">():</span>\n  <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;hello&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">apply_async</span><span class=\"p\">(</span><span class=\"n\">hello</span><span class=\"p\">)</span></code></pre></div><p>这种方式显而易见的一个坏处是传递给broker的数据量可能会比较大。解决的办法也很容易想到，就是把要发布的任务相关的代码，提前告诉worker：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"nd\">@app.task</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;hello_task&#39;</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">hello</span><span class=\"p\">():</span>\n  <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;hello&#39;</span><span class=\"p\">)</span></code></pre></div><p>其中的app是worker中的application，通过装饰器的方式，对任务函数注册。app会维护一个字典，key是任务的名字，也就是这里的<code>hello_task</code>，value是这个函数的内存地址。任务名必须唯一，但是任务名这个参数不是必须的，如果没有给这个参数，celery会自动根据包的路径和函数名生成一个任务名。</p><p>通过上面这种方式，client发布任务只需要提供任务名以及相关参数，不必提供任务相关代码：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\"># client端</span>\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">send_task</span><span class=\"p\">(</span><span class=\"s1\">&#39;hello_task&#39;</span><span class=\"p\">)</span></code></pre></div><p>这里需要注意：client发布任务后，任务会以一个消息的形式写入broker队列，带有任务名称等相关参数，等待worker获取。这里任务的发布，是完全独立于worker端的，即使worker没有启动，消息也会被写入队列。</p><p>这种方式也有显而易见的坏处，所有要执行的任务代码都需要提前在worker端注册好，client端和worker端的耦合变强了。celery下面的另一个常用特性又进一步增加了两者的耦合，甚至造成概念上的混乱。</p><h3><b>delay</b></h3><p>celery为了尽可能“简化”任务的发布，尽量将任务的发布封装成和原始函数的调用方式一致，提供了另一种发布任务的方法。也就是在celery文档开始展示的delay方法。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;hello_task&#39;</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">hello</span><span class=\"p\">():</span>\n  <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;hello&#39;</span><span class=\"p\">)</span>\n  \n<span class=\"n\">hello</span><span class=\"o\">.</span><span class=\"n\">delay</span><span class=\"p\">()</span></code></pre></div><p>上面的代码是client端的代码。在client端，同样对要发布的任务函数做了注册。然后delay方法会从客户端的application里获取任务名，并调用<code>send_task</code>。需要注意的是worker端和client端的任务名要保持一致。</p><p>这种方式的好处有两个：</p><ol><li>任务的发布和原始函数的调用非常类似，代码的可读性更好一些。</li><li>如果把任务函数的注册和调用分开，worker端和client端实际上可以使用相同的代码做任务函数的注册。</li></ol><p>坏处则是容易引起一些混淆。当使用<code>celery -A project worker</code>启动woker端时，代码的作用以及其中的application和client端是两码事。总之，celery的架构中消费者和生产者并没有通过broker完全解耦，任务函数是需要提前约定好的，celery文档中也提到了这个缺点：</p><blockquote>When tasks are sent, no actual function code is sent with it, just the name of the task to execute. When the worker then receives the message it can look up the name in its task registry to find the execution code.<br/>This means that your workers should always be updated with the same software as the client. This is a drawback, but the alternative is a technical challenge that’s yet to be solved.</blockquote><p>接下来比较重要的问题就是worker端启动时做了什么，不同的进程是如何初始化的（尤其是涉及数据库的连接部分）。</p>", 
            "topic": [
                {
                    "tag": "celery", 
                    "tagLink": "https://api.zhihu.com/topics/20061668"
                }, 
                {
                    "tag": "Celery（Distributed Task Queue）", 
                    "tagLink": "https://api.zhihu.com/topics/20203769"
                }, 
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74706972", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 0, 
            "title": "使用python对AppStore抓包", 
            "content": "<h3><b>背景</b></h3><p>苹果官方提供了一部分<a href=\"https://link.zhihu.com/?target=https%3A//affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">API</a>，但是功能有限。如果希望抓取AppStore的数据，比如应用信息、搜索列表、榜单等，需要通过抓包的方式获取相应的接口。然后通过接口爬取相应的数据。</p><p>手机抓包的工具很多，这里使用的是mitmproxy。对于http请求，可以直接抓取。对于https请求，mitmproxy采用类似于中间人攻击的方式，只不过不是诱导用户安装非法证书，而是手动在手机端安装并信任mitmproxy证书。但是对于AppStore，由于它内置了苹果的证书（certificate pinning），使用伪造证书的方式是不可行的。解决的办法是禁用苹果的SSL验证：先越狱，然后安装<a href=\"https://link.zhihu.com/?target=https%3A//github.com/nabla-c0d3/ssl-kill-switch2\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ssl-kill-switch2</a>。</p><h3><b>mitmproxy抓包</b></h3><ol><li>在电脑端安装mitmproxy：<code>pip install mitmproxy</code></li><li>抓包脚本非常简单，mitmproxy提供了<a href=\"https://link.zhihu.com/?target=https%3A//docs.mitmproxy.org/stable/addons-overview/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">addon机制</a>，可以通过提供相应事件名命名的方法，修改mitmproxy对相应事件的处理。比如下面的脚本，对于所有的<code>request</code>都会解析request并打印到日志。</li><li>启动代理<code>mitmdump -s script.py -p 8888</code>。将手机和pc置于同一局域网下，在手机上设置代理：设置 &gt; 无线局域网 &gt; http代理 &gt; 手动填入pc的局域网ip和端口。</li></ol><p>抓包脚本：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\"># </span>\n<span class=\"c1\"># file name: script.py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">json</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Test</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">flow</span><span class=\"p\">):</span>\n        <span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"n\">flow</span><span class=\"o\">.</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">text</span>\n        <span class=\"n\">rq</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n                <span class=\"s1\">&#39;url&#39;</span><span class=\"p\">:</span> <span class=\"n\">flow</span><span class=\"o\">.</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">pretty_url</span><span class=\"p\">,</span>\n                <span class=\"s1\">&#39;query&#39;</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">flow</span><span class=\"o\">.</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">),</span>\n                <span class=\"s1\">&#39;method&#39;</span><span class=\"p\">:</span> <span class=\"n\">flow</span><span class=\"o\">.</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">method</span><span class=\"p\">,</span>\n                <span class=\"s1\">&#39;headers&#39;</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">flow</span><span class=\"o\">.</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">headers</span><span class=\"p\">),</span>\n                <span class=\"s1\">&#39;cookies&#39;</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">flow</span><span class=\"o\">.</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">cookies</span><span class=\"p\">),</span>\n                <span class=\"s1\">&#39;text&#39;</span><span class=\"p\">:</span> <span class=\"n\">text</span><span class=\"p\">,</span>\n                <span class=\"s1\">&#39;ts_start&#39;</span><span class=\"p\">:</span> <span class=\"n\">flow</span><span class=\"o\">.</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">timestamp_start</span><span class=\"p\">,</span>\n                <span class=\"s1\">&#39;ts_end&#39;</span><span class=\"p\">:</span> <span class=\"n\">flow</span><span class=\"o\">.</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">timestamp_end</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">&#39;request-json:</span><span class=\"si\">{}</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">rq</span><span class=\"p\">,</span> <span class=\"n\">ensure_ascii</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)))</span>\n\n<span class=\"n\">addons</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"n\">Test</span><span class=\"p\">()</span>\n<span class=\"p\">]</span></code></pre></div><h3><b>例子：苹果应用商店搜索结果</b></h3><p>搜索请求的抓包结果如下，使用相应的url和参数即可在pc端的爬虫里爬取AppStore的数据。需要注意的有两个地方：一个是有些headers里的参数不是必需的，爬虫里可以省去；另一个是有些参数可能有过期时间，需要定期更新。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-70e40591d10bfb4d98f220f5278d9448_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"809\" data-rawheight=\"758\" class=\"origin_image zh-lightbox-thumb\" width=\"809\" data-original=\"https://pic1.zhimg.com/v2-70e40591d10bfb4d98f220f5278d9448_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;809&#39; height=&#39;758&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"809\" data-rawheight=\"758\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"809\" data-original=\"https://pic1.zhimg.com/v2-70e40591d10bfb4d98f220f5278d9448_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-70e40591d10bfb4d98f220f5278d9448_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "App Store", 
                    "tagLink": "https://api.zhihu.com/topics/19555322"
                }, 
                {
                    "tag": "抓包", 
                    "tagLink": "https://api.zhihu.com/topics/19649993"
                }, 
                {
                    "tag": "python爬虫", 
                    "tagLink": "https://api.zhihu.com/topics/20086364"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70895268", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 0, 
            "title": "mongo锁机制简介", 
            "content": "<h3><b>背景</b></h3><p>锁机制要解决的是并发请求下资源分配的问题，对于数据库来说，就是并发的读写。锁机制要处理两个问题，一个是最基本的，要保证写的原子性，否则会在并发情况下产生混乱。另一个是提高并发效率。</p><h3><b>锁的类型</b></h3><p>锁加在被请求的资源上，用于标明资源当前的状态。从能否被多个用户共享的角度来说，锁有两种类型：用于读的共享锁（S）和用于写的排它锁（X）。</p><p>每一个对资源的请求，都需要首先确保请求的资源上有相应的锁。比如对某个文档的读请求，要先给它加上用于读的S锁，被S锁住的资源不能再加上X锁，确保读的过程中资源不会被改写。同时这个S锁本身是共享的，它锁住的资源可以被其他并发的读请求获取。而写锁是排他的，同一个资源的写锁，只能被单个的请求持有。这种机制即保证了写的原子性（X锁排他），又保证了读的并发性（S锁共享）。</p><p>上面这种处理并发的方式，叫做<b>悲观并发控制</b>（pessimistic concurrency control），也叫<b>悲观锁</b>。每一个读写请求都要检查相应的锁，有了对应的锁才进行后续操作，严格的杜绝了数据的混乱。同时悲观锁的代价是要消耗CPU资源去做锁相关的操作，请求可能会互相阻塞，甚至发生死锁。比如两个写请求A和B同时请求a、b两个资源。如果A给a加上了锁，还没给b加上锁；B给b加上了锁，还没有给a加上锁，就会导致死锁。</p><h3><b>锁的粒度</b></h3><p>随着mongo版本的迭代，锁的粒度越来越精细。对于mongo3.0之后的默认引擎WiredTiger，锁的粒度最小是文档级别的。对于MMAPv1存储引擎最小粒度的锁是表级别的，对一个表的读写操作会锁住整个表，即使这个操作只涉及了少数几条记录。一般来说，锁的粒度越大，越不容易产生死锁，锁的控制就会越简单。同时带来的代价是并发性能变差。</p><p>上面锁的粒度是从空间上来说的，从时间粒度上，悲观锁是在读写操作的整个过程上加了锁。整个读或者写的过程上是互相阻塞的。很自然的，如果减少时间维度上锁的粒度，会带来并发上的好处。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f61a26b3bd409f71e262d3782ef5ab9a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"784\" data-rawheight=\"205\" class=\"origin_image zh-lightbox-thumb\" width=\"784\" data-original=\"https://pic3.zhimg.com/v2-f61a26b3bd409f71e262d3782ef5ab9a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;784&#39; height=&#39;205&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"784\" data-rawheight=\"205\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"784\" data-original=\"https://pic3.zhimg.com/v2-f61a26b3bd409f71e262d3782ef5ab9a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f61a26b3bd409f71e262d3782ef5ab9a_b.jpg\"/></figure><p>比如，只给”写入“的步骤加锁，改成下面这种方式：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-19f36707741dd5a5b0d02802853f3565_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"889\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb\" width=\"889\" data-original=\"https://pic2.zhimg.com/v2-19f36707741dd5a5b0d02802853f3565_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;889&#39; height=&#39;270&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"889\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"889\" data-original=\"https://pic2.zhimg.com/v2-19f36707741dd5a5b0d02802853f3565_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-19f36707741dd5a5b0d02802853f3565_b.jpg\"/></figure><p>但是，这样会产生两个问题：</p><ol><li>读写冲突：读操作没有了S锁，读的过程中有可能数据部分被修改，发生脏读；</li><li>写写冲突：写操作的读和处理阶段，其他的写操作会修改数据</li></ol><p>对于第二个问题，写操作写入时，可以做一个校验，确保从读开始没有其他写操作修改相应数据。如果有了修改，就重新执行整个写操作。这样就减少了资源被锁住的时间，成本是多个写操作修改相同数据时，有可能会发生多次重试。对于读多写少，写冲突少的情况，这种交换是合适的。这种并发处理机制称为<b>乐观并发控制</b>（optimistic concurrency control），也叫<b>乐观锁</b>。和悲观锁相比，通过增加校验和重试机制，放弃了在整个过程上加锁。</p><p>对于第一个问题，一种解决方法是保留数据的历史版本（MVCC），读的是数据的历史版本，写入时创建新的数据版本。</p><p>mongodb的WiredTiger引擎对大多数读写操作使用的是乐观锁，同时使用了MVCC。</p><h3><b>锁的调度和让渡</b></h3><p>mongodb的锁是公平的，所有的请求会排队获取相应的锁。但是mongodb为了优化吞吐量，在执行某个请求时，会同时执行和它相容的其他请求。比如一个请求队列需要的锁如下，执行IS请求的同时，会同时执行和它相容的其他S和IS请求。等这一批请求的S锁释放后，再执行X锁的请求。</p><p>IS → IS → X → X → S → IS</p><p>这种处理机制保证了在相对公平的前提下，提高了吞吐量，不会让某一类请求长时间的等待。</p><p>对于长时间的读或者写操作，某些条件下，mongodb会临时的让渡锁，以防止长时间的阻塞。</p><h3><b>常用操作与锁</b></h3><p>insert：库级别的意向读锁(r)，表级别的意向读锁(r)，文档级别的读锁(R)</p><p>update：库级别的意向写锁(w)，表级别的意向写锁(w)，文档级别的写锁(W)</p><p>foreground方式创建索引：库级别的写锁(W)</p><p>background方式创建索引：库级别的意向写锁(w)，表级别的意向写锁(w)</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>相关文档</b></h3><p><a href=\"https://link.zhihu.com/?target=http%3A//www.mongoing.com/archives/25738\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">mongoing.com/archives/2</span><span class=\"invisible\">5738</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/faq/concurrency/%23faq-concurrency-locking\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">docs.mongodb.com/manual</span><span class=\"invisible\">/faq/concurrency/#faq-concurrency-locking</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/core/wiredtiger/%23storage-wiredtiger\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">docs.mongodb.com/manual</span><span class=\"invisible\">/core/wiredtiger/#storage-wiredtiger</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/dotnet/framework/data/adonet/optimistic-concurrency\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">docs.microsoft.com/en-u</span><span class=\"invisible\">s/dotnet/framework/data/adonet/optimistic-concurrency</span><span class=\"ellipsis\"></span></a></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "MongoDB", 
                    "tagLink": "https://api.zhihu.com/topics/19560787"
                }, 
                {
                    "tag": "乐观锁", 
                    "tagLink": "https://api.zhihu.com/topics/20029916"
                }, 
                {
                    "tag": "并发控制", 
                    "tagLink": "https://api.zhihu.com/topics/19673398"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68828849", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 1, 
            "title": "multiprocessing中的共享变量", 
            "content": "<p>不同的进程默认有自己独立的内存空间，互相之间不能直接访问。所以，通常的全局变量或者传递参数，在创建新进程时，都是拷贝一份到新进程里使用。比如下面的代码，类变量<code>count</code>的地址在子进程和主进程中是不同的。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">import</span> <span class=\"nn\">multiprocessing</span>\n<span class=\"k\">class</span> <span class=\"nc\">Test</span><span class=\"p\">:</span>\n    <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    \n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fun</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;cls id: {}, cls.count id: {}, count: {}&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">),</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">))</span>\n        \n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">test</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Process</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">fun</span><span class=\"p\">)</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;cls id: {}, cls.count id: {}, count: {}&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">),</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">))</span>\n<span class=\"err\">​</span>\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">:</span>\n    <span class=\"n\">Test</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span>\n<span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140663701252024</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4366280112</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">1</span>\n<span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140663701252024</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4366280080</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">0</span>\n<span class=\"k\">class</span> <span class=\"nc\">Test</span><span class=\"p\">:</span>\n    <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Value</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"err\">​</span>\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fun</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;cls id: {}, cls.count id: {}, count: {}&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">),</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">))</span>\n<span class=\"err\">​</span>\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">test</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Process</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">fun</span><span class=\"p\">)</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;cls id: {}, cls.count id: {}, count: {}&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">),</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">))</span>\n<span class=\"err\">​</span>\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">:</span>\n    <span class=\"n\">Test</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># 输出</span>\n<span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140731472827480</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4554919384</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">1</span>\n<span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140731472827480</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4554919384</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">1</span></code></pre></div><h3><b>进程间共享变量</b></h3><p>如果希望不同进程读写同一个变量，需要做特殊的声明。multiprocessing提供了两种实现方式，一种是共享内存，一种是使用服务进程。共享内存只支持两种数据结构<code>Value</code>和<code>Array</code>。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">class</span> <span class=\"nc\">Test</span><span class=\"p\">:</span>\n    <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Value</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fun</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;cls id: </span><span class=\"si\">{}</span><span class=\"s1\">, cls.count id: </span><span class=\"si\">{}</span><span class=\"s1\">, count: </span><span class=\"si\">{}</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">),</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">))</span>\n\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">test</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Process</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">fun</span><span class=\"p\">)</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;cls id: </span><span class=\"si\">{}</span><span class=\"s1\">, cls.count id: </span><span class=\"si\">{}</span><span class=\"s1\">, count: </span><span class=\"si\">{}</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">),</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">))</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">:</span>\n    <span class=\"n\">Test</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># 输出</span>\n<span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140731472827480</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4554919384</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">1</span>\n<span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140731472827480</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4554919384</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">1</span></code></pre></div><p>子进程和主进程访问的<code>count</code>在内存中的地址是相同的。这里有两点需要注意：</p><ol><li><code>multiprocessing.Value</code>对象和<code>Process</code>一起使用的时候，可以像上面那样作为全局变量使用，也可以作为传入参数使用。但是和<code>Pool</code>一起使用的时候，只能作为全局变量使用，作为传入参数使用会报错。 <code>RuntimeError: Synchronized objects should only be shared between processes through inheritance</code></li><li>多个进程读写共享变量的时候，要注意操作是否是进程安全的。对于前面的累加计数器，虽然是一个语句，但是涉及到读和写，和进程的局域临时变量，这个操作不是进程安全的。多进程的累加的时候，会出现不正确的结果。需要给<code>cls.count += 1</code>加上锁。加锁的方式，可以使用外部的锁，也可以直接使用<code>get_lock()</code>方法。<br/></li></ol><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\"># 使用外部的锁</span>\n<span class=\"k\">class</span> <span class=\"nc\">Test</span><span class=\"p\">:</span>\n    <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Lock</span><span class=\"p\">()</span>\n\t\t<span class=\"o\">...</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fun</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">acquire</span><span class=\"p\">()</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">release</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># 使用get_lock()方法</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fun</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"k\">with</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">get_lock</span><span class=\"p\">():</span>\n            <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>共享内存支持的数据结构有限，另一种共享变量的方式是使用服务进程管理需要共享的变量，其他进程操作共享变量的时候通过和服务进程的交互实现。这种方式支持列表、字典等类型，而且可以实现多台机器之间共享变量。但是速度要比共享内存的方式慢。另外，这种方式可以用作<code>Pool</code>的传入参数。同样的，对于非进程安全的操作，也需要加锁。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">import</span> <span class=\"nn\">multiprocessing</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Test</span><span class=\"p\">:</span>\n    <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Lock</span><span class=\"p\">()</span>\n\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fun</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">):</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">acquire</span><span class=\"p\">()</span>\n        <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">if</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">%</span> <span class=\"mi\">500</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;pid: </span><span class=\"si\">{}</span><span class=\"s1\">, cls id: </span><span class=\"si\">{}</span><span class=\"s1\">, cls.count id: </span><span class=\"si\">{}</span><span class=\"s1\">, count: </span><span class=\"si\">{}</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">getpid</span><span class=\"p\">(),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">count</span><span class=\"p\">),</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">))</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">release</span><span class=\"p\">()</span>\n\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">test</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"n\">manager</span> <span class=\"o\">=</span> <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Manager</span><span class=\"p\">()</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">manager</span><span class=\"o\">.</span><span class=\"n\">Value</span><span class=\"p\">(</span><span class=\"s1\">&#39;i&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;main-cls id: </span><span class=\"si\">{}</span><span class=\"s1\">, count id: </span><span class=\"si\">{}</span><span class=\"s1\">, count: </span><span class=\"si\">{}</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">count</span><span class=\"p\">),</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">))</span>\n\n        <span class=\"n\">pool</span> <span class=\"o\">=</span> <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Pool</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"n\">rs</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">):</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">pool</span><span class=\"o\">.</span><span class=\"n\">apply_async</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"o\">=</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">fun</span><span class=\"p\">,</span> <span class=\"n\">kwds</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;count&#39;</span><span class=\"p\">:</span> <span class=\"n\">count</span><span class=\"p\">})</span>\n            <span class=\"n\">rs</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n        <span class=\"n\">pool</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n        <span class=\"n\">pool</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">rs</span><span class=\"p\">:</span>\n            <span class=\"n\">i</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;main-cls id: </span><span class=\"si\">{}</span><span class=\"s1\">, count id: </span><span class=\"si\">{}</span><span class=\"s1\">, count: </span><span class=\"si\">{}</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">),</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">count</span><span class=\"p\">),</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">))</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">:</span>\n    <span class=\"n\">Test</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># 输出</span>\n<span class=\"n\">main</span><span class=\"o\">-</span><span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140298063822200</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4347985312</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">0</span>\n<span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"mi\">47895</span><span class=\"p\">,</span> <span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140298063822200</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4348083224</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">500</span>\n<span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"mi\">47895</span><span class=\"p\">,</span> <span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140298063822200</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4348082776</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">1000</span>\n<span class=\"n\">main</span><span class=\"o\">-</span><span class=\"bp\">cls</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">140298063822200</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"mi\">4347985312</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"mi\">1000</span></code></pre></div><p>另外一种常用的共享对象就是队列<code>multiprocessing.Queue</code>，这个对象本身提供的方法都是进程安全的，所以使用时不必再加锁。</p><h3><b>threading的共享变量</b></h3><p>同一进程内的多线程是共享内存空间的，所以对于全局变量，不同的线程都可以直接访问。和多进程相比，不需要再做特别的声明。但是同样的，要注意操作是否是多线程安全的，添加相应的锁。</p><p></p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "python多进程", 
                    "tagLink": "https://api.zhihu.com/topics/20214819"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64742979", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 2, 
            "title": "TableStore索引小结", 
            "content": "<h3><b>主键和属性键</b></h3><p>TableStore（ots）是阿里云自研的NoSQL数据库。支持多种数据模型，其中<code>wide column</code>模型每条记录的键分为主键和属性键。其中主键需要建表时指定键名和数据类型，建表后不可更改。主键最多可以包括四列，每条记录的主键都是全表唯一的，主键是自带索引的。</p><p>每条记录的属性键是可以随意增减，不同记录的相同属性键也可以存放不同类型的数据。</p><h3><b>数据类型</b></h3><p>ots目前只支持四种数据类型：INTEGER、STRING、DOUBLE和BOOLEAN。其中DOUBLE类型不能做主键类型，BOOLEAN不可以做主键的第一列(分区键)。</p><p>对于mongodb中支持的列表、子文档类型，在ots中只能转成json字符串，保存成STRING类型。这里不如mongodb灵活。作为弥补，ots的索引仍然可以建在这些字段上，深入json结构内。</p><h3><b>主键和二级索引</b></h3><p>每条记录都对应唯一的主键，主键上有索引。索引通过主键查询的效率是比较高的，参考官方文档单行查询是毫秒量级：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8ed811413fc118a5ca4678c498272fbf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1578\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb\" width=\"1578\" data-original=\"https://pic4.zhimg.com/v2-8ed811413fc118a5ca4678c498272fbf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1578&#39; height=&#39;462&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1578\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1578\" data-original=\"https://pic4.zhimg.com/v2-8ed811413fc118a5ca4678c498272fbf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8ed811413fc118a5ca4678c498272fbf_b.jpg\"/></figure><p>如果是根据属性列查询，最直接的做法是在要查询的属性列上建立二级索引。也就是以这些属性列作为主键创建另一张索引表，这张索引表里存原始表的主键。由于二级索引的索引列是索引表的主键，所以对于数据类型也会有相应的限制。</p><p>目前（2019年05月05日）二级索引需要联系阿里工作人员才能开通试用；而且，二级索引的索引列，需要在创建主表的时候声明。</p><h3><b>多元索引</b></h3><p>多元索引的实现不像二级索引那样依赖于ots，所以更加灵活。多元索引还可以解析约定格式的STRING类型的字段，一定程度上突破了ots只支持5种数据类型的约束。比如，地理坐标经纬度可以保存为字符串<code>&#34;-10,120&#34;</code>(维度在前，经度在后)。在这列上建GEO索引，GEO索引会将该列数据解析为坐标点，利用该索引可以做关于地理位置的相关查询。</p><p>下面以<code>test</code>表为例，介绍几种常用索引的使用。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\"># test 表结构</span>\n<span class=\"p\">{</span>\n  <span class=\"s1\">&#39;id&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"c1\"># 主键</span>\n  <span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">:</span> <span class=\"s2\">&#34;[100, 101, 102]&#34;</span><span class=\"p\">,</span>\n  <span class=\"s1\">&#39;doc&#39;</span><span class=\"p\">:</span> <span class=\"s2\">&#34;{&#39;id&#39;: 1, &#39;data&#39;: 3}&#34;</span><span class=\"p\">,</span>\n  <span class=\"s1\">&#39;doc_vec&#39;</span><span class=\"p\">:</span> <span class=\"s2\">&#34;[{&#39;id&#39;: 1, &#39;data&#39;: 3}, {&#39;id&#39;: 3, &#39;data&#39;: 23}]&#34;</span><span class=\"p\">,</span>\n  <span class=\"s1\">&#39;text&#39;</span><span class=\"p\">:</span> <span class=\"s2\">&#34;abcdefg&#34;</span>\n<span class=\"p\">}</span></code></pre></div><h3><b>对文本检索的支持</b></h3><p>对于保存文本的字段，可以创建两种类型的多元索引：字符串索引和分词字符串索引。其中分词字符串索引会对文本做分词，然后创建倒排索引。</p><p>基于文本索引，可以做前缀查询、模糊匹配查询、通配符查询。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">import</span> <span class=\"nn\">tablestore</span> <span class=\"kn\">as</span> <span class=\"nn\">ts</span>\n<span class=\"err\">​</span>\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">OTSClient</span><span class=\"p\">(</span><span class=\"n\">end_point</span><span class=\"p\">,</span> <span class=\"n\">access_key_id</span><span class=\"p\">,</span> <span class=\"n\">access_key_secret</span><span class=\"p\">,</span> <span class=\"n\">instance_name</span><span class=\"p\">)</span>\n<span class=\"err\">​</span>\n<span class=\"c1\"># 前缀查询；提前在text字段上创建名为text_index的字符串索引</span>\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">PrefixQuery</span><span class=\"p\">(</span><span class=\"s1\">&#39;text&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ab&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">rows</span><span class=\"p\">,</span> <span class=\"n\">next_token</span><span class=\"p\">,</span> <span class=\"n\">total_count</span><span class=\"p\">,</span> <span class=\"n\">is_all_succeed</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"p\">(</span>\n  <span class=\"s1\">&#39;test&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test_index&#39;</span><span class=\"p\">,</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">SearchQuery</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">get_total_count</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n<span class=\"c1\"># 包含某个元素；提前在vec字段上创建名为vec_index的整型数组索引</span>\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">TermQuery</span><span class=\"p\">(</span><span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"n\">rows</span><span class=\"p\">,</span> <span class=\"n\">next_token</span><span class=\"p\">,</span> <span class=\"n\">total_count</span><span class=\"p\">,</span> <span class=\"n\">is_all_succeed</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"p\">(</span>\n  <span class=\"s1\">&#39;test&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;vec_index&#39;</span><span class=\"p\">,</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">SearchQuery</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">get_total_count</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n<span class=\"c1\"># 嵌套索引查询</span>\n<span class=\"n\">nested_query</span> <span class=\"o\">=</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">TermQuery</span><span class=\"p\">(</span><span class=\"s1\">&#39;doc_vec.id&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">NestedQuery</span><span class=\"p\">(</span><span class=\"s1\">&#39;doc_vec&#39;</span><span class=\"p\">,</span> <span class=\"n\">nested_query</span><span class=\"p\">)</span>\n<span class=\"n\">rows</span><span class=\"p\">,</span> <span class=\"n\">next_token</span><span class=\"p\">,</span> <span class=\"n\">total_count</span><span class=\"p\">,</span> <span class=\"n\">is_all_succeed</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"p\">(</span>\n  <span class=\"s1\">&#39;test&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;doc_vec_index&#39;</span><span class=\"p\">,</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">SearchQuery</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">get_total_count</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"p\">)</span></code></pre></div><p>目前使用多元索引检索时，还不能像mongodb一样自动的选择索引，需要手动将要使用的索引作为参数指定。而且如果指定的索引不支持当前查询时会报错。</p><h3><b>数组索引</b></h3><p>虽然ots不支持将列表作为字段的值，但是可以在列表json字符串上建立数组索引（需要指明数组元素的数据类型）。例如，可以在<code>test</code>表的<code>vec</code>字段上创建整型数组索引，然后做相关查询，类似于mongodb中的数组查询。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"c1\"># 包含某个元素；提前在vec字段上创建名为vec_index的整型数组索引</span>\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">TermQuery</span><span class=\"p\">(</span><span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"n\">rows</span><span class=\"p\">,</span> <span class=\"n\">next_token</span><span class=\"p\">,</span> <span class=\"n\">total_count</span><span class=\"p\">,</span> <span class=\"n\">is_all_succeed</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"p\">(</span>\n  <span class=\"s1\">&#39;test&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;vec_index&#39;</span><span class=\"p\">,</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">SearchQuery</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">get_total_count</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"p\">)</span></code></pre></div><h3><b>嵌套索引</b></h3><p>ots支持在形如<code>doc_vec</code>的字段上建立嵌套索引。嵌套索引首先是个数组索引，定义嵌套索引时，需要指定数组元素中索引字段的数据类型，如<code>doc_vec</code>中的<code>id</code>和<code>data</code>。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"c1\"># 嵌套索引查询</span>\n<span class=\"n\">nested_query</span> <span class=\"o\">=</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">TermQuery</span><span class=\"p\">(</span><span class=\"s1\">&#39;doc_vec.id&#39;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">NestedQuery</span><span class=\"p\">(</span><span class=\"s1\">&#39;doc_vec&#39;</span><span class=\"p\">,</span> <span class=\"n\">nested_query</span><span class=\"p\">)</span>\n<span class=\"n\">rows</span><span class=\"p\">,</span> <span class=\"n\">next_token</span><span class=\"p\">,</span> <span class=\"n\">total_count</span><span class=\"p\">,</span> <span class=\"n\">is_all_succeed</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"p\">(</span>\n  <span class=\"s1\">&#39;test&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;doc_vec_index&#39;</span><span class=\"p\">,</span> <span class=\"n\">ts</span><span class=\"o\">.</span><span class=\"n\">SearchQuery</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">get_total_count</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"p\">)</span></code></pre></div><p>但是需要注意，在形如<code>doc</code>的字段上创建嵌套索引，没办法像上面这样使用，这一点和mongo不同。另外，目前ots的嵌套索引只能深入一层，更深层次的数组或者子文档也没有办法解析。</p><h3><b>使用感受</b></h3><p>接触ots一个月左右，感觉一些硬性的指标：数据库可靠性、可扩展性、查询速度，应该比较靠谱。但是，相关的API还有很大的优化空间，比如还不支持自动选择索引。另外，python的API感觉很JAVA，使用起来比较繁琐。</p>", 
            "topic": [
                {
                    "tag": "阿里云", 
                    "tagLink": "https://api.zhihu.com/topics/19560108"
                }, 
                {
                    "tag": "表格存储", 
                    "tagLink": "https://api.zhihu.com/topics/20066661"
                }, 
                {
                    "tag": "mongo", 
                    "tagLink": "https://api.zhihu.com/topics/19682834"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64438770", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 0, 
            "title": "Mongo数组字段查询与索引", 
            "content": "<p>mongo的查询可以深入数组。常见的数组字段有如下两种形式：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"p\">{</span>\n  <span class=\"s1\">&#39;_id&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n  <span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">],</span>\n  <span class=\"s1\">&#39;vec_doc&#39;</span><span class=\"p\">:</span> <span class=\"p\">[{</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">:</span> <span class=\"mi\">9</span><span class=\"p\">}]</span>\n<span class=\"p\">}</span>\n<span class=\"p\">{</span>\n  <span class=\"s1\">&#39;_id&#39;</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n  <span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">],</span>\n  <span class=\"s1\">&#39;vec_doc&#39;</span><span class=\"p\">:</span> <span class=\"p\">[{</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">:</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">:</span> <span class=\"mi\">9</span><span class=\"p\">}]</span>\n<span class=\"p\">}</span></code></pre></div><p>对<code>vec</code>中的元素查询：</p><div class=\"highlight\"><pre><code class=\"language-make\"><span class=\"c\"># vec中包含4\n</span><span class=\"c\"></span><span class=\"nf\">db.test.find({&#39;vec&#39;</span><span class=\"o\">:</span> 4})\n<span class=\"c\"># 返回第一个匹配元素的下标\n</span><span class=\"c\"></span><span class=\"err\">db.test.aggregate([</span>\n\t<span class=\"o\">{</span><span class=\"s1\">&#39;$match&#39;</span>: <span class=\"o\">{</span><span class=\"s1\">&#39;vec&#39;</span>: <span class=\"m\">4</span><span class=\"o\">}}</span>,\n\t<span class=\"o\">{</span><span class=\"s1\">&#39;$project&#39;</span>: <span class=\"o\">{</span><span class=\"s1\">&#39;index&#39;</span>: <span class=\"o\">{</span><span class=\"s1\">&#39;$indexOfArray&#39;</span>: <span class=\"o\">[</span><span class=\"s1\">&#39;$vec&#39;</span>, <span class=\"m\">4</span><span class=\"o\">]}}</span>\n<span class=\"err\">])</span>\n\n<span class=\"c\"># vec中元素的范围: (3, 6)\n</span><span class=\"c\"></span><span class=\"nf\">db.test.find({&#39;vec&#39;</span><span class=\"o\">:</span> {&#39;$<span class=\"n\">elemMatch</span>&#39;: {&#39;$<span class=\"n\">gt</span>&#39;: 3<span class=\"p\">,</span> &#39;$<span class=\"n\">lt</span>&#39;: 6}}})\n</code></pre></div><p>对<code>vec</code>字段加索引可以提高上面查询的效率。Mongo将这里创建的索引叫做&#34;multikey index&#34;，相当于将数组字段拍平，然后在<code>vec</code>字段上使用B+树建立一个索引。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"p\">{</span><span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_id&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_id&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">:</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_id&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_id&#39;</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">&#39;vec&#39;</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_id&#39;</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>对<code>vec_doc</code>的查询：</p><div class=\"highlight\"><pre><code class=\"language-make\"><span class=\"c\"># 字段a\n</span><span class=\"c\"></span><span class=\"nf\">db.test.find({&#39;vec_doc&#39;</span><span class=\"o\">:</span> {&#39;$<span class=\"n\">elemMatch</span>&#39;: {&#39;<span class=\"n\">a</span>&#39;: {&#39;$<span class=\"n\">gt</span>&#39;: 3<span class=\"p\">,</span> &#39;$<span class=\"n\">lt</span>&#39;: 5}}}})\n</code></pre></div><p>上面的查询可以在<code>vec_doc.a</code>上加索引，但是直接在<code>vec_doc</code>上加索引好像没有用上。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>参考：</p><a href=\"https://link.zhihu.com/?target=https%3A//docs.mongodb.com/v3.6/tutorial/query-arrays/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">docs.mongodb.com/v3.6/t</span><span class=\"invisible\">utorial/query-arrays/</span><span class=\"ellipsis\"></span></a><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/7396219/mongodb-multikey-indexing-structure\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-2d47e939feed796bcf7483d306661c88_ipico.jpg\" data-image-width=\"316\" data-image-height=\"316\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mongodb: Multikey indexing structure?</a><p></p>", 
            "topic": [
                {
                    "tag": "索引", 
                    "tagLink": "https://api.zhihu.com/topics/19621412"
                }, 
                {
                    "tag": "MongoDB", 
                    "tagLink": "https://api.zhihu.com/topics/19560787"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45027784", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 2, 
            "title": "Spark on Yarn内存设置", 
            "content": "<p>Spark 2.3.1    Hadoop 3.0.3</p><h2><b>1. 背景</b></h2><h2><b>Yarn</b></h2><p>yarn是一个主从型的计算资源管理系统，包含一个ResourceManager和多个NodeManager。其中ResourceManager负责整个集群的资源调度，管理NodeManager；NodeManager负责管理单个节点。</p><p>资源需求提交给yarn后，yarn会按照提交的需求将一定数量的资源（cpu+内存）打包成Container的形式返回。yarn的配置文件中可以设置Container的一些限制，比如最大的内存、最大的cpu数等。如果申请超出了限制，就不会返回Container。</p><p>一个分布式的计算任务在yarn上运行时，首先会申请一个Container运行ApplicationMaster。ApplicationMaster相当于计算任务的main函数，负责计算任务的调度，并且与ResourceManager交互，申请计算资源。通常ApplicationMaster会申请多个Container，并在这些Container中运行相应的计算任务。</p><h2><b>Spark</b></h2><p>Spark是一种分布式计算框架，可以在多种集群资源管理器上运行。Spark计算任务运行时，会首先运行一个driver，相当于计算任务的main函数。它负责计算任务的调度，driver会管理多个executor，executor上会运行具体的计算任务。</p><p>Spark程序运行时，可以设置driver、executor的资源需求（核数、内存数）；根据这些设置向集群管理器申请资源。</p><h2><b>2. Spark on Yarn</b></h2><p>Spark在Yarn上运行时有两种模式：client模式和cluster模式，默认是client模式。</p><h2><b>client模式</b></h2><p>提交Spark程序后，Spark的driver运行在提交程序的主机上（客户端）。driver首先向Yarn申请一个Container运行ApplicationMaster；然后driver通过ApplicationMaster为executor申请Container；最后driver和executor交互，分配计算任务。</p><h2><b>cluster模式</b></h2><p>cluster模式主要和client模式的主要区别是，Spark的driver也运行在Yarn上，和ApplicationMaster运行在同一个Container里。这样提交Spark计算任务后，客户端就可以退出了，计算任务会继续在Yarn上运行。</p><h2><b>3. Executor内存设置</b></h2><p>Spark的executor和driver都运行在单独的JVM中。spark.executor.memory这个参量设置的就是JVM的堆内存，也是executor实际可以使用的内存。JVM本身也需要一定的内存，这部分内存的大小通过spark.executor.memoryOverhead设置。这两部分的和就是向Yarn申请的Container内存大小。</p><p>Yarn配置文件中会限制Container的最小内存（yarn.scheduler.minimum-allocation-mb）、最大内存（yarn.scheduler.maximum-allocation-mb）。</p><p>Container的内存分配大致如下：</p><ul><li>JVM堆外内存：spark.executor.memoryOverhead</li><li>JVM堆内存：spark.executor.memory</li><ul><li>用于计算（如shuffle操作）和存储<br/> spark.memory.fraction * (JVM堆内存 - 300M)spark.memory.fraction默认值为0.6。这部分内存会有一个比例专门用于存储；这个比例通过spark.memory.storageFraction设置。其他的部分会在运行中动态的调整。</li><li>用于保存Spark元数据</li></ul></ul><h2><b>4. Driver内存设置</b></h2><p>driver内存和executor类似也分为堆内和对外，分别通过spark.driver.memory和spark.driver.memoryOverhead设置。计算中对rdd的collect操作会拉到driver里，所以如果有比较大的collect操作，需要更多的driver内存。</p><p>需要注意的是client模式和cluster模式下driver内存的设置是有区别的。</p><h2><b>client模式</b></h2><p>client模式下，任务提交的同时driver就开始运行了。所以driver内存不可以在程序里使用SparkConf类设置，而需要通过配置文件（$SPARK_HOME/conf/spark-defaults.conf）或传入参数（--driver-memory等）的方式设置。</p><p>同时ApplicationMaster的内存配置使用参数<code>spark.yarn.am.memory</code>和<code>spark.yarn.am.memoryOverhead</code>，可以在SparkConf里设置。</p><h2><b>cluster模式</b></h2><p>cluster模式下可以使用<code>spark.driver.memory</code>和<code>spark.driver.memoryOverhead</code>在SparkConf里设置。提交的Container内存申请值是这两者的和，这个Container里会同时运行Spark的driver和Yarn的ApplicationMaster</p><h2><b>5. 相关链接</b></h2><p>Spark官方文档：</p><p><a href=\"https://link.zhihu.com/?target=http%3A//spark.apache.org/docs/latest/configuration.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">spark.apache.org/docs/l</span><span class=\"invisible\">atest/configuration.html</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//spark.apache.org/docs/latest/running-on-yarn.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">spark.apache.org/docs/l</span><span class=\"invisible\">atest/running-on-yarn.html</span><span class=\"ellipsis\"></span></a></p><p>Yarn官方文档：</p><p><a href=\"https://link.zhihu.com/?target=http%3A//hadoop.apache.org/docs/r3.0.3/hadoop-yarn/hadoop-yarn-common/yarn-default.xml\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">hadoop.apache.org/docs/</span><span class=\"invisible\">r3.0.3/hadoop-yarn/hadoop-yarn-common/yarn-default.xml</span><span class=\"ellipsis\"></span></a></p><p></p>", 
            "topic": [
                {
                    "tag": "Spark", 
                    "tagLink": "https://api.zhihu.com/topics/19942170"
                }, 
                {
                    "tag": "YARN", 
                    "tagLink": "https://api.zhihu.com/topics/20041614"
                }, 
                {
                    "tag": "Hadoop", 
                    "tagLink": "https://api.zhihu.com/topics/19563390"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/43061814", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 0, 
            "title": "git笔记", 
            "content": "<h2><b>git简介</b></h2><p>git维护一个关于修改的仓库，本地目录称为工作区，工作区的修改经过暂存区后提交到仓库，并增量式的保存。</p><p>工程开发的一般方式是，远程仓库有两个分支：master和dev。master是比较稳定的分支，是实际部署使用的；dev是开发分支，由多个人协同开发。工作时将dev拉取到本地，创建自己的本地分支，开发测试完成后，merge到dev分支并提交。需要更新部署代码时，将dev合并到master分支，然后部署。</p><p><b>优秀的git教程</b>：<a href=\"https://link.zhihu.com/?target=https%3A//www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">廖雪峰git教程</a></p><h2><b>基本操作</b></h2><p><code>git init</code></p><p>初始化本地仓库</p><p><code>git add .</code></p><p>将工作区修改放入缓存区</p><p><code>git commit -m “修改说明”</code></p><p>将缓存区修改提交至仓库</p><p><code>git commit --amend</code></p><p>追加提交</p><p><code>git clone 远程仓库地址</code></p><p>克隆远程仓库到本地</p><p><code>git remote add origin 远程仓库地址</code></p><p>添加远程仓库地址</p><p><code>git pull</code>，<code>git push</code></p><p>拉取，提交仓库</p><h2><b>分支操作</b></h2><p><code>git branch</code></p><p>查看分支</p><p><code>git checkout -b newbranch</code></p><p>创建并切换到新分支</p><p><code>git checkout newbranch</code></p><p>切换到新分支</p><p><code>git branch -d branch_name</code></p><p>删除分支</p><p><code>git merge branch_name</code></p><p>将branch_name分支合并到当前分支</p><p><code>git merge --no-ff branch_name</code></p><p>合并分支，保留分支提交记录</p><p><code>git log --graph</code></p><p>查看版本历史</p><p><code>git reflog</code></p><p>查看操作记录</p><h2><b>版本退回</b></h2><p><code>git reset --hard version_id</code></p><p>退回到指定版本，也可以给版本加tag：</p><p><code>git tag tagname version_id</code> </p><p><code>git reset -hard tagname</code></p><p class=\"ztext-empty-paragraph\"><br/></p><p><code>git stash list</code></p><p><code>git stash apply</code></p><p><code>git stash pop</code></p><p>保存进度</p>", 
            "topic": [
                {
                    "tag": "Git", 
                    "tagLink": "https://api.zhihu.com/topics/19557710"
                }, 
                {
                    "tag": "笔记", 
                    "tagLink": "https://api.zhihu.com/topics/19554982"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37244899", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 0, 
            "title": "感知机", 
            "content": "<h2><b>感知机</b></h2><p>感知机的出现是受神经元的启发。感知机接受多个输入，对输入加权求和之后，如果结果大于某个阈值就输出1，否则输出0。数学表达式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=y%3D%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7Bcc%7D+1+%26+%5Cvec+w+%5Ccdot+%5Cvec+x+%3E+b+%5C%5C+0+%26+%5Cvec+w+%5Ccdot+%5Cvec+x+%5Cle+b+%5Cend%7Barray%7D%5Cright+.\" alt=\"y=\\left\\{ \\begin{array}{cc} 1 &amp; \\vec w \\cdot \\vec x &gt; b \\\\ 0 &amp; \\vec w \\cdot \\vec x \\le b \\end{array}\\right .\" eeimg=\"1\"/> </p><p>感知机有多种不同的形式，比如大于阈值输出1，反之输出-1。或者根据​ <img src=\"https://www.zhihu.com/equation?tex=%5Cvec+w+%5Ccdot+%5Cvec+x+-+b\" alt=\"\\vec w \\cdot \\vec x - b\" eeimg=\"1\"/> 的符号决定输出。这些不同的形式，本质上是等价的，完成的工作也都是对输入的向量做二分类。而为了达到比较好的分类效果，需要根据训练数据计算出合理的模型参数​。</p><h2><b>几何图像</b></h2><p>​ <img src=\"https://www.zhihu.com/equation?tex=%5Cvec+w+%5Ccdot+%5Cvec+x+-b+%3D0\" alt=\"\\vec w \\cdot \\vec x -b =0\" eeimg=\"1\"/> 表示了高维空间中的一个平面，更一般的我们可以这样写： <img src=\"https://www.zhihu.com/equation?tex=%5Cvec+w+%5Ccdot+%28%5Cvec+x+-+%5Cvec+x_0%29%3D0\" alt=\"\\vec w \\cdot (\\vec x - \\vec x_0)=0\" eeimg=\"1\"/> ​。其中权重向量表示这个平面的法向量，​ <img src=\"https://www.zhihu.com/equation?tex=%5Cvec+x_0\" alt=\"\\vec x_0\" eeimg=\"1\"/> 是这个平面上的任一点。对于某个数据点 <img src=\"https://www.zhihu.com/equation?tex=%5Cvec+x+%5E%2A\" alt=\"\\vec x ^*\" eeimg=\"1\"/> ​，下式的几何意义非常明显：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cvec+w+%5Ccdot+%28%5Cvec+x%5E%2A-%5Cvec+x_0%29%7D%7B%7C%5Cvec+w%7C%7D\" alt=\"\\frac{\\vec w \\cdot (\\vec x^*-\\vec x_0)}{|\\vec w|}\" eeimg=\"1\"/> </p><p>其符号表示这个数据点落在平面的哪一侧，大小是这个数据点与平面的距离。感知机的输出依赖于上式的符号，所以感知机的分类过程就是使用一个高维空间中的平面去切分数据点。计算合理的模型参数，也就等价于找一个平面可以合理的区分被标注的训练数据点。</p><h2><b>计算参数</b></h2><p>假设训练数据是这种形式： <img src=\"https://www.zhihu.com/equation?tex=%7B%28%5Cvec+x_i%2C+y_i%29%7D\" alt=\"{(\\vec x_i, y_i)}\" eeimg=\"1\"/> ​， <img src=\"https://www.zhihu.com/equation?tex=y_i%3D%2B1%E6%88%96-1\" alt=\"y_i=+1或-1\" eeimg=\"1\"/> 表示数据点的分类。首先，我们需要量化前面的“合理”。</p><p>比如，我们可以定义：</p><p><img src=\"https://www.zhihu.com/equation?tex=f%3D%5Csum+%5Climits_%7B%28%5Cvec+w+%5Ccdot+%5Cvec+x_i+-b%29+%5Ccdot+y_i+%3C0%7D+1\" alt=\"f=\\sum \\limits_{(\\vec w \\cdot \\vec x_i -b) \\cdot y_i &lt;0} 1\" eeimg=\"1\"/> </p><p>这个函数表示分类错误的数据点的个数。然后就可以认为f越小，模型的参数越合理。最合理的情况是f为0，即所有的训练数据点都被正确分类。计算参数的问题，就转化成了求f最小值的问题。</p><p>但是，这个“合理性”的量化并不好。虽然看起来很直观，但是它的性质不好：它是阶梯状的分段连续，连续部分梯度为0。所以不能使用梯度信息迭代求最小值。</p><p>我们可以重新定义：</p><p><img src=\"https://www.zhihu.com/equation?tex=f%3D%5Csum+%5Climits_%7B%28%5Cvec+w+%5Ccdot+%5Cvec+x_i+-b%29+%5Ccdot+y_i+%3C0%7D-+%28%5Cvec+w+%5Ccdot+%5Cvec+x_i+-b%29+%5Ccdot+y_i\" alt=\"f=\\sum \\limits_{(\\vec w \\cdot \\vec x_i -b) \\cdot y_i &lt;0}- (\\vec w \\cdot \\vec x_i -b) \\cdot y_i\" eeimg=\"1\"/> </p><p>这个函数表示对所有分类错误的点与平面的距离求和。同样的f越小，代表参数越合理。这里使用距离代替上面的1，使得f变得对模型参数连续，而且分段可导的，导数不为0。这样就可以使用梯度下降法方便的求出我们需要的模型参数了。</p><h2><b>梯度下降</b></h2><p>假设有函数y(x)，我们可以在Xn点做泰勒展开：</p><p><img src=\"https://www.zhihu.com/equation?tex=y%28x%29+%5Capprox+y%28x_n%29+%2B+y%27%28x_n%29%5Ccdot%28x-x_n%29\" alt=\"y(x) \\approx y(x_n) + y&#39;(x_n)\\cdot(x-x_n)\" eeimg=\"1\"/> </p><p>如果我们希望找到一个新的点 <img src=\"https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D\" alt=\"x_{n+1}\" eeimg=\"1\"/> ，使得 <img src=\"https://www.zhihu.com/equation?tex=y%28x_%7Bn%2B1%7D%29\" alt=\"y(x_{n+1})\" eeimg=\"1\"/> ，根据上面的泰勒展开我们可以这样取：</p><p><img src=\"https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D+%3D+x_n+-+%5Ceta+%5Ccdot+%5Cfrac%7By%27%28x_n%29%7D%7B%7Cy%27%28x_n%29%7C%7D%2C+%5Cqquad+%5Ceta%3E0\" alt=\"x_{n+1} = x_n - \\eta \\cdot \\frac{y&#39;(x_n)}{|y&#39;(x_n)|}, \\qquad \\eta&gt;0\" eeimg=\"1\"/> </p><p>上式表示根据导数的符号，将x朝着可以减小y的方向移动一个小步长 <img src=\"https://www.zhihu.com/equation?tex=%5Ceta\" alt=\"\\eta\" eeimg=\"1\"/> 。如果我们迭代这个过程，就会找到y的极小值点。</p><p>另外，我们还可能希望不使用固定的步长，而是梯度大的时候步长大一些；梯度小的时候（暗示接近极值点）步长小一些。我们可以使用：</p><p><img src=\"https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D+%3D+x_n+-+%5Ceta+%5Ccdot+y%27%28x_n%29%2C+%5Cqquad+%5Ceta%3E0\" alt=\"x_{n+1} = x_n - \\eta \\cdot y&#39;(x_n), \\qquad \\eta&gt;0\" eeimg=\"1\"/> </p><p>又或者，我们希望每次迭代都可以使y减少一个固定的量，我们可以使用：</p><p><img src=\"https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D+%3D+x_n+-+%5Ceta+%5Ccdot+y%27%28x_n%29%2C+%5Cqquad+%5Ceta%3E0\" alt=\"x_{n+1} = x_n - \\eta \\cdot y&#39;(x_n), \\qquad \\eta&gt;0\" eeimg=\"1\"/> </p><p>上式有点类似于牛顿法。</p><h2><b>随机梯度下降</b></h2><p>根据前面量化的“合理化”函数（一般称为损失函数，或者目标函数），可以很容易的得到梯度。</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+f%7D%7B%5Cpartial+%5Cvec+w%7D+%3D%5Csum+%5Climits_%7B%28%5Cvec+w+%5Ccdot+%5Cvec+x_i+-b%29+%5Ccdot+y_i+%3C0%7D-+%5Cvec+x_i+y_i\" alt=\"\\frac{\\partial f}{\\partial \\vec w} =\\sum \\limits_{(\\vec w \\cdot \\vec x_i -b) \\cdot y_i &lt;0}- \\vec x_i y_i\" eeimg=\"1\"/> </p><p>如果训练集比较大，分类错误的点比较多，上面的求和可能会比较慢。作为替代，我们可以随机的从错误分类点中选取一个，代替上面的求和。</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+f%7D%7B%5Cpartial+%5Cvec+w%7D+%3D-+%5Cvec+x_c+y_c\" alt=\"\\frac{\\partial f}{\\partial \\vec w} =- \\vec x_c y_c\" eeimg=\"1\"/> </p><p>迭代：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cvec+w_%7Bn%2B1%7D+%3D+%5Cvec+w_n+%2B+%5Cvec+x_c+y_c+%5Ceta\" alt=\"\\vec w_{n+1} = \\vec w_n + \\vec x_c y_c \\eta\" eeimg=\"1\"/> </p><p>参数b的计算也类似。</p><h2><b>更多说明</b></h2><ol><li>对于线性可分的训练集，数学上可以证明上面的迭代会收敛到f=0，也就是完全正确分类。对于线性不可分的训练集，可能会导致震荡，无法收敛。另外，线性不可分的训练集显然不能用感知机完全正确的分类；最简单的例子就是感知机无法解决异或问题。</li><li>损失函数（目标函数）的形式会改变问题的性质，从而影响求解的难易。这里的梯度下降法是很常用的一种求极值的数值方法。</li><li>对于线性可分的训练集，能够正确分类的平面可能不止一个。对于所有的可正确分类的平面，f都等于0，无法区分它们之间的优劣。因此，很自然的我们希望有更好的损失函数（或者优化目标）。</li><li>感知机的输出形式——根据阈值选择输出0或1（或者1、-1），完全没有影响到模型的计算，更像是事后加上去的。而是 <img src=\"https://www.zhihu.com/equation?tex=%5Cvec+w+%5Ccdot+%5Cvec+x+-b\" alt=\"\\vec w \\cdot \\vec x -b\" eeimg=\"1\"/> 和损失函数决定了模型。</li></ol><p></p>", 
            "topic": [
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "神经网络", 
                    "tagLink": "https://api.zhihu.com/topics/19607065"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37206104", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 3, 
            "title": "人工智能大事年表", 
            "content": "<h2><b>1854年，黎曼，非欧几何</b></h2><p>非欧几何的出现，提示公理并不一定是不证自明的命题。公理的选择可以有一定的随意性，只要基于这组公理建立起来的结构足够有意思。很显然，我们希望一组公理满足下面这些性质：</p><ol><li>相容性：公理是自洽的，基于公理推导出来的命题不能互相矛盾</li><li>完备性：公理系统内的任何真命题都可以被证明</li></ol><p>如果有了这样的公理，公理之上的结构就是完全确定了。</p><p><b>1901年，罗素悖论</b></p><p>罗素在集合论的框架下构造了一个命题，这个命题即不为真又不为假。因此说明集合论的公理系统是不完备的。而集合论又是现代数学理论的基础，所以引起了第三次数学危机。</p><p><b>1931年，哥德尔定理</b></p><p>第一定理：任意可以包含自然数的自洽公理系统中，存在不能证明的真命题。</p><p>第二定理：任意可以包含自然数的自洽公理系统，不能在系统内证明公理自洽。</p><p><b>1936年，图灵机</b></p><p>对于希尔伯特而言，理想的数学是这样的：有一组公理，可以在公理内部证明它们自洽；而且它们是完备的；并且存在一种机械的计算步骤，可以判断这个系统内任一命题的真假。前两个对应上面的相容性和完备性，哥德尔给出了否定的答案。最后一个是可判定性。</p><p>我们知道数学中的很多证明依赖于数学家的直觉，这种带有偶然性质的直觉不如计算来的让人感到踏实。而证明的过程——逻辑的推理是可以符号化成计算过程的（布尔代数）。因此很自然的我们期望所有的命题都可以通过计算的方式判定真假。这个问题图灵和丘奇也给出了否定的答案：首先，图灵机（等价于丘奇的 <img src=\"https://www.zhihu.com/equation?tex=%5Clambda\" alt=\"\\lambda\" eeimg=\"1\"/> 演算）抽象的概括了所有的计算过程；然后构造了停机问题，并且证明这个问题在图灵机上是不可判定的。</p><p>总的来说，不论是构造一个数学理论，还是理解现实中的某些物理过程。我们都需要一些公理或者假设，假定它们是真的，在它们的基础上做逻辑推演，得到有意义的结论。虽然仍然存在前面的问题，比如确定假设相容、确定理论完备，但是未来我们应该会对这些问题有更清晰的认识，可以给出更明确的界限。第三次数学危机中得到的结论虽然不是希尔伯特期望的，但是整个探索过程促进了数学的发展。作为副产品的图灵机，也为后来计算机的产生提供了一个理论基础。</p><p><b>1943年，神经元的数学模型</b></p><p><b>1946年，ENIAC</b></p><p>计算机出现。</p><p><b>1956年</b></p><p>人工智能这个词被John McCarth提出。</p><p>感知机出现。</p><p>第一个AI程序：Logic Theorist</p><p><b>1959年，Arthur Samuel</b></p><p>Arthur Samuel写出一个下棋程序，提出机器学习的概念。</p><p><b>1969年，Marvin Minsky</b></p><p>Marvin Minsky证明了感知机（单层神经网络）不能解决异或问题。</p><p><b>1973年，Lighthill report</b></p><p>James Lighthill对人工智能的批评直接导致了第一次低潮。</p><p><b>1986年，反向传播算法</b></p><p>加速计算。</p><p><b>1995年，支持向量机</b></p><p>支持向量机的很多性能在当时优于神经网络（神经网络第二次低潮）</p><p><b>2006年，深度学习（逐层预训练）</b></p><p>加速计算。效果超过了支持向量机等其他算法。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>小结</b></h2><ol><li>深度学习本质上还是神经网络，是在感知机的基础上发展起来的。感知机，支持向量机和逻辑回归的关系又比较密切。所以这几个可以一起看。</li><li>概率图模型也是一大类机器学习算法。包括贝叶斯网络、HMM、条件随机场等。这一类算法也比较系统。</li><li>k近邻、决策树感觉是相对独立一些的算法。</li></ol>", 
            "topic": [
                {
                    "tag": "人工智能", 
                    "tagLink": "https://api.zhihu.com/topics/19551275"
                }, 
                {
                    "tag": "深度学习（Deep Learning）", 
                    "tagLink": "https://api.zhihu.com/topics/19813032"
                }, 
                {
                    "tag": "图灵机", 
                    "tagLink": "https://api.zhihu.com/topics/19599012"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35651182", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 2, 
            "title": "spark读取mongo数据（python）", 
            "content": "<p>使用mongo官方提供的<a href=\"https://link.zhihu.com/?target=https%3A//docs.mongodb.com/spark-connector/current/python-api/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">spark connector</a>可以很方便的让spark读写mongo中的数据。</p><p>示例：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">from</span> <span class=\"nn\">pyspark.sql</span> <span class=\"kn\">import</span> <span class=\"n\">SparkSession</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyspark</span> <span class=\"kn\">import</span> <span class=\"n\">SparkConf</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span><span class=\"o\">==</span><span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">:</span>\n    <span class=\"n\">myconf</span> <span class=\"o\">=</span> <span class=\"n\">SparkConf</span><span class=\"p\">()</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"n\">setAppName</span><span class=\"p\">(</span><span class=\"s2\">&#34;test&#34;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">setMaster</span><span class=\"p\">(</span><span class=\"s2\">&#34;yarn&#34;</span><span class=\"p\">)</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"s1\">&#39;spark.executor.instances&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;4&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"s1\">&#39;spark.executor.memory&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;4G&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"s1\">&#39;spark.executor.cores&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;4&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"s1\">&#39;spark.task.cpus&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;4&#39;</span><span class=\"p\">)</span>    \n\n    <span class=\"c1\"># 指定连接器对应的spark-package</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"s2\">&#34;spark.jars.packages&#34;</span><span class=\"p\">,</span><span class=\"s2\">&#34;org.mongodb.spark:mongo-spark-connector_2.11:2.2.0&#34;</span><span class=\"p\">)</span>\n    <span class=\"c1\"># 指定mongo地址，需要每个工作节点都能访问到</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"s2\">&#34;spark.mongodb.input.uri&#34;</span><span class=\"p\">,</span><span class=\"s2\">&#34;mongodb://192.168.1.15:27017/&#34;</span><span class=\"p\">)</span>\n    <span class=\"c1\"># 设置要读取的dbs名和collection名</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"s2\">&#34;spark.mongodb.input.database&#34;</span><span class=\"p\">,</span><span class=\"s2\">&#34;db_name&#34;</span><span class=\"p\">)</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"s2\">&#34;spark.mongodb.input.collection&#34;</span><span class=\"p\">,</span><span class=\"s2\">&#34;collection_name&#34;</span><span class=\"p\">)</span>\n    <span class=\"c1\"># 指定分区方式</span>\n    <span class=\"n\">myconf</span><span class=\"o\">.</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"s2\">&#34;spark.mongodb.input.partitioner&#34;</span><span class=\"p\">,</span><span class=\"s2\">&#34;MongoSplitVectorPartitioner&#34;</span><span class=\"p\">)</span>\n\n    <span class=\"n\">spark</span> <span class=\"o\">=</span> <span class=\"n\">SparkSession</span><span class=\"o\">.</span><span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">(</span><span class=\"n\">conf</span><span class=\"o\">=</span><span class=\"n\">myconf</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">getOrCreate</span><span class=\"p\">()</span>\n    <span class=\"c1\"># 使用指定格式读取</span>\n    <span class=\"n\">mg_data</span> <span class=\"o\">=</span> <span class=\"n\">spark</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"s2\">&#34;com.mongodb.spark.sql&#34;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">()</span>\n    <span class=\"n\">mg_data</span><span class=\"o\">.</span><span class=\"n\">createOrReplaceTempView</span><span class=\"p\">(</span><span class=\"s2\">&#34;tmp_table&#34;</span><span class=\"p\">)</span>\n    <span class=\"n\">mydf</span> <span class=\"o\">=</span> <span class=\"n\">spark</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"p\">(</span><span class=\"s2\">&#34;select _id, trackName from tmp_table limit 4&#34;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">mydf</span><span class=\"o\">.</span><span class=\"n\">rdd</span><span class=\"o\">.</span><span class=\"n\">collect</span><span class=\"p\">())</span>\n    <span class=\"n\">spark</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>有几个问题需要注意，有一些我自己也没搞清楚。</p><p>1. spark的py脚本提交到yarn上，有这样几种方式：</p><ul><ul><li>使用spark-submit提交</li><li>使用python提交</li><li>之前还可以使用pyspark提交，但是spark2.3已经不支持了</li></ul></ul><p>使用第一种方式提交，原则上相关参数的传入有三种方式：一种是在脚本中设置，就像上面这样；一种是提交的时候传入参数；还有一种是将参数设置写在文件中，通过文件传入。在<a href=\"https://link.zhihu.com/?target=https%3A//spark.apache.org/docs/latest/configuration.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Spark文档</a>中有详细介绍。</p><p>mongo-spark连接器通过‘spark.jars.packages’这个参数设置，如果是提交时传入对应的参数是‘--packages’。spark的这些“工具包”（参考<a href=\"https://link.zhihu.com/?target=https%3A//spark.apache.org/third-party-projects.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">spark-packages.org</a>），感觉上类似python中import导入的工具包。</p><p><b>这里的第一个问题是</b>：如果使用spark-submit提交脚本，package的参数只能在提交时传入；像实例这样在脚本中设置会出一些问题:<code>java.lang.ClassNotFoundException: Failed to find data source: com.mongodb.spark.sql. Please find packages at http://spark.apache.org/third-party-projects.html</code> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>2.  从spark文档来看，spark有意在弱化rdd，而强调DataFrame。因此spark程序的主要入口也从SparkContext转移到SparkSession。Dataframe这种格式支持sql，可以在map、reduce等计算之前对数据做一些预处理。</p><div class=\"highlight\"><pre><code class=\"language-text\">from pyspark import SparkConf\nfrom pyspark.sql import SparkSession\n\nif __name__==&#39;__main__&#39;:\n   myconf = SparkConf().setMaster(&#39;yarn&#39;)\n   spark = SparkSession.builder.config(conf=myconf).getOrCreate()\n   # 读取各种格式的数据，并返回dataframe\n   mydata = spark.read.json(&#39;...&#39;)  # json格式文件\n   mydata = spark.read.csv(&#39;...&#39;)\n   mydata = spark.read.text(&#39;...&#39;)\n   mydata = spark.read.format(&#39;..&#39;).load() # 自定义格式 读取mongo数据就是用的这种方式</code></pre></div><p><b>这里的第二个问题是</b>：这种方式读mongo中的表，好像是把整个表都读出来，因为读大表的时候明显感觉到比较慢。虽然读出来之后，可以使用sql语句做一些过滤操作。但是能不能读的时候就根据过滤条件只读一部分呢？</p><p><b>第二个问题的答案：</b>可以在读mongo时使用filter或pipline，相关语句会传给mongo执行。使用sql的方式是将所有数据读入集群，然后并行的执行sql语句。两种方式适合不同的场景，可以参考这个<a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/39653769/difference-between-apache-spark-sql-and-mongodb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">链接</a></p><div class=\"highlight\"><pre><code class=\"language-python3\">    <span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">spark</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"o\">.</span><span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"s2\">&#34;com.mongodb.spark.sql&#34;</span><span class=\"p\">)</span> \\\n        <span class=\"o\">.</span><span class=\"n\">option</span><span class=\"p\">(</span><span class=\"s2\">&#34;uri&#34;</span><span class=\"p\">,</span> <span class=\"s2\">&#34;mongodb://127.0.0.1:27017/dbname&#34;</span><span class=\"p\">)</span> \\\n        <span class=\"o\">.</span><span class=\"n\">option</span><span class=\"p\">(</span><span class=\"s2\">&#34;collection&#34;</span><span class=\"p\">,</span> <span class=\"s2\">&#34;collection_name&#34;</span><span class=\"p\">)</span> \\\n        <span class=\"o\">.</span><span class=\"n\">option</span><span class=\"p\">(</span><span class=\"s2\">&#34;pipeline&#34;</span><span class=\"p\">,</span> <span class=\"s2\">&#34;[{&#39;$limit&#39;:100},{&#39;$project&#39;:{&#39;myfield&#39;:1}}]&#34;</span><span class=\"p\">)</span> \\\n        <span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">()</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>3.使用Dataframe做sql操作有两种方式。一种是直接使用Dataframe这种数据类型的方法，另一种是使用<code>spark.sql</code>方法</p><div class=\"highlight\"><pre><code class=\"language-text\">#使用Dataframe方法\nnewdata = mydata.filter(&#34;col_name &gt; 3&#34;).limit(1000)\nnewdata = newdata.select(col_name1,col_name2).orderBy(...).limit(10)\n\n#使用spark.sql方法\nmydata.createOrReplaceTempView(&#39;tmp_name&#39;)\nnewdata = spark.sql(&#39;select * from tmp_name where ...&#39;)</code></pre></div><p><b>第三个问题</b>：不清楚上面两种方法各有什么优缺点，或者两者等价？</p><p></p>", 
            "topic": [
                {
                    "tag": "Spark", 
                    "tagLink": "https://api.zhihu.com/topics/19942170"
                }, 
                {
                    "tag": "mongo", 
                    "tagLink": "https://api.zhihu.com/topics/19682834"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/34635519", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 1, 
            "title": "2018-03-16：ubuntu安装pyspark", 
            "content": "<p><b>安装java环境</b></p><p>spark需要用到java环境，如果在终端敲入<code>java -version</code>命令提示找不到java命令。这说明还没有安装java环境。安装方式有很多中，最简单的使用apt安装：</p><p><code>sudo apt install openjdk-8-jre-headless</code> </p><p>这里选择的是jdk8，现在jdk9也已经有了，但是试了一下有一些小问题。</p><p>另一种安装方式，是下载openjdk的安装包，解压到要安装的目录，并将解压后的bin路径添加到环境变量PATH中：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo vi /etc/profile\n\n#添加\nexport PATH=$PATH:path_to_java_bin\n\n#使用下面的命令使设置立即生效：（下同）\nsource /etc/profile</code></pre></div><p>做完上面的操作使用<code>java -version</code> 命令会看到jdk的版本信息。另外除了openjdk还有其他版本的jdk可以选择，这里只使用了openjdk。</p><p>spark还需要一个JAVA_HOME的环境变量，来得到jdk的安装目录。上面的安装不会自动生成这个变量，所以需要手动添加：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo vi /etc/profile\n\n#添加\n# 使用apt安装时，默认路径是下面这个。\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>安装pyspark</b></p><p>假定已经安装了python，以及python的包管理工具pip。最简单的安装pyspark的方式就是使用pip命令：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo pip3 install pyspark  #python3版本\nsudo pip install pyspark #python2版本</code></pre></div><p>这样安装以后，可以使用<code>pyspark</code>命令运行交互式的spark，也可以使用<code>spark-submit</code>命令提交脚本。</p><p>如果使用的是python3，需要添加环境变量：<code>export PYSPARK_PYTHON=python3</code></p><p>这种安装方式，可以使用已经配置好的分布式环境；也可以在本地做单节点多进程的计算。但是不能配置spark standlone分布式环境。（<a href=\"https://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pyspark/2.3.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">参考来源</a>）</p><p>而且神奇的是，使用这种安装方式可以直接用python提交脚本：<code>python3  test.py </code> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>另一种比较常规的安装方式，是下载spark安装包。解压到要安装的目录。然后添加环境变量：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo /etc/profile\n\n#添加\nexport SPARK_HOME=path_to_spark\nexport PATH=$PATH:$SPARK_HOMR/bin\n\n#说明：添加环境变量的目的主要是为了让系统找到命令。\n#其实也可以不添加，然后使用命令的时候加上完整路径。\n#设置环境变量可以在/etc/profile里\n#也可以在～目录下的.bash_profile或.bashrc中，略有差异</code></pre></div><p><b>分布式环境</b></p><p>spark的主要作用是提供一套更高级更简单的分布式编程接口，使得分布式编程不像MPI那样复杂（同时不如MPI自由度大）。按上面的方式安装好之后，就可以在单机上学习spark编程了。</p><p>如果希望代码在多台机器上运行，则需要搭建分布式环境。分布式环境的搭建也有多种工具，spark安装包本身也提供了一套工具，可以搭建“spark standalone cluster”分布式环境。这里我们选择搭建的是yarn环境；spark standalone的搭建相对更简单，可以参考<a href=\"https://link.zhihu.com/?target=http%3A//spark.apache.org/docs/latest/spark-standalone.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">spark官方说明</a>。</p><p>搭建yarn环境大致分下面几步：</p><ol><li>下载hadoop安装包，解压到安装目录</li><li>添加相关环境变量</li><li>配置hadoop和yarn的参数</li><li>格式化分布式文件系统：<code>hdfs namenode -format</code>；启动hdfs：<code>start-dfs.sh</code>；启动yarn：<code>start-yarn.sh</code> </li></ol><p>具体配置可以参考<a href=\"https://link.zhihu.com/?target=http%3A//hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/ClusterSetup.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官方说明</a>，还有很多博客，这里就不重复写了。</p>", 
            "topic": [
                {
                    "tag": "Spark", 
                    "tagLink": "https://api.zhihu.com/topics/19942170"
                }, 
                {
                    "tag": "Hadoop", 
                    "tagLink": "https://api.zhihu.com/topics/19563390"
                }, 
                {
                    "tag": "YARN", 
                    "tagLink": "https://api.zhihu.com/topics/20041614"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/32793153", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 5, 
            "title": "plotly笔记——画图的逻辑", 
            "content": "<p><b>安装（ubuntu系统）</b></p><div class=\"highlight\"><pre><code class=\"language-text\">pip3 install plotly</code></pre></div><p><b>离线绘图与在线绘图</b></p><p>plotly有两种绘图方式，安装上面的包之后可以直接使用离线绘图方式绘图，只需导入：</p><div class=\"highlight\"><pre><code class=\"language-text\">import plotly.offline as pyoff\nimport plotly.graph_objs as go</code></pre></div><p>如果需要在线绘图，需要注册一个plotly的账号，并在本地配置证书。具体步骤可以参考<a href=\"https://link.zhihu.com/?target=https%3A//plot.ly/python/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官网</a>。在线绘图需要导入：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">import</span> <span class=\"nn\">plotly.plotly</span> <span class=\"k\">as</span> <span class=\"nn\">py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">plotly.graph_objs</span> <span class=\"k\">as</span> <span class=\"nn\">go</span></code></pre></div><p>离线绘图不需要连接plotly服务器，也不需要plotly账号，使用比较方便；但是离线绘图相比在线绘图缺少一些功能。比如离线绘图只能输出html文件，然后从html里下载图片，不能像在线绘图一样直接导出图片。</p><p>在线绘图的缺点是需要连接服务器，绘图的速度会受网络状态的影响，尤其是绘制数据量较大的图。优势是绘制的图片以及相关数据会同步到自己的账号里。在线绘图的免费账号每日最多绘制100张图片，还有一些附加功能是需要收费的。</p><p><b>绘图逻辑</b></p><p>相比与ggplot2，plotly的绘图逻辑更清晰一些，主要分成三个步骤：设置数据（trace）、设置布局（layout）、画图保存</p><p>例：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">import</span> <span class=\"nn\">plotly.plotly</span> <span class=\"k\">as</span> <span class=\"nn\">py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">plotly.graph_objs</span> <span class=\"k\">as</span> <span class=\"nn\">go</span>\n<span class=\"kn\">import</span> <span class=\"nn\">plotly.offline</span> <span class=\"k\">as</span> <span class=\"nn\">pyoff</span>\n\n<span class=\"n\">x</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]</span>\n<span class=\"n\">y</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"n\">mydata</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">go</span><span class=\"o\">.</span><span class=\"n\">Scatter</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"p\">)]</span> <span class=\"c1\">#设置数据</span>\n<span class=\"n\">mylay</span><span class=\"o\">=</span><span class=\"n\">go</span><span class=\"o\">.</span><span class=\"n\">Layout</span><span class=\"p\">(</span><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">&#39;图片标题&#39;</span><span class=\"p\">,</span><span class=\"n\">xtitle</span><span class=\"o\">=</span><span class=\"s1\">&#39;x轴&#39;</span><span class=\"p\">)</span> <span class=\"c1\">#设置坐标</span>\n<span class=\"n\">myfig</span><span class=\"o\">=</span><span class=\"n\">go</span><span class=\"o\">.</span><span class=\"n\">Figure</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">mydata</span><span class=\"p\">,</span><span class=\"n\">layout</span><span class=\"o\">=</span><span class=\"n\">mylay</span><span class=\"p\">)</span> <span class=\"c1\">#生成Figure数据</span>\n\n<span class=\"n\">py</span><span class=\"o\">.</span><span class=\"n\">image_save</span><span class=\"p\">(</span><span class=\"n\">myfig</span><span class=\"p\">,</span> <span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">&#39;fig.png&#39;</span><span class=\"p\">)</span> <span class=\"c1\">#使用在线服务，生成图片文件</span>\n<span class=\"n\">pyoff</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">myfig</span><span class=\"p\">)</span> <span class=\"c1\">#离线方式绘图</span></code></pre></div><p><b>设置数据</b></p><p>设置数据的时候需要指定所图形的类型：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"n\">mydata</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">go</span><span class=\"o\">.</span><span class=\"n\">Scatter</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"p\">)]</span> <span class=\"c1\">#散点图或线图</span>\n<span class=\"n\">mydata</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">go</span><span class=\"o\">.</span><span class=\"n\">Bar</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"p\">)]</span> <span class=\"c1\">#条形图</span>\n<span class=\"n\">mydata</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">go</span><span class=\"o\">.</span><span class=\"n\">Histogram</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"p\">)]</span> <span class=\"c1\">#频率直方图</span>\n<span class=\"n\">mydata</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">go</span><span class=\"o\">.</span><span class=\"n\">Pie</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"p\">)]</span> <span class=\"c1\">#饼图</span>\n<span class=\"o\">...</span></code></pre></div><p>这一步操作类似于ggplot2中的：</p><div class=\"highlight\"><pre><code class=\"language-text\">myfig = ggplot(aes(x=x,y=y),data=mydata) + geom_point()\nmyfig = ggplot(aes(x=x,y=y),data=mydata) + geom_bar()\n...</code></pre></div><p>我们注意到，plotly中的数据是放在一个数列里的。在同一张图上绘制多组数据变得非常简单：</p><div class=\"highlight\"><pre><code class=\"language-text\">mydata = [go.Scatter(x=x1, y=y1), go.Bar(x=x2,y=y2)]</code></pre></div><p>每组数据在设置的时候，可以加上一些相关的参数，比如颜色透明度、曲线的类型、点的类型、图例的名字、是否显示图例等等：</p><div class=\"highlight\"><pre><code class=\"language-text\">import plotly.graph_objs as go\nimport plotly.offline as pyoff\n\nx1 = [1,2,3,4,5]\ny1 = [1,2,3,4,5]\nx2 = [1,2,3,4,5]\ny2 = [5,4,3,2,1]\nmydata = [go.Scatter(x=x1, y=y1, name=&#39;x1-y1&#39;, \n                     marker=dict(color=&#39;rgb(255,0,0)&#39;)), \n          go.Bar(x=x2,y=y2,marker=dict(color=&#39;#009efd&#39;),\n                 showledgen=False)]\nmyfig = go.Figure(data=mydata)\npyoff.plot(myfig)</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-860609671fa59cf2c7548bc4d52c2818_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"450\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-860609671fa59cf2c7548bc4d52c2818_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;450&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"450\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-860609671fa59cf2c7548bc4d52c2818_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-860609671fa59cf2c7548bc4d52c2818_b.jpg\"/></figure><p><b>设置Layout</b></p><p>这部分的设置都是和数据无关的绘图参数，比如坐标轴的范围、名字、图片的标题，相关的字体，坐标刻度等等。如果不设置，只使用默认的配置也是可以的，上面的图片和代码就没有设置Layout。</p><p>这部分设置对应与ggplot中的theme、xlim、xlab等一系列的参数；plotly的逻辑清晰之处就是把数据相关的图片参数设置、数据无关的参数设置分开，前者放在数据设置中，后者放在Layout设置中。</p><p>对比：</p><div class=\"highlight\"><pre><code class=\"language-text\">#plotly\nmylay = go.Layout(title=&#39;标题&#39;, color=&#39;rgb(0,0,0)&#39;,\n                  xaxis=dict(title=&#39;x轴&#39;,range=[0,10]))\n\n#ggplot\nmyp &lt; myp + labs(title=&#39;标题&#39;, x=&#39;x轴&#39;) + xlim(0.10) + \n      theme(title=element_text(color=&#39;black&#39;))</code></pre></div><p><b>其他</b></p><p>更多说明移步<a href=\"https://link.zhihu.com/?target=https%3A//plot.ly/python/reference/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">plotly参数文档</a>，写的很详细。</p>", 
            "topic": [
                {
                    "tag": "数据可视化", 
                    "tagLink": "https://api.zhihu.com/topics/19593576"
                }, 
                {
                    "tag": "数据分析", 
                    "tagLink": "https://api.zhihu.com/topics/19559424"
                }, 
                {
                    "tag": "ggplot2", 
                    "tagLink": "https://api.zhihu.com/topics/20053089"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31736035", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 1, 
            "title": "关于Hugo静态网站的部署", 
            "content": "<p><a href=\"https://link.zhihu.com/?target=https%3A//gohugo.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hugo</a>是github上的一个开源项目，用于从md文件自动生成静态博客。Hugo的安装和简单使用有一篇<a href=\"https://link.zhihu.com/?target=http%3A//gohugo.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">中文文档</a>，比较有帮助。</p><p>网站的可以部署在github上，上面的文档中有介绍。也可以使用常用的web server如nginx、Apache等部署在自己的服务器上，需要先用Hugo命令生成public目录。</p><p>除了上面的部署方法，也可以使用Hugo server命令直接部署：</p><div class=\"highlight\"><pre><code class=\"language-text\">hugo server \n     --theme=hyde \n     --baseUrl=&#34;http://yoururl.com&#34; \n     --bind=&#34;0.0.0.0&#34;\n     --port=8888\n     --buidDrafts</code></pre></div><p>如果在局域网内部署，或者没有自己的域名，也可以使用ip地址：</p><div class=\"highlight\"><pre><code class=\"language-text\">--baseUrl=&#34;http://192.168.1.11/&#34;</code></pre></div><p>hugo server的一部分参数可以放在config.toml文件里，比如：</p><div class=\"highlight\"><pre><code class=\"language-text\">#config.toml文件\ntheme = &#34;hyde&#34;\nbuildDrafts = true</code></pre></div><p>看<a href=\"https://link.zhihu.com/?target=https%3A//gohugo.io/getting-started/configuration/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官方文档</a>，似乎baseURL等参数也可以放在config.toml文件里，但是自己试了一下不可以。不清楚为什么，希望有人可以解答一下。</p><p>官方文档截图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-015c2c19d13c5d93b4c0fc38c77f375a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"737\" data-rawheight=\"712\" class=\"origin_image zh-lightbox-thumb\" width=\"737\" data-original=\"https://pic3.zhimg.com/v2-015c2c19d13c5d93b4c0fc38c77f375a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;737&#39; height=&#39;712&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"737\" data-rawheight=\"712\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"737\" data-original=\"https://pic3.zhimg.com/v2-015c2c19d13c5d93b4c0fc38c77f375a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-015c2c19d13c5d93b4c0fc38c77f375a_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "静态博客页面生成器", 
                    "tagLink": "https://api.zhihu.com/topics/20036297"
                }, 
                {
                    "tag": "Hexo", 
                    "tagLink": "https://api.zhihu.com/topics/19851557"
                }
            ], 
            "comments": [
                {
                    "userName": "followingevil", 
                    "userLink": "https://www.zhihu.com/people/42c8591c069f149a3a83c63d6f5c3aa8", 
                    "content": "<p>你好，请问如果我写了一个.css 文件，如何让新的markdown文件用到这个.css文件？谢谢</p><p><br></p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "行者", 
                    "userLink": "https://www.zhihu.com/people/8fe8abd14fdeb496543ed85b0a83d56b", 
                    "content": "你好，生成public后本地打开页面，不跳转，主题效果没有，该怎么弄", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/30742700", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 4, 
            "title": "阿里云服务器配置transmission", 
            "content": "<p><b>transmission</b>是一个下载BitTorrent的客户端，最近买了一台阿里云服务器，想在上面下载一些东西，然后再传回本地。</p><p>服务器是<b>ubuntu系统</b>，由于服务器没有图形用户界面，所以有两种选择：安装transmission-cli，然后用命令行操作；或者安装transmission-daemon，使用web客户端操作下载任务。这里选择的是后者。</p><p><b>安装：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">apt-get update\napt-get install transmission-daemon</code></pre></div><p><b>配置文件：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">#位置在/etc/transmission-daemon/settings.json\n#主要是修改web客户端相关的参数\n\n&#34;rpc-port&#34;:9091   #web客户端所在的端口，默认是9091\n&#34;rpc-username&#34;: &#34;username&#34;   #web客户端登录用户名\n&#34;rpc-password&#34;: &#34;password&#34;   #web客户端登录密码\n&#34;rpc-whitelist-enabled&#34;: false  #默认是true，远程登录需要设为false禁用白名单</code></pre></div><p>注意：修改配置文件的时候需要保证<code>transmission-daemon</code>服务是停止的 </p><p><b>启动服务：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">service transmission-daemon start</code></pre></div><p>理论上讲，这个时候就可以远程访问服务器上的transmission的web客户端了：</p><div class=\"highlight\"><pre><code class=\"language-text\">#浏览器地址：\nhttp://主机ip地址:9091/transmission/web/</code></pre></div><p><b>但是阿里云主机上没有成功，查看系统日志<code>/var/log/syslog</code> 发现服务开启的时候没有成功打开端口：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">transmission-daemon[32127]: UDP Failed to set receive buffer: requested 4194304, got 425984\ntransmission-daemon[32127]: UDP Failed to set send buffer: requested 1048576, got 425984</code></pre></div><p><b>可以通过修改系统配置文件来解决：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">#位置/etc/sysctl.conf\n#增加两行：\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 4194304\n\n#重新载入参数：\nsysctl -p\n#重启transmission服务：\nservice transmission-daemon restart</code></pre></div><p><b>然后使用netstat命令查看9091端口已经正常开启了。可是仍然连不上web客户端，最后发现原来阿里云服务的防火墙没关，默认入方向是全禁。</b>在后台更改防火墙规则后，transmission的web客户端就可以正常使用了。</p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-fe63f3a689fd2380eafe038446019510_b.jpg\" data-caption=\"\" data-rawwidth=\"864\" data-rawheight=\"440\" class=\"origin_image zh-lightbox-thumb\" width=\"864\" data-original=\"https://pic1.zhimg.com/v2-fe63f3a689fd2380eafe038446019510_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;864&#39; height=&#39;440&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-rawwidth=\"864\" data-rawheight=\"440\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"864\" data-original=\"https://pic1.zhimg.com/v2-fe63f3a689fd2380eafe038446019510_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fe63f3a689fd2380eafe038446019510_b.jpg\"/></figure><p>下载速度还挺快，一会就下好了O(∩_∩)O  然后取回本地的时候跪了：因为没钱，所以买了最便宜的服务器，上行带宽只有1Mb/s，所以传回本地速度只有100kb左右。绕了一圈还不如直接在本地下载 /(ㄒoㄒ)/</p><p>所以接下来的问题是如何配置服务器给本地下载加速？？？由于阿里云服务器的下行速度明显大于上行速度，如果可以把下行至服务器的流量反弹到本地电脑上就好了。或者用服务器挖比特币，然后换钱升级带宽。。。</p>", 
            "topic": [
                {
                    "tag": "Ubuntu", 
                    "tagLink": "https://api.zhihu.com/topics/19557067"
                }, 
                {
                    "tag": "BT 下载（BitTorrent）", 
                    "tagLink": "https://api.zhihu.com/topics/19594769"
                }, 
                {
                    "tag": "阿里云", 
                    "tagLink": "https://api.zhihu.com/topics/19560108"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/29986325", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 0, 
            "title": "Ubuntu定时弹窗：notify-send + crontab", 
            "content": "<p><b>ubuntu的弹窗命令：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">notify-send 标题 “内容”</code></pre></div><p>标题和内容两个参数不需要全都给出。</p><p>有参数-t可以控制弹窗消失的速度，但是ubuntu上这个参数会被忽略。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>定时任务：</b></p><p>linux有多种方法实现定时任务，这里使用的是crontab命令。</p><div class=\"highlight\"><pre><code class=\"language-text\">crontab -e</code></pre></div><p>终端中执行上面的命令会打开一个编辑器，可以添加自己的定时任务。需要添加相关环境变量：(每小时弹窗一次)</p><div class=\"highlight\"><pre><code class=\"language-text\">#PATH\nPATH=/sbin:/bin:/usr/bin:/usr/sbin\n# m h  dom mon dow   command\n0 * * * * export DISPLAY=:0 &amp;&amp; notify-send “test”</code></pre></div><p>export命令用来指定输出设备。</p><p>也可以把notify-send写在一个脚本里：</p><div class=\"highlight\"><pre><code class=\"language-text\">root@pc:~$ cat cmdfile\n#!/bin/bash\nexport DISPLAY=:0\nnotify-send &#34;test&#34;\nroot@pc:~$ </code></pre></div><p>然后直接在crontab -e里调用脚本：</p><div class=\"highlight\"><pre><code class=\"language-text\">#PATH\nPATH=/sbin:/bin:/usr/bin:/usr/sbin\n# m h  dom mon dow   command\n0 * * * * sh /path_to_file/cmdfile</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>其他</b></p><ul><li>使用crontab -l可以查看定时任务</li><li>crontab -e 实际编辑的文件在 /var/spool/cron/crontabs/ 下</li><li>ubuntu中crontab的日志会写入系统日志中：/var/log/syslog</li></ul>", 
            "topic": [
                {
                    "tag": "Shell 语言", 
                    "tagLink": "https://api.zhihu.com/topics/20052025"
                }, 
                {
                    "tag": "Ubuntu", 
                    "tagLink": "https://api.zhihu.com/topics/19557067"
                }, 
                {
                    "tag": "定时休息", 
                    "tagLink": "https://api.zhihu.com/topics/20053102"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/29793506", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 8, 
            "title": "vim学习笔记——vim的特点", 
            "content": "<p>参考书籍：《Vim实用技巧》</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>vim和传统编辑器的区别</b></p><p>编辑的动作可以分成两个部分：在文档中定位，在文档中操作（插入、删除）。传统编辑器主要实用鼠标来定位，同时光标位置总是可以插入字符。</p><p><b>vim和传统编辑器最大的区别是使用键盘定位</b>：比如w跳转到下一个单词的开头。这样做的好处是编辑文档的时候手可以不离开键盘。同时带来的问题是必须区分键盘输入是在定位还是在输入。vim的解决方式是将插入单独放入“插入模式”中。只有文档处于插入模式的状态中时，键盘的输入才会被直接写入文档。插入模式之外的状态叫做“普通模式”，也是vim打开文档的默认状态。这样，普通模式承担的主要功能就包括：定位，以及删除（还有复制）。</p><p>鼠标虽然是移动光标最直观的方式，但是受限于鼠标的结构，它操作的自由度远远不如键盘。因此在普通模式下，键盘除了定位，还可以有很多很多的空间来操作文档。也带来了上百条的命令。</p><p>严格的说，vim编辑文档时有四种模式：普通模式，插入模式，可视模式，命令行模式。作为初学者可以把主要精力放在<b>定位和操作</b>这两个步骤上。先不深究可视模式，命令行模式也只需要知道最基本的几条命令：</p><div class=\"highlight\"><pre><code class=\"language-text\">#命令后加回车\n:w  写入（保存文档）\n:q  退出（关闭文档）\n:wq 保存并退出\n:q! 强制退出</code></pre></div><p><b>常用定位命令</b></p><div class=\"highlight\"><pre><code class=\"language-text\">h 左\nl 右\nj 下行\nk 上行\ngj  下一屏幕行\ngk  上一屏幕行\n\nw  下一个单词开头\nb  上一个单词开头\ne  下一个单词结尾\nge 上一个单词结尾\nW  下一个字串开头\nB  上一个字串开头\nE  下一个字串结尾\ngE 上一个字串结尾\n\n0  行首\n$  行尾\n^  行首第一个非空字符\ng0 屏幕行行首\ng$ 屏幕行行尾\ng^ 屏幕行第一个非空字符\n\nf+某字符 当前行内正向查找并跳转到某字符\nF+某字符 当前行内反向查找并跳转到某字符\n;    查找并跳转到下一个(行内)\n,    查找并跳转到上一个(行内)\n\n{   段首\n}   段尾\nctrl+b  上翻页\nctrl+f  下翻页\nctrl+o  跳回上一位置\nm+标记字符   设置标记\n`+标记字符   跳转到标记\n\ngg  文档开头\nG   文档结尾</code></pre></div><p><b>常用操作命令</b></p><div class=\"highlight\"><pre><code class=\"language-text\">i  光标前插入（进入插入模式）\na  光标后插入\nI  行首插入\nA  行尾插入\no  当前行下插入一行\nO  当前行前插入一行\n\n#注意：修改命令以c开头，表示change\ncw  修改到词尾的内容\nciw 修改整词\ncaw 修改整词包括词尾空格\ncW  修改到字串尾的内容\nciW 修改整字串\ncaW 修改整字串包括字串尾空格\nC   修改到行尾的内容\ncis  修改当前句\ncas  修改当前句包括句尾空格\ncip  修改当前段\ncap  修改当前段包括段尾空行\nEsc  退出插入模式，返回普通模式\nctrl+[  同Esc\n\n#注意：删除命令以d开头，表示delete\ndw  删除到词尾的内容\ndiw 删除整词\ndaw 删除整词包括词尾空格\ndW  删除到字串尾的内容\ndiW 删除整字串\ndaW 删除整字串包括字串尾空格\nD   删除到行尾的内容\ndis  删除当前句\ndas  删除当前句包括句尾空格\ndip  删除当前段\ndap  删除当前段包括段尾空行\n\n.   在当前位置重复上一次操作\nu   撤销上一次操作</code></pre></div>", 
            "topic": [
                {
                    "tag": "Vim", 
                    "tagLink": "https://api.zhihu.com/topics/19570193"
                }, 
                {
                    "tag": "笔记", 
                    "tagLink": "https://api.zhihu.com/topics/19554982"
                }, 
                {
                    "tag": "教程", 
                    "tagLink": "https://api.zhihu.com/topics/19577346"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/29287995", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 0, 
            "title": "MySQL文件导入时的若干问题", 
            "content": "<p>这里总结了文件导入时遇到的三个小问题：</p><ul><li>分隔符的设置</li><li>导入含有转义字符的字符串</li><li>字符集的设置</li></ul><p><b>分隔符的设置</b></p><p>将外部文件导入MySQL时，经常会用到load data infile命令：</p><div class=\"highlight\"><pre><code class=\"language-text\">LOAD DATA INFILE &#39;filename&#39; INTO TABLE tablename</code></pre></div><p>默认每条记录是以换行符分隔，记录中的字段以制表符分隔。</p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-cce3b107315350433f9fbb8b258881da_b.png\" data-rawwidth=\"355\" data-rawheight=\"93\" class=\"content_image\" width=\"355\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;355&#39; height=&#39;93&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"355\" data-rawheight=\"93\" class=\"content_image lazy\" width=\"355\" data-actualsrc=\"https://pic3.zhimg.com/v2-cce3b107315350433f9fbb8b258881da_b.png\"/></figure><p>其中，cat -t把制表符显示成^I。test1.csv前两行是用制表符分隔，第三行是以逗号分隔的。导入MySQL中时，前两行会正常导入：</p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-243b2c9d43ab7eaf9e5ff44b551606d3_b.png\" data-rawwidth=\"556\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb\" width=\"556\" data-original=\"https://pic4.zhimg.com/v2-243b2c9d43ab7eaf9e5ff44b551606d3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;556&#39; height=&#39;266&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"556\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"556\" data-original=\"https://pic4.zhimg.com/v2-243b2c9d43ab7eaf9e5ff44b551606d3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-243b2c9d43ab7eaf9e5ff44b551606d3_b.png\"/></figure><p>第三行没有得到正确的导入。</p><p>load data命令中可以由用户自己定义分隔符：</p><div class=\"highlight\"><pre><code class=\"language-text\">load data infile &#39;filename&#39; into table tbname\nfields terminated by &#39;,&#39;;</code></pre></div><p>上面将字段分隔符设为逗号。导入结果如下：</p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-a92219d0557636d3b49a75f0d90cb6fc_b.png\" data-rawwidth=\"471\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb\" width=\"471\" data-original=\"https://pic1.zhimg.com/v2-a92219d0557636d3b49a75f0d90cb6fc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;471&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"471\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"471\" data-original=\"https://pic1.zhimg.com/v2-a92219d0557636d3b49a75f0d90cb6fc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a92219d0557636d3b49a75f0d90cb6fc_b.png\"/></figure><p>和预料的一样，第三行正常的导入，而前两行没有正常导入。<b>MySQL目前似乎不支持设置多种字段分隔符。</b>如果想导入上面的文件，可以先使用sed命令预处理一下。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>导入含有转义字符的字符串</b></p><p>另一个导入时经常遇到的问题是字符串中含有转义字符&#39; \\ &#39;</p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-572fa1485fe7361841381b173766c549_b.png\" data-rawwidth=\"312\" data-rawheight=\"157\" class=\"content_image\" width=\"312\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;312&#39; height=&#39;157&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"312\" data-rawheight=\"157\" class=\"content_image lazy\" width=\"312\" data-actualsrc=\"https://pic2.zhimg.com/v2-572fa1485fe7361841381b173766c549_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-962c98f4ac15c5a0c726d2ce265725bc_b.png\" data-rawwidth=\"473\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb\" width=\"473\" data-original=\"https://pic1.zhimg.com/v2-962c98f4ac15c5a0c726d2ce265725bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;473&#39; height=&#39;270&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"473\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"473\" data-original=\"https://pic1.zhimg.com/v2-962c98f4ac15c5a0c726d2ce265725bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-962c98f4ac15c5a0c726d2ce265725bc_b.png\"/></figure><p>上面的load data语句中，我们将一个换行符设为字段分隔符，两个连着的换行符设为记录分隔符（等价于将空行设为记录分隔符）。导入结果出现了异常，这是因为MySQL中&#39; \\ &#39;有特别的含义，为了避免上面的问题，可以在导入时将转义字符设为空：<b>escaped by &#39;&#39;</b></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-82c43ab61b0b18f153571fac77ae9b4e_b.png\" data-rawwidth=\"476\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb\" width=\"476\" data-original=\"https://pic3.zhimg.com/v2-82c43ab61b0b18f153571fac77ae9b4e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;476&#39; height=&#39;259&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"476\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"476\" data-original=\"https://pic3.zhimg.com/v2-82c43ab61b0b18f153571fac77ae9b4e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-82c43ab61b0b18f153571fac77ae9b4e_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>导入时的字符集设置</b></p><p>导入字符串含有特殊字符时，会遇到这样一条错误：</p><p>ERROR 1300 (HY000): Invalid utf8 character string</p><p>这时因为MySQL中的utf8最多只用三个字节，有一些使用四个字节表示的特殊字符无法导入：</p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-199fa9efaa318fafad7dad927a6d052f_b.png\" data-rawwidth=\"331\" data-rawheight=\"158\" class=\"content_image\" width=\"331\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;331&#39; height=&#39;158&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"331\" data-rawheight=\"158\" class=\"content_image lazy\" width=\"331\" data-actualsrc=\"https://pic4.zhimg.com/v2-199fa9efaa318fafad7dad927a6d052f_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-5ff3fc89c9e586eefa15accba145aeaf_b.png\" data-rawwidth=\"548\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb\" width=\"548\" data-original=\"https://pic4.zhimg.com/v2-5ff3fc89c9e586eefa15accba145aeaf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;548&#39; height=&#39;90&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"548\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"548\" data-original=\"https://pic4.zhimg.com/v2-5ff3fc89c9e586eefa15accba145aeaf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5ff3fc89c9e586eefa15accba145aeaf_b.png\"/></figure><p>第三条记录中含有emoji表情，会导致整个文件导入失败。</p><p>一个解决的办法是将数据库和表的字符集设为utf8mb4，以及更改MySQL client的默认字符集参数。如果只修改前者，文件会被导入，但是特殊字符会显示为&#39; ? &#39;。</p><p>更改表和数据库的字符集：</p><div class=\"highlight\"><pre><code class=\"language-text\">alter database dbname character set = utf8mb4;\nalter table tbname character set = utf8mb4;\nalter table tbname modify colname char(...) character set utf8mb4;</code></pre></div><p>更改MySQL client默认字符集：在相关配置文件中设置。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "MySQL 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19667043"
                }
            ], 
            "comments": [
                {
                    "userName": "jiajia", 
                    "userLink": "https://www.zhihu.com/people/dbedd8281def4b17895c053bf158dd75", 
                    "content": "执行导入文件，报错1148：the used command is not allowed with this mysql  version  应该怎么处理？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/29219594", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 0, 
            "title": "gawk中的$0", 
            "content": "<p>gawk中的$0代表输入的原记录，一般情况下不会受到输出字段分隔符OFS设置的影响。</p><p>比如下面的例子：</p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-80438c40ac0c97db48885b5680902caa_b.png\" data-rawwidth=\"467\" data-rawheight=\"485\" class=\"origin_image zh-lightbox-thumb\" width=\"467\" data-original=\"https://pic3.zhimg.com/v2-80438c40ac0c97db48885b5680902caa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;467&#39; height=&#39;485&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"467\" data-rawheight=\"485\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"467\" data-original=\"https://pic3.zhimg.com/v2-80438c40ac0c97db48885b5680902caa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-80438c40ac0c97db48885b5680902caa_b.png\"/></figure><p>输出的记录分隔符由空行变成了我们设置的ORS，但是输出的字段分隔符没有受到OFS的影响。</p><p>这里$0的行为就像一个读入的常量，和原始输入的记录保持一致，不受输出字段分隔符OFS的影响。</p><p>但是$0并不是常量，当$0中的字段被改变的时候，$0也会跟着改变。同时，字段分隔符也会变成设置的OFS。就像下面这个例子：（test.csv和前面例子相同）</p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-d4b87e52b10b2e839b0c316184c379a3_b.png\" data-rawwidth=\"610\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb\" width=\"610\" data-original=\"https://pic4.zhimg.com/v2-d4b87e52b10b2e839b0c316184c379a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;610&#39; height=&#39;224&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"610\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"610\" data-original=\"https://pic4.zhimg.com/v2-d4b87e52b10b2e839b0c316184c379a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d4b87e52b10b2e839b0c316184c379a3_b.png\"/></figure><p>甚至这样也是可以的：</p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-2d4bb7b42e9d05e152e23baa641c76e7_b.png\" data-rawwidth=\"704\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-2d4bb7b42e9d05e152e23baa641c76e7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;704&#39; height=&#39;226&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"704\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-2d4bb7b42e9d05e152e23baa641c76e7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2d4bb7b42e9d05e152e23baa641c76e7_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这种行为，似乎和源码中的rebuild_record函数有关。具体的我也不清楚，类似的一个函数是reset_record，和NF的计算有关。</p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Shell 编程", 
                    "tagLink": "https://api.zhihu.com/topics/20052022"
                }, 
                {
                    "tag": "AWK", 
                    "tagLink": "https://api.zhihu.com/topics/19562735"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27789644", 
            "userName": "拿破仑", 
            "userLink": "https://www.zhihu.com/people/0509c664247c5099627b2690f8264493", 
            "upvote": 1, 
            "title": "概率与统计小结", 
            "content": "<p>基本概念：随机事件，基本事件，基本事件空间，<b>随机变量</b></p><p>概率的运算～集合的运算～概率的古典定义～概率的公理化定义：</p><ul><li>定义在基本事件空间 <img src=\"https://www.zhihu.com/equation?tex=%5COmega\" alt=\"\\Omega\" eeimg=\"1\"/> 全体子集上的函数 <img src=\"https://www.zhihu.com/equation?tex=P%28A%29\" alt=\"P(A)\" eeimg=\"1\"/></li><li>满足 <img src=\"https://www.zhihu.com/equation?tex=0+%5Cle+P%28A%29+%5Cle+1\" alt=\"0 \\le P(A) \\le 1\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=P%28%5COmega%29%3D1\" alt=\"P(\\Omega)=1\" eeimg=\"1\"/></li><li>若 <img src=\"https://www.zhihu.com/equation?tex=A_i\" alt=\"A_i\" eeimg=\"1\"/> 互斥，则 <img src=\"https://www.zhihu.com/equation?tex=P%28%5Ccup+A_i%29%3D%5Csum_%7Bi%7DP%28A_i%29\" alt=\"P(\\cup A_i)=\\sum_{i}P(A_i)\" eeimg=\"1\"/></li></ul><p>条件概率： <img src=\"https://www.zhihu.com/equation?tex=P%28A%7CB%29%3D%5Cfrac%7BP%28AB%29%7D%7BA%28B%29%7D\" alt=\"P(A|B)=\\frac{P(AB)}{A(B)}\" eeimg=\"1\"/>       可导出全概率公式</p><p>常见概型与分布：</p><ul><li>两点分布</li><li>二项分布（贝努里概型）</li><li>泊松分布 <img src=\"https://www.zhihu.com/equation?tex=P%5C%7BX%3Dk%5C%7D%3D%5Cfrac%7B%5Clambda%5Ek+e%5E%7B-%5Clambda%7D%7D%7Bk%21%7D\" alt=\"P\\{X=k\\}=\\frac{\\lambda^k e^{-\\lambda}}{k!}\" eeimg=\"1\"/> ，注意泊松定理，泊松分布是二项分布的某种极限情况。</li><li>指数分布 <img src=\"https://www.zhihu.com/equation?tex=f%28x%29%3D%5Clambda+e%5E%7B-%5Clambda+x%7D\" alt=\"f(x)=\\lambda e^{-\\lambda x}\" eeimg=\"1\"/> ，描述“寿命”</li><li>正态分布</li></ul><p>推广：联合概率分布 ～ 多元积分；边缘分布函数</p><p>注意：<b>泊松分布与指数分布的关系</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>数字特征：期望，方差 <img src=\"https://www.zhihu.com/equation?tex=E%28X-E%28X%29%29%5E2\" alt=\"E(X-E(X))^2\" eeimg=\"1\"/> ，原点矩 <img src=\"https://www.zhihu.com/equation?tex=E%28X%5Ek%29\" alt=\"E(X^k)\" eeimg=\"1\"/> ，中心矩 <img src=\"https://www.zhihu.com/equation?tex=E%28X-E%28X%29%29%5Ek\" alt=\"E(X-E(X))^k\" eeimg=\"1\"/></p><p>数字特征：协方差 <img src=\"https://www.zhihu.com/equation?tex=E%5B%28X-EX%29%28Y-EY%29%5D\" alt=\"E[(X-EX)(Y-EY)]\" eeimg=\"1\"/> ，相关系数 <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7BCov%28X%2CY%29%7D%7B%5Csigma_x+%5Csigma_y%7D\" alt=\"\\frac{Cov(X,Y)}{\\sigma_x \\sigma_y}\" eeimg=\"1\"/></p><p><b>大数定律：</b>充分多的独立随机变量，若存在期望以及有界方差，则它们的算术平均概率上等于其期望。</p><p><b>中心极限定理：</b>充分多的独立同分布随机变量，若存在方差且方差不为零，则它们的算术平均的分布概率上为正态分布，期望为原分布期望，方差为 <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Csigma%5E2%7D%7Bn%7D\" alt=\"\\frac{\\sigma^2}{n}\" eeimg=\"1\"/></p><p>注意：中心极限定理中的方差概率上等于零，这是和大数定律相容的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>统计的基本概念：随机抽样，样本，观察值，样本空间，统计量</p><p>常见统计量：</p><ul><li>样本均值</li><li>样本方差 <img src=\"https://www.zhihu.com/equation?tex=S%5E2%3D%5Cfrac%7B1%7D%7Bn-1%7D%5Csum%28X_i-%5Coverline%7BX%7D%29%5E2\" alt=\"S^2=\\frac{1}{n-1}\\sum(X_i-\\overline{X})^2\" eeimg=\"1\"/></li><li>样本k阶中心矩 <img src=\"https://www.zhihu.com/equation?tex=B_k%3D%5Cfrac%7B1%7D%7Bn%7D%5Csum%28X_i-%5Coverline%7BX%7D%29%5Ek\" alt=\"B_k=\\frac{1}{n}\\sum(X_i-\\overline{X})^k\" eeimg=\"1\"/></li></ul><p>常用统计量分布</p><ul><li>卡方分布：n个标准正态分布的平方和</li><li>学生分布（t分布）</li><li>F分布</li></ul><p>注：统计量本身也是随机变量，满足某种分布。通过统计量的观察值可以研究统计量的分布，进而研究原始随机变量的分布。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>参数估计：</p><ul><li>矩估计，应用大数定律，样本k阶矩依概率收敛到总体k阶矩</li><li>极大似然估计，计算观测值出现的概率，使其最大化</li></ul><p>区间估计：构造统计量满足特定分布，依据置信水平确定统计量区间，带入观测值求参数区间</p><p>假设检验：构造统计量满足特定分布，依据置信水平确定统计量区间，依据观测值判断假设。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>方差分析：离差分析</p><p>回归分析：离差平方和最小（最小二乘），假设检验（系数是否为零），预测值的置信区间</p>", 
            "topic": [
                {
                    "tag": "概率论与数理统计", 
                    "tagLink": "https://api.zhihu.com/topics/19850960"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/nds2017"
}
