{
    "title": "前端小溪", 
    "description": "今天学习点什么好呢？", 
    "followers": [
        "https://www.zhihu.com/people/dan-shen-gou-8-64", 
        "https://www.zhihu.com/people/hello-jay", 
        "https://www.zhihu.com/people/ping-tou-ge-62-19", 
        "https://www.zhihu.com/people/lan-lan-lan-lan-96-82", 
        "https://www.zhihu.com/people/redingsir", 
        "https://www.zhihu.com/people/yiban-ban-19-78", 
        "https://www.zhihu.com/people/you-er-duo-55-68", 
        "https://www.zhihu.com/people/yao-ming-shu-71", 
        "https://www.zhihu.com/people/wjfeng-92", 
        "https://www.zhihu.com/people/zhi-wei-64-20", 
        "https://www.zhihu.com/people/guo-fan-70", 
        "https://www.zhihu.com/people/zhang-san-feng-69-10-23", 
        "https://www.zhihu.com/people/wei-kai-82-37", 
        "https://www.zhihu.com/people/wu-li-su-shuo-79", 
        "https://www.zhihu.com/people/lin-fei-94-27", 
        "https://www.zhihu.com/people/meng-sha-87-58", 
        "https://www.zhihu.com/people/qiu-qiu-35-61", 
        "https://www.zhihu.com/people/er-wa-zi-37", 
        "https://www.zhihu.com/people/liu-yan-hua-85", 
        "https://www.zhihu.com/people/cywu", 
        "https://www.zhihu.com/people/li-xiao-dou-7-7", 
        "https://www.zhihu.com/people/cyranory", 
        "https://www.zhihu.com/people/marshal_liu", 
        "https://www.zhihu.com/people/a-liang-24-63", 
        "https://www.zhihu.com/people/fan-xx-73", 
        "https://www.zhihu.com/people/xu-qiang-29-78", 
        "https://www.zhihu.com/people/vasks", 
        "https://www.zhihu.com/people/xin-zhe-48-61", 
        "https://www.zhihu.com/people/lei-guo-guo-44", 
        "https://www.zhihu.com/people/wang-liao-52", 
        "https://www.zhihu.com/people/010-49-11", 
        "https://www.zhihu.com/people/jerry-39-3-85", 
        "https://www.zhihu.com/people/huang-jun-xin", 
        "https://www.zhihu.com/people/o-zing", 
        "https://www.zhihu.com/people/bu-dong-fu-zi", 
        "https://www.zhihu.com/people/a-men-1-7", 
        "https://www.zhihu.com/people/tang-si-yuan-13", 
        "https://www.zhihu.com/people/wang-yu-feng-95", 
        "https://www.zhihu.com/people/dong-xu-53-1", 
        "https://www.zhihu.com/people/jiangfeng16", 
        "https://www.zhihu.com/people/elizaguan520", 
        "https://www.zhihu.com/people/konglee", 
        "https://www.zhihu.com/people/happy-13-39", 
        "https://www.zhihu.com/people/wang-tonny-39", 
        "https://www.zhihu.com/people/yang-wei-li-47-73", 
        "https://www.zhihu.com/people/cai-jing-gongzi", 
        "https://www.zhihu.com/people/xiao-yu-55-32", 
        "https://www.zhihu.com/people/sherry-8-56-52", 
        "https://www.zhihu.com/people/jinxin-li-27", 
        "https://www.zhihu.com/people/pigpig-28-87", 
        "https://www.zhihu.com/people/ye-xiao-1-61", 
        "https://www.zhihu.com/people/glees", 
        "https://www.zhihu.com/people/charles-li-11", 
        "https://www.zhihu.com/people/hujun-wu", 
        "https://www.zhihu.com/people/grey-86-72", 
        "https://www.zhihu.com/people/tony-mistark", 
        "https://www.zhihu.com/people/xue-wa-jue-ji-de-nu-hai", 
        "https://www.zhihu.com/people/Liiu00", 
        "https://www.zhihu.com/people/Mr.CJ", 
        "https://www.zhihu.com/people/qing-chen-ti-yu", 
        "https://www.zhihu.com/people/kou-de-er-20", 
        "https://www.zhihu.com/people/wen-zhe-95", 
        "https://www.zhihu.com/people/stone-72", 
        "https://www.zhihu.com/people/jzcoder", 
        "https://www.zhihu.com/people/walksky", 
        "https://www.zhihu.com/people/tian-bu-ze-qian", 
        "https://www.zhihu.com/people/michael-xu-19", 
        "https://www.zhihu.com/people/mu-tou-ren-51-13", 
        "https://www.zhihu.com/people/zxqi", 
        "https://www.zhihu.com/people/zhang-hong-chuan-88", 
        "https://www.zhihu.com/people/dan-hu-you", 
        "https://www.zhihu.com/people/a-lan-51-12-72", 
        "https://www.zhihu.com/people/takukai-kan", 
        "https://www.zhihu.com/people/xu-yao-zuo-ye-more", 
        "https://www.zhihu.com/people/yildhd-wang", 
        "https://www.zhihu.com/people/yyx365", 
        "https://www.zhihu.com/people/pan-jian-long", 
        "https://www.zhihu.com/people/jing-zhi-62-75", 
        "https://www.zhihu.com/people/gai-lun-65", 
        "https://www.zhihu.com/people/shui-shui-16-92", 
        "https://www.zhihu.com/people/ybtk", 
        "https://www.zhihu.com/people/yin-yang-88-25", 
        "https://www.zhihu.com/people/chen-cceh", 
        "https://www.zhihu.com/people/Zou.yu", 
        "https://www.zhihu.com/people/su-xiao-run", 
        "https://www.zhihu.com/people/zcto", 
        "https://www.zhihu.com/people/zhong-ju-pai", 
        "https://www.zhihu.com/people/jiang-xiao-bo-86", 
        "https://www.zhihu.com/people/jimmy.li", 
        "https://www.zhihu.com/people/AlphaZen", 
        "https://www.zhihu.com/people/liu-wei-wei-13", 
        "https://www.zhihu.com/people/casual_spindrift", 
        "https://www.zhihu.com/people/jsio", 
        "https://www.zhihu.com/people/advstock", 
        "https://www.zhihu.com/people/yzsn-10", 
        "https://www.zhihu.com/people/li-shi-qian-92", 
        "https://www.zhihu.com/people/haofei", 
        "https://www.zhihu.com/people/lvtuwan", 
        "https://www.zhihu.com/people/tang-bao-jie", 
        "https://www.zhihu.com/people/dong-reng-ran", 
        "https://www.zhihu.com/people/white-62", 
        "https://www.zhihu.com/people/liu-meng-yin-68", 
        "https://www.zhihu.com/people/hua-lin-44", 
        "https://www.zhihu.com/people/qethan", 
        "https://www.zhihu.com/people/yong-wang-98-39", 
        "https://www.zhihu.com/people/liu-he-58-95", 
        "https://www.zhihu.com/people/roger-chan-75", 
        "https://www.zhihu.com/people/yi-wen-7-31", 
        "https://www.zhihu.com/people/tan-zhao-zhong-xian-guai-ren-kan-35", 
        "https://www.zhihu.com/people/cheng-pan-fu-chi-tu-shi", 
        "https://www.zhihu.com/people/zhi-tong-dao-he-23-19", 
        "https://www.zhihu.com/people/li-tian-xing-87-77", 
        "https://www.zhihu.com/people/li-jin-long-55-91", 
        "https://www.zhihu.com/people/aloneBear", 
        "https://www.zhihu.com/people/yan-xun-yue-51", 
        "https://www.zhihu.com/people/bi-qing-fan", 
        "https://www.zhihu.com/people/zgem-sheng", 
        "https://www.zhihu.com/people/zhang-yu-hao-27-86", 
        "https://www.zhihu.com/people/winnie-wen-88", 
        "https://www.zhihu.com/people/xi-yang-75-70", 
        "https://www.zhihu.com/people/wangziaaa", 
        "https://www.zhihu.com/people/qu-shuang-49", 
        "https://www.zhihu.com/people/gafish", 
        "https://www.zhihu.com/people/li-mao-85-40", 
        "https://www.zhihu.com/people/jesse-80-75-43", 
        "https://www.zhihu.com/people/fengmingyuqi", 
        "https://www.zhihu.com/people/wei-qing-82-61", 
        "https://www.zhihu.com/people/dai-anshi", 
        "https://www.zhihu.com/people/wu_anli", 
        "https://www.zhihu.com/people/jiao-da-ge-88", 
        "https://www.zhihu.com/people/lan-se-boo", 
        "https://www.zhihu.com/people/mu-zi-jin-6", 
        "https://www.zhihu.com/people/wu-qiang-58-43", 
        "https://www.zhihu.com/people/touchumind", 
        "https://www.zhihu.com/people/li-tian-12-15", 
        "https://www.zhihu.com/people/jinwyp", 
        "https://www.zhihu.com/people/staven630", 
        "https://www.zhihu.com/people/cai-cai-19-82-89"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/68220306", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 3, 
            "title": "APubPlat 一款Devops自动化部署、持续集成、堡垒机开源项目、Web Terminal", 
            "content": "<p>嗨、很高心你能进入这里，我是zane,  在这里给你介绍一款完整的Devops自动化部署工具</p><p>APubPlat - 一款完整的Devops自动化部署、持续集成、堡垒机、并且友好的Web Terminal开源项目。</p><p>如果你对它感兴趣，就给一个小小的关注吧，一款好的产品更需要碰撞和火花。：</p><p>github address : <a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/APubPlat\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/APubPlat</span><span class=\"ellipsis\"></span></a></p><p>document : <a href=\"https://link.zhihu.com/?target=http%3A//apub-wiki.seosiwei.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://apub-wiki.seosiwei.com</a></p><p>接下来我还会持续的更新和迭代。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>功能描述</h2><ul><li>资产管理： 方便快捷的管理资产，可为资产分组，为应用分配不同的资产，快捷控制台管理等。</li><li>应用管理：可建立各种应用任务，前端，后端发布任务，可同时执行单机和多机任务，并实时显示任务日志。</li><li>WEB控制台： 一套强大的Web Terminal，可直接替代Xshell等工具，可单个或批量打开窗口或执行命令（已支持linux系统，后期版本支持windows系统）。</li><li>脚本管理：可为单个或者多个资产预装各种软装或者执行各种命令，可自由自定义各种预装脚本，例如安装nginx</li><li>单|多机脚本生成：可同时为单机或者多机器同时生成shell脚本到指定的目录，方便统一管理和操作。</li><li>备份还原：单多机可同时备份，并按详细日期进行备份，可随时随意一键恢复任意历史版本。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>应用场景</h2><ul><li>各种前端静态发布（例如：vue,react,jquery之类的纯前端持续集成）</li><li>前端中间层发布（例如：使用node.js开发的前端中间层之类的服务持续集成）</li><li>后端发布 （不限制后端语言，只依赖于shell脚本）</li><li>单机 | 多台机器 同时发布、备份、还原</li><li>web版本的xshell，让你不管何时何地都能方便的管理服务器资源</li><li>强大的权限管理能力，为不同角色分配不同的管理权限，让我们的持续集成更灵活更方便</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>安装环境</h2><p>APubPlat依赖的环境并不复杂，对软硬件的要求也并不高，一台1G双核的服务器都能搞定。</p><p>APubPlat 开发技术基于egg.js、vue.js, 因此只需要安装node环境，node.js版本推荐 8.9.0 ~ 10.15.1 之间</p><p>数据库基于mongudb、环境数据库基于redis、web服务器基于nginx，所有的软件和服务你都可以安装在一台机器中。</p><p>如果想了解更多你可以选择去查看项目文档： <a href=\"https://link.zhihu.com/?target=http%3A//apub-wiki.seosiwei.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://apub-wiki.seosiwei.com</a></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>项目预览</h2><h3>登录界面、第一次使用时请注册admin账号，其他账号在后台中进行新增和编辑管理</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ac309c6e7ddfbff3f09230ecbcf67091_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1862\" data-rawheight=\"1104\" class=\"origin_image zh-lightbox-thumb\" width=\"1862\" data-original=\"https://pic2.zhimg.com/v2-ac309c6e7ddfbff3f09230ecbcf67091_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1862&#39; height=&#39;1104&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1862\" data-rawheight=\"1104\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1862\" data-original=\"https://pic2.zhimg.com/v2-ac309c6e7ddfbff3f09230ecbcf67091_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ac309c6e7ddfbff3f09230ecbcf67091_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>你可以自定义任何适合你的项目环境</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9db8c7bebef5a3a2456f68e9b4120e99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2166\" data-rawheight=\"1004\" class=\"origin_image zh-lightbox-thumb\" width=\"2166\" data-original=\"https://pic2.zhimg.com/v2-9db8c7bebef5a3a2456f68e9b4120e99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2166&#39; height=&#39;1004&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2166\" data-rawheight=\"1004\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2166\" data-original=\"https://pic2.zhimg.com/v2-9db8c7bebef5a3a2456f68e9b4120e99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9db8c7bebef5a3a2456f68e9b4120e99_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3><br/></h3><h3>资产管理是项目的一个核心能力，所有持续集成都依赖于资产，也是Web Terminal的入口之一</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2be383b5a5f3e1c4059ffff444551637_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2376\" data-rawheight=\"998\" class=\"origin_image zh-lightbox-thumb\" width=\"2376\" data-original=\"https://pic4.zhimg.com/v2-2be383b5a5f3e1c4059ffff444551637_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2376&#39; height=&#39;998&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2376\" data-rawheight=\"998\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2376\" data-original=\"https://pic4.zhimg.com/v2-2be383b5a5f3e1c4059ffff444551637_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2be383b5a5f3e1c4059ffff444551637_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3><br/></h3><h3>你可以新建任何需要发布和管理的应用，分配相应的资产，可以选择单机部署、部分部署或者全量部署</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1eb74b4d8f85dc0cd802f2c42205ecb0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2370\" data-rawheight=\"1042\" class=\"origin_image zh-lightbox-thumb\" width=\"2370\" data-original=\"https://pic1.zhimg.com/v2-1eb74b4d8f85dc0cd802f2c42205ecb0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2370&#39; height=&#39;1042&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2370\" data-rawheight=\"1042\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2370\" data-original=\"https://pic1.zhimg.com/v2-1eb74b4d8f85dc0cd802f2c42205ecb0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1eb74b4d8f85dc0cd802f2c42205ecb0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3><br/></h3><h3>在这里你可以查看任何时候的应用构建状态、备份状态、生成配置状态</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2743a2489069fbb464b5281227e8ebae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2364\" data-rawheight=\"978\" class=\"origin_image zh-lightbox-thumb\" width=\"2364\" data-original=\"https://pic3.zhimg.com/v2-2743a2489069fbb464b5281227e8ebae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2364&#39; height=&#39;978&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2364\" data-rawheight=\"978\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2364\" data-original=\"https://pic3.zhimg.com/v2-2743a2489069fbb464b5281227e8ebae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2743a2489069fbb464b5281227e8ebae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3><br/></h3><h3>一切的部署都依赖于shell脚本，脚本的正确与否，决定了你的应用是否能部署成功</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-423ed9a75a7d3bb666eb0f4250087657_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2318\" data-rawheight=\"1422\" class=\"origin_image zh-lightbox-thumb\" width=\"2318\" data-original=\"https://pic4.zhimg.com/v2-423ed9a75a7d3bb666eb0f4250087657_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2318&#39; height=&#39;1422&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2318\" data-rawheight=\"1422\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2318\" data-original=\"https://pic4.zhimg.com/v2-423ed9a75a7d3bb666eb0f4250087657_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-423ed9a75a7d3bb666eb0f4250087657_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>友好的web化界面部署日志，支持多机，你可以随时掌控部署状态，也可随时终端某台机器的发布</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-edae37f35fc44939665ffe53869fe8bb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2314\" data-rawheight=\"1348\" class=\"origin_image zh-lightbox-thumb\" width=\"2314\" data-original=\"https://pic4.zhimg.com/v2-edae37f35fc44939665ffe53869fe8bb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2314&#39; height=&#39;1348&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2314\" data-rawheight=\"1348\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2314\" data-original=\"https://pic4.zhimg.com/v2-edae37f35fc44939665ffe53869fe8bb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-edae37f35fc44939665ffe53869fe8bb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>强大的Web Terminal能力，跟xshell工具一样的体验，随时随地管理你的资产吧</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6d528cb3db6c2bcd53c1fc5cc6f04c94_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2394\" data-rawheight=\"1520\" class=\"origin_image zh-lightbox-thumb\" width=\"2394\" data-original=\"https://pic1.zhimg.com/v2-6d528cb3db6c2bcd53c1fc5cc6f04c94_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2394&#39; height=&#39;1520&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2394\" data-rawheight=\"1520\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2394\" data-original=\"https://pic1.zhimg.com/v2-6d528cb3db6c2bcd53c1fc5cc6f04c94_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6d528cb3db6c2bcd53c1fc5cc6f04c94_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>感兴趣</h2><p>如果你有那么一点感兴趣，别犹豫先star或者watch，我会持续的更新和迭代，让它成为你开发中的神器吧</p><p>github address: <a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/APubPlat\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/APubPlat</span><span class=\"ellipsis\"></span></a></p><p>如果你也认可我，那也可以给我一个following额</p><p>你还可以加入QQ群来尽情的交流吧，一款好的产品更需要碰撞和火花。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5e587b135d372f150efd34d4384f9b9e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"741\" class=\"origin_image zh-lightbox-thumb\" width=\"541\" data-original=\"https://pic3.zhimg.com/v2-5e587b135d372f150efd34d4384f9b9e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;541&#39; height=&#39;741&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"741\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"541\" data-original=\"https://pic3.zhimg.com/v2-5e587b135d372f150efd34d4384f9b9e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5e587b135d372f150efd34d4384f9b9e_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }, 
                {
                    "tag": "DevOps", 
                    "tagLink": "https://api.zhihu.com/topics/19791242"
                }, 
                {
                    "tag": "持续集成(CI)", 
                    "tagLink": "https://api.zhihu.com/topics/19603714"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61835909", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 1, 
            "title": "zanePerfor监控系统在高并发项目下的架构配置建议实践说明", 
            "content": "<p>HI!，你好，我是zane，zanePerfor是一款我开发的一个前端性能监控平台，现在支持web浏览器端和微信小程序端。</p><p>我定义为一款完整，高性能，高可用的前端性能监控系统，这是未来会达到的目的，现今的架构也基本支持了高可用，高性能的部署。实际上还不够，在很多地方还有优化的空间，我会持续的优化和升级。</p><p>开源不易，如果你也热爱技术，拥抱开源，希望能小小的支持给个star。</p><p>项目的github地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/zanePerfor\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/zanePerfor</span><span class=\"ellipsis\"></span></a></p><p>项目开发文档说明：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/performance/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.seosiwei.com/perfo</span><span class=\"invisible\">rmance/index.html</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>zanePerfor应用理论上能够支持千万级以上pv项目，但实际情况需要依赖于服务器和数据库的性能，以下项尽可能的从各种配置来提升应用的性能。</p><p>备注：以下内容以选择redis消息队列来阐述和说明。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>一：相关项目配置项说明</h3><div class=\"highlight\"><pre><code class=\"language-text\">config.default.js 配置说明</code></pre></div><p>1、servers集群模式下服务器之间主要通过内网进行通信，因此在这里hostname我们需要配置成内网IP，做如下更改即可<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">// 集群配置（一般默认即可）\n    config.cluster = {\n        listen: {\n            port: config.port,\n            hostname: address.ip(),  // 此处替换127.0.0.1\n            ip: address.ip(),\n        },\n    };</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>2、实时统计任务在大流量项目下时间尽可能的长一些，即能减轻数据库的压力也能提升实时统计的准确性 （定时任务时间间隔建议5-20分钟之间）</p><div class=\"highlight\"><pre><code class=\"language-text\">// 执行pvuvip定时任务的时间间隔 默认每分钟定时执行一次 (可更改)\nconfig.pvuvip_task_minute_time = &#39;0 */1 * * * *&#39;;\n// 更改为\nconfig.pvuvip_task_minute_time = &#39;0 */10 * * * *&#39;;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>3、上报和消费数据方式选择redis</p><div class=\"highlight\"><pre><code class=\"language-text\">// 上报原始数据使用redis存储、kafka储存、还是使用mongodb存储\nconfig.report_data_type = &#39;redis&#39;; // redis  mongodb  kafka</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>4、在数据库性能足够强悍的情况下，每次定时任务的时间尽量短，消费的数据尽量多，消息队列池尽量不做限制</p><div class=\"highlight\"><pre><code class=\"language-text\">config.redis_consumption = {\n    // 定时任务执行时间\n    task_time: &#39;*/10 * * * * *&#39;,\n    // 每次定时任务消费线程数(web端)\n    thread_web: 2000,\n    // 每次定时任务消费线程数(wx端)\n    thread_wx: 2000,\n    // 消息队列池限制数, 0：不限制 number: 限制条数，高并发时服务优雅降级方案\n    total_limit_web: 0,\n    total_limit_wx: 0,\n};</code></pre></div><ul><li>task_time 消费消息定时任务间隔</li><li>thread_wx 每次消费数据条数</li><li>total_limit_wx 限制消息队列中总条数</li></ul><p>以上配置表示：每10秒钟消费2000条数据，不对上报数据条数做限制 （如果定时任务设置了type: &#39;all&#39;,消费数据会成倍数增加）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>5、解析用户IP使用redis方式，并关闭文件缓存（备注：流量大时，本地文件存储的数据会比较大，每次加载会比较耗时）</p><div class=\"highlight\"><pre><code class=\"language-text\">// 解析用户ip地址为城市是使用redis还是使用mongodb\nconfig.ip_redis_or_mongodb = &#39;redis&#39;; // redus  mongodb\n\n// 文件缓存ip对应地理位置（文件名）\nconfig.ip_city_cache_file = {\n    isuse: false, // 是否开启本地文件缓存（数据量太大时建议不开启）\n    web: &#39;web_ip_city_cache_file.txt&#39;,\n    wx: &#39;wx_ip_city_cache_file.txt&#39;,\n};</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>6、mongodb集群模式下url链接需要更改为内网ip,连接池可以稍微调大一些</p><div class=\"highlight\"><pre><code class=\"language-text\">// mongodb 服务\nconst dbclients = {\n    db3: {\n        // 集群分片\n        url: &#39;mongodb://192.168.1.10:30000/performance&#39;,\n        options: {\n            autoReconnect: true,\n            poolSize: 50,\n        },\n    },\n};</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>二：HTTP层面说明（以下内容已在程序中实现）</h3><h3>1、设置Connection，关闭keep-alive</h3><p>为什么要关闭？</p><ul><li>在高并发项目下，tcp保持连接时间不要太长，因此nginx的keepalive_timeout尽量设置的更短</li><li>同一域下请求频率低、请求次数少的http链接尽量减少tcp链接时间，因此keepalive_timeout尽量设置低</li></ul><p>而对于本应用来说，上面两条都已满足，因此关闭keep-alive选项。</p><div class=\"highlight\"><pre><code class=\"language-text\">// node服务实现：\nctx.set(&#39;Connection&#39;, &#39;close&#39;);\n\n// nginx服务实现：\nhttp {\n    keepalive_timeout: 0;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>2、返回空body信息</h3><ul><li>上报接口接收到请求就尽快返回状态码，逻辑处理放到后面处理</li><li>body返回内容尽量简短或者为空</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">// 代码实现：\nasync wxReport() {\n    const { ctx } = this;\n    ctx.set(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n    ctx.set(&#39;Connection&#39;, &#39;close&#39;);\n    ctx.status = 200;\n\n    // 后续逻辑处理...\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>三：node单机集群</h3><p>使用node.js的Cluster 模块开启多进程，尽可能的榨干服务器资源，利用上多核 CPU 的并发优势。同时也保证单机服务的稳定性。</p><p>egg.js提供多进程模型和进程间通讯。</p><p>传送门：<a href=\"https://link.zhihu.com/?target=https%3A//eggjs.org/zh-cn/core/cluster-and-ipc.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">eggjs.org/zh-cn/core/cl</span><span class=\"invisible\">uster-and-ipc.html</span><span class=\"ellipsis\"></span></a></p><p>开启方式：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 应用package.json\n// 案例中开启两个worker进程，默认会开启服务器cpu核数个worker进程\n&#34;scripts&#34;: {\n    &#34;start&#34;: &#34;egg-scripts start --daemon --workers=2 --title=performance&#34;,\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>四：Mongodb集群搭建</h3><p>高流量，高并发项目少不了mongodb集群的搭建，关于mongodb集群搭建请参考以下两篇文章：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/43\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zanePerfor前端性能监控平台高可用之Mongodb集群分片架构</a><br/></p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/42\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zanePerfor前端性能监控平台高可用之Mongodb副本集读写分离架构</a></p><p>案例：现在有3台服务器，内网ip分别为：（10.1.0.86、10.1.0.97、10.1.0.70），现在我们来搭建由三台服务器组建的集群。</p><h3>1、分别在每台服务器上创建如下3个文件</h3><div class=\"highlight\"><pre><code class=\"language-text\">kdir -p /data/mongod/s0\nmkdir -p /data/mongod/log\nmkdir -p /data/mongod/c0</code></pre></div><h3>2、分别在每台服务器上启动Shard Server</h3><div class=\"highlight\"><pre><code class=\"language-text\">mongod --dbpath /data/mongod/s0 --logpath /data/mongod/log/s0.log --fork --smallfiles --port 27020 --bind_ip 10.1.0.86 --shardsvr\nmongod --dbpath /data/mongod/s0 --logpath /data/mongod/log/s0.log --fork --smallfiles --port 27020 --bind_ip 10.1.0.97 --shardsvr\nmongod --dbpath /data/mongod/s0 --logpath /data/mongod/log/s0.log --fork --smallfiles --port 27020 --bind_ip 10.1.0.70 --shardsvr</code></pre></div><h3>3、分别在每台服务器上启动Config Server</h3><div class=\"highlight\"><pre><code class=\"language-text\">mongod --dbpath /data/mongod/c0 --logpath  /data/mongod/log/c0.log --fork --smallfiles --port 27100 --bind_ip 10.1.0.86 --replSet rs1 --configsvr\nmongod --dbpath /data/mongod/c0 --logpath  /data/mongod/log/c0.log --fork --smallfiles --port 27100 --bind_ip 10.1.0.97 --replSet rs1 --configsvr\nmongod --dbpath /data/mongod/c0 --logpath  /data/mongod/log/c0.log --fork --smallfiles --port 27100 --bind_ip 10.1.0.70 --replSet rs1 --configsvr</code></pre></div><h3>4、配置副本集</h3><div class=\"highlight\"><pre><code class=\"language-text\">// 进入97的mongo\nmongo --port 27100 --host 10.1.0.97\n\n// 使用admin账户\nuse admin\n\n// 初始化副本集\nrs.initiate({_id:&#34;rs1&#34;,members:[{_id:0,host:&#34;10.1.0.97:27100&#34;},{_id:1,host:&#34;10.1.0.86:27100&#34;},{_id:2,host:&#34;10.1.0.70:27100&#34;}]})\n\n// 查看副本集状态\nrs.status()</code></pre></div><h3>5、启动Route Process服务</h3><div class=\"highlight\"><pre><code class=\"language-text\">mongos  --logpath /data/mongod/log/mongo.log --port 30000 --bind_ip 10.1.0.97 --fork --configdb rs1/10.1.0.97:27100,10.1.0.86:27100,10.1.0.70:27100</code></pre></div><h3>6、配置Sharding分片</h3><div class=\"highlight\"><pre><code class=\"language-text\">// 进入路由服务器\nmongo --port 30000 --host 10.1.0.97\n\n// 添加分片\nsh.addShard(&#34;10.1.0.97:27020&#34;)\nsh.addShard(&#34;10.1.0.86:27020&#34;)\nsh.addShard(&#34;10.1.0.70:27020&#34;)\n\n// 查看分片信息\nsh.status();</code></pre></div><h3>7、设置分片数据库与片键</h3><div class=\"highlight\"><pre><code class=\"language-text\">//指定需要分片的数据库\nsh.enableSharding(&#34;performance&#34;)\n\n//创建索引（需要对片建创建索引）\ndb.wx_ajaxs_wx3feeea844b1d03ffs.ensureIndex({&#34;path&#34;:1})\n\n//设置分片（对performance数据库的wx_ajaxs_wx3feeea844b1d03ffs表按照path字段以hashed的方式分片）\nsh.shardCollection(&#34;performance.wx_ajaxs_wx3feeea844b1d03ffs&#34;, { &#34;path&#34;: &#34;hashed&#34;})\n\n//查看分片信息\nsh.status()</code></pre></div><p>其他表分片重复以上步骤即可, 至此一个简单的3台服务器集群搭建完毕。</p><p>注意事项：对mongodb进行分片时需要绑定内网IP，不然请求无法连通。</p><h3><b>备注：应用中对浏览器端 | 微信小程序端</b> <b>默认使用 _id字段 进行分片, 尽量不要更改。</b></h3><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f671e4529d09118d5c28f41d6a7c3007_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1692\" data-rawheight=\"1376\" class=\"origin_image zh-lightbox-thumb\" width=\"1692\" data-original=\"https://pic4.zhimg.com/v2-f671e4529d09118d5c28f41d6a7c3007_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1692&#39; height=&#39;1376&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1692\" data-rawheight=\"1376\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1692\" data-original=\"https://pic4.zhimg.com/v2-f671e4529d09118d5c28f41d6a7c3007_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f671e4529d09118d5c28f41d6a7c3007_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3><br/></h3><h3>五：servers负载均衡</h3><p>servers负载：即把所有上报的请求分发到不同的servers进行处理，减小单个servers服务的压力，也减轻了单个服务器的压力。</p><ul><li>zanePerfor做到了一套代码多服务部署的方案</li><li>应用保证了多服务同时运行时，task任务不重复执行</li></ul><p>此处servers负载均衡采用nginx方案，ng配置如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">upstream ps-servers {\n    server 10.1.0.86:7001 weight=1 max_fails=4 fail_timeout=5;\n    server 10.1.0.97:7001 weight=1 max_fails=4 fail_timeout=5;\n    server 10.1.0.70:7001 weight=2 max_fails=4 fail_timeout=5;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>参数说明:</h3><p>weight=number：设置服务器的权重，默认情况下为1</p><p>max_conns=number：限制到代理服务器的同时活动连接的最大数量，默认为0</p><p>max_fails=number：服务器通信的失败尝试次数</p><p>fail_timeout=number：服务器通信失败超时时间，默认为10</p><p>backup:将服务器标记为备份服务器。它将在主服务器不可用时传递请求</p><p>down:将服务器标记为永久不可用</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>六：redis集群</h3><p>应用中有很多功能都会依赖于redis的缓存能力，因此一台高性能的redis或者redis集群显得很有必要。</p><p>官方如此介绍redis的强劲性能：性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s ，理论上来说单台redis就能满足绝大部分的应用。</p><p>至于redis是否需要集群的支持，需要根据各个应用的情况来决定，博主暂时用的单台redis，500w PV内暂未遇见性能问题。</p><p>至于redis集群的搭建此处暂不做介绍，暂时挂个官网参考链接：<a href=\"https://link.zhihu.com/?target=https%3A//redis.io/topics/cluster-tutorial\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">redis.io/topics/cluster</span><span class=\"invisible\">-tutorial</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>zanePerfor在高流量项目下的架构配置建议实践说明（完）。</p><p></p>", 
            "topic": [
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58658870", 
            "userName": "波罗学", 
            "userLink": "https://www.zhihu.com/people/6b8174bead21abd5b4688eac95274038", 
            "upvote": 11, 
            "title": "快速了解kafka的基础架构", 
            "content": "<p>今天来聊下大数据场景下比较流行的消息队列组件kafka。本篇文章将主要从理论角度来介绍。</p><p>kafka是一款开源、追求高吞吐、实时性，可持久化的流式消息队列，可同时处理在线（消息）与离线应用(业务数据和日志)。在如今火热的大数据时代，得到了广泛的应用。</p><h2>整体架构</h2><p>kafka的消息以Topic进行归类，支持分布式distribution、可分区partition和可复制replicated的特性。下面为本人梳理的一张Kafka系统架构图。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f00681b8c681c213d569c8d0d1cb8003_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"425\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-f00681b8c681c213d569c8d0d1cb8003_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;425&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"425\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-f00681b8c681c213d569c8d0d1cb8003_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f00681b8c681c213d569c8d0d1cb8003_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Kafka的架构相较于其他消息系统而言，比较简单。其整体流程简述如下</p><p>Producer与指定Topic各分区Partition的Leader连接，从而将消息push到Broker中。<br/>Broker可理解消息系统的中间代理，将消息写入磁盘实现持久化，并可对消息复制备份。<br/>Consumer采用pull的方式主动获取broker中指定Topic的消息，并进行处理。<br/>Zookeeper负责Kafka服务相关metadata的存储，如broker，topic和consumer等信息的存储。</p><p>注：zookeeper是一个分布式协调服务，分布式应用可基于它实现同步服务，配置维护和命名服务等。此篇文章不做介绍，以后有时间再做总结！</p><p>下面对涉及的各个组件作详细介绍。</p><h2>主题Topic</h2><p>首先，Kafka中的消息以Topic分类管理。在Kafka中，一个topic可被多个Consumer订阅。通过集群管理，每个Topic可由多个Partition组成。如下图</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3c957146a0349b0186c2d61a1b744fc2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-3c957146a0349b0186c2d61a1b744fc2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;373&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-3c957146a0349b0186c2d61a1b744fc2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3c957146a0349b0186c2d61a1b744fc2_b.jpg\"/></figure><p>从上图可以看出，Topic中数据是顺序不可变序列，采用log追加方式写入，因而kafka中无因随机写入导致性能低下的问题。</p><p>Topic的数据可存储在多个partition中，即可存放在不同的服务器上。这可使Topic大小不限于一台server容量。同时，消息存在多个partition上，可以实现Topic上消息的并发访问。</p><p>Kafka中数据不会因被consumer消费后而丢失，而是通过配置指定消息保存时长。Topic中每个partition中的消息都有一个唯一的标识，也称为offset。因数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-784518472ee24cfe390dbf46d83bc22e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"347\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-784518472ee24cfe390dbf46d83bc22e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;347&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"347\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-784518472ee24cfe390dbf46d83bc22e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-784518472ee24cfe390dbf46d83bc22e_b.jpg\"/></figure><p>基于此，消息获取即可采用顺序访问，我们也可以指定任意offset随机访问，且不会对其他consumer产生影响。</p><h2>分布式Distribution</h2><p>Kafka的集群分布式主要涉及两个内容：Partition分区与Replication备份。</p><p>Partition实现将Topic中的各个消息存储到不同的分区中，从而分布在不同的Kafka节点之上，使Topic的数据大小不限于一台Server。</p><p>Replication主要用于容错，对一个Partition复制多份，存储在不同kafka节点上。这可防止因某一分区数据丢失而导致错误。</p><p>虽然Relication复制Partition多份，但其中只有一个为Leader角色，其余Partition角色皆为Follower。Producer发布消息都是由Leader负责写入，并同步到其他的Follower分区中。如果Leader失效，则某个Follower会自动替换，成为新的Leader分区。此时，Follower可能落后于Leader，所以从所有Follower中选择一个”up-to-date”的分区。</p><p>关于性能方面，考虑Leader不但承载了客户的连接与消息写入，还负责将消息同步至不同的Follower分区上，性能开销较大。因此，不同Partition的Leader分布在不同的kafka节点上，从而防止某个节点压力过载。</p><p>为了更好了解Partition与Replication关系。举个例子，假设现有一个Topic名为spark_topic，其Partition分区数量为3，Replication备份因子为2。则效果如下图</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-98179b0d7bfbb5c71453031404a459fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"636\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-98179b0d7bfbb5c71453031404a459fe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;636&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"636\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-98179b0d7bfbb5c71453031404a459fe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-98179b0d7bfbb5c71453031404a459fe_b.jpg\"/></figure><p>spark_topic存在spark_topic-1，spark_topic-2，spark_topic-3共三个分区。而每个分区均有两处备份，如spark_topic-1，其同时存在于kafka节点broker0与broker1上，其中broker01上的分区角色为Leader。</p><h2>消费者Consumer</h2><p>Consumer负责消费消息。Kafka中Consumer消费消息采用fetch方式主动拉取，这种方式的好处是Consumer客户端能根据自己的处理消息能力决定消息获取的速度与批量获取的数量，从而防止系统过载。</p><p>Kafka的消息并不会因为消息被Consumer消费而丢失，因而其提供一个唯一的标识offset实现消息的顺序获取，而offset需要consumer自行维护，非kafka节点服务管理。这不同于传统的消息系统。在Kafka集群中，消费者的信息与offset在zookeeper也有保存维护，Consumer会间歇性向zookeeper同步offset。</p><p>Kafka的Consumer提供分组功能，每个Consumer都属于一个分组。那分组的作用是什么呢？</p><p>类似queue模式，一个Consumer分组的多个Consumer订阅同一个Topic，一条消息只分发给其中一个Consumer，实现负载均衡效果。</p><p>发布订阅模式，而不同组的多个Consumer订阅同一个Topic，一条消息会广播给在不同分组的所有Consumer。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b52fca1f7b332def801298a7654d3a12_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-b52fca1f7b332def801298a7654d3a12_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;302&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-b52fca1f7b332def801298a7654d3a12_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b52fca1f7b332def801298a7654d3a12_b.jpg\"/></figure><p>请注意，在Kafka中，同一Consumer分组中，一个Consumer只能订阅一个Topic中的Partition，因而在一个Consumer分组中，同时订阅同一个Topic的Consumer的个数不能超过Partition分区数。可参看上图所示。</p><p>同样，为减少网络IO开销，Consumer可采用batch fetch方式实现一次批量获取多条消息。</p><h2>应用场景</h2><p>下面是一些官网介绍的Kafka应用场景，包括消息系统、网站行为跟踪、应用监控、日志收集等等。</p><h2>消息系统</h2><p>Kafka可以作为传统消息系统的替代。相比传统消息，Kafka有更高的吞吐量、拥有内置的分区Partition、复制备份高容错能力。</p><p>传统消息系统对高吞吐量没有过高要求，但kafka的低延迟特性和强大的备份容错能力是传统消息所必须的。</p><h2>网站行为追踪</h2><p>Kafka可用于用户行为追踪，通过将用户行为数据发送给Kafka。以此为基础，实现用户行为在线与离线分析，可用于网站实时监控与异常行为拦截等。</p><h2>日志收集</h2><p>Kafka可以作为日志收集解决方案。日志收集通常是将不同服务器的日志文件收集到一个中心区域，Kafka实现了对日志文件数据进行抽象，统一了处理接口。Kafka低延迟，支持不同的日志数据源，分布式消费易于扩展，可同时将数据提供给hdfs、storm、监控软件等等。</p><h2>应用监控</h2><p>Kafka可用于监控运行中的应用系统。如收集分布式应用的数据进行聚合计算，进行分析检测异常情况。</p><p>个人感觉，本质和网站行为分析异常监控有异曲同工之处，只不过所监控的数据对象不同罢了。</p><h2>结束</h2><p>利用两周末学习总结了大数据中常用的消息队列服务-Kafka。本篇主要从架构角度介绍。个人感觉，介绍系统架构比操作实战更加困难，文章如有错误，请帮忙请指正。</p><p></p>", 
            "topic": [
                {
                    "tag": "大数据", 
                    "tagLink": "https://api.zhihu.com/topics/19740929"
                }, 
                {
                    "tag": "消息队列", 
                    "tagLink": "https://api.zhihu.com/topics/19708788"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55680941", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 2, 
            "title": "kafka的安装和常用基本命令说明", 
            "content": "<h2>一:  MAC安装kafka</h2><h2>安装：</h2><p>kafka依赖java环境，因此你可能需要先安装好java环境。</p><div class=\"highlight\"><pre><code class=\"language-text\">// mac 环境使用brew直接安装kafka\nbrew install kafka \n\n// 卸载\nbrew uninstall kafka</code></pre></div><p>mac 安装kafka过程中会自动的安装好zookeeper。</p><h2>启动：</h2><div class=\"highlight\"><pre><code class=\"language-text\">// 启动\nbrew services start kafka\nbrew services start zookeeper\n\n// 重启\nbrew services restart kafka\nbrew services restart zookeeper</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>二：Linux安装kafka</h2><h2>一、进入官网下载安装包</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//kafka.apache.org/downloads\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">kafka.apache.org/downlo</span><span class=\"invisible\">ads</span><span class=\"ellipsis\"></span></a><br/></p><p>下载Binary包如下图，下面以2.1.0版本为例：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d5acb3764bc2dfceccd1dc03d7f6950d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"874\" data-rawheight=\"828\" class=\"origin_image zh-lightbox-thumb\" width=\"874\" data-original=\"https://pic2.zhimg.com/v2-d5acb3764bc2dfceccd1dc03d7f6950d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;874&#39; height=&#39;828&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"874\" data-rawheight=\"828\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"874\" data-original=\"https://pic2.zhimg.com/v2-d5acb3764bc2dfceccd1dc03d7f6950d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d5acb3764bc2dfceccd1dc03d7f6950d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">cd /usr/src\n// 下载包\nwget http://mirror.bit.edu.cn/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz\n\n// 解压\ntar -xzf kafka_2.11-2.1.0.tgz\n// 重命名为kafka\nmv kafka_2.11-2.1.0 kafka\n\ncd kafka</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>前台启动Zookeeper 和kafka</h2><div class=\"highlight\"><pre><code class=\"language-text\">bin/zookeeper-server-start.sh config/zookeeper.properties\n\nbin/kafka-server-start.sh config/server.properties</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>后台启动Zookeeper 和kafka</h2><div class=\"highlight\"><pre><code class=\"language-text\">bin/zookeeper-server-start.sh config/zookeeper.properties 1&gt;/dev/null  2&gt;&amp;1  &amp;\n\nbin/kafka-server-start.sh config/server.properties 1&gt;/dev/null  2&gt;&amp;1  &amp;</code></pre></div><p>其中1&gt;/dev/null 2&gt;&amp;1 是将命令产生的输入和错误都输入到空设备，也就是不输出的意思。/dev/null代表空设备。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>kafka配置说明：</h2><p>配置文件server.properties</p><div class=\"highlight\"><pre><code class=\"language-text\">// mac 电脑配置文件地址\nvim /usr/local/etc/kafka/server.properties\n\n// Linux 配置文件地址\nvim /usr/src/kafka/config/server.properties</code></pre></div><p><b>配置参考地址：</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.orchome.com/472\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">orchome.com/472</span><span class=\"invisible\"></span></a><br/></p><p>备注： 尽量配置host.name, 例如本地的配置</p><div class=\"highlight\"><pre><code class=\"language-text\">host.name = 127.0.0.1\nport=9092</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>常用基本命令：</h2><p><b>创建一个主题(topic)</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// mac\nkafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n\n// linux\nbin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>删除topic</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// mac \nkafka-topics  --delete --zookeeper localhost:2181 --topic 【topic name】\n\n// linux \nbin/kafka-topics.sh --delete --zookeeper localhost:2181 --topic 【topic name】</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>查看创建的topic list</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// mac\nkafka-topics --list --zookeeper localhost:2181\n\n// linux\nbin/kafka-topics.sh --list --zookeeper localhost:2181</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>生产消息</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// mac \nkafka-console-producer --broker-list localhost:9092 --topic test\n\n// linux \nbin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>消费消息</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// mac \nkafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning\n\n// linux \nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>更多使用方式可参考：<a href=\"https://link.zhihu.com/?target=http%3A//www.orchome.com/454\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">orchome.com/454</span><span class=\"invisible\"></span></a></p>", 
            "topic": [
                {
                    "tag": "Kafka", 
                    "tagLink": "https://api.zhihu.com/topics/20012159"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55542481", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 2, 
            "title": "node.js中kafka的封装和高并发消费限流优雅降级以及egg-kafka的封装说明", 
            "content": "<p>HI!，你好，我是zane，zanePerfor是一款我开发的一个前端性能监控平台，现在支持web浏览器端和微信小程序端。</p><p>我定义为一款完整，高性能，高可用的前端性能监控系统，这是未来会达到的目的，现今的架构也基本支持了高可用，高性能的部署。实际上还不够，在很多地方还有优化的空间，我会持续的优化和升级。</p><p>开源不易，如果你也热爱技术，拥抱开源，希望能小小的支持给个star。</p><p>项目的github地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/zanePerfor\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/zanePerfor</span><span class=\"ellipsis\"></span></a></p><p>项目开发文档说明：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/performance/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.seosiwei.com/perfo</span><span class=\"invisible\">rmance/index.html</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。<br/>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 <br/>这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 <br/>这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 <br/>针对于zanePerfor这样的用户访问行为，页面性能监控系统，但又要求实时处理的限制，这是一个可行的解决方案。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>zanePerfor中对于kafka的应用使用了kafka-node包，并在此基础上封装了egg-kafka插件。</p><p>zanePerfor初步的探索了kafka在node.js中的应用，以下内容主要讲解kafka在zanePerfor项目中的使用方式。</p><p>如果你对在node.js中使用kafka有更多的建议和心得，也希望能跟我一起分享。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>zanePerfor项目中kafka应用介绍：</h2><p><b>启用kafka配置说明：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// config/config.default.js\n// kafka 配置 (report_data_type=kafka生效)\n// 配置参考 https://www.npmjs.com/package/kafka-node\nconfig.kafka = {\n    client: {\n        kafkaHost: &#39;localhost:9092&#39;,\n    },\n    producer: {\n        web: {\n            topic: &#39;zane_perfor_web&#39;,\n            partition: 0, // default 0\n            attributes: 0, // default: 0\n            // timestamp: Date.now(),\n        },\n        wx: {\n            topic: &#39;zane_perfor_wx&#39;,\n        },\n    },\n    // consumer 和 consumerGroup消费任选其一即可\n    // 优先选择consumer消费，两种消费配置任留一种即可\n    consumer: {\n        web: {\n            topic: &#39;zane_perfor_web&#39;,\n            offset: 0, // default 0\n            partition: 0, // default 0\n            isone: false, // 此参数默认不可更改\n            total_limit: 10000, // 消息队列消费池限制数, 0：不限制 number: 限制条数 高并发时服务优雅降级方案\n        },\n        wx: {\n            topic: &#39;zane_perfor_wx&#39;,\n            isone: false,\n            total_limit: 10000,\n        },\n    },\n    consumerGroup: {\n        web: { // ConsumerGroup(options, topics)\n            topic: &#39;zane_perfor_web&#39;,\n            groupId: &#39;WebPerformanceGroup&#39;,\n            commitOffsetsOnFirstJoin: true,\n        },\n        wx: {\n            topic: &#39;zane_perfor_wx&#39;,\n            groupId: &#39;WxPerformanceGroup&#39;,\n            commitOffsetsOnFirstJoin: true,\n        },\n    },\n};</code></pre></div><p><b>配置说明：</b></p><p><b>client参数说明：</b></p><p>client参数即为kafka-node中的KafkaClient参数，参考地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/kafka-node%23kafkaclient\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">npmjs.com/package/kafka</span><span class=\"invisible\">-node#kafkaclient</span><span class=\"ellipsis\"></span></a></p><p><b>producer生产者参数说明：</b></p><p>producer分web端和wx端配置</p><p>producer参数为kafka-node中的send参数，参考地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/kafka-node%23sendpayloads-cb\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">npmjs.com/package/kafka</span><span class=\"invisible\">-node#sendpayloads-cb</span><span class=\"ellipsis\"></span></a></p><p><b>consumer消费者参数说明：</b></p><p>consumer分web端和wx端配置</p><p>consumer参数为kafka-node中的consumer参数, 参考地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/kafka-node%23consumerclient-payloads-options\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">npmjs.com/package/kafka</span><span class=\"invisible\">-node#consumerclient-payloads-options</span><span class=\"ellipsis\"></span></a></p><p><b>consumerGroup消费者参数说明：</b></p><p>consumerGroup分web端和wx端配置</p><p>consumerGroup参数为kafka-node中的consumerGroup参数，参考地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/kafka-node%23consumergroupoptions-topics\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">npmjs.com/package/kafka</span><span class=\"invisible\">-node#consumergroupoptions-topics</span><span class=\"ellipsis\"></span></a></p><h2>关于消费者说明</h2><p>config配置中有consumer和consumerGroup配置，规则如下：</p><ul><li>如果consumer配置为真有限使用consumer配置</li><li>如果想启用consumerGroup配置，则注释或者删除consumer配置即可</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>kafka生产消费逻辑实现：</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a83a16d0f9cbf562a26dff52b4cd3a22_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"911\" data-rawheight=\"602\" class=\"origin_image zh-lightbox-thumb\" width=\"911\" data-original=\"https://pic3.zhimg.com/v2-a83a16d0f9cbf562a26dff52b4cd3a22_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;911&#39; height=&#39;602&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"911\" data-rawheight=\"602\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"911\" data-original=\"https://pic3.zhimg.com/v2-a83a16d0f9cbf562a26dff52b4cd3a22_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a83a16d0f9cbf562a26dff52b4cd3a22_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>核心代码实现：</h2><p><b>一：生产者</b></p><p>kafka的性能非常强劲，能支持超高并发，因此所有客户端上报的信息都存储到消息队列中，限流策略只使用在消费端，生产端不做限流设置。</p><div class=\"highlight\"><pre><code class=\"language-text\">// app/controller/api/web/report.js\n// 通过kafka 消息队列消费数据\n    async saveWebReportDataForKafka(query) {\n        // 生产者\n        this.app.kafka.send(\n            &#39;web&#39;,\n            JSON.stringify(query)\n        );\n\n        // 消费者\n        if (!isKafkaConsumer &amp;&amp; !this.app.config.kafka.consumer.web.isone) {\n            this.ctx.service.web.reportTask.saveWebReportDatasForKafka();\n            isKafkaConsumer = true;\n            this.app.config.kafka.consumer.web.isone = true;\n        }\n    }</code></pre></div><ul><li>this.app.kafka.send是封装的插件egg-kafka中的方法，功能就是生产信息</li><li>if (!isKafkaConsumer &amp;&amp; !this.app.config.kafka.consumer.web.isone)是为了保证订阅消息的方法只执行一次，后面一但有消息产生，会自动触发订阅函数进行数据消费消费。</li></ul><p><b>二：消费者</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// app/service/web/report_task.js\n// kafka 消费信息\n    async saveWebReportDatasForKafka() {\n        if (this.kafkaConfig.consumer) {\n            this.app.kafka.consumer(&#39;web&#39;, message =&gt; {\n                this.consumerDatas(message);\n            });\n        } else if (this.kafkaConfig.consumerGroup) {\n            this.app.kafka.consumerGroup(&#39;web&#39;, message =&gt; {\n                this.consumerDatas(message);\n            });\n        }\n    }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>this.app.kafka.consumer 单独消费，egg-kafka中暴露的方法</li><li>this.app.kafka.consumerGroup 以分组的方式消费消息</li><li>优先使用consumer消费，其次使用consumerGroup进行消费</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>egg-kafka插件封装说明</h2><p>为了更好、更方便的使用kafka，项目中对node-kafka进行了一层封装。</p><p>详细请参考：/lib/plugin/egg-kafka/lib/kafka.js</p><p><b>send代码实现如下：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">send(type, data) {\n        assert(type, &#39;[egg-kafka] type is must required.&#39;);\n        if (!data) return;\n        let producer = this.app.config.kafka.producer[type] || {};\n        let producers = [];\n        if (typeof (data) === &#39;string&#39;) {\n            producer.messages = data;\n            producers = [ producer ];\n        } else if (Object.prototype.toString.call(data) === &#39;[object Object]&#39;) {\n            producer = Object.assign({}, producer, data);\n            producers = [ producer ];\n        } else if (Object.prototype.toString.call(data) === &#39;[object Array]&#39;) {\n            for (let i = 0; i &lt; data.length; i++) {\n                data[i] = Object.assign({}, producer, data[i]);\n            }\n            producers = data;\n        }\n        this.producer.send(producers, (err, data) =&gt; {\n            if (err) assert(err, &#39;[egg-kafka] err. errmsg ${err}&#39;);\n            console.log(data);\n        });\n    }</code></pre></div><p>send有两个参数，第一个参数type为发送类型，有web、wx两个值可以选择。</p><p><b>对data做了一定的判断，send调用可以有以下几种方式：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// 消息为String\nthis.app.kafka.send(&#39;web&#39;,&#39;hello world!&#39;);\n// 消息为Object\nthis.app.kafka.send(&#39;web&#39;,{ topic:&#39;test&#39;, messages:&#39;hello world!&#39; });\n// 消息为Array\nthis.app.kafka.send(&#39;web&#39;,[{ topic: &#39;test&#39;, messages: &#39;hi&#39;, partition: 0}]);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>consumer方法代码实现：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">consumer(type = &#39;web&#39;, fn) {\n    assert(type, &#39;[egg-kafka] consumers type argument must be required&#39;);\n    const kafkaConfig = this.app.config.kafka;\n    const consumer = kafkaConfig.consumer[type] || {};\n    const consumers = Array.isArray(consumer) ? consumer : [ consumer ];\n    const Consumer = kafka.Consumer;\n    const _consumer = new Consumer(\n        this.client,\n        consumers,\n        {\n            autoCommit: true,\n        }\n    );\n    _consumer.on(&#39;error&#39;, err =&gt; {\n        this.app.coreLogger.error(`[egg-kafka] consumer have error ${err}`);\n    });\n    _consumer.on(&#39;message&#39;, message =&gt; {\n        fn &amp;&amp; fn(message);\n    });\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>consumerGroup代码实现：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">consumerGroup(type = &#39;web&#39;, fn) {\n    assert(type, &#39;[egg-kafka] consumers type argument must be required&#39;);\n    const kafkaConfig = this.app.config.kafka;\n    const kafkaHost = kafkaConfig.client.kafkaHost;\n    const consumerOption = kafkaConfig.consumerGroup[type] || {};\n    const topic = consumerOption.topic;\n    consumerOption.kafkaHost = kafkaHost;\n    const ConsumerGroup = kafka.ConsumerGroup;\n    const _consumer = new ConsumerGroup(consumerOption, topic);\n    _consumer.on(&#39;error&#39;, err =&gt; {\n        this.app.coreLogger.error(`[egg-kafka] consumer have error ${err}`);\n    });\n    _consumer.on(&#39;message&#39;, message =&gt; {\n        fn &amp;&amp; fn(message);\n    });\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>消费限流策略：</h2><p>由于kafka性能及其强悍，因此zanePerfor只对消费进行限流</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b25a6a21392c25ecccee1675e2c386da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1182\" data-rawheight=\"523\" class=\"origin_image zh-lightbox-thumb\" width=\"1182\" data-original=\"https://pic3.zhimg.com/v2-b25a6a21392c25ecccee1675e2c386da_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1182&#39; height=&#39;523&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1182\" data-rawheight=\"523\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1182\" data-original=\"https://pic3.zhimg.com/v2-b25a6a21392c25ecccee1675e2c386da_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b25a6a21392c25ecccee1675e2c386da_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>代码实现：</b></p><p><b>设置消费池数量</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// config.default.js\n{\n\ttopic: &#39;zane_perfor_web&#39;,\n\toffset: 0, // default 0\n\tpartition: 0, // default 0\n\tisone: false, // 此参数默认不可更改\n\ttotal_limit: 10000, // 消息队列消费池限制数, 0：不限制 number: 限制条数 高并发时服务优雅降级方案\t\t\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>kafka连接池数量判断</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// app/service/web/report_task.js 中 getWebItemDataForKafka 方法\n// kafka 连接池限制\nconst msgtab = query.time + query.ip;\nif (this.kafkatotal &amp;&amp; this.kafkalist.length &gt;= this.kafkatotal) return;\nthis.kafkalist.push(msgtab);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>数据消费完成之后删除消费标识</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// app/service/web/report_task.js 中 getWebItemDataForKafka 方法\nthis.savePages(item, system.slow_page_time, () =&gt; {\n    // 释放消费池\n    const index = this.kafkalist.indexOf(msgtab);\n    if (index &gt; -1) this.kafkalist.splice(index, 1);\n});</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>至此实现了egg.js中对kafka的应用和封装。</p>", 
            "topic": [
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }, 
                {
                    "tag": "Kafka", 
                    "tagLink": "https://api.zhihu.com/topics/20012159"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53427708", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 0, 
            "title": "zanePerfor中一套简单通用的Node前后端Token登录机制和github授权登录方式", 
            "content": "<p>HI!，你好，我是zane，zanePerfor是一款我开发的一个前端性能监控平台，现在支持web浏览器端和微信小程序端。</p><p>我定义为一款完整，高性能，高可用的前端性能监控系统，这是未来会达到的目的，现今的架构也基本支持了高可用，高性能的部署。实际上还不够，在很多地方还有优化的空间，我会持续的优化和升级。</p><p>开源不易，如果你也热爱技术，拥抱开源，希望能小小的支持给个star。</p><p>项目的github地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/zanePerfor\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/zanePerfor</span><span class=\"ellipsis\"></span></a></p><p>项目开发文档说明：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/performance/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.seosiwei.com/perfo</span><span class=\"invisible\">rmance/index.html</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>谈起Token登录机制，相信绝大部分人都不陌生，相信很多的前端开发人员都有实际的开发实践。</p><p>此文章的Token登录机制主要针对于无实际开发经验或者开发过简单登录机制的人员，如果你是大佬几乎可以略过了，如果你感兴趣或者闲来无事也可以稍微瞅它一瞅。</p><p>此文章不会教你一步一步的实现一套登录逻辑，只会结合zanePerfor项目阐述它的登录机制，讲明白其原理比写一堆代码来的更实在和简单。</p><p>zanePerfor项目的主要技术栈是 egg.js、redis和mongodb, 如果你不懂没关系，因为他们都只是简单使用，很容易理解。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>登录实现结果：</h2><ul><li>如果用户未注册时先注册然后直接登录</li><li>用户每次登录都会动态生成session令牌</li><li>同一账号在同一时刻只能在一个地方登录</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>cookie在项目中的作用</h2><p>我们知道http是无状态的，因此如果要知道用户某次请求是否登录就需要带一定的标识，浏览器端http请求带标识常用的方式有两种：1、使用cookie附带标识，2、使用header信息头附带标识。</p><p>这里我们推荐的方式是使用cooke附带标识，因为它相当于来说更安全和更容易操作。</p><p><b>更安全体现在：</b>cookie只能在同域下传输，还可以设置httpOnly来禁止js的更改。</p><p><b>更容易操作体现在：</b>cookie传输是浏览器请求时自带的传输头信息，我们不需要额外的操作，cookie还能精确到某一个路径，并且可以设置过期时间自动过期，这样就显得更可控。</p><p>当然header信息头也有它的优势和用武之地，这里不做阐述。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>redis在项目中的作用</h2><p>一般的项目我们会把识别用户的标识放存放在Session中，但是Session有其使用的局限性。</p><p><b>Session的局限</b>：Session 默认存放在 Cookie 中，但是如果我们的 Session 对象过于庞大，浏览器可能拒绝保存，这样就失去了数据的完整性。当 Session 过大时还会对每次http请求带来额外的开销。还有一个比较大的局限性是Session存放在单台服务器中，当有多台服务器时无法保证统一的登录态。还会带来代码的强耦合性，不能使得登录逻辑代码解耦。</p><p>因此这里引入redis进行用户身份识别的储存。</p><p><b>redis的优势：</b>redis使用简单，redis性能足够强悍，储存空间无限制，多台服务器可以使用统一的登录态，登录逻辑代码的解耦。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>前端统一登录态封装</h2><p>前端统一登录态应该是每位前端童鞋都做过的事情，下面以zanePerfor的Jquery的AJAX为例做简单的封装为例：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 代码路径：app/public/js/util.js\najax(json) {\n    // ...代码略...\n    return $.ajax({\n        type: json.type || &#34;post&#34;,\n        url: url,\n        data: json.data || &#34;&#34;,\n        dataType: &#34;json&#34;,\n        async: asyncVal,\n        success: function(data) {\n            // ...代码略...\n            // success 时统一使用this.error方法进行处理\n            if (typeof(data) == &#39;string&#39;) {\n                This.error(JSON.parse(data), json);\n            } else {\n                This.error(data, json);\n            }\n        },\n        // ...代码略...\n    });\n};\n\nerror(data, json) {\n    //判断code 并处理\n    var dataCode = parseInt(data.code);\n    // code 为1004表示未登录 需要统一走登录页面\n    if (!json.isGoingLogin &amp;&amp; dataCode == 1004) {\n        //判断app或者web\n        if (window.location.href.indexOf(config.loginUrl) == -1) {\n            location.href = config.loginUrl + &#39;?redirecturl=&#39; + encodeURIComponent(location.href);\n        } else {\n            popup.alert({\n                type: &#39;msg&#39;,\n                title: &#39;用户未登陆,请登录!&#39;\n            });\n        }\n    } else {\n        switch (dataCode) {\n            // code 为1000表示请求成功\n            case 1000:\n                json.success &amp;&amp; json.success(data);\n                break;\n            default:\n                if (json.goingError) {\n                    //走error回调\n                    json.error &amp;&amp; json.error(data);\n                } else {\n                    //直接弹出错误信息\n                    popup.alert({\n                        type: &#39;msg&#39;,\n                        title: data.desc\n                    });\n                };\n        }\n    };\n}</code></pre></div><ul><li>前端的逻辑代码很简单，就是统一的判断返回code, 如果未登录则跳转到登录页面。</li></ul><h2><br/></h2><h2>User表结构说明</h2><div class=\"highlight\"><pre><code class=\"language-text\">// 代码路径 app/model/user.js\nconst UserSchema = new Schema({\n        user_name: { type: String }, // 用户名称\n        pass_word: { type: String }, // 用户密码\n        system_ids: { type: Array }, // 用户所拥有的系统Id\n        is_use: { type: Number, default: 0 }, // 是否禁用 0：正常  1：禁用\n        level: { type: Number, default: 1 }, // 用户等级（0：管理员，1：普通用户）\n        token: { type: String }, // 用户秘钥\n        usertoken: { type: String }, // 用户登录态秘钥\n        create_time: { type: Date, default: Date.now }, // 用户访问时间\n    });</code></pre></div><ul><li>用户表中 usertoken 字段比较重要，它表示每次用户登录时动态生成的Token令牌key, 也是存在在redis中用户信息的key值，此值每次用户登录时都会更新，并且是随机和唯一的。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>Node Servers端登录逻辑</h2><p>我们先来一张登录的页面</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-468ff6c6e12b0644edf9123b4f2a5afb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"546\" class=\"origin_image zh-lightbox-thumb\" width=\"756\" data-original=\"https://pic4.zhimg.com/v2-468ff6c6e12b0644edf9123b4f2a5afb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;756&#39; height=&#39;546&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"546\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"756\" data-original=\"https://pic4.zhimg.com/v2-468ff6c6e12b0644edf9123b4f2a5afb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-468ff6c6e12b0644edf9123b4f2a5afb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b8f46dcca1566f07fc946d78ac5a02ba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1213\" data-rawheight=\"746\" class=\"origin_image zh-lightbox-thumb\" width=\"1213\" data-original=\"https://pic3.zhimg.com/v2-b8f46dcca1566f07fc946d78ac5a02ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1213&#39; height=&#39;746&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1213\" data-rawheight=\"746\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1213\" data-original=\"https://pic3.zhimg.com/v2-b8f46dcca1566f07fc946d78ac5a02ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b8f46dcca1566f07fc946d78ac5a02ba_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>业务代码如下：</h2><div class=\"highlight\"><pre><code class=\"language-text\">// 代码路径  app/service/user.js\n// 用户登录\n    async login(userName, passWord) {\n        // 检测用户是否存在\n        const userInfo = await this.getUserInfoForUserName(userName);\n        if (!userInfo.token) throw new Error(&#39;用户名不存在！&#39;);\n        if (userInfo.pass_word !== passWord) throw new Error(&#39;用户密码不正确！&#39;);\n        if (userInfo.is_use !== 0) throw new Error(&#39;用户被冻结不能登录，请联系管理员！&#39;);\n\n        // 清空以前的登录态\n        if (userInfo.usertoken) this.app.redis.set(`${userInfo.usertoken}_user_login`, &#39;&#39;);\n\n        // 设置新的redis登录态\n        const random_key = this.app.randomString();\n        this.app.redis.set(`${random_key}_user_login`, JSON.stringify(userInfo), &#39;EX&#39;, this.app.config.user_login_timeout);\n        // 设置登录cookie\n        this.ctx.cookies.set(&#39;usertoken&#39;, random_key, {\n            maxAge: this.app.config.user_login_timeout * 1000,\n            httpOnly: true,\n            encrypt: true,\n            signed: true,\n        });\n        // 更新用户信息\n        await this.updateUserToken({ username: userName, usertoken: random_key });\n\n        return userInfo;\n    }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>对照user表来进行逻辑的梳理。</h2><ul><li>每次登录前都会清除上一次在redis中的登录态信息，所以上一次的登录令牌对应的redis信息会失效，因此我们只需要做一个校验用户Token的信息在redis中是否存在即可判断用户当前登录态是否有效。</li><li>清除上一次登录态信息之后立即生成一个随机并唯一的key值做为新的Token令牌，并更新redis中Token的令牌信息 和 设置新的cookie令牌，这样就保证了以前的登录态失效，当前的登录态有效。</li><li>redis 和 cookie 都设置相同的过期时间，以保证Token的时效性和安全性。</li><li>cookie的httpOnly 我们需要开启，这样就保证的Token的不可操作性，encrypt 和 signed参数是egg.js 的参数，主要负责对cookie进行加密，让前端的cookie不已明文的方式呈现，提高安全性。</li><li>最后再更新用户的Token令牌信息，以保证用户的Token每次都是最新的，也用以下次登录时的清除操作。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>Servers 端用户登录校验中间件</h2><p>中间件的概念相信大家都不陌生，用过koa,express和redux都应该知道，egg.js的中间件来自于与koa，在这里就不说概念了。</p><p>在zanePerfor项目中我们只需要对所有需要进行登录校验的路由(请求)进行中间件校验即可。</p><p><b>在egg中可这样使用：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// 代码来源 app/router/api.js\n// 获得controller 和 middleware（中间件）\nconst { controller, middleware } = app;\n\n// 对需要校验的路由进行校验\n// 退出登录\napiV1Router.get(&#39;user/logout&#39;, tokenRequired, user.logout);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-aee02902106c7f810c376eddf2eec1b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1272\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb\" width=\"1272\" data-original=\"https://pic3.zhimg.com/v2-aee02902106c7f810c376eddf2eec1b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1272&#39; height=&#39;554&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1272\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1272\" data-original=\"https://pic3.zhimg.com/v2-aee02902106c7f810c376eddf2eec1b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-aee02902106c7f810c376eddf2eec1b2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>业务代码如下：</h2><div class=\"highlight\"><pre><code class=\"language-text\">// 代码路径  app/middleware/token_required.js\n// Token校验中间件\nmodule.exports = () =&gt; {\n    return async function(ctx, next) {\n        const usertoken = ctx.cookies.get(&#39;usertoken&#39;, {\n            encrypt: true,\n            signed: true,\n        }) || &#39;&#39;;\n        if (!usertoken) {\n            ctx.body = {\n                code: 1004,\n                desc: &#39;用户未登录&#39;,\n            };\n            return;\n        }\n        const data = await ctx.service.user.finUserForToken(usertoken);\n        if (!data || !data.user_name) {\n            ctx.cookies.set(&#39;usertoken&#39;, &#39;&#39;);\n            const descr = data &amp;&amp; !data.user_name ? data.desc : &#39;登录用户无效！&#39;;\n            ctx.body = {\n                code: 1004,\n                desc: descr,\n            };\n            return;\n        }\n        await next();\n    };\n};\n\n// finUserForToken方法代码路径\n// 代码路径  app/service/user.js\n\n// 根据token查询用户信息\nasync finUserForToken(usertoken) {\n    let user_info = await this.app.redis.get(`${usertoken}_user_login`);\n\n    if (user_info) {\n        user_info = JSON.parse(user_info);\n        if (user_info.is_use !== 0) return { desc: &#39;用户被冻结不能登录，请联系管理员！&#39; };\n    } else {\n        return null;\n    }\n    return await this.ctx.model.User.findOne({ token: user_info.token }).exec();\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>逻辑梳理：</h2><ul><li>首先会获得上传的token令牌，这里cookie.get方法的 encrypt 和 signed 需要为true，这会把Token解析为明文。</li><li>在finUserForToken方法中主要是获取Token令牌对应的redis用户信息，只有当用户的信息为真值时才会通过校验</li><li>在中间件这一环节还有一个比较常规的验证 就是 验证请求的 referer, referer也是浏览器请求时自带的，在浏览器端不可操作，这相对的增加了一些安全性(项目中暂未做，这个验证比较简单，如果有需要的自己去实现)。</li></ul><h2>到此zanePerfor的Token校验机制其实已经完全实现完了，只是未做整体的总结，下面来继续的完成注册的逻辑。</h2><p class=\"ztext-empty-paragraph\"><br/></p><h2>用户注册逻辑实现</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-578a3bbabe81fa3d0007db3ca44dffb7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1100\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb\" width=\"1100\" data-original=\"https://pic4.zhimg.com/v2-578a3bbabe81fa3d0007db3ca44dffb7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1100&#39; height=&#39;357&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1100\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1100\" data-original=\"https://pic4.zhimg.com/v2-578a3bbabe81fa3d0007db3ca44dffb7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-578a3bbabe81fa3d0007db3ca44dffb7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>业务代码如下：</h2><div class=\"highlight\"><pre><code class=\"language-text\">// 代码路径  app/service/user.js\n\n// 用户注册\nasync register(userName, passWord) {\n    // 检测用户是否存在\n    const userInfo = await this.getUserInfoForUserName(userName);\n    if (userInfo.token) throw new Error(&#39;用户注册：用户已存在！&#39;);\n\n    // 新增用户\n    const token = this.app.randomString();\n\n    const user = this.ctx.model.User();\n    user.user_name = userName;\n    user.pass_word = passWord;\n    user.token = token;\n    user.create_time = new Date();\n    user.level = userName === &#39;admin&#39; ? 0 : 1;\n    user.usertoken = token;\n    const result = await user.save();\n\n    // 设置redis登录态\n    this.app.redis.set(`${token}_user_login`, JSON.stringify(result), &#39;EX&#39;, this.app.config.user_login_timeout);\n    // 设置登录cookie\n    this.ctx.cookies.set(&#39;usertoken&#39;, token, {\n        maxAge: this.app.config.user_login_timeout * 1000,\n        httpOnly: true,\n        encrypt: true,\n        signed: true,\n    });\n\n    return result;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>用户注册的代码比较简单，首先检测用户是否存在，不存在则储存</li><li>生成动态并唯一的Token令牌，并保持数据到redis 和设置 cookie令牌信息， 这里都设置相同的过期时间，并加密cookie信息和httpOnly。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>退出登录逻辑</h2><p>退出登录逻辑很简单，直接清除用户Token对应的redis信息和cookie token令牌即可。</p><div class=\"highlight\"><pre><code class=\"language-text\">// 登出\nlogout(usertoken) {\n    this.ctx.cookies.set(&#39;usertoken&#39;, &#39;&#39;);\n    this.app.redis.set(`${usertoken}_user_login`, &#39;&#39;);\n    return {};\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>冻结用户逻辑</h2><p>冻结用户的逻辑也比较简单，唯一需要注意的是，冻结的时候需要清除用户Token对应的redis信息。</p><div class=\"highlight\"><pre><code class=\"language-text\">// 冻结解冻用户\nasync setIsUse(id, isUse, usertoken) {\n    // 冻结用户信息\n    isUse = isUse * 1;\n    const result = await this.ctx.model.User.update(\n        { _id: id },\n        { is_use: isUse },\n        { multi: true }\n    ).exec();\n    // 清空登录态\n    if (usertoken) this.app.redis.set(`${usertoken}_user_login`, &#39;&#39;);\n    return result;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>删除用户逻辑</h2><p>删除用户逻辑跟冻结用户逻辑一致，也需要注意清除用户Token对应的redis信息。</p><div class=\"highlight\"><pre><code class=\"language-text\">// 删除用户\nasync delete(id, usertoken) {\n    // 删除\n    const result = await this.ctx.model.User.findOneAndRemove({ _id: id }).exec();\n    // 清空登录态\n    if (usertoken) this.app.redis.set(`${usertoken}_user_login`, &#39;&#39;);\n    return result;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>第三方github登录说明</h2><p>根据zanePerfor的登录校验机制可以得出以下的结论：</p><ul><li>User表的用户名必须存在，密码可无，并且用户名在代码中强校验不能重复，但是在数据库中用户名是可以重复的。</li><li>usertoken字段很重要，是实现所有Token机制的核心字段，每次登录和注册都会是随机并唯一的值</li></ul><p>基于以上两点做第三方登录我们只需要实现以下几点即可：</p><ul><li>只要给用户名赋值即可，因为用户密码登录和第三方登录是两套逻辑，因此用户名可以重复，这就解决了第三方登录一定不会存在用户已注册的提示。</li><li>第一次登录时注册用户，并把第三方的用户名当做表的用户名，第三方的secret作为用户的token字段。</li><li>第二次登录时使用token字段检测用户是否已注册，已注册走登录逻辑，未注册走注册逻辑。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">// 代码地址  app/service/user.js\n\n// github register 核心注册逻辑\nasync githubRegister(data = {}) {\n    // 此字段为github用户名\n    const login = data.login;\n   // 此字段为github 唯一用户标识\n    const token = data.node_id;\n    let userInfo = {};\n    if (!login || !token) {\n        userInfo = { desc: &#39;github 权限验证失败, 请重试！&#39; };\n        return;\n    }\n    // 通过token去查询用户是否存在\n    userInfo = await this.getUserInfoForGithubId(token);\n    // 身材Token随机并唯一令牌\n    const random_key = this.app.randomString();\n    if (userInfo.token) {\n        // 存在则直接登录\n        if (userInfo.is_use !== 0) {\n            userInfo = { desc: &#39;用户被冻结不能登录，请联系管理员！&#39; };\n        } else {\n            // 清空以前的登录态\n            if (userInfo.usertoken) this.app.redis.set(`${userInfo.usertoken}_user_login`, &#39;&#39;);\n            // 设置redis登录态\n            this.app.redis.set(`${random_key}_user_login`, JSON.stringify(userInfo), &#39;EX&#39;, this.app.config.user_login_timeout);\n            // 设置登录cookie\n            this.ctx.cookies.set(&#39;usertoken&#39;, random_key, {\n                maxAge: this.app.config.user_login_timeout * 1000,\n                httpOnly: true,\n                encrypt: true,\n                signed: true,\n            });\n            // 更新用户信息\n            await this.updateUserToken({ username: login, usertoken: random_key });\n        }\n    } else {\n        // 不存在 先注册 再登录\n        const user = this.ctx.model.User();\n        user.user_name = login;\n        user.token = token;\n        user.create_time = new Date();\n        user.level = 1;\n        user.usertoken = random_key;\n        userInfo = await user.save();\n        // 设置redis登录态\n        this.app.redis.set(`${random_key}_user_login`, JSON.stringify(userInfo), &#39;EX&#39;, this.app.config.user_login_timeout);\n        // 设置登录cookie\n        this.ctx.cookies.set(&#39;usertoken&#39;, random_key, {\n            maxAge: this.app.config.user_login_timeout * 1000,\n            httpOnly: true,\n            encrypt: true,\n            signed: true,\n        });\n    }\n    return userInfo;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>详细的github第三方授权方式请参考：</b><a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/performance/github.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.seosiwei.com/perfo</span><span class=\"invisible\">rmance/github.html</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结：</h2><ul><li>前端封装统一的登录验证，项目组 code 1004 为用户未登录，1000为成功。</li><li>user数据表中储存一个usertoken字段，此字段是随机并唯一的标识，在注册时存入此字段，在每次登录时更新此字段。</li><li>浏览器端的Token令牌即usertoken字段，redis的每个Token存储的是相应的用户信息</li><li>每次登录时清除上一次用户的登录信息，即清除redis登录校验信息，这样就能保证同一用户同一时间只能在一个地方登录</li><li>usertoken字段是随时在变的，redis用户信息和cookie Token令牌都有过期时间，cookie经过加密和httpOnly，更大的保证了Token的安全性</li><li>对所有需要校验的http请求做中间件校验，通过Token令牌获取redis用户信息并验证，验证即通过，验证失败则重新去登录</li><li>第三方登录使用token做用户是否充分校验，第一次登录注册，第二次登录则走登录逻辑</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>原文地址：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/49\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zanePerfor中一套简单通用的Node前后端Token登录机制和github授权登录方式简述</a></p>", 
            "topic": [
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }, 
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53149950", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 1, 
            "title": "mysqls一款专为node.js生成sql语句的插件、链式调用、使用灵活、支持事物", 
            "content": "<h2>mysqls</h2><p>It is written in JavaScript,crud for mysql.You can also use transactions very easily.<br/></p><p>mysqls 一款专为node.js生成sql语句的插件，链式调用，使用灵活。支持生成sql语法，也支持生成语法之后直接调用，支持事物等特性。 </p><p>API参考很流行的ThinkPHP模型API。</p><p>npm地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/mysqls\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">npmjs.com/package/mysql</span><span class=\"invisible\">s</span><span class=\"ellipsis\"></span></a></p><p>github: <a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/mysqls\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/mysqls</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>mysqls是笔者在开发过程中为了更简单、更高效的开发效率而封装的一个库，年初做的，最近从新小修改和加强了一下。分享给有需要的人，感兴趣的也可以看看笔者的思路。<br/>因为个人使用过ThinkPHP,认为其对mysql的封装调用方式是非常友好和易用的，因此绝大部分api参考其中。<br/>如果你有其他的意见和建议也希望可以跟我分享。<br/></p><h2>安装：</h2><div class=\"highlight\"><pre><code class=\"language-text\">npm install mysqls --save-dev</code></pre></div><p>mysqls参数说明</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>init: sql初始化API <br/></li><li>exec: 执行sql语句</li><li>sql: 链式调用生成sql语句，支持生成后直接执行sql语句</li><li>transaction: 执行事务API</li></ul><h2>项目使用：</h2><div class=\"highlight\"><pre><code class=\"language-text\">//import方式\nimport { init, exec, sql, transaction } from &#39;mysqls&#39;\n\n//require方式\nlet { init, exec, sql, transaction } = require(&#39;mysqls&#39;)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>mysql配置初始化：</h2><div class=\"highlight\"><pre><code class=\"language-text\">// 可在项目的启动时初始化配置\ninit({\n    host: &#39;localhost&#39;,\n    user: &#39;root&#39;,\n    password:&#39;123456&#39;,\n    database: &#39;test&#39;,\n    port: 3306,\n})</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>init 参数说明</h2><ul><li>ispool: 是否以连接池的方式初始化 (default:true)</li><li>host: host地址 (default:&#39;127.0.0.1&#39;)</li><li>user: 用户名 (default:&#39;root&#39;)</li><li>password: 数据库密码 (default:&#39;root&#39;)</li><li>database: 使用的数据库 (default:&#39;test&#39;)</li><li>port: 端口 (default:&#39;3306&#39;)</li><li>waitConnection: 是否等待链接(连接池时使用) (default:true)</li><li>connectionLimit: 连接池大小 (default:10)</li><li>queueLimit: 排队限制 (default:0)</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>只生成sql语句</h2><div class=\"highlight\"><pre><code class=\"language-text\">sql\n    .table(&#39;node_table&#39;)\n    .field(&#39;id,name&#39;)\n    .where({id:1})\n    .select()\n\n// result\nSELECT id,name FROM node_table WHERE id=1</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>使用exec函数执行sql语句</h2><div class=\"highlight\"><pre><code class=\"language-text\">const sqlstr = sql\n    .table(&#39;node_table&#39;)\n    .field(&#39;id,name&#39;)\n    .where({id:1})\n    .select();\n\nconst result = await exec(sqlstr);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>使用sql.prototype.exec链式调用</h2><div class=\"highlight\"><pre><code class=\"language-text\">const result = sql\n    .table(&#39;node_table&#39;)\n    .field(&#39;id,name&#39;)\n    .where({id:1})\n    .select(true)\n    .exec();</code></pre></div><ul><li>链式调用执行sql时select方法需要传参数:true</li><li>同样适合update(true),insert(true),delet(true),query(true)方法</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>使用Promise方式</h2><div class=\"highlight\"><pre><code class=\"language-text\">//使用 exec 函数\nexec(sql.table(&#39;web_pages&#39;).where({id:147}).select())\n    .then(res=&gt;{\n        console.log(res)\n    }).catch(err=&gt;{\n        console.log(err)\n    })\n\n// 使用 exec 方法\nsql.table(&#39;web_pages&#39;).where({id:147}).select(true).exec()\n    .then(res=&gt;{\n        console.log(res)\n    }).catch(err=&gt;{\n        console.log(err)\n    })</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>使用async/await</h2><div class=\"highlight\"><pre><code class=\"language-text\">//使用 exec 函数\nconst result = await exec(sql.table(&#39;web_pages&#39;).where({id:147}).select())\n\n// 使用 exec 方法\nconst result = await sql.table(&#39;web_pages&#39;).where({id:147}).select(true).exec()</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>处理事务</h2><div class=\"highlight\"><pre><code class=\"language-text\">const tranSqlArr = [\n    sql.table(&#39;table1&#39;).data({number:&#39;number-5&#39;}).update(),\n    sql.table(&#39;table2&#39;).data({number:&#39;number+5&#39;}).update()\n]\nconst result = await transaction(tranSqlArr)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>生成sql语句简单用法</h2><ul><li>备注：sql调用方法的顺序内部已经做了排序，因此可以不按严格的sql语句顺序来写</li></ul><p>查询</p><div class=\"highlight\"><pre><code class=\"language-text\">sql\n    .table(&#39;node_table&#39;)\n    .field(&#39;id,name&#39;)\n    .where({id:1})\n    .select()\n\nSELECT id,name FROM node_table WHERE id=1</code></pre></div><p>插入</p><div class=\"highlight\"><pre><code class=\"language-text\">sql\n    .table(&#39;node_table&#39;)\n    .data({name:&#39;zane&#39;,email:&#39;752636052@qq.com&#39;})\n    .insert()\n\nINSERT INTO node_table (name,email) VALUES (`zane`,`752636052@qq.com`)</code></pre></div><p>更新</p><div class=\"highlight\"><pre><code class=\"language-text\">sql\n    .table(&#39;node_table&#39;)\n    .data({name:&#39;zane&#39;,email:&#39;752636052@qq.com&#39;})\n    .update()\n\nUPDATE node_table SET name=`zane`,email=`752636052@qq.com`</code></pre></div><p>删除</p><div class=\"highlight\"><pre><code class=\"language-text\">sql .table(&#39;node_table&#39;)\n    .where({name:&#39;zane&#39;})\n    .delet();\n\nDELETE FROM node_table WHERE name=`zane`</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>生成sql语句高级用法</h2><div class=\"highlight\"><pre><code class=\"language-text\">//参数json多字段\nsql\n    .table(&#39;node_table&#39;)\n    .where({id:1,name:&#39;zane&#39;})\n    .select()\n\nSELECT  * FROM node_table WHERE id=1 AND name=`zane`\n\n//参数数组\nlet data=[\n    {id:1,name:&#39;zhangsan&#39;,_type:&#39;or&#39;},\n    {sex:1,number:3}\n]\nsql.table(&#39;node_table&#39;).where(data).select()\n\nSELECT * FROM node_table WHERE (id=1 OR name=`zhangsan` ) AND (sex=1 AND number=3 )\n\n//多字段连接方式\nlet data=[\n    {id:1,name:&#39;zhangsan&#39;,_type:&#39;or&#39;,_nexttype:&#39;or&#39;},\n    {sex:1,number:3,_type:&#39;and&#39;}\n]\nsql.table(&#39;node_table&#39;).where(data).select()\n\nSELECT * FROM node_table WHERE (id=1 OR name=`zhangsan`) OR (sex=1 AND number=3)\n\n//表达式查询\nlet data={\n    id:{eq:100,egt:10,_type:&#39;or&#39;},\n    name:&#39;zhangshan&#39;\n}\nsql.table(&#39;node_table&#39;).where(data).select()\n\nSELECT  * FROM node_table WHERE ((id=100) OR (id&gt;=10)) AND name=`zhangshan`\n\n//混合查询\nlet data=[{\n    id:{eq:100,egt:10,_type:&#39;or&#39;},\n    name:&#39;zhangshan&#39;,\n    _nexttype:&#39;or&#39;\n},{\n    status:1,\n    name:{like:&#39;%zane%&#39;}\n}]\nsql.table(&#39;node_table&#39;).where(data).select()\n\nSELECT * FROM node_table WHERE (((id=100) OR (id&gt;=10)) AND name=`zhangshan`) OR (status=1 AND ((name LIKE `%zane%`))) \n\n\n//UNION ， UNION ALL 组合使用\nsql\n    .union(&#39;SELECT * FROM think_user_1&#39;,true)\n    .union(&#39;SELECT * FROM think_user_2&#39;,true)\n    .union([&#39;SELECT * FROM think_user_3&#39;,&#39;SELECT name FROM think_user_4&#39;])\n    .union(&#39;SELECT * FROM think_user_5&#39;,true)\n    .select()\n\n得到\n(SELECT * FROM think_user_1) UNION ALL  \n(SELECT * FROM think_user_2) UNION ALL \n(SELECT * FROM think_user_3) UNION \n(SELECT name FROM think_user_4)  UNION  \n(SELECT * FROM think_user_5)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>更多用法请查看详细文档：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/mysqls/blob/master/README-CN.md\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/mysqls/blob/master/README-CN.md</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52959378", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 8, 
            "title": "Flutter屏幕适配（自适应）方案", 
            "content": "<p>现代手机屏幕尺寸各不相同，导致我们平时写布局的时候会在个不同的移动设备上显示的效果不同。</p><p>为了达到一套代码所有手机体验一致效果，需要做尺寸上的适配。</p><h2>适配方案：</h2><p><b>计算公式：实际尺寸 = UI尺寸 * 设备宽度/设计图宽度</b></p><p><b>1px方案 : 1px = 1 / 设备像素比</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>实现代码如下（以750设计图为例）：</h2><div class=\"highlight\"><pre><code class=\"language-text\">import &#39;package:flutter/material.dart&#39;;\nimport &#39;dart:ui&#39;;\n\nclass Adapt {\n    static MediaQueryData mediaQuery = MediaQueryData.fromWindow(window);\n    static double _width = mediaQuery.size.width;\n    static double _height = mediaQuery.size.height;\n    static double _topbarH = mediaQuery.padding.top;\n    static double _botbarH = mediaQuery.padding.bottom;\n    static double _pixelRatio = mediaQuery.devicePixelRatio;\n    static var _ratio;\n    static init(int number){\n        int uiwidth = number is int ? number : 750;\n        _ratio = _width / uiwidth;\n    }\n    static px(number){\n        if(!(_ratio is double || _ratio is int)){Adapt.init(750);}\n        return number * _ratio;\n    }\n    static onepx(){\n        return 1/_pixelRatio;\n    }\n    static screenW(){\n        return _width;\n    }\n    static screenH(){\n        return _height;\n    }\n    static padTopH(){\n        return _topbarH;\n    }\n    static padBotH(){\n        return _botbarH;\n    }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>解析：</p><p>1、默认750设计图</p><p>2、引入 &#39;dart:ui&#39; 获得屏幕尺寸相关信息</p><p>3、计算真实像素值</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>使用方式：</h2><div class=\"highlight\"><pre><code class=\"language-text\">// 设置文本大小 30 为设计图尺寸\nnew Text(\n    &#39;Hello World!&#39;,\n    style: TextStyle(\n         fontSize: Adapt.px(30),\n     )\n)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">// 容器尺寸大小设置 一个设计图为 300*300像素的容器\nnew Container(    width: Adapt.px(300),  \n    height: Adapt.px(300),\n)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">// 1px \nnew Container(\n    decoration: new BoxDecoration(\n          border: new Border(bottom:BorderSide(width: Adapt.one())),\n    ),\n)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>Adapt.px(100)  计算适配后的尺寸</li><li>Adapt.onepx()  1px像素大小</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>推荐我开发的Flutter App Demo:</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/FlutterApp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">wangweianger/FlutterApp</a></p>", 
            "topic": [
                {
                    "tag": "Flutter", 
                    "tagLink": "https://api.zhihu.com/topics/20172123"
                }, 
                {
                    "tag": "自适应网页", 
                    "tagLink": "https://api.zhihu.com/topics/19828159"
                }, 
                {
                    "tag": "Dart", 
                    "tagLink": "https://api.zhihu.com/topics/19647245"
                }
            ], 
            "comments": [
                {
                    "userName": "smalltwo", 
                    "userLink": "https://www.zhihu.com/people/d2d7c3c257e4aa5d61e62f8b78445872", 
                    "content": "不知道flutter中iOS端有没有像素对齐的问题", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "有轮子，搜一下，那个还挺清晰", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "xuyonghua", 
                    "userLink": "https://www.zhihu.com/people/36291173ffc1cf3ef6e75fed564b67a3", 
                    "content": "<p>在release 模式下返回为0</p>", 
                    "likes": 3, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51532903", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 1, 
            "title": "zanePerfor前端监控平台性能优化之数据库分表", 
            "content": "<p>HI!，你好，我是zane，zanePerfor是一款最近我开发的一个前端性能监控平台，现在支持web浏览器端和微信小程序段。<br/>我定义为一款完整，高性能，高可用的前端性能监控系统，这是未来会达到的目的，现今的架构也基本支持了高可用，高性能的部署。实际上还不够，在很多地方还有优化的空间，我会持续的优化和升级。<br/>开源不易，如果你也热爱技术，拥抱开源，希望能小小的支持给个star。<br/>项目的github地址：<br/><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Flink.juejin.im%253Ftarget%253Dhttps%25253A%25252F%25252Fgithub.com%25252Fwangweianger%25252FzanePerfor\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">github.com/wangweiange…</a><br/><br/>项目开发文档说明：<br/><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Flink.juejin.im%253Ftarget%253Dhttps%25253A%25252F%25252Fblog.seosiwei.com%25252Fperformance%25252Findex.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">blog.seosiwei.com/performance…</a><br/><br/>为什么要分表</p><ul><li>zanePerfor可以创建多个应用，并进行数据的上报统计。</li><li>每个应用同类型的数据存放在同一张表中会造成单表的数据存储量非常大，索引文件的体积相应的也会很大。</li><li>在单表中，需要对每个应用的appId做索引，如果分表此索引则可去掉。</li><li>这样就造成了单表的读写性能都会相应的降低。</li></ul><h2>分表的优势</h2><ul><li>解决了单表的数据存储大小压力</li><li>解决了单表的读写压力</li><li>减少索引字段和索引体积大小</li><li>应用解耦与查询性能的提升</li></ul><h2>分表的劣势</h2><ul><li>分表唯一的劣势是在Mongodb集群架构中分片变得需要频繁的维护</li><li>每新增一个应用，就会动态的新增一张表，如果此表需要做分片，那么就需要初始化一次分片规则</li></ul><h2>zanePerfor分表图</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e0bc17712c25513ee69b245c24eb9a15_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1089\" data-rawheight=\"657\" class=\"origin_image zh-lightbox-thumb\" width=\"1089\" data-original=\"https://pic2.zhimg.com/v2-e0bc17712c25513ee69b245c24eb9a15_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1089&#39; height=&#39;657&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1089\" data-rawheight=\"657\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1089\" data-original=\"https://pic2.zhimg.com/v2-e0bc17712c25513ee69b245c24eb9a15_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e0bc17712c25513ee69b245c24eb9a15_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>在zanePerfor中的代码实现：</h2><h2><b>1、在servers启动时，在app对象下挂载一个models对象，用来存储所有的Schema对象</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">// 在app.js下挂载models对象\n\n&#39;use strict&#39;;\n\nmodule.exports = async app =&gt; {\n    app.models = {};\n};</code></pre></div><h2><b>2、需要分表的model中，在app.models下挂载一个按某字段拆分表的方法</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">&#39;use strict&#39;;\n\nmodule.exports = app =&gt; {\n    const mongoose = app.mongoose;\n    const Schema = mongoose.Schema;\n    const conn = app.mongooseDB.get(&#39;db3&#39;);\n\n    const WebAjaxsSchema = new Schema({\n        app_id: { type: String }, \n        create_time: { type: Date, default: Date.now },\n        ...\n    });\n\n\n    // ----------拆表代码如下：-----------\n    // 此处根据appId拆表\n    app.models.WebAjaxs = function(appId) {\n        return conn.model(`web_ajaxs_${appId}`, WebAjaxsSchema);\n    };\n\n    // ----------默认写法（不拆表）---------\n    // return conn.model(`web_ajaxs`, WebAjaxsSchema);\n};</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3、调用方式</b></h2><p>调用方式也很简单，跟默认的调用方式有一点小区别 （下面以调用单个ajax详情为例）</p><div class=\"highlight\"><pre><code class=\"language-text\">// 获得单个ajax详情信息\nasync getDetailForId(appId, id) {\n\t// ---------拆表调用方式---------\n    return await this.app.models.WebAjaxs(appId).findOne({ _id: id }).read(&#39;sp&#39;).exec() || {};\n    \n    // ---------默认调用方式---------\n    // return await this.ctx.model.WebAjaxs.findOne({ _id: id }).read(&#39;sp&#39;).exec() || {};\n\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>备注：应用根据appId拆表，因此所有查询操作需要传入appId进行查询。</p><p>以上只是实践的一种方式，同理，还可以通过 时间日期拆表，其他字段拆表。</p><p>zanePerfor暂时只做分表，暂未做分库，已经能满足绝大部分业务需求，若某一天觉得不能满足业务需求的时候再考虑是否分库。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>文章来源：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/44\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zane的博客</a></p>", 
            "topic": [
                {
                    "tag": "MongoDB", 
                    "tagLink": "https://api.zhihu.com/topics/19560787"
                }, 
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }, 
                {
                    "tag": "eggjs", 
                    "tagLink": "https://api.zhihu.com/topics/20073492"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/49947996", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 1, 
            "title": "zanePerfor前端性能监控平台高可用之Mongodb集群分片架构", 
            "content": "<p>HI!，你好，我是zane，zanePerfor是一款最近我开发的一个前端性能监控平台，现在支持web浏览器端和微信小程序段。<br/>我定义为一款完整，高性能，高可用的前端性能监控系统，这是未来会达到的目的，现今的架构也基本支持了高可用，高性能的部署。实际上还不够，在很多地方还有优化的空间，我会持续的优化和升级。</p><p><br/>开源不易，如果你也热爱技术，拥抱开源，希望能小小的支持给个star。</p><p><br/><b>项目的github地址：</b><br/><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Flink.juejin.im%253Ftarget%253Dhttps%25253A%25252F%25252Fgithub.com%25252Fwangweianger%25252FzanePerfor\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">github.com/wangweiange…</a><br/><br/><b>项目开发文档说明：</b><br/><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Flink.juejin.im%253Ftarget%253Dhttps%25253A%25252F%25252Fblog.seosiwei.com%25252Fperformance%25252Findex.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">blog.seosiwei.com/performance…</a></p><h2>分片的概念：</h2><p>在MongoDB中，分片集群（sharded cluster）是一种水平扩展数据库系统性能的方法，能够将数据集分布式存储在不同的分片（shard）上，每个分片只保存数据集的一部分，MongoDB保证各个分片之间不会有重复的数据，所有分片保存的数据之和就是完整的数据集。分片集群将数据集分布式存储，能够将负载分摊到多个分片上，每个分片只负责读写一部分数据，充分利用了各个shard的系统资源，提高数据库系统的吞吐量。</p><h2>为什么要分片：</h2><ul><li>解决高并发时系统吞吐量</li><li>解决垂直扩展的价格昂贵成本，降低成本</li><li>提高系统的稳定，高可用性</li><li>提供大数据量时的分布式计算能力</li><li>解决单机或副本集的磁盘不足</li><li>解决请求量巨大时的内存不足等</li></ul><h2>MongoDB分片集群结构分布：</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-399edfb6e11054dc0e432b46af274f18_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-399edfb6e11054dc0e432b46af274f18_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;411&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-399edfb6e11054dc0e432b46af274f18_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-399edfb6e11054dc0e432b46af274f18_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上图中主要有如下所述三个主要组件：</p><h2>Shard:</h2><p>用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障</p><h2>Config Server:</h2><p>mongod配置服务器，存储了整个 ClusterMetadata，其中包括 chunk信息（配置服务器3.4起需要是副本集）。</p><h2>Query Routers:</h2><p>mongos路由器，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</p><h2>分片实例</h2><p><b>（备注：鉴于成本，以下内容在单机下部署为例，多机部署只需要替换下IP即可）</b><br/></p><p><b>分片计划</b></p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>三个Shard分片  端口：27020，27021，27022</li><li>三个Config服务  端口：27100，27101，27102</li><li>一个Mongos路由服务  端口：30000</li></ul><p>创建Shard分片目录</p><div class=\"highlight\"><pre><code class=\"language-text\">// 创建分片数据和日志存储目录\nmkdir -p /data/mongod/s0\nmkdir -p /data/mongod/s1\nmkdir -p /data/mongod/s2\nmkdir -p /data/mongod/log</code></pre></div><h2>启动Shard Server</h2><div class=\"highlight\"><pre><code class=\"language-text\">mongod --dbpath /data/mongod/s0 --logpath /data/mongod/log/s0.log --fork --smallfiles --port 27020 --shardsvr\nmongod --dbpath /data/mongod/s1 --logpath /data/mongod/log/s1.log --fork --smallfiles --port 27021 --shardsvr\nmongod --dbpath /data/mongod/s2 --logpath /data/mongod/log/s2.log --fork --smallfiles --port 27022 --shardsvr</code></pre></div><ul><li>--dbpath：存储数据目录</li><li>--logpath：存储日志目录</li><li>--smallfiles：是否使用较小的默认文件。默认为false</li><li>--shardsvr：是表示以sharding模式启动Mongodb服务器</li></ul><p><b>提示：每个Shard分片也可以是Mongodb副本集</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>创建Config Server目录</h2><div class=\"highlight\"><pre><code class=\"language-text\">mkdir -p /data/mongod/c0\nmkdir -p /data/mongod/c1\nmkdir -p /data/mongod/c2</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>启动Config Server</h2><div class=\"highlight\"><pre><code class=\"language-text\">mongod --dbpath /data/mongod/c0 --logpath  /data/mongod/log/c0.log --fork --smallfiles --port 27100 --replSet rs1 --configsvr\nmongod --dbpath /data/mongod/c1 --logpath  /data/mongod/log/c1.log --fork --smallfiles --port 27101 --replSet rs1 --configsvr\nmongod --dbpath /data/mongod/c2 --logpath  /data/mongod/log/c2.log --fork --smallfiles --port 27102 --replSet rs1 --configsvr</code></pre></div><ul><li>--replSet：副本集名称，副本集名称必须一致</li><li>--configsvr：是表示以config配置服务启动Mongodb服务器</li></ul><p><b>提示：配置服务器需要是Mongodb副本集</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>配置副本集：</h2><div class=\"highlight\"><pre><code class=\"language-text\">// shell 命令进入mongodb\nmongo --port 27100\n// 使用admin账户\nuse admin;\n// 初始化副本集\nrs.initiate({_id:&#34;rs1&#34;,members:[{_id:0,host:&#34;127.0.0.1:27100&#34;},{_id:1,host:&#34;127.0.0.1:27101&#34;},{_id:2,host:&#34;127.0.0.1:27102&#34;}]})\n// 查看副本集状态\nrs.status();</code></pre></div><p><b>提示：Mongodb副本集节点的增删非常简单，增加使用</b> <b><code>rs.add(&#34;127.0.0.1:27103&#34;)</code>  删除使用：<code>rs.remove(&#34;127.0.0.1:27103&#34;)</code></b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>启动Route Process</h2><div class=\"highlight\"><pre><code class=\"language-text\">mongos  --logpath /data/mongod/log/mongo.log --port 30000 --fork --configdb rs1/127.0.0.1:27100,127.0.0.1:27101,127.0.0.1:27102</code></pre></div><ul><li>mongos服务不存储数据，因此不需要dbpath</li><li>--configdb是核心配置，表示设定config server的地址列表，格式： 副本集名称/host:prot,host:prot,host:prot 格式。</li></ul><p><b>提示：mongos路由服务也可以是副本集</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>配置Sharding分片</h2><div class=\"highlight\"><pre><code class=\"language-text\">// 进入路由服务器\nmongo --port 30000\n\n// 添加分片\nsh.addShard(&#34;127.0.0.1:27020&#34;)\nsh.addShard(&#34;127.0.0.1:27021&#34;)\nsh.addShard(&#34;127.0.0.1:27022&#34;)\n\n// 查看分片信息\nsh.status();</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>设置分片数据库与片键</h2><h2>指定需要分片的数据库</h2><div class=\"highlight\"><pre><code class=\"language-text\">sh.enableSharding(&#34;performance&#34;)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>设置分片的片键</h2><p>Mongodb如何分片是一门学问，分的好对数据均衡存储，查询效率有很高的提升，分的不好导致分片不均匀，有的chunk太大，有的太小，查询效率低下，需要好好的实践和琢磨。</p><p>Sharding架构下，如果不手动分片，Mongodb不会自动分片，所有数据会存储到一个片中，所以我们希望分片的表必须手动分片。</p><p>分片选择的片键首先需要建立索引。</p><p>例如：下面对performance数据库的 pagelist 集合进行分片，选择url为片键。</p><p>1、创建索引</p><div class=\"highlight\"><pre><code class=\"language-text\">db.pagelist.ensureIndex({&#34;url&#34;:1})</code></pre></div><p>2、设置分片</p><div class=\"highlight\"><pre><code class=\"language-text\">sh.shardCollection(&#34;performance.pagelist&#34;,{url:1})</code></pre></div><h2>至此分片完毕。</h2><p>Mongodb一个chunk默认大小为64M，当数据量大于64M时会重新创建新的chunk储存数据。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>在zanePerfor (前端性能监控平台)生产环境中使用Mongodb集群分片。</h2><p>在zanePerfor使用集群分片非常简单，跟单机配置模式是一样的，只需要更改下端口号即可。</p><h2><b>一：找到项目的 config/config.prod.js文件</b></h2><p><b>更改如下Mongodb配置即可：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// mongodb 服务\n// 此处替换 url 参数为链接副本集方式即可\nconst dbclients = {\n        db3: {\n           // 单路由方式\n            url: &#39;mongodb://127.0.0.1:30000/performance&#39;,\n           // 路由副本集方式\n            url: &#39;mongodb://127.0.0.1:30000,127.0.0.1:30001,127.0.0.1:30002/performance?replicaSet=mongos&#39;,\n            options: {\n                poolSize: 100,\n                keepAlive: 10000,\n                connectTimeoutMS: 10000,\n                autoReconnect: true,\n                reconnectTries: 100,\n                reconnectInterval: 1000,\n            },\n        },\n };</code></pre></div><h2><b>二：分片规则</b></h2><p><br/>分片规则初期使用hashed分片，例如webpages集合分片方式：<br/>sh.shardCollection(&#34;performance.webpages&#34;, { &#34;url&#34;: &#34;hashed&#34;})<br/>详细的分配规则和性能还在总结和实践中，调优之后我会放到github中。<br/><br/><b>zanePerfor github地址：</b><br/><b><a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/zanePerfor\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/zanePerfor</span><span class=\"ellipsis\"></span></a></b></p><p><br/><b>zanePerfor 开发文档：</b><br/><b><a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/performance/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.seosiwei.com/perfo</span><span class=\"invisible\">rmance/index.html</span><span class=\"ellipsis\"></span></a></b></p>", 
            "topic": [
                {
                    "tag": "MongoDB", 
                    "tagLink": "https://api.zhihu.com/topics/19560787"
                }, 
                {
                    "tag": "集群", 
                    "tagLink": "https://api.zhihu.com/topics/19596215"
                }, 
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/49813742", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 1, 
            "title": "zanePerfor完整 高性能 高可用的前端性能监控系统之Mongodb副本集读写分离架构", 
            "content": "<p>HI!，你好，我是zane，zanePerfor是一款最近我开发的一个前端性能监控平台，现在支持web浏览器端和微信小程序段。<br/>我定义为一款完整，高性能，高可用的前端性能监控系统，这是未来会达到的目的，现今的架构也基本支持了高可用，高性能的部署。实际上还不够，在很多地方还有优化的空间，我会持续的优化和升级。</p><p><br/>开源不易，如果你也热爱技术，拥抱开源，希望能小小的支持给个star。</p><p><br/><b>项目的github地址：</b><br/><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Flink.juejin.im%253Ftarget%253Dhttps%25253A%25252F%25252Fgithub.com%25252Fwangweianger%25252FzanePerfor\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">github.com/wangweiange…</a><br/><br/><b>项目开发文档说明：</b><br/><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Flink.juejin.im%253Ftarget%253Dhttps%25253A%25252F%25252Fblog.seosiwei.com%25252Fperformance%25252Findex.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">blog.seosiwei.com/performance…</a><br/><br/><br/><b>Mongodb副本集架构</b><br/>优势：</p><p>MongoDB 副本集（Replica Set）是有自动故障恢复功能的主从集群，有一个Primary节点和一个或多个Secondary节点组成。</p><p>当主节点挂掉之后，会由多个副本节点选举产生出新的主节点。（节点数请保持为基数个）。</p><p>这样就能保证应用的高可用，其中一个或多个节点挂掉之后还能正常运行和服务。</p><h2>劣势：</h2><p>数据丢失：主节点挂掉之后，副本节点选举出新的主节点需要一定的时间，这段时间会造成数据的丢失。</p><p>不能完全保证项目的高可用：在副本集的环境中，要是所有的Secondary都宕机了，只剩下Primary。最后Primary会变成Secondary，将不能再提供服务。</p><h2>总结：</h2><p>在大多数情况下推荐使用副本集架构，副本集架构在保证高可用的同时还能降低服务器成本，相对于集群分片来说配置也更简单，更易于维护，具体选择什么架构需要根据自己的项目来觉定。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Mongodb副本集架构搭建：</h2><p>Mongodb副本集搭建比价简单，你只需要根据下面的步骤一步一步操作即可（以下内容以Linux或mac为例进行搭建）。</p><h2>一：安装Mongodb （略）</h2><p>请参考： <a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/40\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LINUX系统下安装mongodb</a></p><p>关于副本集搭建还可参考我的另一篇文章： <a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/39\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MongoDB主从副本集架构</a></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>二：副本集搭建</h2><p><b>（备注：鉴于成本，以下内容在单机下部署为例，多机部署只需要替换下IP即可）</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1、创建数据和日志存放目录</b></h2><p>// 数据存放目录 mkdir -p /data/replication/s0 mkdir -p /data/replication/s1 mkdir -p /data/replication/s2 // 日志存放目录 mkdir -p /data/replication/log<br/><br/><b>2、启动Mongodb服务</b></p><p><b>（下面以</b>28100，28101，28100三个端口为例）</p><div class=\"highlight\"><pre><code class=\"language-text\">// 启动mongodb服务\nmongod --dbpath /data/replication/s0 --logpath /data/replication/log/s0.log --fork --smallfiles --port 28100 --replSet rs1\nmongod --dbpath /data/replication/s1 --logpath /data/replication/log/s1.log --fork --smallfiles --port 28101 --replSet rs1\nmongod --dbpath /data/replication/s2 --logpath /data/replication/log/s2.log --fork --smallfiles --port 28102 --replSet rs1</code></pre></div><ul><li>--dbpath：存放数据目录</li><li>--logpath：存放日志目录</li><li>--smallfiles：是否使用较小的默认文件。默认为false，不使用。</li><li>--replSet: 副本集名称，副本集名称必须一致</li></ul><p><b>进入28100服务设置副本集</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// 登录 mongodb\nmongo localhost:28100\n\n// 切换到admin用户\nuse admin\n\n// 初始化副本集\nrs.initiate({_id:&#34;rs1&#34;,members:[{_id:0,host:&#34;127.0.0.1:28100&#34;},{_id:1,host:&#34;127.0.0.1:28101&#34;},{_id:2,host:&#34;127.0.0.1:28102&#34;}]})\n\n// 查看副本集状态\nrs.status()</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>副本集设置成功之后，查看状态会看到如下信息即标识成功。</p><div class=\"highlight\"><pre><code class=\"language-text\">{\n\t&#34;set&#34; : &#34;rs1&#34;,\n\t&#34;date&#34; : ISODate(&#34;2018-11-14T08:40:44.659Z&#34;),\n\t&#34;myState&#34; : 1,\n\t&#34;term&#34; : NumberLong(2),\n\t&#34;heartbeatIntervalMillis&#34; : NumberLong(2000),\n\t&#34;optimes&#34; : {\n\t\t&#34;lastCommittedOpTime&#34; : {\n\t\t\t&#34;ts&#34; : Timestamp(1542184835, 1),\n\t\t\t&#34;t&#34; : NumberLong(2)\n\t\t},\n\t\t&#34;readConcernMajorityOpTime&#34; : {\n\t\t\t&#34;ts&#34; : Timestamp(1542184835, 1),\n\t\t\t&#34;t&#34; : NumberLong(2)\n\t\t},\n\t\t&#34;appliedOpTime&#34; : {\n\t\t\t&#34;ts&#34; : Timestamp(1542184835, 1),\n\t\t\t&#34;t&#34; : NumberLong(2)\n\t\t},\n\t\t&#34;durableOpTime&#34; : {\n\t\t\t&#34;ts&#34; : Timestamp(1542184835, 1),\n\t\t\t&#34;t&#34; : NumberLong(2)\n\t\t}\n\t},\n\t&#34;members&#34; : [\n\t\t{\n\t\t\t&#34;_id&#34; : 0,\n\t\t\t&#34;name&#34; : &#34;127.0.0.1:28100&#34;,\n\t\t\t&#34;health&#34; : 1,\n\t\t\t&#34;state&#34; : 1,\n\t\t\t&#34;stateStr&#34; : &#34;PRIMARY&#34;,\n\t\t\t&#34;uptime&#34; : 5977,\n\t\t\t&#34;optime&#34; : {\n\t\t\t\t&#34;ts&#34; : Timestamp(1542184835, 1),\n\t\t\t\t&#34;t&#34; : NumberLong(2)\n\t\t\t},\n\t\t\t&#34;optimeDate&#34; : ISODate(&#34;2018-11-14T08:40:35Z&#34;),\n\t\t\t&#34;electionTime&#34; : Timestamp(1542178880, 1),\n\t\t\t&#34;electionDate&#34; : ISODate(&#34;2018-11-14T07:01:20Z&#34;),\n\t\t\t&#34;configVersion&#34; : 1,\n\t\t\t&#34;self&#34; : true\n\t\t},\n\t\t{\n\t\t\t&#34;_id&#34; : 1,\n\t\t\t&#34;name&#34; : &#34;127.0.0.1:28101&#34;,\n\t\t\t&#34;health&#34; : 1,\n\t\t\t&#34;state&#34; : 2,\n\t\t\t&#34;stateStr&#34; : &#34;SECONDARY&#34;,\n\t\t\t&#34;uptime&#34; : 5970,\n\t\t\t&#34;optime&#34; : {\n\t\t\t\t&#34;ts&#34; : Timestamp(1542184835, 1),\n\t\t\t\t&#34;t&#34; : NumberLong(2)\n\t\t\t},\n\t\t\t&#34;optimeDurable&#34; : {\n\t\t\t\t&#34;ts&#34; : Timestamp(1542184835, 1),\n\t\t\t\t&#34;t&#34; : NumberLong(2)\n\t\t\t},\n\t\t\t&#34;optimeDate&#34; : ISODate(&#34;2018-11-14T08:40:35Z&#34;),\n\t\t\t&#34;optimeDurableDate&#34; : ISODate(&#34;2018-11-14T08:40:35Z&#34;),\n\t\t\t&#34;lastHeartbeat&#34; : ISODate(&#34;2018-11-14T08:40:43.345Z&#34;),\n\t\t\t&#34;lastHeartbeatRecv&#34; : ISODate(&#34;2018-11-14T08:40:43.603Z&#34;),\n\t\t\t&#34;pingMs&#34; : NumberLong(0),\n\t\t\t&#34;syncingTo&#34; : &#34;127.0.0.1:28102&#34;,\n\t\t\t&#34;configVersion&#34; : 1\n\t\t},\n\t\t{\n\t\t\t&#34;_id&#34; : 2,\n\t\t\t&#34;name&#34; : &#34;127.0.0.1:28102&#34;,\n\t\t\t&#34;health&#34; : 1,\n\t\t\t&#34;state&#34; : 2,\n\t\t\t&#34;stateStr&#34; : &#34;SECONDARY&#34;,\n\t\t\t&#34;uptime&#34; : 5970,\n\t\t\t&#34;optime&#34; : {\n\t\t\t\t&#34;ts&#34; : Timestamp(1542184835, 1),\n\t\t\t\t&#34;t&#34; : NumberLong(2)\n\t\t\t},\n\t\t\t&#34;optimeDurable&#34; : {\n\t\t\t\t&#34;ts&#34; : Timestamp(1542184835, 1),\n\t\t\t\t&#34;t&#34; : NumberLong(2)\n\t\t\t},\n\t\t\t&#34;optimeDate&#34; : ISODate(&#34;2018-11-14T08:40:35Z&#34;),\n\t\t\t&#34;optimeDurableDate&#34; : ISODate(&#34;2018-11-14T08:40:35Z&#34;),\n\t\t\t&#34;lastHeartbeat&#34; : ISODate(&#34;2018-11-14T08:40:43.345Z&#34;),\n\t\t\t&#34;lastHeartbeatRecv&#34; : ISODate(&#34;2018-11-14T08:40:43.575Z&#34;),\n\t\t\t&#34;pingMs&#34; : NumberLong(0),\n\t\t\t&#34;syncingTo&#34; : &#34;127.0.0.1:28100&#34;,\n\t\t\t&#34;configVersion&#34; : 1\n\t\t}\n\t],\n\t&#34;ok&#34; : 1,\n\t&#34;operationTime&#34; : Timestamp(1542184835, 1),\n\t&#34;$clusterTime&#34; : {\n\t\t&#34;clusterTime&#34; : Timestamp(1542184835, 1),\n\t\t&#34;signature&#34; : {\n\t\t\t&#34;hash&#34; : BinData(0,&#34;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&#34;),\n\t\t\t&#34;keyId&#34; : NumberLong(0)\n\t\t}\n\t}\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3、设置Mongodb副本可读</b></h2><p><b>在mac和linux系统中，一般在~目录下会有个.mongorc.js文件，给此文件新增一句rs.slaveOk();即可。</b></p><p>​查看是否有次文件：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">cd ~\nll -a</code></pre></div><p>若无，则全局查找：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 全局搜索\nsudo find / -name .mongorc.js</code></pre></div><p>添加rs.slaveOk();</p><div class=\"highlight\"><pre><code class=\"language-text\">vi ~/.mongorc.js\n\n// 此文件默认为空\n// 增加一行,保存退出\nrs.slaveOk();</code></pre></div><p>重启Mongodb，这时所有副本节点都可读。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>在zanePerfor (前端性能监控平台)生产环境中使用，并做读写分离。</b></h2><h2><b>一：找到项目的 config/config.prod.js文件</b></h2><p><b>更改如下Mongodb配置即可：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// mongodb 服务\n// 此处替换 url 参数为链接副本集方式即可\nconst dbclients = {\n        db3: {\n           url: &#39;mongodb://127.0.0.1:28100,127.0.0.1:28101,127.0.0.1:28102/performance?replicaSet=rs1&#39;,\n            options: {\n                poolSize: 100,\n                keepAlive: 10000,\n                connectTimeoutMS: 10000,\n                autoReconnect: true,\n                reconnectTries: 100,\n                reconnectInterval: 1000,\n            },\n        },\n };</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>读写分离：</b></h2><h2><b>项目所有查询已经做好了读写分离操作，例如查询page页列表，其他皆如此即可，这样就保证了服务的读写压力（主节点负责写数据，副本节点负责读取数据）。</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9bcb22c2213cced871fa77c062b5f714_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb\" width=\"716\" data-original=\"https://pic1.zhimg.com/v2-9bcb22c2213cced871fa77c062b5f714_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;716&#39; height=&#39;194&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"716\" data-original=\"https://pic1.zhimg.com/v2-9bcb22c2213cced871fa77c062b5f714_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9bcb22c2213cced871fa77c062b5f714_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>read参数说明</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">primary - (默认值)    只从主节点读取。如果主节点不可用则报错。不能跟 tags 选项组合使用。\nsecondary            只有当从节点可用时，从中读取，否则报错。\nprimaryPreferred     优先读取主节点，不可用时读取从节点。\nsecondaryPreferred   优先读取从节点，不可用时读取主节点。\nnearest              所有操作都读最近的候选节点，不同于其他模式，该选项会随机选取所有主、从节点。</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>选项别名：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">p   primary\npp  primaryPreferred\ns   secondary\nsp  secondaryPreferred\nn   nearest</code></pre></div><h2>zanePerfor下一步架构：Mongodb集群分片敬请关注。</h2><p><b>zanePerfor github地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/zanePerfor\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/zanePerfor</span><span class=\"ellipsis\"></span></a></b></p><p><b>zanePerfor 开发文档：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/performance/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.seosiwei.com/perfo</span><span class=\"invisible\">rmance/index.html</span><span class=\"ellipsis\"></span></a></b></p>", 
            "topic": [
                {
                    "tag": "MongoDB", 
                    "tagLink": "https://api.zhihu.com/topics/19560787"
                }, 
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48957460", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 2, 
            "title": "zanePerfor 一款完整，高性能，高可用的前端性能监控系统，不要错过", 
            "content": "<p>HI!，你好，我是zane，zanePerfor是一款最近我开发的一个前端性能监控平台，现在支持web浏览器端和微信小程序段。<br/>我定义为一款完整，高性能，高可用的前端性能监控系统，这是未来会达到的目的，现今的架构也基本支持了高可用，高性能的部署。实际上还不够，在很多地方还有优化的空间，我会持续的优化和升级。<br/>开源不易，如果你也热爱技术，拥抱开源，希望能小小的支持给个star。<br/><b>项目的github地址：</b><br/><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Fwangweianger%252FzanePerfor\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">github.com/wangweiange…</a><br/><br/><b>项目开发文档说明：</b><br/><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fblog.seosiwei.com%252Fperformance%252Findex.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">blog.seosiwei.com/performance…</a><br/><br/>文档还在编辑中，需要一段时间，我会慢慢的完善，如果你感兴趣就先收藏吧。<br/><b>项目目的：</b><br/>打造一款完整，高性能，高可用的前端性能监控系统，提升前端对于服务端技术的空白，体验并解决高并发系统的开发和解决方案，我相信如果你是前端工程师，此项目对于你对后端的理解一定会有很大的提升。<br/>zanePerfor是什么?<br/><b>zanePerfor是一个服务于性能监控的业务平台项目</b>，目前实现了浏览器，微信小程序的相关基础性能统计。<br/>备注：zanePerfor目前还不完善，处于开发初期，我会长期的维护和升级<br/>展望：zanePerfor的目标是解决中小应用的性能统计，支持通用的数据统计和定制化的统计开发，解决高并发下的应用高可用<br/>性能：目前架构理论上来说可支持每日(百万、千万)级PV，未来会持续开发和优化<br/>zanePerfor目前实现了哪些功能？<br/>浏览器端(WEB)<br/></p><ul><li>页面级的性能上报（多页面 || 单页面应用程序通用）</li><li>页面AJAX性能上报</li><li>页面所有加载资源性能上报（图片,js,css）</li><li>页面所有错误信息上报（js,css,ajax）</li></ul><p>微信小程序端<br/></p><ul><li>path路径对应的AJAX性能上报</li><li>小程序错误信息上报（js,ajax,img）</li><li>用户设备信息及其网络信息上报</li></ul><p>后端界面展示功能（web,小程序通用）<br/></p><ul><li>统计每分钟应用的PV,UV,IP信息，统计每天的PV,UV,IP,跳出率，用户访问平均深度</li><li>统计实时和每天的应用top最高访问排行，跳出率最高排行</li><li>统计实时和每天的全国省份流量热力图</li><li>统计每个用户每次访问的行为轨迹</li></ul><p>下面用图来展示实现的大致功能<br/>实时PV,UV,IP统计<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-942fa224631bfefc83a803cc5d30545d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"682\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic2.zhimg.com/v2-942fa224631bfefc83a803cc5d30545d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;682&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"682\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic2.zhimg.com/v2-942fa224631bfefc83a803cc5d30545d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-942fa224631bfefc83a803cc5d30545d_b.jpg\"/></figure><p><br/>单页面性能详情列表<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-650ab4dbee92305d319e3c4ed3710211_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"749\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic2.zhimg.com/v2-650ab4dbee92305d319e3c4ed3710211_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;749&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"749\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic2.zhimg.com/v2-650ab4dbee92305d319e3c4ed3710211_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-650ab4dbee92305d319e3c4ed3710211_b.jpg\"/></figure><p><br/>单个AJAX性能详情<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4c7712df5d5ea4f454499b7cc61f435c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"737\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-4c7712df5d5ea4f454499b7cc61f435c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;737&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"737\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-4c7712df5d5ea4f454499b7cc61f435c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4c7712df5d5ea4f454499b7cc61f435c_b.jpg\"/></figure><p><br/>用户轨迹跟着<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cee6e8e4616b8edeaf3203d22ee0a3f7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"772\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-cee6e8e4616b8edeaf3203d22ee0a3f7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;772&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"772\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-cee6e8e4616b8edeaf3203d22ee0a3f7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cee6e8e4616b8edeaf3203d22ee0a3f7_b.jpg\"/></figure><p><br/>省份实时流量统计<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-eddcd458d016bffdce0a4c5bdea3e54b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"733\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-eddcd458d016bffdce0a4c5bdea3e54b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;733&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"733\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-eddcd458d016bffdce0a4c5bdea3e54b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-eddcd458d016bffdce0a4c5bdea3e54b_b.jpg\"/></figure><p><br/><br/>非常感谢你能看到此处，说明你也是一位热爱技术的伙伴，如果有任何疑问和技术解决方案，请联系我！<br/><br/>文章来源：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/41\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zane的博客</a></p>", 
            "topic": [
                {
                    "tag": "前端性能", 
                    "tagLink": "https://api.zhihu.com/topics/19970406"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "MongoDB", 
                    "tagLink": "https://api.zhihu.com/topics/19560787"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39567900", 
            "userName": "海中月是天上月", 
            "userLink": "https://www.zhihu.com/people/f906a5e807880b00829fbee49aa89e22", 
            "upvote": 2, 
            "title": "事件冒泡、事件捕获与事件委托", 
            "content": "<p>其实我当时正在看小程序官方的（美女）文档，突然看到这样一段话</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>自基础库版本 <a href=\"https://link.zhihu.com/?target=https%3A//developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">1.5.0</a> 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用<code>capture-bind</code>、<code>capture-catch</code>关键字，后者将中断捕获阶段和取消冒泡阶段。</blockquote><p>于是，自然而然的想了解一下什么是事件冒泡、事件捕获？ 事件委托是什么鬼（黑鬼三连？）</p><p>有问 那么就有答案</p><hr/><p>结论：他们是描述事件触发<b>时序问题</b>的术语</p><p>一个完整的JS事件流是从window开始，最后回到window的一个过程</p><p>假如代码是这样子的</p><div class=\"highlight\"><pre><code class=\"language-cfm\">&lt;div&gt;\n    &lt;p&gt;Only You&lt;/p&gt;\n&lt;/div&gt;</code></pre></div><p>那么，</p><p>问题1：冒泡与捕获触发过程？</p><p>答：</p><p>事件 冒泡：p-&gt;div-&gt;body-&gt;document-&gt;window</p><p>事件捕获:window-&gt;document-&gt;body-&gt;div-&gt;p</p><p>事件委托：？？？（最后再解释吧）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>问题2：冒泡与捕获触发的先后顺序？</p><p>答：</p><p>事件捕获--&gt;目标过程--&gt;事件冒泡</p><p class=\"ztext-empty-paragraph\"><br/></p><p>问题3：目前各大浏览器都支持那种方式？</p><p>答：<br/>chrome、firefox、360、百度、猎豹、IE？？？ 这些支持是都支持的</p><p>只是IE仅支持事件捕获的冒泡阶段</p><p class=\"ztext-empty-paragraph\"><br/></p><p>问题4：如何控制使用那种方式？</p><p>答：</p><p>W3C：element.addEventListener（&#34;click/mouseover...&#34;,fn,boolean）第三个参数为true（捕获） 为false（冒泡）</p><p>IE:element.attachEvent(&#34;onclick/onmouseover...&#34;,fn)只能在IE浏览器使用（反人类终将被放弃）仅支持冒泡。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>问题5：冒泡与捕获孰优孰劣？</p><p>答：</p><blockquote>对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>问题6：如何阻止它们！？</p><p>答：</p><blockquote>在支持addEventListener()的浏览器中，可以调用事件对象的stopPropagation()方法以阻止事件的继续传播。如果在同一对象上定义了其他处理程序，剩下的处理程序将依旧被调用，但调用stopPropagation()之后任何其他对象上的事件处理程序将不会被调用。不仅可以阻止事件在冒泡阶段的传播，还能阻止事件在捕获阶段的传播。<br/>在IE9中，是通过设置事件对象cancelBubble属性为true来实现阻止事件进一步传播。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>到这里又看到一个题外话</p><blockquote><b>阻止事件的默认行为</b><br/>　　e.preventDefault()可以阻止事件的默认行为发生，默认行为是指：点击a标签就转跳到其他页面、拖拽一个图片到浏览器会自动打开、点击表单的提交按钮会提交表单等等，因为有的时候我们并不希望发生这些事情，所以需要阻止默认行为。<br/>　　IE9之前的IE中，可以通过设置事件对象的returnValue属性为false达到同样的效果。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>到这里基本上楼主的疑问就没有了，那么在来看一看     <b>事件委托</b></p><blockquote>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。<br/>　　对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click事件会一直冒泡到document层次。也就是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">&lt;ul id=&#34;list&#34;&gt;\n    &lt;li&gt;red&lt;/li&gt;\n    &lt;li&gt;yellow&lt;/li&gt;\n    &lt;li&gt;blue&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div><p>如果点击页面中的li元素，然后输出li当中的颜色，我们通常会这样写</p><div class=\"highlight\"><pre><code class=\"language-text\">(function(){\n    var list = document.getElementById(&#39;list&#39;);\n    var colors = list.getElementsByTagName(&#39;li&#39;);\n    for(var i=0;i&lt;colors.length;i++){\n        colors[i].addEventListener(&#39;click&#39;,showColor,false);\n    };\n    function showColor(e){\n        var x = e.target;\n        alert(&#34;The color is &#34; + x.innerHTML);\n    };\n})();</code></pre></div><p>利用事件流的特性，我们只绑定一个事件处理函数也可以完成</p><div class=\"highlight\"><pre><code class=\"language-text\">(function(){\n    var list = document.getElementById(&#39;list&#39;);\n    list.addEventListener(&#39;click&#39;,showColor,false);\n    function showColor(e){\n        var x = e.target;\n        if(x.nodeName.toLowerCase() === &#39;li&#39;){\n            alert(&#39;The color is &#39; + x.innerHTML);\n        }\n    }\n})();</code></pre></div><p>最后看到度娘上都在写</p><p><b>事件委托还有一个好处就是添加进来的元素也能绑定事件</b></p><p>没有使用事件委托：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;body&gt;\n &lt;ul id=&#34;thl&#34;&gt;\n   &lt;li&gt;001&lt;/li&gt;\n   &lt;li&gt;002&lt;/li&gt;\n   &lt;li&gt;003&lt;/li&gt;\n&lt;/ul&gt;\n&lt;button onclick=&#34;fun()&#34;&gt;touch&lt;/button&gt;\n\n&lt;script&gt;\n    var thl= document.getElementById(&#39;thl&#39;);\n    var aLi = thl.getElementsByTagName(&#39;li&#39;);\n    for (var i = 0; i &lt; aLi.length; i++) {\n    　　aLi[i].onclick = fn;\n    }\n    \n    function fn (){\n      console.log(this.innerHTML);\n    }\n\n    function fun(){\n        var node=document.createElement(&#34;li&#34;);\n        var textnode=document.createTextNode(&#34;maomaoliang&#34;);\n        node.appendChild(textnode);\n        document.getElementById(&#34;thl&#34;).appendChild(node);\n    }\n&lt;/script&gt;\n&lt;/body&gt;\n</code></pre></div><p>使用了事件委托：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;script&gt;\n    var thl= document.getElementById(&#39;thl&#39;);\n    thl.onclick = function(ev) {\n        ev = ev || event;\n        //兼容处理\n        var target = ev.target || ev.srcElement;\n    　　//找到li元素\n        if (target.nodeName.toLowerCase() == &#39;li&#39;) {\n              console.log(target.innerHTML);\n         }\n    };\n\n    function fun(){\n        var node=document.createElement(&#34;li&#34;);\n        var textnode=document.createTextNode(&#34;maomaoliang&#34;);\n        node.appendChild(textnode);\n        document.getElementById(&#34;thl&#34;).appendChild(node);\n    }\n&lt;/script&gt;</code></pre></div><p>此文仅用来总结、备忘、笔记</p><p>欢迎指正</p>", 
            "topic": [
                {
                    "tag": "js事件", 
                    "tagLink": "https://api.zhihu.com/topics/19691457"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38325718", 
            "userName": "Peter Cheng", 
            "userLink": "https://www.zhihu.com/people/564abf3ad7a477b3b910e733a7d37c34", 
            "upvote": 1, 
            "title": "G2（Antv）在vue中的实践", 
            "content": "<h2>前言</h2><p>团队使用G2的原因，主要是设计师认可阿里的审美，UI视觉稿输出的就是G2的图表。</p><h2>在vue中使用G2，Echarts等图表原理</h2><p>为不同类型的图表建不同的文件，Line，Map，Pie等。在mounted（dom结构已经生成的时候），调用图表的渲染函数，对外暴露一个data，并且watch一个data，当data改变的时候，重新调用图表的渲染函数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Line.vue示例</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">template</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">:style</span><span class=\"o\">=</span><span class=\"s\">&#34;{ width: `${width}px`, height:`${height}px` }&#34;</span> <span class=\"na\">:id</span><span class=\"o\">=</span><span class=\"s\">&#34;id&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">template</span><span class=\"p\">&gt;</span>\n\n<span class=\"p\">&lt;</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span>\n<span class=\"k\">import</span> <span class=\"nx\">G2</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;@antv/G2&#39;</span><span class=\"p\">;</span>\n\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"p\">{</span>\n  <span class=\"nx\">data</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n      <span class=\"nx\">chart</span><span class=\"o\">:</span> <span class=\"kc\">null</span>\n    <span class=\"p\">};</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">props</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">charData</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"nb\">Array</span><span class=\"p\">,</span>\n      <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"p\">[];</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">width</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"nb\">Number</span>\n      <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"mi\">500</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">height</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"nb\">Number</span><span class=\"p\">,</span>\n      <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"mi\">500</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">id</span><span class=\"o\">:</span> <span class=\"nb\">String</span><span class=\"p\">,</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">mounted</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">drawChart</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">charData</span><span class=\"p\">);</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">watch</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">charData</span><span class=\"p\">(</span><span class=\"nx\">val</span><span class=\"p\">,</span> <span class=\"nx\">oldVal</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">drawChart</span><span class=\"p\">(</span><span class=\"nx\">val</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">methods</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">drawChart</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">const</span> <span class=\"p\">{</span> <span class=\"nx\">height</span><span class=\"p\">,</span> <span class=\"nx\">id</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"p\">;</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span> <span class=\"o\">&amp;&amp;</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span><span class=\"p\">.</span><span class=\"nx\">destroy</span><span class=\"p\">();</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">G2</span><span class=\"p\">.</span><span class=\"nx\">Chart</span><span class=\"p\">({</span>\n        <span class=\"nx\">id</span><span class=\"o\">:</span> <span class=\"nx\">id</span><span class=\"p\">,</span>\n        <span class=\"nx\">forceFit</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n        <span class=\"nx\">height</span><span class=\"o\">:</span> <span class=\"nx\">height</span><span class=\"p\">,</span>\n        <span class=\"nx\">padding</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"mi\">40</span><span class=\"p\">,</span> <span class=\"mi\">80</span><span class=\"p\">]</span>\n      <span class=\"p\">});</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span><span class=\"p\">.</span><span class=\"nx\">source</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">);</span>\n\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span><span class=\"p\">.</span><span class=\"nx\">line</span><span class=\"p\">().</span><span class=\"nx\">position</span><span class=\"p\">(</span><span class=\"s1\">&#39;periodId*value&#39;</span><span class=\"p\">).</span><span class=\"nx\">size</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"nx\">shape</span><span class=\"p\">(</span><span class=\"s1\">&#39;smooth&#39;</span><span class=\"p\">);</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span><span class=\"p\">.</span><span class=\"nx\">point</span><span class=\"p\">().</span><span class=\"nx\">position</span><span class=\"p\">(</span><span class=\"s1\">&#39;periodId*value&#39;</span><span class=\"p\">).</span><span class=\"nx\">shape</span><span class=\"p\">(</span><span class=\"s1\">&#39;circle&#39;</span><span class=\"p\">);</span>\n\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span><span class=\"p\">.</span><span class=\"nx\">render</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>当然你想对图表数据的显示进行操作，就需要单独引用DataSet函数，这样减少了不必要的包的体积。</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span>\n<span class=\"k\">import</span> <span class=\"nx\">DataSet</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;@antv/data-set&#39;</span><span class=\"p\">;</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">ds</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">DataSet</span><span class=\"p\">();</span>\n<span class=\"k\">const</span> <span class=\"nx\">dv</span> <span class=\"o\">=</span> <span class=\"nx\">ds</span><span class=\"p\">.</span><span class=\"nx\">createView</span><span class=\"p\">().</span><span class=\"nx\">source</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">);</span>\n<span class=\"nx\">dv</span><span class=\"p\">.</span><span class=\"nx\">transform</span><span class=\"p\">({</span>\n  <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"s1\">&#39;fold&#39;</span><span class=\"p\">,</span>\n  <span class=\"nx\">fields</span><span class=\"o\">:</span> <span class=\"nx\">fields</span><span class=\"p\">,</span>\n  <span class=\"nx\">key</span><span class=\"o\">:</span> <span class=\"s1\">&#39;which&#39;</span><span class=\"p\">,</span>\n  <span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"s1\">&#39;value&#39;</span>\n<span class=\"p\">});</span>\n\n<span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span><span class=\"p\">.</span><span class=\"nx\">source</span><span class=\"p\">(</span><span class=\"nx\">dv</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n  <span class=\"nx\">periodId</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">range</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">});</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span></code></pre></div><h2>对比Echarts</h2><ul><li>因为之前一直都在用Echarts，期间也用过charts，highcharts等，这些基本都是一个模式的，通过树状结构的配置渲染图表。有时候图表option的配置可能很长，所以我们当时做大屏展示的时候，将option抽出成一个单独的js文件，减少.vue文件行数。也可能是当时项目比较大，分工比较细，每一个图表基本都要新建一个option，代码比较冗余。但好处是，可以抽象出一个Chart.vue这样的公共组件，供所有图表使用，调只需提供option。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>而在使用G2的使用，我就无法抽出这样一个公共的组件，虽然G2支持树状结构的配置，但是通过函数方式调用，结构更加直观，扁平，更重要的是，你可以通过标签声明式的方式组成图表，官方就有推荐vue-viser。Antv也支持响应式，通过配置forceFit: true就可以实现宽度的自适应。而echarts需要通过监听window.resize，或者watch高度的变化，调用this.chart.resize()重新resize视图。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>Chart.vue(Echarts)</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">template</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">:style</span><span class=\"o\">=</span><span class=\"s\">&#34;{height:height,width:width}&#34;</span> <span class=\"na\">ref</span><span class=\"o\">=</span><span class=\"s\">&#34;myEchart&#34;</span> <span class=\"p\">/&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">template</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span>\n  <span class=\"k\">import</span> <span class=\"p\">{</span><span class=\"nx\">mapState</span><span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;vuex&#39;</span>\n  <span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"p\">{</span>\n    <span class=\"nx\">props</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">width</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"nb\">String</span><span class=\"p\">,</span>\n      <span class=\"p\">},</span>\n      <span class=\"nx\">height</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"nb\">String</span><span class=\"p\">,</span>\n      <span class=\"p\">},</span>\n      <span class=\"nx\">setOption</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"nb\">Object</span>\n      <span class=\"p\">},</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">data</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"nx\">chart</span><span class=\"o\">:</span> <span class=\"kc\">null</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">mounted</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n      <span class=\"nx\">setTimeout</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">initChart</span><span class=\"p\">()</span>\n      <span class=\"p\">},</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">beforeDestroy</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span> <span class=\"o\">=</span> <span class=\"kc\">null</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">methods</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">initChart</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span> <span class=\"o\">=</span> <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">echarts</span><span class=\"p\">.</span><span class=\"nx\">init</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">$refs</span><span class=\"p\">.</span><span class=\"nx\">myEchart</span><span class=\"p\">)</span>\n        <span class=\"c1\">// 把配置和数据放这里\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setOption</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span><span class=\"p\">.</span><span class=\"nx\">setOption</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setOption</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">},</span>\n      <span class=\"nx\">changeSetOption</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setOption</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">chart</span><span class=\"p\">.</span><span class=\"nx\">setOption</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setOption</span><span class=\"p\">,</span> <span class=\"kc\">true</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">watch</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"s1\">&#39;setOption&#39;</span><span class=\"o\">:</span> <span class=\"s1\">&#39;changeSetOption&#39;</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>vue-viser示例</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">template</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n    <span class=\"p\">&lt;</span><span class=\"nt\">v-chart</span> <span class=\"na\">:forceFit</span><span class=\"o\">=</span><span class=\"s\">&#34;true&#34;</span> <span class=\"na\">:height</span><span class=\"o\">=</span><span class=\"s\">&#34;height&#34;</span> <span class=\"na\">:data</span><span class=\"o\">=</span><span class=\"s\">&#34;data&#34;</span> <span class=\"na\">:scale</span><span class=\"o\">=</span><span class=\"s\">&#34;scale&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">v-tooltip</span> <span class=\"p\">/&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">v-axis</span> <span class=\"p\">/&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">v-line</span> <span class=\"na\">position</span><span class=\"o\">=</span><span class=\"s\">&#34;year*value&#34;</span> <span class=\"p\">/&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">v-point</span> <span class=\"na\">position</span><span class=\"o\">=</span><span class=\"s\">&#34;year*value&#34;</span> <span class=\"na\">shape</span><span class=\"o\">=</span><span class=\"s\">&#34;circle&#34;</span> <span class=\"p\">/&gt;</span>\n    <span class=\"p\">&lt;/</span><span class=\"nt\">v-chart</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">template</span><span class=\"p\">&gt;</span>\n\n<span class=\"p\">&lt;</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span>\n<span class=\"k\">const</span> <span class=\"nx\">data</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n  <span class=\"p\">{</span> <span class=\"nx\">year</span><span class=\"o\">:</span> <span class=\"s1\">&#39;1991&#39;</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"p\">},</span>\n  <span class=\"p\">{</span> <span class=\"nx\">year</span><span class=\"o\">:</span> <span class=\"s1\">&#39;1992&#39;</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"p\">},</span>\n<span class=\"p\">];</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">scale</span> <span class=\"o\">=</span> <span class=\"p\">[{</span>\n  <span class=\"nx\">dataKey</span><span class=\"o\">:</span> <span class=\"s1\">&#39;value&#39;</span><span class=\"p\">,</span>\n  <span class=\"nx\">min</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n<span class=\"p\">},{</span>\n  <span class=\"nx\">dataKey</span><span class=\"o\">:</span> <span class=\"s1\">&#39;year&#39;</span><span class=\"p\">,</span>\n  <span class=\"nx\">min</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n  <span class=\"nx\">max</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n<span class=\"p\">}];</span>\n\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"p\">{</span>\n  <span class=\"nx\">data</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n      <span class=\"nx\">data</span><span class=\"p\">,</span>\n      <span class=\"nx\">scale</span><span class=\"p\">,</span>\n      <span class=\"nx\">height</span><span class=\"o\">:</span> <span class=\"mi\">400</span><span class=\"p\">,</span>\n    <span class=\"p\">};</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span></code></pre></div><h2>总结</h2><p>个人感觉Antv的学习曲线高一点，而且Antv还年轻，缺少沉淀，网上没有多少除官方以为的资料，而且你经常无法从官方获取你想要的解决的问题。echarts有更深的沉淀，网上资料齐全。性能方面没有做过对比，看好Antv的发展，默默在github上点了赞。</p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "Ant Design", 
                    "tagLink": "https://api.zhihu.com/topics/20023366"
                }, 
                {
                    "tag": "ECharts", 
                    "tagLink": "https://api.zhihu.com/topics/20005584"
                }
            ], 
            "comments": [
                {
                    "userName": "涂图途", 
                    "userLink": "https://www.zhihu.com/people/10ec33c2121a8ef91fcae88db7abb11a", 
                    "content": "<p>请问我想在vue组件生命周期钩子里调重新渲染图表的方法怎么调  不知道怎么找到chart对象</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Peter Cheng", 
                    "userLink": "https://www.zhihu.com/people/564abf3ad7a477b3b910e733a7d37c34", 
                    "content": "<p>window.echarts.init(this.$refs.myEchart)</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "涂图途", 
                            "userLink": "https://www.zhihu.com/people/10ec33c2121a8ef91fcae88db7abb11a", 
                            "content": "<p>谢谢</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Peter Cheng"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36929468", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 5, 
            "title": "深入理解Vue的computed实现原理及其实现方式", 
            "content": "<p>继上一篇：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/36\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入理解Vue的watch实现原理及其实现方式</a> 继续讲解</p><p>Vue的computed实现相对于watch和data来说比较难以理解，要真正的理解computed的工作方式，你需要深入理解Vue的双向数据绑定原理和实现方式。</p><p>如果你还不是很理解推荐你先看此文章：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/35\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">彻底搞懂Vue针对数组和双向绑定(MVVM)的处理方式</a><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>首先来看一波Vue中computed的使用方式：</h2><div class=\"highlight\"><pre><code class=\"language-text\">var vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    // 仅读取\n    aDouble: function () {\n      return this.a * 2\n    },\n    // 读取和设置\n    aPlus: {\n      get: function () {\n        return this.a + 1\n      },\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\nvm.aPlus   // =&gt; 2\nvm.aPlus = 3\nvm.a       // =&gt; 2\nvm.aDouble // =&gt; 4</code></pre></div><h2>计算属性的主要应用场景是代替模板内的表达式，或者data值的任何复杂逻辑都应该使用computed来计算，它有两大优势：</h2><p>1、逻辑清晰，方便于管理</p><p>2、计算值会被缓存，依赖的data值改变时才会从新计算</p><h2>此文我们需要核心理解的是：</h2><p>1、computed是如何初始化之后干了些什么</p><p>2、为何触发data值改变时computed会从新计算</p><p>3、computed值为什么说是被缓存的呢，如何做的</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果以上三个问题你都已知，你可以忽略下文了，若未知或一知半解，请抱着学习的态度看看别人的理解。</p><p>备注：以下只是我的个人理解，并不保证绝对的正确性，若有问题欢迎指正</p><p>以下大部分代码摘自Vue源码。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果你看到了这里，就当做你已经深入理解了Vue的MVVM原理及其实现方式。相关Vue的MVVM实现直接取自上一篇文章。</p><h2>Dep代码的实现：</h2><div class=\"highlight\"><pre><code class=\"language-text\">//标识当前的Dep id\nlet uidep = 0\nclass Dep{\n\tconstructor () {\n\t\tthis.id = uidep++\n\t\t// 存放所有的监听watcher\n    \tthis.subs = []\n  \t}\n\n  \t//添加一个观察者对象\n  \taddSub (Watcher) {\n    \tthis.subs.push(Watcher)\n  \t}\n  \t//依赖收集\n\tdepend () {\n\t\t//Dep.target 作用只有需要的才会收集依赖\n\t    if (Dep.target) {\n\t      Dep.target.addDep(this)\n\t    }\n\t}\n\n\t// 调用依赖收集的Watcher更新\n    notify () {\n\t    const subs = this.subs.slice()\n\t    for (let i = 0, l = subs.length; i &lt; l; i++) {\n\t      subs[i].update()\n\t    }\n  \t}\n}\n\nDep.target = null\nconst targetStack = []\n\n// 为Dep.target 赋值\nfunction pushTarget (Watcher) {\n\tif (Dep.target) targetStack.push(Dep.target)\n  \tDep.target = Watcher\n}\nfunction popTarget () {\n  Dep.target = targetStack.pop()\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>Watcher代码的实现：</h2><div class=\"highlight\"><pre><code class=\"language-text\">//去重 防止重复收集\nlet uid = 0\nclass Watcher{\n\tconstructor(vm,expOrFn,cb,options){\n\t\t//传进来的对象 例如Vue\n\t\tthis.vm = vm\n\t\tif (options) {\n\t      this.deep = !!options.deep\n\t      this.user = !!options.user\n\t      this.lazy = !!options.lazy\n\t    }else{\n\t    \tthis.deep = this.user = this.lazy = false\n\t    }\n\t    this.dirty = this.lazy\n\t\t//在Vue中cb是更新视图的核心，调用diff并更新视图的过程\n\t\tthis.cb = cb\n\t\tthis.id = ++uid\n\t\tthis.deps = []\n\t    this.newDeps = []\n\t    this.depIds = new Set()\n\t    this.newDepIds = new Set()\n\t\tif (typeof expOrFn === &#39;function&#39;) {\n\t\t\t//data依赖收集走此处\n\t      \tthis.getter = expOrFn\n\t    } else {\n\t    \t//watch依赖走此处\n\t      \tthis.getter = this.parsePath(expOrFn)\n\t    }\n\t\t//设置Dep.target的值，依赖收集时的watcher对象\n\t\tthis.value = this.lazy ? undefined : this.get()\n\t}\n\n\tget(){\n\t\t//设置Dep.target值，用以依赖收集\n\t    pushTarget(this)\n\t    const vm = this.vm\n\t    //此处会进行依赖收集 会调用data数据的 get\n\t    let value = this.getter.call(vm, vm)\n\t    popTarget()\n\t    return value\n\t}\n\n\t//添加依赖\n  \taddDep (dep) {\n  \t\t//去重\n  \t\tconst id = dep.id\n\t    if (!this.newDepIds.has(id)) {\n\t      \tthis.newDepIds.add(id)\n\t      \tthis.newDeps.push(dep)\n\t      \tif (!this.depIds.has(id)) {\n\t      \t\t//收集watcher 每次data数据 set\n\t      \t\t//时会遍历收集的watcher依赖进行相应视图更新或执行watch监听函数等操作\n\t        \tdep.addSub(this)\n\t      \t}\n\t    }\n  \t}\n\n  \t//更新\n  \tupdate () {\n  \t\tif (this.lazy) {\n      \t\tthis.dirty = true\n    \t}else{\n    \t\tthis.run()\n    \t}\n\t}\n\n\t//更新视图\n\trun(){\n\t\tconsole.log(`这里会去执行Vue的diff相关方法，进而更新数据`)\n\t\tconst value = this.get()\n\t\tconst oldValue = this.value\n        this.value = value\n\t\tif (this.user) {\n\t\t\t//watch 监听走此处\n            this.cb.call(this.vm, value, oldValue)\n        }else{\n        \t//data 监听走此处\n        \t//这里只做简单的console.log 处理，在Vue中会调用diff过程从而更新视图\n\t\t\tthis.cb.call(this.vm, value, oldValue)\n        }\n\t}\n\n    //如果计算熟悉依赖的data值发生变化时会调用\n    //案例中 当data.name值发生变化时会执行此方法\n\tevaluate () {\n\t    this.value = this.get()\n\t    this.dirty = false\n\t}\n\t//收集依赖\n\tdepend () {\n\t    let i = this.deps.length\n\t    while (i--) {\n\t      this.deps[i].depend()\n\t    }\n\t}\n\n\t// 此方法获得每个watch中key在data中对应的value值\n\t//使用split(&#39;.&#39;)是为了得到 像&#39;a.b.c&#39; 这样的监听值\n\tparsePath (path){\n\t\tconst bailRE = /[^w.$]/\n\t  if (bailRE.test(path)) return\n\t  \tconst segments = path.split(&#39;.&#39;)\n\t  \treturn function (obj) {\n\t\t    for (let i = 0; i &lt; segments.length; i++) {\n\t\t      \tif (!obj) return\n\t\t      \t//此处为了兼容我的代码做了一点修改\t \n\t\t        //此处使用新获得的值覆盖传入的值 因此能够处理 &#39;a.b.c&#39;这样的监听方式\n\t\t        if(i==0){\n\t\t        \tobj = obj.data[segments[i]]\n\t\t        }else{\n\t\t        \tobj = obj[segments[i]]\n\t\t        }\n\t\t    }\n\t\t    return obj\n\t\t }\n\t}\n}</code></pre></div><p><b>在Watcher中对于computed来说核心注意点是以下方法：</b><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">//如果计算熟悉依赖的data值发生变化时会调用\n//案例中 当data.name值发生变化时会执行此方法\nevaluate () {\n    this.value = this.get()\n    this.dirty = false\n}</code></pre></div><p>当computed中用到的data值发生变化时，视图更新调用computed值时会从新执行，获得新的计算属性值。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Observer代码实现</h2><div class=\"highlight\"><pre><code class=\"language-text\">class Observer{\n\tconstructor (value) {\n\t    this.value = value\n\t    // 增加dep属性（处理数组时可以直接调用）\n\t    this.dep = new Dep()\n\t    //将Observer实例绑定到data的__ob__属性上面去，后期如果oberve时直接使用，不需要从新Observer,\n\t    //处理数组是也可直接获取Observer对象\n\t    def(value, &#39;__ob__&#39;, this)\n\t    if (Array.isArray(value)) {\n\t    \t//这里只测试对象\n\t    } else {\n\t    \t//处理对象\n\t      \tthis.walk(value)\n\t    }\n\t}\n\n\twalk (obj) {\n    \tconst keys = Object.keys(obj)\n    \tfor (let i = 0; i &lt; keys.length; i++) {\n    \t\t//此处我做了拦截处理，防止死循环，Vue中在oberve函数中进行的处理\n    \t\tif(keys[i]==&#39;__ob__&#39;) return;\n      \t\tdefineReactive(obj, keys[i], obj[keys[i]])\n    \t}\n  \t}\n}\n//数据重复Observer\nfunction observe(value){\n\tif(typeof(value) != &#39;object&#39; ) return;\n\tlet ob = new Observer(value)\n  \treturn ob;\n}\n// 把对象属性改为getter/setter，并收集依赖\nfunction defineReactive (obj,key,val) {\n  \tconst dep = new Dep()\n  \t//处理children\n  \tlet childOb = observe(val)\n  \tObject.defineProperty(obj, key, {\n    \tenumerable: true,\n    \tconfigurable: true,\n    \tget: function reactiveGetter () {\n    \t\tconsole.log(`调用get获取值，值为${val}`)\n      \t\tconst value = val\n      \t\tif (Dep.target) {\n\t        \tdep.depend()\n\t\t        if (childOb) {\n\t\t          \tchildOb.dep.depend()\n\t\t        }\n\t      \t}\n      \t\treturn value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t    \tconsole.log(`调用了set，值为${newVal}`)\n\t      \tconst value = val\n\t       \tval = newVal\n\t       \t//对新值进行observe\n\t      \tchildOb = observe(newVal)\n\t      \t//通知dep调用,循环调用手机的Watcher依赖，进行视图的更新\n\t      \tdep.notify()\n\t    }\n  })\n}\n//辅助方法\nfunction def (obj, key, val) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  })\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>此文的重点Computed代码实现：</h2><div class=\"highlight\"><pre><code class=\"language-text\">//空函数\nconst noop = ()=&gt;{}\n// computed初始化的Watcher传入lazy: true就会触发Watcher中的dirty值为true\nconst computedWatcherOptions = { lazy: true }\n//Object.defineProperty 默认value参数\nconst sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n}\n// 初始化computed\nclass initComputed {\n\tconstructor(vm, computed){\n\t\t//新建存储watcher对象，挂载在vm对象执行\n\t\tconst watchers = vm._computedWatchers = Object.create(null)\n\t\t//遍历computed\n\t\tfor (const key in computed) {\n\t\t    const userDef = computed[key]\n\t\t    //getter值为computed中key的监听函数或对象的get值\n\t\t    let getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get\n\t\t    //新建computed的 watcher\n\t\t    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions)\n\t\t    if (!(key in vm)) {\n\t\t      \t/*定义计算属性*/\n\t\t      \tthis.defineComputed(vm, key, userDef)\n\t\t    }\n\t\t}\n\t}\n    //把计算属性的key挂载到vm对象下，并使用Object.defineProperty进行处理\n    //因此调用vm.somecomputed 就会触发get函数\n\tdefineComputed (target, key, userDef) {\n\t  if (typeof userDef === &#39;function&#39;) {\n\t    sharedPropertyDefinition.get = this.createComputedGetter(key)\n\t    sharedPropertyDefinition.set = noop\n\t  } else {\n\t    sharedPropertyDefinition.get = userDef.get\n\t      ? userDef.cache !== false\n\t        ? this.createComputedGetter(key)\n\t        : userDef.get\n\t      : noop\n\t      //如果有设置set方法则直接使用，否则赋值空函数\n\t    \tsharedPropertyDefinition.set = userDef.set\n\t      \t? userDef.set\n\t      \t: noop\n\t  }\n\t  Object.defineProperty(target, key, sharedPropertyDefinition)\n\t}\n\n\t//计算属性的getter 获取计算属性的值时会调用\n\tcreateComputedGetter (key) {\n\t  return function computedGetter () {\n\t  \t//获取到相应的watcher\n\t    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]\n\t    if (watcher) {\n\t    \t//watcher.dirty 参数决定了计算属性值是否需要重新计算，默认值为true，即第一次时会调用一次\n\t      \tif (watcher.dirty) {\n\t      \t\t/*每次执行之后watcher.dirty会设置为false，只要依赖的data值改变时才会触发\n\t      \t\twatcher.dirty为true,从而获取值时从新计算*/\n\t        \twatcher.evaluate()\n\t      \t}\n\t      \t//获取依赖\n\t      \tif (Dep.target) {\n\t        \twatcher.depend()\n\t      \t}\n\t      \t//返回计算属性的值\n\t      \treturn watcher.value\n\t    }\n\t  }\n\t}\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>代码已经写完，完整代码如下：</h2><div class=\"highlight\"><pre><code class=\"language-text\">//标识当前的Dep id\nlet uidep = 0\nclass Dep{\n\tconstructor () {\n\t\tthis.id = uidep++\n\t\t// 存放所有的监听watcher\n    \tthis.subs = []\n  \t}\n\n  \t//添加一个观察者对象\n  \taddSub (Watcher) {\n    \tthis.subs.push(Watcher)\n  \t}\n  \t//依赖收集\n\tdepend () {\n\t\t//Dep.target 作用只有需要的才会收集依赖\n\t    if (Dep.target) {\n\t      Dep.target.addDep(this)\n\t    }\n\t}\n\n\t// 调用依赖收集的Watcher更新\n    notify () {\n\t    const subs = this.subs.slice()\n\t    for (let i = 0, l = subs.length; i &lt; l; i++) {\n\t      subs[i].update()\n\t    }\n  \t}\n}\n\nDep.target = null\nconst targetStack = []\n\n// 为Dep.target 赋值\nfunction pushTarget (Watcher) {\n\tif (Dep.target) targetStack.push(Dep.target)\n  \tDep.target = Watcher\n}\nfunction popTarget () {\n  Dep.target = targetStack.pop()\n}\n/*----------------------------------------Watcher------------------------------------*/\n//去重 防止重复收集\nlet uid = 0\nclass Watcher{\n\tconstructor(vm,expOrFn,cb,options){\n\t\t//传进来的对象 例如Vue\n\t\tthis.vm = vm\n\t\tif (options) {\n\t      this.deep = !!options.deep\n\t      this.user = !!options.user\n\t      this.lazy = !!options.lazy\n\t    }else{\n\t    \tthis.deep = this.user = this.lazy = false\n\t    }\n\t    this.dirty = this.lazy\n\t\t//在Vue中cb是更新视图的核心，调用diff并更新视图的过程\n\t\tthis.cb = cb\n\t\tthis.id = ++uid\n\t\tthis.deps = []\n\t    this.newDeps = []\n\t    this.depIds = new Set()\n\t    this.newDepIds = new Set()\n\t\tif (typeof expOrFn === &#39;function&#39;) {\n\t\t\t//data依赖收集走此处\n\t      \tthis.getter = expOrFn\n\t    } else {\n\t    \t//watch依赖走此处\n\t      \tthis.getter = this.parsePath(expOrFn)\n\t    }\n\t\t//设置Dep.target的值，依赖收集时的watcher对象\n\t\tthis.value = this.lazy ? undefined : this.get()\n\t}\n\n\tget(){\n\t\t//设置Dep.target值，用以依赖收集\n\t    pushTarget(this)\n\t    const vm = this.vm\n\t    //此处会进行依赖收集 会调用data数据的 get\n\t    let value = this.getter.call(vm, vm)\n\t    popTarget()\n\t    return value\n\t}\n\n\t//添加依赖\n  \taddDep (dep) {\n  \t\t//去重\n  \t\tconst id = dep.id\n\t    if (!this.newDepIds.has(id)) {\n\t      \tthis.newDepIds.add(id)\n\t      \tthis.newDeps.push(dep)\n\t      \tif (!this.depIds.has(id)) {\n\t      \t\t//收集watcher 每次data数据 set\n\t      \t\t//时会遍历收集的watcher依赖进行相应视图更新或执行watch监听函数等操作\n\t        \tdep.addSub(this)\n\t      \t}\n\t    }\n  \t}\n\n  \t//更新\n  \tupdate () {\n  \t\tif (this.lazy) {\n      \t\tthis.dirty = true\n    \t}else{\n    \t\tthis.run()\n    \t}\n\t}\n\n\t//更新视图\n\trun(){\n\t\tconsole.log(`这里会去执行Vue的diff相关方法，进而更新数据`)\n\t\tconst value = this.get()\n\t\tconst oldValue = this.value\n        this.value = value\n\t\tif (this.user) {\n\t\t\t//watch 监听走此处\n            this.cb.call(this.vm, value, oldValue)\n        }else{\n        \t//data 监听走此处\n        \t//这里只做简单的console.log 处理，在Vue中会调用diff过程从而更新视图\n\t\t\tthis.cb.call(this.vm, value, oldValue)\n        }\n\t}\n\n    //如果计算熟悉依赖的data值发生变化时会调用\n    //案例中 当data.name值发生变化时会执行此方法\n\tevaluate () {\n\t    this.value = this.get()\n\t    this.dirty = false\n\t}\n\t//收集依赖\n\tdepend () {\n\t    let i = this.deps.length\n\t    while (i--) {\n\t      this.deps[i].depend()\n\t    }\n\t}\n\n\t// 此方法获得每个watch中key在data中对应的value值\n\t//使用split(&#39;.&#39;)是为了得到 像&#39;a.b.c&#39; 这样的监听值\n\tparsePath (path){\n\t\tconst bailRE = /[^w.$]/\n\t  if (bailRE.test(path)) return\n\t  \tconst segments = path.split(&#39;.&#39;)\n\t  \treturn function (obj) {\n\t\t    for (let i = 0; i &lt; segments.length; i++) {\n\t\t      \tif (!obj) return\n\t\t      \t//此处为了兼容我的代码做了一点修改\t \n\t\t        //此处使用新获得的值覆盖传入的值 因此能够处理 &#39;a.b.c&#39;这样的监听方式\n\t\t        if(i==0){\n\t\t        \tobj = obj.data[segments[i]]\n\t\t        }else{\n\t\t        \tobj = obj[segments[i]]\n\t\t        }\n\t\t    }\n\t\t    return obj\n\t\t }\n\t}\n}\n\n/*----------------------------------------Observer------------------------------------*/\nclass Observer{\n\tconstructor (value) {\n\t    this.value = value\n\t    // 增加dep属性（处理数组时可以直接调用）\n\t    this.dep = new Dep()\n\t    //将Observer实例绑定到data的__ob__属性上面去，后期如果oberve时直接使用，不需要从新Observer,\n\t    //处理数组是也可直接获取Observer对象\n\t    def(value, &#39;__ob__&#39;, this)\n\t    if (Array.isArray(value)) {\n\t    \t//这里只测试对象\n\t    } else {\n\t    \t//处理对象\n\t      \tthis.walk(value)\n\t    }\n\t}\n\n\twalk (obj) {\n    \tconst keys = Object.keys(obj)\n    \tfor (let i = 0; i &lt; keys.length; i++) {\n    \t\t//此处我做了拦截处理，防止死循环，Vue中在oberve函数中进行的处理\n    \t\tif(keys[i]==&#39;__ob__&#39;) return;\n      \t\tdefineReactive(obj, keys[i], obj[keys[i]])\n    \t}\n  \t}\n}\n//数据重复Observer\nfunction observe(value){\n\tif(typeof(value) != &#39;object&#39; ) return;\n\tlet ob = new Observer(value)\n  \treturn ob;\n}\n// 把对象属性改为getter/setter，并收集依赖\nfunction defineReactive (obj,key,val) {\n  \tconst dep = new Dep()\n  \t//处理children\n  \tlet childOb = observe(val)\n  \tObject.defineProperty(obj, key, {\n    \tenumerable: true,\n    \tconfigurable: true,\n    \tget: function reactiveGetter () {\n    \t\tconsole.log(`调用get获取值，值为${val}`)\n      \t\tconst value = val\n      \t\tif (Dep.target) {\n\t        \tdep.depend()\n\t\t        if (childOb) {\n\t\t          \tchildOb.dep.depend()\n\t\t        }\n\t      \t}\n      \t\treturn value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t    \tconsole.log(`调用了set，值为${newVal}`)\n\t      \tconst value = val\n\t       \tval = newVal\n\t       \t//对新值进行observe\n\t      \tchildOb = observe(newVal)\n\t      \t//通知dep调用,循环调用手机的Watcher依赖，进行视图的更新\n\t      \tdep.notify()\n\t    }\n  })\n}\n//辅助方法\nfunction def (obj, key, val) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  })\n}\n/*----------------------------------------初始化watch------------------------------------*/\n//空函数\nconst noop = ()=&gt;{}\n// computed初始化的Watcher传入lazy: true就会触发Watcher中的dirty值为true\nconst computedWatcherOptions = { lazy: true }\n//Object.defineProperty 默认value参数\nconst sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n}\n// 初始化computed\nclass initComputed {\n\tconstructor(vm, computed){\n\t\t//新建存储watcher对象，挂载在vm对象执行\n\t\tconst watchers = vm._computedWatchers = Object.create(null)\n\t\t//遍历computed\n\t\tfor (const key in computed) {\n\t\t    const userDef = computed[key]\n\t\t    //getter值为computed中key的监听函数或对象的get值\n\t\t    let getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get\n\t\t    //新建computed的 watcher\n\t\t    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions)\n\t\t    if (!(key in vm)) {\n\t\t      \t/*定义计算属性*/\n\t\t      \tthis.defineComputed(vm, key, userDef)\n\t\t    }\n\t\t}\n\t}\n    //把计算属性的key挂载到vm对象下，并使用Object.defineProperty进行处理\n    //因此调用vm.somecomputed 就会触发get函数\n\tdefineComputed (target, key, userDef) {\n\t  if (typeof userDef === &#39;function&#39;) {\n\t    sharedPropertyDefinition.get = this.createComputedGetter(key)\n\t    sharedPropertyDefinition.set = noop\n\t  } else {\n\t    sharedPropertyDefinition.get = userDef.get\n\t      ? userDef.cache !== false\n\t        ? this.createComputedGetter(key)\n\t        : userDef.get\n\t      : noop\n\t      //如果有设置set方法则直接使用，否则赋值空函数\n\t    \tsharedPropertyDefinition.set = userDef.set\n\t      \t? userDef.set\n\t      \t: noop\n\t  }\n\t  Object.defineProperty(target, key, sharedPropertyDefinition)\n\t}\n\n\t//计算属性的getter 获取计算属性的值时会调用\n\tcreateComputedGetter (key) {\n\t  return function computedGetter () {\n\t  \t//获取到相应的watcher\n\t    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]\n\t    if (watcher) {\n\t    \t//watcher.dirty 参数决定了计算属性值是否需要重新计算，默认值为true，即第一次时会调用一次\n\t      \tif (watcher.dirty) {\n\t      \t\t/*每次执行之后watcher.dirty会设置为false，只要依赖的data值改变时才会触发\n\t      \t\twatcher.dirty为true,从而获取值时从新计算*/\n\t        \twatcher.evaluate()\n\t      \t}\n\t      \t//获取依赖\n\t      \tif (Dep.target) {\n\t        \twatcher.depend()\n\t      \t}\n\t      \t//返回计算属性的值\n\t      \treturn watcher.value\n\t    }\n\t  }\n\t}\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>computed测试：</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">//1、首先来创建一个Vue构造函数：\nfunction Vue(){\n}\n//2、设置data和computed的值：\nlet data={\n    name:&#39;Hello&#39;,\n}\nlet computed={\n\tgetfullname:function(){\n\t\tconsole.log(&#39;-----走了computed 之 getfullname------&#39;)\n\t\tconsole.log(&#39;新的值为：&#39;+data.name + &#39; - world&#39;)\n\t\treturn data.name + &#39; - world&#39;\n\t}\n}\n//3、实例化Vue并把data挂载到Vue上\nlet vue \t\t= new Vue()\nvue.data \t\t= data\n//4、创建Watcher对象\nlet updateComponent = (vm)=&gt;{\n\t// 收集依赖\n\tdata.name\n\t\n}\nnew Watcher(vue,updateComponent,()=&gt;{})\n//5、初始化Data并收集依赖\nobserve(data)\n//6、初始化computed\nnew initComputed(vue,computed)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>在浏览器console中测试：</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">//首先或的一次getfullname\nvue.getfullname\n\n//第二次调用getfullname看看会有什么变化呢\nvue.getfullname</code></pre></div><p>分析：调用vue.getfullname第一次会打印 &#39;-----走了computed 之 getfullname------&#39;，即计算属性第一次计算了值，第二次调用时，不会再打印值</p><p>即直接获取的缓存值，为什么第二次是获得的缓存值呢，因为第二次执行时watcher.dirty=true，就会直接返回watcher.value值。</p><div class=\"highlight\"><pre><code class=\"language-text\">//为data.name赋值\ndata.name = &#39;Hi&#39;</code></pre></div><p>分析：执行data.name时会触发两个Watcher监听函数(为什么是两个Watcher自己去脑补一下额！)，一个是全局的watcher，一个是computed的watcher，第一个Watcher会更新视图，第二个Watcher会触发watcher.dirty=true。</p><div class=\"highlight\"><pre><code class=\"language-text\">//name值变更只收再次执行会是什么呢\nvue.getfullname\n\n//再执行一次\nvue.getfullname</code></pre></div><p>分析：运行vue.getfullname时会执行computedGetter函数，因为watcher.dirty=true因此会从新计算值，因此会打印 &#39;-----走了computed 之 getfullname------&#39;，值为&#39;HI world&#39;, 再次执行只会获得计算属性的缓存值。</p><p><b>所有测试代码如下：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">/*----------------------------------------Vue------------------------------------*/\nfunction Vue(){\n}\n/*----------------------------------------测试代码------------------------------------*/\n// 调用\nlet data={\n    name:&#39;Hello&#39;,\n}\nlet computed={\n\tgetfullname:function(){\n\t\tconsole.log(&#39;-----走了computed 之 getfullname------&#39;)\n\t\tconsole.log(&#39;新的值为：&#39;+data.name + &#39; - world&#39;)\n\t\treturn data.name + &#39; - world&#39;\n\t}\n}\nlet vue \t\t= new Vue()\nvue.data \t\t= data\nlet updateComponent = (vm)=&gt;{\n\t// 收集依赖\n\tdata.name\n}\nnew Watcher(vue,updateComponent,()=&gt;{})\nobserve(data)\nnew initComputed(vue,computed)\n\n//测试 浏览器console中相继运行一下代码测试\nvue.getfullname\nvue.getfullname\ndata.name=&#39;Hi&#39;\nvue.getfullname\nvue.getfullname</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "MVVM", 
                    "tagLink": "https://api.zhihu.com/topics/19685551"
                }, 
                {
                    "tag": "前端框架", 
                    "tagLink": "https://api.zhihu.com/topics/19806306"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36793748", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 2, 
            "title": "这一次 彻底理解Vue的watch实现原理及其实现方式", 
            "content": "<p>理解Vue中Watch的实现原理和方式之前，你需要深入的理解MVVM的实现原理，如果你还不是很理解，推荐你阅读我之前的几篇文章：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/35\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">彻底搞懂Vue针对数组和双向绑定(MVVM)的处理方式</a><br/></p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/22\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vue.js源码解读系列 - 双向绑定具体如何初始化和工作</a><br/></p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/24\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vue.js源码解读系列 - 剖析observer,dep,watch三者关系 如何具体的实现数据双向绑定</a><br/></p><p>也可以关注我的博客查看关于Vue更多的源码解析：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/myblog\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/myblog</span><span class=\"ellipsis\"></span></a></p><p>备注：</p><p>1、此文大部分代码来自于Vue源码</p><p>2、此文MVVM部分代码来自于【<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/35\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">彻底搞懂Vue针对数组和双向绑定(MVVM)的处理方式</a>】，若有不懂之处，建议先看上文</p><p>3、部分代码为了兼容测试做了部分更改，但原理跟Vue一致</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>画一张watch的简单工作流程图：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-27de71bffaff8259476ed02183aa89f2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2036\" data-rawheight=\"862\" class=\"origin_image zh-lightbox-thumb\" width=\"2036\" data-original=\"https://pic3.zhimg.com/v2-27de71bffaff8259476ed02183aa89f2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2036&#39; height=&#39;862&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2036\" data-rawheight=\"862\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2036\" data-original=\"https://pic3.zhimg.com/v2-27de71bffaff8259476ed02183aa89f2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-27de71bffaff8259476ed02183aa89f2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>把上文的 Dep,Oberver,Wather拿过来并做部分更改（增加收集依赖去重处理）：</p><h2>Dep代码如下：</h2><div class=\"highlight\"><pre><code class=\"language-text\">//标识当前的Dep id\nlet uidep = 0\nclass Dep{\n\tconstructor () {\n\t\tthis.id = uidep++\n\t\t// 存放所有的监听watcher\n    \tthis.subs = []\n  \t}\n\n  \t//添加一个观察者对象\n  \taddSub (Watcher) {\n    \tthis.subs.push(Watcher)\n  \t}\n\n  \t//依赖收集\n\tdepend () {\n\t\t//Dep.target 作用只有需要的才会收集依赖\n\t    if (Dep.target) {\n\t      Dep.target.addDep(this)\n\t    }\n\t}\n\n\t// 调用依赖收集的Watcher更新\n    notify () {\n\t    const subs = this.subs.slice()\n\t    for (let i = 0, l = subs.length; i &lt; l; i++) {\n\t      subs[i].update()\n\t    }\n  \t}\n}\n\nDep.target = null\nconst targetStack = []\n\n// 为Dep.target 赋值\nfunction pushTarget (Watcher) {\n\tif (Dep.target) targetStack.push(Dep.target)\n  \tDep.target = Watcher\n}\nfunction popTarget () {\n  Dep.target = targetStack.pop()\n}</code></pre></div><h2>Watcher代码如下：</h2><div class=\"highlight\"><pre><code class=\"language-text\">//去重 防止重复收集\nlet uid = 0\nclass Watcher{\n\tconstructor(vm,expOrFn,cb,options){\n\t\t//传进来的对象 例如Vue\n\t\tthis.vm = vm\n\t\tif (options) {\n\t      this.deep = !!options.deep\n\t      this.user = !!options.user\n\t    }else{\n\t    \tthis.deep = this.user = false\n\t    }\n\t\t//在Vue中cb是更新视图的核心，调用diff并更新视图的过程\n\t\tthis.cb = cb\n\t\tthis.id = ++uid\n\t\tthis.deps = []\n\t    this.newDeps = []\n\t    this.depIds = new Set()\n\t    this.newDepIds = new Set()\n\t\tif (typeof expOrFn === &#39;function&#39;) {\n\t\t\t//data依赖收集走此处\n\t      \tthis.getter = expOrFn\n\t    } else {\n\t    \t//watch依赖走此处\n\t      \tthis.getter = this.parsePath(expOrFn)\n\t    }\n\t\t//设置Dep.target的值，依赖收集时的watcher对象\n\t\tthis.value =this.get()\n\t}\n\n\tget(){\n\t\t//设置Dep.target值，用以依赖收集\n\t    pushTarget(this)\n\t    const vm = this.vm\n\t    //此处会进行依赖收集 会调用data数据的 get\n\t    let value = this.getter.call(vm, vm)\n\t    //深度监听\n\t    if (this.deep) {\n\t      traverse(value)\n\t    }\n\t    popTarget()\n\t    return value\n\t}\n\n\t//添加依赖\n  \taddDep (dep) {\n  \t\t//去重\n  \t\tconst id = dep.id\n\t    if (!this.newDepIds.has(id)) {\n\t      \tthis.newDepIds.add(id)\n\t      \tthis.newDeps.push(dep)\n\t      \tif (!this.depIds.has(id)) {\n\t      \t\t//收集watcher 每次data数据 set\n\t      \t\t//时会遍历收集的watcher依赖进行相应视图更新或执行watch监听函数等操作\n\t        \tdep.addSub(this)\n\t      \t}\n\t    }\n  \t}\n\n  \t//更新\n  \tupdate () {\n\t    this.run()\n\t}\n\n\t//更新视图\n\trun(){\n\t\tconst value = this.get()\n\t\tconst oldValue = this.value\n        this.value = value\n\t\tif (this.user) {\n\t\t\t//watch 监听走此处\n            this.cb.call(this.vm, value, oldValue)\n        }else{\n        \t//data 监听走此处\n        \t//这里只做简单的console.log 处理，在Vue中会调用diff过程从而更新视图\n\t\t\tconsole.log(`这里会去执行Vue的diff相关方法，进而更新数据`)\n        }\n\t\t\n\t}\n\t// 此方法获得每个watch中key在data中对应的value值\n\t//使用split(&#39;.&#39;)是为了得到 像&#39;a.b.c&#39; 这样的监听值\n\tparsePath (path){\n\t\tconst bailRE = /[^w.$]/\n\t  if (bailRE.test(path)) return\n\t  \tconst segments = path.split(&#39;.&#39;)\n\t  \treturn function (obj) {\n\t\t    for (let i = 0; i &lt; segments.length; i++) {\n\t\t      \tif (!obj) return\n\t\t      \t//此处为了兼容我的代码做了一点修改\t \n\t\t        //此处使用新获得的值覆盖传入的值 因此能够处理 &#39;a.b.c&#39;这样的监听方式\n\t\t        if(i==0){\n\t\t        \tobj = obj.data[segments[i]]\n\t\t        }else{\n\t\t        \tobj = obj[segments[i]]\n\t\t        }\n\t\t    }\n\t\t    return obj\n\t\t }\n\t}\n}\n//深度监听相关代码 为了兼容有一小点改动\nconst seenObjects = new Set()\nfunction traverse (val) {\n  seenObjects.clear()\n  _traverse(val, seenObjects)\n}\n\nfunction _traverse (val, seen) {\n  let i, keys\n  const isA = Array.isArray(val)\n  if (!isA &amp;&amp; Object.prototype.toString.call(val)!= &#39;[object Object]&#39;) return;\n  if (val.__ob__) {\n    const depId = val.__ob__.dep.id\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId)\n  }\n  if (isA) {\n    i = val.length\n    while (i--){\n    \tif(i == &#39;__ob__&#39;) return;\n    \t_traverse(val[i], seen)\n    } \n  } else {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--){\n    \tif(keys[i] == &#39;__ob__&#39;) return;\n    \t_traverse(val[keys[i]], seen)\n    } \n  }\n}</code></pre></div><h2>Observer代码如下：</h2><div class=\"highlight\"><pre><code class=\"language-text\">class Observer{\n\tconstructor (value) {\n\t    this.value = value\n\t    // 增加dep属性（处理数组时可以直接调用）\n\t    this.dep = new Dep()\n\t    //将Observer实例绑定到data的__ob__属性上面去，后期如果oberve时直接使用，不需要从新Observer,\n\t    //处理数组是也可直接获取Observer对象\n\t    def(value, &#39;__ob__&#39;, this)\n\t    if (Array.isArray(value)) {\n\t    \t//这里只测试对象\n\t    } else {\n\t    \t//处理对象\n\t      \tthis.walk(value)\n\t    }\n\t}\n\n\twalk (obj) {\n    \tconst keys = Object.keys(obj)\n    \tfor (let i = 0; i &lt; keys.length; i++) {\n    \t\t//此处我做了拦截处理，防止死循环，Vue中在oberve函数中进行的处理\n    \t\tif(keys[i]==&#39;__ob__&#39;) return;\n      \t\tdefineReactive(obj, keys[i], obj[keys[i]])\n    \t}\n  \t}\n}\n//数据重复Observer\nfunction observe(value){\n\tif(typeof(value) != &#39;object&#39; ) return;\n\tlet ob = new Observer(value)\n  \treturn ob;\n}\n// 把对象属性改为getter/setter，并收集依赖\nfunction defineReactive (obj,key,val) {\n  \tconst dep = new Dep()\n  \t//处理children\n  \tlet childOb = observe(val)\n  \tObject.defineProperty(obj, key, {\n    \tenumerable: true,\n    \tconfigurable: true,\n    \tget: function reactiveGetter () {\n    \t\tconsole.log(`调用get获取值，值为${val}`)\n      \t\tconst value = val\n      \t\tif (Dep.target) {\n\t        \tdep.depend()\n\t\t        if (childOb) {\n\t\t          \tchildOb.dep.depend()\n\t\t        }\n\t      \t}\n      \t\treturn value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t    \tconsole.log(`调用了set，值为${newVal}`)\n\t      \tconst value = val\n\t       \tval = newVal\n\t       \t//对新值进行observe\n\t      \tchildOb = observe(newVal)\n\t      \t//通知dep调用,循环调用手机的Watcher依赖，进行视图的更新\n\t      \tdep.notify()\n\t    }\n  })\n}\n\n//辅助方法\nfunction def (obj, key, val) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  })\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>此文的重点来了，watch代码的实现</h2><p>watch代码大部摘自于Vue源码，我做了部分修改，把Watch改写成一个cass类，代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">class stateWatch{\n\tconstructor (vm, watch) {\n\t\tthis.vm = vm\n\t\t//初始化watch\n\t    this.initWatch(vm, watch)\n\t}\n\tinitWatch (vm, watch) {\n\t\t//遍历watch对象\n\t  \tfor (const key in watch) {\n\t\t    const handler = watch[key]\n\t\t    //数组则遍历进行createWatcher\n\t\t    if (Array.isArray(handler)) {\n\t\t      \tfor (let i = 0; i &lt; handler.length; i++) {\n\t\t        \tthis.createWatcher(vm, key, handler[i])\n\t\t      \t}\n\t\t    } else {\n\t\t      \tthis.createWatcher(vm, key, handler)\n\t\t    }\n\t  \t}\n\t}\n\tcreateWatcher (vm, key, handler) {\n\t  let options\n\t  if (Object.prototype.toString.call(handler) == &#39;[object Object]&#39; ) {\n\t  \t//处理对象\n\t    options = handler\n\t    handler = handler.handler\n\t  }\n\t  if (typeof handler === &#39;string&#39;) {\n\t    handler = vm[handler]\n\t  }\n\t  vm.$watch(key, handler, options)\n\t}\n}</code></pre></div><p>初始化watch的类已经写好，其中createWatcher有调用到vm.$watch，下面来实现$watch方法</p><p>新建一个Vue构造函数：</p><div class=\"highlight\"><pre><code class=\"language-text\">function Vue(){\n}</code></pre></div><p>为Vue新增原型方法$watch代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">Vue.prototype.$watch=function(expOrFn,cb,options){\n\tconst vm = this\n    options = options || {}\n    //此参数用于给data从新赋值时走watch的监听函数\n    options.user = true\n    //watch依赖收集的Watcher\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    //immediate=true时 会调用一次 watcher.run 方法，因此会调用一次watch中相关key的函数\n    if (options.immediate) {\n      cb.call(vm, watcher.value)\n    }\n    //返回一个取消监听的函数\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>OK 万事具备，所有的代码已经写完，完整代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">/*----------------------------------------Dep---------------------------------------*/\n//标识当前的Dep id\nlet uidep = 0\nclass Dep{\n\tconstructor () {\n\t\tthis.id = uidep++\n\t\t// 存放所有的监听watcher\n    \tthis.subs = []\n  \t}\n\n  \t//添加一个观察者对象\n  \taddSub (Watcher) {\n    \tthis.subs.push(Watcher)\n  \t}\n\n  \t//依赖收集\n\tdepend () {\n\t\t//Dep.target 作用只有需要的才会收集依赖\n\t    if (Dep.target) {\n\t      Dep.target.addDep(this)\n\t    }\n\t}\n\n\t// 调用依赖收集的Watcher更新\n    notify () {\n\t    const subs = this.subs.slice()\n\t    for (let i = 0, l = subs.length; i &lt; l; i++) {\n\t      subs[i].update()\n\t    }\n  \t}\n}\n\nDep.target = null\nconst targetStack = []\n\n// 为Dep.target 赋值\nfunction pushTarget (Watcher) {\n\tif (Dep.target) targetStack.push(Dep.target)\n  \tDep.target = Watcher\n}\nfunction popTarget () {\n  Dep.target = targetStack.pop()\n}\n/*----------------------------------------Watcher------------------------------------*/\n//去重 防止重复收集\nlet uid = 0\nclass Watcher{\n\tconstructor(vm,expOrFn,cb,options){\n\t\t//传进来的对象 例如Vue\n\t\tthis.vm = vm\n\t\tif (options) {\n\t      this.deep = !!options.deep\n\t      this.user = !!options.user\n\t    }else{\n\t    \tthis.deep = this.user = false\n\t    }\n\t\t//在Vue中cb是更新视图的核心，调用diff并更新视图的过程\n\t\tthis.cb = cb\n\t\tthis.id = ++uid\n\t\tthis.deps = []\n\t    this.newDeps = []\n\t    this.depIds = new Set()\n\t    this.newDepIds = new Set()\n\t\tif (typeof expOrFn === &#39;function&#39;) {\n\t\t\t//data依赖收集走此处\n\t      \tthis.getter = expOrFn\n\t    } else {\n\t    \t//watch依赖走此处\n\t      \tthis.getter = this.parsePath(expOrFn)\n\t    }\n\t\t//设置Dep.target的值，依赖收集时的watcher对象\n\t\tthis.value =this.get()\n\t}\n\n\tget(){\n\t\t//设置Dep.target值，用以依赖收集\n\t    pushTarget(this)\n\t    const vm = this.vm\n\t    //此处会进行依赖收集 会调用data数据的 get\n\t    let value = this.getter.call(vm, vm)\n\t    //深度监听\n\t    if (this.deep) {\n\t      traverse(value)\n\t    }\n\t    popTarget()\n\t    return value\n\t}\n\n\t//添加依赖\n  \taddDep (dep) {\n  \t\t//去重\n  \t\tconst id = dep.id\n\t    if (!this.newDepIds.has(id)) {\n\t      \tthis.newDepIds.add(id)\n\t      \tthis.newDeps.push(dep)\n\t      \tif (!this.depIds.has(id)) {\n\t      \t\t//收集watcher 每次data数据 set\n\t      \t\t//时会遍历收集的watcher依赖进行相应视图更新或执行watch监听函数等操作\n\t        \tdep.addSub(this)\n\t      \t}\n\t    }\n  \t}\n\n  \t//更新\n  \tupdate () {\n\t    this.run()\n\t}\n\n\t//更新视图\n\trun(){\n\t\tconst value = this.get()\n\t\tconst oldValue = this.value\n        this.value = value\n\t\tif (this.user) {\n\t\t\t//watch 监听走此处\n            this.cb.call(this.vm, value, oldValue)\n        }else{\n        \t//data 监听走此处\n        \t//这里只做简单的console.log 处理，在Vue中会调用diff过程从而更新视图\n\t\t\tconsole.log(`这里会去执行Vue的diff相关方法，进而更新数据`)\n        }\n\t\t\n\t}\n\t// 此方法获得每个watch中key在data中对应的value值\n\t//使用split(&#39;.&#39;)是为了得到 像&#39;a.b.c&#39; 这样的监听值\n\tparsePath (path){\n\t\tconst bailRE = /[^w.$]/\n\t  if (bailRE.test(path)) return\n\t  \tconst segments = path.split(&#39;.&#39;)\n\t  \treturn function (obj) {\n\t\t    for (let i = 0; i &lt; segments.length; i++) {\n\t\t      \tif (!obj) return\n\t\t      \t//此处为了兼容我的代码做了一点修改\t \n\t\t        //此处使用新获得的值覆盖传入的值 因此能够处理 &#39;a.b.c&#39;这样的监听方式\n\t\t        if(i==0){\n\t\t        \tobj = obj.data[segments[i]]\n\t\t        }else{\n\t\t        \tobj = obj[segments[i]]\n\t\t        }\n\t\t    }\n\t\t    return obj\n\t\t }\n\t}\n}\n//深度监听相关代码 为了兼容有一小点改动\nconst seenObjects = new Set()\nfunction traverse (val) {\n  seenObjects.clear()\n  _traverse(val, seenObjects)\n}\n\nfunction _traverse (val, seen) {\n  let i, keys\n  const isA = Array.isArray(val)\n  if (!isA &amp;&amp; Object.prototype.toString.call(val)!= &#39;[object Object]&#39;) return;\n  if (val.__ob__) {\n    const depId = val.__ob__.dep.id\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId)\n  }\n  if (isA) {\n    i = val.length\n    while (i--){\n    \tif(i == &#39;__ob__&#39;) return;\n    \t_traverse(val[i], seen)\n    } \n  } else {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--){\n    \tif(keys[i] == &#39;__ob__&#39;) return;\n    \t_traverse(val[keys[i]], seen)\n    } \n  }\n}\n\n/*----------------------------------------Observer------------------------------------*/\nclass Observer{\n\tconstructor (value) {\n\t    this.value = value\n\t    // 增加dep属性（处理数组时可以直接调用）\n\t    this.dep = new Dep()\n\t    //将Observer实例绑定到data的__ob__属性上面去，后期如果oberve时直接使用，不需要从新Observer,\n\t    //处理数组是也可直接获取Observer对象\n\t    def(value, &#39;__ob__&#39;, this)\n\t    if (Array.isArray(value)) {\n\t    \t//这里只测试对象\n\t    } else {\n\t    \t//处理对象\n\t      \tthis.walk(value)\n\t    }\n\t}\n\n\twalk (obj) {\n    \tconst keys = Object.keys(obj)\n    \tfor (let i = 0; i &lt; keys.length; i++) {\n    \t\t//此处我做了拦截处理，防止死循环，Vue中在oberve函数中进行的处理\n    \t\tif(keys[i]==&#39;__ob__&#39;) return;\n      \t\tdefineReactive(obj, keys[i], obj[keys[i]])\n    \t}\n  \t}\n}\n//数据重复Observer\nfunction observe(value){\n\tif(typeof(value) != &#39;object&#39; ) return;\n\tlet ob = new Observer(value)\n  \treturn ob;\n}\n// 把对象属性改为getter/setter，并收集依赖\nfunction defineReactive (obj,key,val) {\n  \tconst dep = new Dep()\n  \t//处理children\n  \tlet childOb = observe(val)\n  \tObject.defineProperty(obj, key, {\n    \tenumerable: true,\n    \tconfigurable: true,\n    \tget: function reactiveGetter () {\n    \t\tconsole.log(`调用get获取值，值为${val}`)\n      \t\tconst value = val\n      \t\tif (Dep.target) {\n\t        \tdep.depend()\n\t\t        if (childOb) {\n\t\t          \tchildOb.dep.depend()\n\t\t        }\n\t      \t}\n      \t\treturn value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t    \tconsole.log(`调用了set，值为${newVal}`)\n\t      \tconst value = val\n\t       \tval = newVal\n\t       \t//对新值进行observe\n\t      \tchildOb = observe(newVal)\n\t      \t//通知dep调用,循环调用手机的Watcher依赖，进行视图的更新\n\t      \tdep.notify()\n\t    }\n  })\n}\n\n//辅助方法\nfunction def (obj, key, val) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  })\n}\n/*----------------------------------------初始化watch------------------------------------*/\nclass stateWatch{\n\tconstructor (vm, watch) {\n\t\tthis.vm = vm\n\t\t//初始化watch\n\t    this.initWatch(vm, watch)\n\t}\n\tinitWatch (vm, watch) {\n\t\t//遍历watch对象\n\t  \tfor (const key in watch) {\n\t\t    const handler = watch[key]\n\t\t    //数组则遍历进行createWatcher\n\t\t    if (Array.isArray(handler)) {\n\t\t      \tfor (let i = 0; i &lt; handler.length; i++) {\n\t\t        \tthis.createWatcher(vm, key, handler[i])\n\t\t      \t}\n\t\t    } else {\n\t\t      \tthis.createWatcher(vm, key, handler)\n\t\t    }\n\t  \t}\n\t}\n\tcreateWatcher (vm, key, handler) {\n\t  let options\n\t  if (Object.prototype.toString.call(handler) == &#39;[object Object]&#39; ) {\n\t  \t//处理对象\n\t    options = handler\n\t    handler = handler.handler\n\t  }\n\t  if (typeof handler === &#39;string&#39;) {\n\t    handler = vm[handler]\n\t  }\n\t  vm.$watch(key, handler, options)\n\t}\n}\n\n/*----------------------------------------Vue------------------------------------*/\nfunction Vue(){\n}\n\nVue.prototype.$watch=function(expOrFn,cb,options){\n\tconst vm = this\n    options = options || {}\n    //此参数用于给data从新赋值时走watch的监听函数\n    options.user = true\n    //watch依赖收集的Watcher\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    //immediate=true时 会调用一次 watcher.run 方法，因此会调用一次watch中相关key的函数\n    if (options.immediate) {\n      cb.call(vm, watcher.value)\n    }\n    //返回一个取消监听的函数\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>代码测试：</h2><p>再回头看看上面那张简单的Vue watch流程图，测试代码我们严格按照流程图顺序进行</p><p>为了方便观看此处复制一份流程图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-27de71bffaff8259476ed02183aa89f2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2036\" data-rawheight=\"862\" class=\"origin_image zh-lightbox-thumb\" width=\"2036\" data-original=\"https://pic3.zhimg.com/v2-27de71bffaff8259476ed02183aa89f2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2036&#39; height=&#39;862&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2036\" data-rawheight=\"862\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2036\" data-original=\"https://pic3.zhimg.com/v2-27de71bffaff8259476ed02183aa89f2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-27de71bffaff8259476ed02183aa89f2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>1、新建vue对象，并定义data和watch值:</h2><div class=\"highlight\"><pre><code class=\"language-text\">let vue = new Vue()</code></pre></div><p>定义一个data值并挂载到vue中，并给vue新增一个doSomething的方法：</p><div class=\"highlight\"><pre><code class=\"language-text\">let data={\n    name:&#39;zane&#39;,\n    blog:&#39;https://blog.seosiwei.com/&#39;,\n    age:20,\n    fn:&#39;&#39;,\n    some:{\n    \tf:&#39;xiaowang&#39;\n    }\n}\nvue.data = data\nvue.doSomething=()=&gt;{\n\tconsole.log(`i will do something`)\n}</code></pre></div><p>定义一个watch值</p><div class=\"highlight\"><pre><code class=\"language-text\">let watch={\n\tname: function (val, oldVal) {\n\t\tconsole.log(&#39;----------name--------&#39;)\n      \tconsole.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n    },\n    blog:function (val, oldVal) {\n    \tconsole.log(&#39;----------blog---------&#39;)\n      \tconsole.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n    },\n    age:&#39;doSomething&#39;,\n    fn:[\n      function handle1 (val, oldVal) { console.log(&#39;111111&#39;) },\n      function handle2 (val, oldVal) { console.log(&#39;222222&#39;) }\n    ],\n    some:{\n      \thandler: function (val, oldVal) {\n      \t\tconsole.log(&#39;----------some---------&#39;)\n      \t\tconsole.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n      \t},\n      \timmediate: true\n    },\n    &#39;some.f&#39;: function (val, oldVal) { \n\t\tconsole.log(`----some.f-----`)\n\t\tconsole.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n\t},\n}</code></pre></div><h2>2、始化Wathcer</h2><div class=\"highlight\"><pre><code class=\"language-text\">let updateComponent = (vm)=&gt;{\n\t// 收集依赖\n\tdata.age\n\tdata.blog\n\tdata.name\n\tdata.some\n\tdata.some.f\n\tdata.fn\n}\nnew Watcher(vue,updateComponent)</code></pre></div><h2>3、初始化Data数据并收集依赖</h2><div class=\"highlight\"><pre><code class=\"language-text\">observe(data)\n//此处会调用上面的函数updateComponent，从而调用 get 收集依赖</code></pre></div><h2>4、初始化watch</h2><p>其中会新创建watcher对象即（Dep.target=watcher）,调用watch对象key对应的data数据的set，从而收集依赖</p><div class=\"highlight\"><pre><code class=\"language-text\">new stateWatch(vue, watch)</code></pre></div><h2>5、触发set更新</h2><p>所有依赖都已经收集好是时候触发了</p><div class=\"highlight\"><pre><code class=\"language-text\">//首先会立即调用一次watch中的some的函数\n\n//会触发vue下的doSomething方法\ndata.age=25\n\n//会触发watch中监听的blog的函数\ndata.blog=&#39;http://www.seosiwei.com/&#39;\n\n//会触发watch中监听的name的函数\ndata.name=&#39;xiaozhang&#39;\n\n//会触发watch中some.f监听的函数\ndata.some.f=&#39;deep f&#39;\n\n//会触发watch中fn监听的两个函数\ndata.fn=&#39;go fn&#39;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>完整测试代码如下：</h2><div class=\"highlight\"><pre><code class=\"language-text\">let data={\n    name:&#39;zane&#39;,\n    blog:&#39;https://blog.seosiwei.com/&#39;,\n    age:20,\n    fn:&#39;&#39;,\n    some:{\n    \tf:&#39;xiaowang&#39;\n    }\n}\nlet watch={\n\tname: function (val, oldVal) {\n\t\tconsole.log(&#39;----------name--------&#39;)\n      \tconsole.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n    },\n    blog:function (val, oldVal) {\n    \tconsole.log(&#39;----------blog---------&#39;)\n      \tconsole.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n    },\n    age:&#39;doSomething&#39;,\n    fn:[\n      function handle1 (val, oldVal) { console.log(&#39;111111&#39;) },\n      function handle2 (val, oldVal) { console.log(&#39;222222&#39;) }\n    ],\n    some:{\n      \thandler: function (val, oldVal) {\n      \t\tconsole.log(&#39;----------some---------&#39;)\n      \t\tconsole.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n      \t},\n      \timmediate: true\n    },\n    &#39;some.f&#39;: function (val, oldVal) { \n\t\tconsole.log(`----some.f-----`)\n\t\tconsole.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n\t},\n}\n\nlet vue = new Vue()\nvue.data = data\nvue.doSomething=()=&gt;{\n\tconsole.log(`i will do something`)\n}\nlet updateComponent = (vm)=&gt;{\n\t// 收集依赖\n\tdata.age\n\tdata.blog\n\tdata.name\n\tdata.some\n\tdata.some.f\n\tdata.fn\n}\nnew Watcher(vue,updateComponent)\nobserve(data)\nnew stateWatch(vue, watch)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>watch实现完毕。</b></p><p>下一篇准备写：彻底搞懂Vue中computed（计算属性）的实现方式和原理</p>", 
            "topic": [
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }, 
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36773721", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 1, 
            "title": "这一次 彻底搞懂Vue针对数组和双向绑定(MVVM)的处理方式", 
            "content": "<p>欢迎关注我的博客：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/myblog\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/myblog</span><span class=\"ellipsis\"></span></a></p><p>Vue内部实现了一组观察数组的变异方法，例如：push()，pop()，shift()等。<br/></p><p>Object.definePropert只能把对象属性改为getter/setter，而对于数组的方法就无能为力了，其内部巧妙的使用了数组的属性来实现了数据的双向绑定，下面我们来一步一步的实现一个简单版。</p><p>下文大部分代码摘自Vue源码</p><h2>首先我们来实现给定一个数组 调用相关方法时触发自定义的函数</h2><h2>定义一个需要监听变化的数组</h2><div class=\"highlight\"><pre><code class=\"language-text\">let obarr = []</code></pre></div><h2>来copy一份数组的原型方法,防止污染原生数组方法</h2><div class=\"highlight\"><pre><code class=\"language-text\">const arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)</code></pre></div><h2>我们先把arrayMethods对象上的push转换为观察者对象</h2><div class=\"highlight\"><pre><code class=\"language-text\">Object.defineProperty(arrayMethods,&#39;push&#39;,{\n    value:function mutator(){\n    \tconsole.log(&#39;obarr.push会走这里&#39;)\n    }\n})</code></pre></div><p>此时arrayMethods定义了一个push的新属性，那么我们如何把它和 let obarr = [] 绑定起来呢，来看看下面的实现？</p><div class=\"highlight\"><pre><code class=\"language-text\">obarr.__proto__ = arrayMethods</code></pre></div><p>使用arrayMethods覆盖obarr的所有方法</p><p>到此现在完整代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">let obarr = []\nconst arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)\t\nObject.defineProperty(arrayMethods,&#39;push&#39;,{\n    value:function mutator(){\n    \tconsole.log(&#39;obarr.push会走这里&#39;)\n    }\n})\nobarr.__proto__ = arrayMethods;</code></pre></div><p>向obarr中push一个值看看，是不是走了console呢，肯定的答复你：yes 走了。</p><div class=\"highlight\"><pre><code class=\"language-text\">obarr.push(0)</code></pre></div><p>针对于不支持__proto__的浏览器实现如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">let obarr = []\nconst arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)\t\nObject.defineProperty(arrayMethods,&#39;push&#39;,{\n    value:function mutator(){\n    \tconsole.log(&#39;obarr.push会走这里&#39;)\n    }\n})\nObject.defineProperty(obarr,&#39;push&#39;,{\n\tvalue:arrayMethods.push\n})</code></pre></div><p>来真正的为arr赋值代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">let obarr = []\nconst arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)\nObject.defineProperty(arrayMethods,&#39;push&#39;,{\n    value:function mutator(){\n    \t  //缓存原生方法，之后调用\n    \t  const original = arrayProto[&#39;push&#39;]\t\n    \t  let args = Array.from(arguments)\n\t  original.apply(this,args)\n\t  console.log(obarr)\n    }\n})\nobarr.__proto__ = arrayMethods;</code></pre></div><p>现在每次执行obarr.push(0)时,obarr都会新增一项。</p><p>上面实现了push方法，其他的方法同理，我们只需要把所有需要实现的方法循环遍历执行即可，升级后代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">const arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)\n;[\n  &#39;push&#39;,\n  &#39;pop&#39;,\n  &#39;shift&#39;,\n  &#39;unshift&#39;,\n  &#39;splice&#39;,\n  &#39;sort&#39;,\n  &#39;reverse&#39;\n].forEach(item=&gt;{\n\tObject.defineProperty(arrayMethods,item,{\n\t    value:function mutator(){\n\t    \t//缓存原生方法，之后调用\n\t    \tconst original = arrayProto[item]\t\n\t    \tlet args = Array.from(arguments)\n\t\t    original.apply(this,args)\n\t    },\n\t})\n})\nfunction protoAugment (target,src) {\n  target.__proto__ = src\n}\n// 调用\nlet obarr = []\nprotoAugment(obarr, arrayMethods)</code></pre></div><p>来多试几次吧：</p><div class=\"highlight\"><pre><code class=\"language-text\">obarr.push(1)\nobarr.push(2)\nobarr.push(3)\nobarr.push(4)</code></pre></div><p>分析：</p><p>1、经过以上的代码可以看出，只会更改我们给定数组(obarr)的相关方法，而不会污染Array的原生方法，因此其他普通数组不受影响。</p><p>2、从新赋值数组的__proto__属性为arrayMethods，而arrayMethods我们从新定义了push，pop等相关属性方法，因此当我们使用数组的push,pop等方法时会调用arrayMethods的相关属性方法，达到监听数组变化的能力。</p><p>3、对于不支持__proto__属性的浏览器，直接使用Object.defineProperty从新定义相关属性。</p><p>4、而Vue的实现方法正如上，更改我们需要监听的Array数组属性值（属性值为函数），在监听函数里执行数组的原生方法，并通知所有注册的观察者进行响应式处理。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>下面来简单的实现Vue对数组的依赖收集和通知更新</h2><p>实现Vue的数据双向绑定有3大核心：Observer,Dep,Watcher,来个简单实现</p><p><b>首先来实现dep,dep主要负责依赖的收集,get时触发收集，set时通知watcher通信：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Dep{\n\tconstructor () {\n\t\t// 存放所有的监听watcher\n    \tthis.subs = []\n  \t}\n\n  \t//添加一个观察者对象\n  \taddSub (Watcher) {\n    \tthis.subs.push(Watcher)\n  \t}\n\n  \t//依赖收集\n\tdepend () {\n\t\t//Dep.target 作用只有需要的才会收集依赖\n\t    if (Dep.target) {\n\t      Dep.target.addDep(this)\n\t    }\n\t}\n\n\t// 调用依赖收集的Watcher更新\n    notify () {\n\t    const subs = this.subs.slice()\n\t    for (let i = 0, l = subs.length; i &lt; l; i++) {\n\t      subs[i].update()\n\t    }\n  \t}\n}\n\n// 为Dep.target 赋值\nfunction pushTarget (Watcher) {\n  Dep.target = Watcher\n}</code></pre></div><p><b>再来简单的实现Watcher,Watcher负责数据变更之后调用Vue的diff进行视图的更新：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Watcher{\n\tconstructor(vm,expOrFn,cb,options){\n\t\t//传进来的对象 例如Vue\n\t\tthis.vm = vm\n\t\t//在Vue中cb是更新视图的核心，调用diff并更新视图的过程\n\t\tthis.cb = cb\n\t\t//收集Deps，用于移除监听\n\t\tthis.newDeps = []\n\t\tthis.getter = expOrFn\n\t\t//设置Dep.target的值，依赖收集时的watcher对象\n\t\tthis.value =this.get()\n\t}\n\n\tget(){\n\t\t//设置Dep.target值，用以依赖收集\n\t    pushTarget(this)\n\t    const vm = this.vm\n\t    let value = this.getter.call(vm, vm)\n\t    return value\n\t}\n\n\t//添加依赖\n  \taddDep (dep) {\n  \t\t// 这里简单处理，在Vue中做了重复筛选，即依赖只收集一次，不重复收集依赖\n\t    this.newDeps.push(dep)\n\t    dep.addSub(this)\n  \t}\n\n  \t//更新\n  \tupdate () {\n\t    this.run()\n\t}\n\n\t//更新视图\n\trun(){\n\t\t//这里只做简单的console.log 处理，在Vue中会调用diff过程从而更新视图\n\t\tconsole.log(`这里会去执行Vue的diff相关方法，进而更新数据`)\n\t}\n}</code></pre></div><p><b>简单实现Observer，Observer负责数据的双向绑定，并把对象属性改为getter/setter</b></p><div class=\"highlight\"><pre><code class=\"language-text\">//获得arrayMethods对象上所有属性的数组\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n\nclass Observer{\n\tconstructor (value) {\n\t    this.value = value\n\t    // 增加dep属性（处理数组时可以直接调用）\n\t    this.dep = new Dep()\n\t    //将Observer实例绑定到data的__ob__属性上面去，后期如果oberve时直接使用，不需要从新Observer,\n\t    //处理数组是也可直接获取Observer对象\n\t    def(value, &#39;__ob__&#39;, this)\n\t    if (Array.isArray(value)) {\n\t    \t//处理数组\n\t        const augment = value.__proto__ ? protoAugment : copyAugment  \n\t        //此处的 arrayMethods 就是上面使用Object.defineProperty处理过\n\t        augment(value, arrayMethods, arrayKeys)\n\t        // 循环遍历数组children进行oberve\n\t        this.observeArray(value)\n\t    } else {\n\t    \t//处理对象\n\t      \tthis.walk(value)\n\t    }\n\t}\n\n\twalk (obj) {\n    \tconst keys = Object.keys(obj)\n    \tfor (let i = 0; i &lt; keys.length; i++) {\n    \t\t//此处我做了拦截处理，防止死循环，Vue中在oberve函数中进行的处理\n    \t\tif(keys[i]==&#39;__ob__&#39;) return;\n      \t\tdefineReactive(obj, keys[i], obj[keys[i]])\n    \t}\n  \t}\n\n\tobserveArray (items) {\n    \tfor (let i = 0, l = items.length; i &lt; l; i++) {\n\t      observe(items[i])\n    \t}\n  \t}\n}\n//数据重复Observer\nfunction observe(value){\n\tif(typeof(value) != &#39;object&#39; ) return;\n\tlet ob = new Observer(value)\n  \treturn ob;\n}\n// 把对象属性改为getter/setter，并收集依赖\nfunction defineReactive (obj,key,val) {\n  \tconst dep = new Dep()\n  \t//处理children\n  \tlet childOb = observe(val)\n  \tObject.defineProperty(obj, key, {\n    \tenumerable: true,\n    \tconfigurable: true,\n    \tget: function reactiveGetter () {\n    \t\tconsole.log(`调用get获取值，值为${val}`)\n      \t\tconst value = val\n      \t\tif (Dep.target) {\n\t        \tdep.depend()\n\t\t        if (childOb) {\n\t\t          \tchildOb.dep.depend()\n\t\t        }\n\t\t        //此处是对Array数据类型的依赖收集\n\t\t        if (Array.isArray(value)) {\n\t\t          \tdependArray(value)\n\t\t        }\n\t      \t}\n      \t\treturn value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t    \tconsole.log(`调用了set，值为${newVal}`)\n\t      \tconst value = val\n\t       \tval = newVal\n\t       \t//对新值进行observe\n\t      \tchildOb = observe(newVal)\n\t      \t//通知dep调用,循环调用手机的Watcher依赖，进行视图的更新\n\t      \tdep.notify()\n\t    }\n  })\n}\n\n//辅助方法\nfunction def (obj, key, val) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  })\n}\n\n//重新赋值Array的__proto__属性\nfunction protoAugment (target,src) {\n  target.__proto__ = src\n}\n//不支持__proto__的直接修改相关属性方法\nfunction copyAugment (target, src, keys) {\n  for (let i = 0, l = keys.length; i &lt; l; i++) {\n    const key = keys[i]\n    def(target, key, src[key])\n  }\n}\n//收集数组的依赖\nfunction dependArray (value) {\n  for (let e, i = 0, l = value.length; i &lt; l; i++) {\n    e = value[i]\n    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()\n    if (Array.isArray(e)) {\n    \t//循环遍历chindren进行依赖收集\n        dependArray(e)\n    }\n  }\n}</code></pre></div><p>Observer中写了一些相关需要的方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>让我们来修改下处理数组的相关方法，当使用Array.push相关方法时可以调用Watcher更新视图</p><div class=\"highlight\"><pre><code class=\"language-text\">const arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)\n;[\n  &#39;push&#39;,\n  &#39;pop&#39;,\n  &#39;shift&#39;,\n  &#39;unshift&#39;,\n  &#39;splice&#39;,\n  &#39;sort&#39;,\n  &#39;reverse&#39;\n].forEach(item=&gt;{\n\tObject.defineProperty(arrayMethods,item,{\n\t    value:function mutator(){\n\t    \t//缓存原生方法，之后调用\n\t    \tconst original = arrayProto[item]\t\n\t    \tlet args = Array.from(arguments)\n\t\t    original.apply(this,args)\n\t\t    const ob = this.__ob__\n\t\t    ob.dep.notify()\n\t    },\n\t})\n})</code></pre></div><h2><br/></h2><h2>大功至此告成，把所有代码整理完整如下：</h2><div class=\"highlight\"><pre><code class=\"language-text\">/*----------------------------------------处理数组------------------------------------*/\nconst arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)\n;[\n  &#39;push&#39;,\n  &#39;pop&#39;,\n  &#39;shift&#39;,\n  &#39;unshift&#39;,\n  &#39;splice&#39;,\n  &#39;sort&#39;,\n  &#39;reverse&#39;\n].forEach(item=&gt;{\n\tObject.defineProperty(arrayMethods,item,{\n\t    value:function mutator(){\n\t    \t//缓存原生方法，之后调用\n\t    \tconst original = arrayProto[item]\t\n\t    \tlet args = Array.from(arguments)\n\t\t    original.apply(this,args)\n\t\t    const ob = this.__ob__\n\t\t    ob.dep.notify()\n\t    },\n\t})\n})\n/*----------------------------------------Dep---------------------------------------*/\nclass Dep{\n\tconstructor () {\n\t\t// 存放所有的监听watcher\n    \tthis.subs = []\n  \t}\n\n  \t//添加一个观察者对象\n  \taddSub (Watcher) {\n    \tthis.subs.push(Watcher)\n  \t}\n\n  \t//依赖收集\n\tdepend () {\n\t\t//Dep.target 作用只有需要的才会收集依赖\n\t    if (Dep.target) {\n\t      Dep.target.addDep(this)\n\t    }\n\t}\n\n\t// 调用依赖收集的Watcher更新\n    notify () {\n\t    const subs = this.subs.slice()\n\t    for (let i = 0, l = subs.length; i &lt; l; i++) {\n\t      subs[i].update()\n\t    }\n  \t}\n}\n\n// 为Dep.target 赋值\nfunction pushTarget (Watcher) {\n  Dep.target = Watcher\n}\n\n/*----------------------------------------Watcher------------------------------------*/\nclass Watcher{\n\tconstructor(vm,expOrFn,cb,options){\n\t\t//传进来的对象 例如Vue\n\t\tthis.vm = vm\n\t\t//在Vue中cb是更新视图的核心，调用diff并更新视图的过程\n\t\tthis.cb = cb\n\t\t//收集Deps，用于移除监听\n\t\tthis.newDeps = []\n\t\tthis.getter = expOrFn\n\t\t//设置Dep.target的值，依赖收集时的watcher对象\n\t\tthis.value =this.get()\n\t}\n\n\tget(){\n\t\t//设置Dep.target值，用以依赖收集\n\t    pushTarget(this)\n\t    const vm = this.vm\n\t    let value = this.getter.call(vm, vm)\n\t    return value\n\t}\n\n\t//添加依赖\n  \taddDep (dep) {\n  \t\t// 这里简单处理，在Vue中做了重复筛选，即依赖只收集一次，不重复收集依赖\n\t    this.newDeps.push(dep)\n\t    dep.addSub(this)\n  \t}\n\n  \t//更新\n  \tupdate () {\n\t    this.run()\n\t}\n\n\t//更新视图\n\trun(){\n\t\t//这里只做简单的console.log 处理，在Vue中会调用diff过程从而更新视图\n\t\tconsole.log(`这里会去执行Vue的diff相关方法，进而更新数据`)\n\t}\n}\n\n/*----------------------------------------Observer------------------------------------*/\n//获得arrayMethods对象上所有属性的数组\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n\nclass Observer{\n\tconstructor (value) {\n\t    this.value = value\n\t    // 增加dep属性（处理数组时可以直接调用）\n\t    this.dep = new Dep()\n\t    //将Observer实例绑定到data的__ob__属性上面去，后期如果oberve时直接使用，不需要从新Observer,\n\t    //处理数组是也可直接获取Observer对象\n\t    def(value, &#39;__ob__&#39;, this)\n\t    if (Array.isArray(value)) {\n\t    \t//处理数组\n\t        const augment = value.__proto__ ? protoAugment : copyAugment  \n\t        //此处的 arrayMethods 就是上面使用Object.defineProperty处理过\n\t        augment(value, arrayMethods, arrayKeys)\n\t        // 循环遍历数组children进行oberve\n\t        this.observeArray(value)\n\t    } else {\n\t    \t//处理对象\n\t      \tthis.walk(value)\n\t    }\n\t}\n\n\twalk (obj) {\n    \tconst keys = Object.keys(obj)\n    \tfor (let i = 0; i &lt; keys.length; i++) {\n    \t\t//此处我做了拦截处理，防止死循环，Vue中在oberve函数中进行的处理\n    \t\tif(keys[i]==&#39;__ob__&#39;) return;\n      \t\tdefineReactive(obj, keys[i], obj[keys[i]])\n    \t}\n  \t}\n\n\tobserveArray (items) {\n    \tfor (let i = 0, l = items.length; i &lt; l; i++) {\n\t      observe(items[i])\n    \t}\n  \t}\n}\n//数据重复Observer\nfunction observe(value){\n\tif(typeof(value) != &#39;object&#39; ) return;\n\tlet ob = new Observer(value)\n  \treturn ob;\n}\n// 把对象属性改为getter/setter，并收集依赖\nfunction defineReactive (obj,key,val) {\n  \tconst dep = new Dep()\n  \t//处理children\n  \tlet childOb = observe(val)\n  \tObject.defineProperty(obj, key, {\n    \tenumerable: true,\n    \tconfigurable: true,\n    \tget: function reactiveGetter () {\n    \t\tconsole.log(`调用get获取值，值为${val}`)\n      \t\tconst value = val\n      \t\tif (Dep.target) {\n\t        \tdep.depend()\n\t\t        if (childOb) {\n\t\t          \tchildOb.dep.depend()\n\t\t        }\n\t\t        //此处是对Array数据类型的依赖收集\n\t\t        if (Array.isArray(value)) {\n\t\t          \tdependArray(value)\n\t\t        }\n\t      \t}\n      \t\treturn value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t    \tconsole.log(`调用了set，值为${newVal}`)\n\t      \tconst value = val\n\t       \tval = newVal\n\t       \t//对新值进行observe\n\t      \tchildOb = observe(newVal)\n\t      \t//通知dep调用,循环调用手机的Watcher依赖，进行视图的更新\n\t      \tdep.notify()\n\t    }\n  })\n}\n\n//辅助方法\nfunction def (obj, key, val) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  })\n}\n\n//重新赋值Array的__proto__属性\nfunction protoAugment (target,src) {\n  target.__proto__ = src\n}\n//不支持__proto__的直接修改相关属性方法\nfunction copyAugment (target, src, keys) {\n  for (let i = 0, l = keys.length; i &lt; l; i++) {\n    const key = keys[i]\n    def(target, key, src[key])\n  }\n}\n//收集数组的依赖\nfunction dependArray (value) {\n  for (let e, i = 0, l = value.length; i &lt; l; i++) {\n    e = value[i]\n    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()\n    if (Array.isArray(e)) {\n    \t//循环遍历chindren进行依赖收集\n        dependArray(e)\n    }\n  }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>测试：</h2><p><b>定义一个data对象：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">let data={\n    name:&#39;zane&#39;,\n    blog:&#39;https://blog.seosiwei.com/&#39;,\n    hobby:[&#39;basketball&#39;,&#39;football&#39;],\n    list:[\n        {name:&#39;zhangsan&#39;},\n        {name:&#39;lishi&#39;}\n    ]\n}</code></pre></div><p><b>调用watcher，并进行数据监听</b></p><div class=\"highlight\"><pre><code class=\"language-text\">let getUpdates = (vm)=&gt;{\n\tconsole.log(&#39;默认调用一次，进行依赖收集&#39;)\n}\nnew Watcher(this,getUpdates)\nobserve(data)</code></pre></div><p><b>调用get收集依赖</b></p><div class=\"highlight\"><pre><code class=\"language-text\">//收集name依赖\ndata.name\n//收集hobby依赖\ndata.hobby</code></pre></div><p><b>测试数据监听</b></p><div class=\"highlight\"><pre><code class=\"language-text\">//都会打印这里会去执行Vue的diff相关方法，进而更新数据\ndata.name = &#39;zhangshan&#39;\ndata.hobby.push(&#39;volleyball&#39;)</code></pre></div><p>是不时出现可可爱的 这里会去执行Vue的diff相关方法，进而更新数据 日志呢。</p><p>没进行依赖收集的属性会打印日志吗,来尝试一下吧</p><div class=\"highlight\"><pre><code class=\"language-text\">//不会打印更新\ndata.blog = &#39;http://www.seosiwei.com/&#39;\n//不会调用每一个children的打印更新\ndata.list.push({name:&#39;xiaowang&#39;})</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>以上基本实现了Vue对数组和对象的双向绑定处理方式，收集依赖和更新视同原理，当然代码并没有做太多的优化，比如（Watcher重复的收集）。</h2><h2>大部分代码摘自与Vue源码，部分实现的比较简单，做了一些更改，代码进行的从新组织，整体能很好的说明Vue的核心MVVM实现方式。</h2><p>下一篇：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/36\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">彻底搞懂Vue中watch的实现方式和原理</a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>来自于：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/35\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">彻底搞懂Vue针对数组和双向绑定(MVVM)的处理方式</a></p>", 
            "topic": [
                {
                    "tag": "MVVM", 
                    "tagLink": "https://api.zhihu.com/topics/19685551"
                }, 
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36595006", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 2, 
            "title": "如何做到网页性能的极致优化", 
            "content": "<p>对于一个大项目来说，项目性能优化是一项非常重要的工作。此处的大应该怎样理解，我把大理解为以下几项：<br/></p><ul><li>项目代码量足够大，例如一个京东商城</li><li>项目主页面足够复杂，有非常多的逻辑和业务代码(并不一定项目大)</li><li>项目用户访问量大，也就是并发量高</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>提升网页性能的方式有很多，把很多方法做到位就能大大的提升网页访问速度。</p><p>那么对于网页性能的提升，作为开发者的我们能做哪些事情呢？</p><p>备注：以下是博主的一些实践和想法 主要针对于http1.1协议</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>在说性能优化方法之前我们来思考下哪些问题会带来性能方面的瓶颈？</h2><p>用户的每次请求都是一次完整的http请求过程，我们可以大致想到以下几个问题会导致网页访问变慢</p><p>1、同时访问的用户太多，同时访问的用户越多页面加载就越慢，因为每台服务器的宽带，读取文件的速度，处理计算的速度是固定的，同时访问的请求越多就一定会带来一些性能上的问题。</p><p>2、网页返回的内容越大，网页就越慢，这是一定的</p><p>3、http请求时body的内容越大，网页也就越慢，这同上</p><p>4、网页依赖的文件越多，也就意味着更多的http请求，加载时间也会带来一定的影响</p><p>5、用户的网络越慢，网页加载时间就一定越慢，因为传输的内容大小是固定的，网络越慢每次返回的资源大小也更少</p><p>6、服务器网络宽带越小，响应的时间也一定越慢</p><p>7、服务器内存，硬盘，cup越小或性能越差也会响应时间越长</p><p>8 、....</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>对于网页的性能优化可分为三个部分：</h2><p>1、针对于前端代码层面的性能优化</p><p>2、针对于浏览器和http方面的性能优化</p><p>3、针对于web服务器和后端的性能优化</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>一：前端代码层面的优化</h2><p><b>比较大提升性能的几个点：</b></p><p>1、网页资源或图片使用cdn加速和压缩</p><p>2、css放头部js放底部，js可以根据情况加上async或defer</p><p>3、图片做懒加载</p><p>4、做首屏渲染，首屏以下代码做异步加载</p><p>5、做按需加载，在资源需要时再加载（比如路由资源，弹出层等）</p><p>6、做骨架屏渲染，提升界面体验效果</p><p>7、某些资源或数据使用浏览器缓存，sessionStorage和localStorage,或者浏览器数据库</p><p>8、使用Service Worker缓存任何可控的资源，甚至可以做离线应用</p><p><b>代码层面的优化：</b></p><p>1、压缩js,jss,img等资源</p><p>2、CSS Sprite技术等</p><p>3、尽量减少html,css层级深度</p><p>4、api资源请求尽量使用异步</p><p>6、合并css,js,图片</p><p>7、减少http请求，css嵌入网页，小图片使用base64</p><p>8、抽离公共代码，减少资源体积</p><p>9、代码层面的优化有很多，不一一列举，只要做到极致，一定会有效果。</p><p>10、......</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>二：浏览器和http方面的优化</h2><p>1、针对于资源（css,js,img）尽量做强缓存，web服务器设置Cache-Control的max-age，设置合适的值(值越大缓存时间越长)</p><p>2、针对于有可能会变的资源可以使用协商缓存，设置ETag或Last-Modified，也可以两者同时设置</p><p>服务器会优先验证ETag的值，因为Last-Modified的值只精确到了秒级，并没有精确到毫秒级别，并不能100%的保证两次资源是否一致，而ETag不会有此问题。</p><p>3、合并资源，减少http请求数量，在http1.1中，只能同时处理一定量的http请求，请求过多的资源会先处于等待状态</p><p>4、使用浏览器的缓存功能，例如sesson和local,有些资源和数据第二次以后可以完全不必要去后端获取</p><p>5、使用新的api，Service Worker开辟新的线程去做耗时的工作或之后需要的资源。甚至可以做离线应用</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>三：web服务器和后端的优化</h2><p>web服务器和后端是前端开发者们基本接触不到的点</p><p>1、对于html,css,js等资源我们可以开启资源压缩，常用的为gzip，开启gzip会对服务器cpu有一定的消耗，对于流量不大的网站没什么影响</p><p>2、对于常规的网站我们可以开启Connection: keep-alive，这样http通道就会高效的被利用，请求也会加快</p><p>3、对于高并发的网站尽量不要设置Connection参数(即keepalive_timeout的值)，或者值设置的越短越好，服务器处理请求的数量是一定的，如果每次请求占用通道的时间越长，同时处理的请求就会越少。</p><p>4、搭建自己的cdn服务器，让资源返回速度更快</p><p>5、最大化的利用服务器性能：开启多线程，设置最大并发链接数、最大链接数、最大文件访问数、tcp等待状态等</p><p><b>还可以从提升硬件方面考虑性能问题</b></p><p>1、提升服务器性能，根据项目情况选择相应服务器，计算密集，I/O密集 ，进程密集等。</p><p>2、提升网络带宽，增加内存、硬盘、cpu等</p><p>3、对于高访问量的资源或者api做负载均衡配置</p><p>4、拆分服务器，例如后台服务器，资源文件服务器，数据库服务器，nginx入口服务器等，特定的资源去特定的服务器获取</p><p>5、对于高并发的网站需要做集群处理，后台服务器集群，数据库集群，redis集群等</p><p>6、使用redis缓存数据资源，redis相对于关系数据库能很大的提升获取资源速度</p><p><b>针对于后端代码的优化就交给后端人员。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果能做到以上60%以上的点，你的网站性能一定会有大幅度的提升。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>转载自：<a href=\"https://link.zhihu.com/?target=https%3A//blog.seosiwei.com/detail/33\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">如何做到网页性能的极致优化</a></p>", 
            "topic": [
                {
                    "tag": "性能优化", 
                    "tagLink": "https://api.zhihu.com/topics/19633850"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36594440", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 1, 
            "title": "mysqls 一个node对mysql的封装库 链式调用、支持事务", 
            "content": "<p>在我自己的平常开发中很少有见到javascript对sql的封装比较好的库(找了一圈也没找到、应该是暂时我没发现)，因此前期的项目中根据自己的项目情况实现了一套封装方法。</p><p>最近我准备写一个这样的库，基于前期自己对mysql的封装（ThinkPHP是我使用过的一个PHP框架，对它的模型模块调用sql的方式很喜欢） 因此决定参考其API，用javascript实现一次。<br/></p><h2>mysqls想表达什么</h2><ul><li>node.js连接mysql的库有很多，因此觉得没必要自己再封装一个，为了达到库的广泛使用性，因此此库只做生成SQL语句的功能封装</li><li>整个api采用链式调用的方式，这样能最大化的减少开发代码和使用自由度</li><li>链式调用方法顺序内部已经做了排序，因此可以不按严格的sql语句顺序来使用方法</li><li>sql调用方法直接参考ThinkPHP的api，因此不用自己再从新定义方法名称</li><li>自由、简洁、使用简单是它想表达出来的</li><li>完整的API说明文档，写文档比写代码更累，时间更久，可见开源框架文档的难能可贵，为它们致敬</li></ul><h2>进入正文：</h2><p>简介：node-transform-mysql是在node.js场景中使用mysql，根据传入的参数生成相应的sql语句。它所做的事情很简单也很专一，只负责生成sql语句，不执行任何实际的增删改查。你也不用担心它的体量，整体代码300行左右，压缩之后代码不足8k。</p><p>github地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/node-transform-mysql\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://github.com/wangweianger/mysql</a>s</p><p>npm地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/mysqls\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">npmjs.com/package/mysql</span><span class=\"invisible\">s</span><span class=\"ellipsis\"></span></a></p><p>API文档地址：<a href=\"https://link.zhihu.com/?target=https%3A//wangweianger.gitbooks.io/node-transform-mysql/content/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">wangweianger.gitbooks.io</span><span class=\"invisible\">/node-transform-mysql/content/</span><span class=\"ellipsis\"></span></a></p><h2>安装：</h2><div class=\"highlight\"><pre><code class=\"language-text\">npm install mysqls --save-dev</code></pre></div><p>然后使用一个支持 CommonJS 或 ES2015 的模块管理器，例如 webpack：</p><div class=\"highlight\"><pre><code class=\"language-text\">//import方式\nimport { execute,sql,transaction } from &#39;mysqls&#39;\n\n//require方式\nlet { execute,sql,transaction } = require(&#39;mysqls&#39;)</code></pre></div><h2>参数说明</h2><p>execute     ：执行单挑sql语句       参数：（config,sqlStr）<br/>sql         ：链式调用生成sql语句    链式调用语法，参考后文<br/>transaction ：执行事务相关任务时使用  参数：（config,sqlArr）<br/>定义一个公共的config配置</p><div class=\"highlight\"><pre><code class=\"language-text\">let config={\n    host:&#39;localhost&#39;,\n    user:&#39;root&#39;,\n    password:&#39;123456&#39;,\n    database:&#39;web-performance&#39;,\n    port:&#39;3306&#39;,\n}</code></pre></div><h2>使用Promise方式</h2><div class=\"highlight\"><pre><code class=\"language-text\">//使用\nlet sqlstr = sql.table(&#39;web_pages&#39;).where({id:147}).select()\n\nexecute(config,sqlstr).then(res=&gt;{\n      console.log(res)\n}).catch(err=&gt;{\n    console.log(err)\n})</code></pre></div><h2>使用async/await</h2><div class=\"highlight\"><pre><code class=\"language-text\">let sqlstr = sql.table(&#39;web_pages&#39;).where({id:147}).select()\n\nlet result = await execute(config,sqlstr)\nconsole.log(result)</code></pre></div><h2>处理事务</h2><div class=\"highlight\"><pre><code class=\"language-text\">let tranSqlArr = [\n    sql.table(&#39;table1&#39;).data({number:number-5}).update(),\n    sql.table(&#39;table2&#39;).data({number:number+5}).update()\n]\nlet result = await transaction(config,tranSqlArr)\nconsole.log(result)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>生成sql语句简单用法</h2><h2>sql调用方法的顺序内部已经做了排序，因此可以不按严格的sql语句顺序来写</h2><p>查询</p><div class=\"highlight\"><pre><code class=\"language-text\">sql\n    .table(&#39;node_table&#39;)\n    .where(&#39;id=1&#39;)\n    .select()\n\nSELECT * FROM node_table WHERE id=1\n\nsql\n    .table(&#39;node_table&#39;)\n    .field(&#39;id,name&#39;)\n    .where({id:1})\n    .select()\n\nSELECT id,name FROM node_table WHERE id=1</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>插入</p><div class=\"highlight\"><pre><code class=\"language-text\">sql\n    .table(&#39;node_table&#39;)\n    .data({name:&#39;zane&#39;,email:&#39;752636052@qq.com&#39;})\n    .insert()\n\nINSERT INTO node_table (name,email) VALUES (`zane`,`752636052@qq.com`)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>更新</p><div class=\"highlight\"><pre><code class=\"language-text\">sql\n    .table(&#39;node_table&#39;)\n    .data({name:&#39;zane&#39;,email:&#39;752636052@qq.com&#39;})\n    .update()\n\nUPDATE node_table SET name=`zane`,email=`752636052@qq.com`</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>删除</p><div class=\"highlight\"><pre><code class=\"language-text\">sql .table(&#39;node_table&#39;)\n    .where({name:&#39;zane&#39;})\n    .delet();\n\nDELETE FROM node_table WHERE name=`zane`</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>生成sql语句高级用法</h2><p>数据库的查询是最复杂的，因此高级用法主要针对于查询</p><div class=\"highlight\"><pre><code class=\"language-text\">//参数json多字段\nsql\n    .table(&#39;node_table&#39;)\n    .where({id:1,name:&#39;zane&#39;})\n    .select()\n\nSELECT  * FROM node_table WHERE id=1 AND name=`zane`\n\n//参数数组\nlet data=[\n    {id:1,name:&#39;zhangsan&#39;,_type:&#39;or&#39;},\n    {sex:1,number:3}\n]\nsql.table(&#39;node_table&#39;).where(data).select()\n\nSELECT * FROM node_table WHERE (id=1 OR name=`zhangsan` ) AND (sex=1 AND number=3 )\n\n//多字段连接方式\nlet data=[\n    {id:1,name:&#39;zhangsan&#39;,_type:&#39;or&#39;,_nexttype:&#39;or&#39;},\n    {sex:1,number:3,_type:&#39;and&#39;}\n]\nsql.table(&#39;node_table&#39;).where(data).select()\n\nSELECT * FROM node_table WHERE (id=1 OR name=`zhangsan`) OR (sex=1 AND number=3)\n\n//表达式查询\nlet data={\n    id:{eq:100,egt:10,_type:&#39;or&#39;},\n    name:&#39;zhangshan&#39;\n}\nsql.table(&#39;node_table&#39;).where(data).select()\n\nSELECT  * FROM node_table WHERE ((id=100) OR (id&gt;=10)) AND name=`zhangshan`\n\n//混合查询\nlet data=[{\n    id:{eq:100,egt:10,_type:&#39;or&#39;},\n    name:&#39;zhangshan&#39;,\n    _nexttype:&#39;or&#39;\n},{\n    status:1,\n    name:{like:&#39;%zane%&#39;}\n}]\nsql.table(&#39;node_table&#39;).where(data).select()\n\nSELECT * FROM node_table WHERE (((id=100) OR (id&gt;=10)) AND name=`zhangshan`) OR (status=1 AND ((name LIKE `%zane%`))) \n\n\n//UNION ， UNION ALL 组合使用\nsql\n    .union(&#39;SELECT * FROM think_user_1&#39;,true)\n    .union(&#39;SELECT * FROM think_user_2&#39;,true)\n    .union([&#39;SELECT * FROM think_user_3&#39;,&#39;SELECT name FROM think_user_4&#39;])\n    .union(&#39;SELECT * FROM think_user_5&#39;,true)\n    .select()\n\n得到\n(SELECT * FROM think_user_1) UNION ALL  \n(SELECT * FROM think_user_2) UNION ALL \n(SELECT * FROM think_user_3) UNION \n(SELECT name FROM think_user_4)  UNION  \n(SELECT * FROM think_user_5)\n\n//子查询\nlet sqlstring = sql.field(&#39;id,name&#39;).table(&#39;node_table&#39;).group(&#39;field&#39;)\nsql.table(sqlstring).group(&#39;field&#39;).where(&#39;id=1&#39;).order(&#39;status&#39;).select()\n\n得到\nSELECT * FROM (SELECT id,name FROM node_table GROUP BY field ) WHERE id=1 GROUP BY field ORDER BY status</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>更多用法请查看详细文档</p><p>API文档地址：<a href=\"https://link.zhihu.com/?target=https%3A//wangweianger.gitbooks.io/node-transform-mysql/content/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">wangweianger.gitbooks.io</span><span class=\"invisible\">/node-transform-mysql/content/</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>项目运行</h2><div class=\"highlight\"><pre><code class=\"language-text\">git clone https://github.com/wangweianger/mysqls.git\nnpm install\n\n//dve\nnpm run dve\n\n//product\nnpm run build</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>此库后期也会根据自己的使用不断的完善，也欢迎您的建议</p><p>如果你绝对对你有帮助，欢迎给个star</p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "MongoDB", 
                    "tagLink": "https://api.zhihu.com/topics/19560787"
                }, 
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35785188", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 1, 
            "title": "performance-report页面性能、资源、错误、ajax，fetch请求上报插件 完善小巧", 
            "content": "<h2>2018年04月17日<i>34</i> browse</h2><p>performance-report只做页面性能数据的采集和上报，是比较完整和健全的数据上报插件，它可以帮你完成以下功能：</p><ul><li>当前页面URL (data.page)</li><li>上一页面URL （data.preUrl）</li><li>当前浏览器版本信息 （data.appVersion）</li><li>页面性能数据信息 （data.performance），例如：页面加载时间，白屏时间，dns解析时间等</li><li>当前页面错误信息 （data.errorList） 包含（js,css,img,ajax,fetch 等错误信息）</li><li>当前页面所有资源性能数据 （data.resoruceList）,例如ajax,css,img等资源加载性能数据</li><li>不用担心阻塞页面，压缩资源大小6kb,上报方式为异步上报</li></ul><p>github地址，如果你觉得对你有用的话欢迎给个star</p><h2><a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/web-performance-report\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/web-performance-report</span><span class=\"ellipsis\"></span></a> </h2><p>完整的前端性能监控系统</p><h2><a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/web-performance-monitoring-system\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/web-performance-monitoring-system</span><span class=\"ellipsis\"></span></a> </h2><p>使用方式：</p><ul><li>1、下载 dist/performance-report.min.js 到本地</li><li>使用script标签引入到html的头部（备注：放到所有js资源之前）</li><li>3、使用performance函数进行数据的监听上报</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">&lt;html&gt;\n&lt;head&gt;\n\t&lt;meta charset=&#34;UTF-8&#34;&gt;\n\t&lt;title&gt;performance test&lt;/title&gt;\n\t&lt;!-- 放到所有资源之前 防止获取不到error信息 --&gt;\n\t&lt;script src=&#34;../dist/performance-report.min.js&#34;&gt;&lt;/script&gt;\n\t&lt;script&gt;\n\t\t//开始上报数据\n\t\tPerformance({\n\t\t    domain:&#39;http://some.com/api&#39;, //更改成你自己的上报地址域名\n\t\t})\n\t&lt;/script&gt;\n&lt;/head&gt;</code></pre></div><h2>参数说明：</h2><p>完整调用方式</p><div class=\"highlight\"><pre><code class=\"language-text\">Performance({\n    domain:&#39;http://some.com/api&#39;, \n    outtime:500,\n    isPage:true,\n    isResource:true,\n    isError:true,\n    filterUrl:[&#39;http://localhost:35729/livereload.js?snipver=1&#39;]\n},(data)=&gt;{\n\tfetch(&#39;http://some.com/api&#39;,{type:&#39;POST&#39;,body:JSON.stringify(result)}).then((data)=&gt;{})\n})</code></pre></div><ul><li>同时传入 domain和传入的function ，function优先级更高</li><li>domain\t：上报api接口</li><li>outtime\t：上报延迟时间，保证异步数据的加载 （默认：1000ms）</li><li>isPage\t：是否上报页面性能数据 （默认：true）</li><li>isResource\t：是否上报页面资源性能数据 （默认：true）</li><li>isError\t：是否上报页面错误信息数据 （默认：true）</li><li>filterUrl ：不需要上报的ajax请求 （例如开发模式下的livereload链接）</li><li>fn\t：自定义上报函数，上报方式可以用ajax可以用fetch (非必填：默认使用fetch)</li></ul><h2>错误处理：</h2><p>插件会处理所有的error信息并完成上报，错误处理分为4种类型</p><ul><li>1.图片资源，js资源文本资源等资源错误信息 n=&#39;resource&#39;</li><li>2.js报错，代码中的js报错 n=&#39;js&#39;</li><li>3.ajax请求错误 n=&#39;ajax&#39;</li><li>4.fetch请求错误\tn=&#39;fetch&#39;</li></ul><h2>AJAX处理：</h2><ul><li>AJAX分为 XMLHttpRequest 和 Fetch的处理</li><li>AJAX兼容老板般与新版本 例如：jq的1.x版本与2.x版本以上需要做兼容处理</li><li>拦截所有fetch请求信息，遇到错误时收集并上报</li></ul><h2>所有资源信息处理：</h2><ul><li>上报所有资源信息，资源类型以type来区分 type类型有</li><li>script：js脚本资源</li><li>img：图片资源</li><li>fetchrequest：fetch请求资源</li><li>xmlhttprequest：ajax请求资源</li><li>other ：其他</li></ul><h2>运行方式：</h2><div class=\"highlight\"><pre><code class=\"language-text\">git clone https://github.com/wangweianger/web-performance-report.git\nnpm install\n//开发\nnpm run dev\n//打包\nnpm run build\n\nhttp://localhost:8080/test/ 页面测试</code></pre></div><h2>单页面程序处理说明：</h2><ul><li>对于单页面应用程序，只有第一次加载的页面性能数据有效，之后的路由跳转不会有页面的性能数据，因为需要的静态资源已经加载完成</li><li>如果新的路由有ajax请求或者fetch请求，会抓取所有新的请求数据并上报。</li><li>多页面应用程序不会受影响</li></ul><p><b>一份完整的上报数据看起来像这样：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">{\n  &#34;page&#34;: &#34;http://localhost:8080/test/&#34;, \n  &#34;preUrl&#34;: &#34;&#34;, \n  &#34;appVersion&#34;: &#34;5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&#34;, \n  &#34;errorList&#34;: [\n    {\n      &#34;t&#34;: 1523948635259, \n      &#34;n&#34;: &#34;js&#34;, \n      &#34;msg&#34;: &#34;ReferenceError: wangwei is not defined at http://localhost:8080/test/:64:15&#34;, \n      &#34;data&#34;: {\n        &#34;resourceUrl&#34;: &#34;http://localhost:8080/test/&#34;, \n        &#34;line&#34;: 64, \n        &#34;col&#34;: 15\n      }, \n      &#34;method&#34;: &#34;GET&#34;\n    }, \n    {\n      &#34;t&#34;: 1523948635330, \n      &#34;n&#34;: &#34;resource&#34;, \n      &#34;msg&#34;: &#34;img is load error&#34;, \n      &#34;data&#34;: {\n        &#34;target&#34;: &#34;img&#34;, \n        &#34;type&#34;: &#34;error&#34;, \n        &#34;resourceUrl&#34;: &#34;http://img1.imgtn.bd95510/&#34;\n      }, \n      &#34;method&#34;: &#34;GET&#34;\n    }, \n    {\n      &#34;t&#34;: 1523948635405, \n      &#34;n&#34;: &#34;ajax&#34;, \n      &#34;msg&#34;: &#34;ajax请求错误&#34;, \n      &#34;data&#34;: {\n        &#34;resourceUrl&#34;: &#34;&#34;, \n        &#34;text&#34;: &#34;&#34;, \n        &#34;status&#34;: 0\n      }\n    }, \n    {\n      &#34;t&#34;: 1523948635425, \n      &#34;n&#34;: &#34;fetch&#34;, \n      &#34;msg&#34;: &#34;fetch请求错误&#34;, \n      &#34;data&#34;: {\n        &#34;resourceUrl&#34;: &#34;http://mock-api.seosiwei.com/guest/order/api/order/getOrde&#34;, \n        &#34;text&#34;: &#34;TypeError: Failed to fetch&#34;, \n        &#34;status&#34;: 0\n      }, \n      &#34;method&#34;: &#34;POST&#34;\n    }\n  ], \n  &#34;performance&#34;: {\n    &#34;dnst&#34;: 0, \n    &#34;tcpt&#34;: 0, \n    &#34;wit&#34;: 17, \n    &#34;domt&#34;: 239, \n    &#34;lodt&#34;: 904, \n    &#34;radt&#34;: 8, \n    &#34;rdit&#34;: 0, \n    &#34;uodt&#34;: 0, \n    &#34;reqt&#34;: 23, \n    &#34;andt&#34;: 645\n  }, \n  &#34;resourceList&#34;: [\n    {\n      &#34;name&#34;: &#34;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&#34;, \n      &#34;method&#34;: &#34;GET&#34;, \n      &#34;type&#34;: &#34;script&#34;, \n      &#34;duration&#34;: &#34;0.00&#34;, \n      &#34;decodedBodySize&#34;: 0, \n      &#34;nextHopProtocol&#34;: &#34;h2&#34;\n    }, \n    {\n      &#34;name&#34;: &#34;https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=295864288,1887240069&amp;fm=27&amp;gp=0.jpg&#34;, \n      &#34;method&#34;: &#34;GET&#34;, \n      &#34;type&#34;: &#34;img&#34;, \n      &#34;duration&#34;: &#34;0.00&#34;, \n      &#34;decodedBodySize&#34;: 0, \n      &#34;nextHopProtocol&#34;: &#34;http/1.1&#34;\n    }, \n    {\n      &#34;name&#34;: &#34;http://mock-api.seosiwei.com/guest/home/api/shop/getHomeInitInfo&#34;, \n      &#34;method&#34;: &#34;GET&#34;, \n      &#34;type&#34;: &#34;fetchrequest&#34;, \n      &#34;duration&#34;: &#34;157.10&#34;, \n      &#34;decodedBodySize&#34;: 0, \n      &#34;nextHopProtocol&#34;: &#34;http/1.1&#34;\n    }, \n    {\n      &#34;name&#34;: &#34;http://mock-api.seosiwei.com/guest/order/api/order/getOrder&#34;, \n      &#34;method&#34;: &#34;POST&#34;, \n      &#34;type&#34;: &#34;xmlhttprequest&#34;, \n      &#34;duration&#34;: &#34;148.40&#34;, \n      &#34;decodedBodySize&#34;: 0, \n      &#34;nextHopProtocol&#34;: &#34;http/1.1&#34;\n    }\n  ]\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>原文地址：<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fblog.seosiwei.com%252Fdetail%252F30\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">performance-report页面性能、资源、错误、ajax，fetch请求上报插件</a></p><p></p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35442522", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 6, 
            "title": "vue.js源码 - 剖析observer,dep,watch如何具体的实现数据双向绑定", 
            "content": "<p>最近在解析vue源码，后期会不断更新有兴趣的可以关注我的博客</p><p>关注我的博客：<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Flink.juejin.im%252F%253Ftarget%253Dhttps%25253A%25252F%25252Flink.juejin.im%25252F%25253Ftarget%25253Dhttps%2525253A%2525252F%2525252Flink.juejin.im%2525252F%2525253Ftarget%2525253Dhttps%252525253A%252525252F%252525252Flink.juejin.im%252525252F%252525253Ftarget%252525253Dhttps%25252525253A%25252525252F%25252525252Flink.juejin.im%25252525252F%25252525253Ftarget%25252525253Dhttps%2525252525253A%2525252525252F%2525252525252Flink.juejin.im%2525252525252F%2525252525253Ftarget%2525252525253Dhttps%252525252525253A%252525252525252F%252525252525252Fgithub.com%252525252525252Fwangweianger%252525252525252Fmyblog\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zane的个人博客</a></p><h2>Vue双向数据绑定的核心和基础api是Object.defineProperty,其内部真正参与数据双向绑定流程的主要有Obderver、Dep和Watcher,基于defineProperty和发布者订阅者模式，最终实现数据的双向绑定。那么Obderver、Dep和Watcher是如何具体配合工作的呢？下面就来理一理。</h2><p>看此文章之前你需要对vue的双向数据绑定有一定的理解。若不了解可移步：<a href=\"https://link.zhihu.com/?target=http%3A//blog.seosiwei.com/detail/22\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vue.js源码解读系列 - 双向绑定具体如何初始化和工作</a></p><p>看到这里就当你对双向数据绑定已经有一定的理解：</p><p>提示：要看懂此篇文章你需要对vue的mvvm有一定的了解，并需要和专注的去理解，或者对照源码跟着走，不然就很难真的看懂。</p><h2>在这里把双向数据绑定分为两个流程：</h2><p>1、收集依赖流程：</p><div class=\"highlight\"><pre><code class=\"language-text\">observe -&gt; \nwalk -&gt; \ndefineReactive -&gt; get -&gt; \ndep.depend() -&gt; \nwatcher.addDep(new Dep()) -&gt; \nwatcher.newDeps.push(dep) -&gt; \ndep.addSub(new Watcher()) -&gt; \ndep.subs.push(watcher)</code></pre></div><p>依赖收集会经过以上流程，最终watcher.newDeps数组中存放dep列表，dep.subs数组中存放watcher列表。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么要进行依赖收集？</p><div class=\"highlight\"><pre><code class=\"language-text\">new Vue({ data(){ return {\n    name:&#39;zane&#39;,\nsex:&#39;男&#39; } } })\n</code></pre></div><p>有上面这个data，实际上页面只使用到了name，并没有使用age，根据Object.defineProperty的转换，如果我们设置了this.sex=&#39;女&#39;，那么Vue也会去执行一遍虚拟DOM的比较，这样就无形的浪费了一些性能，因此才需要做依赖收集，界面用到了就收集，没有用到就不收集。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们跟着流程走来理一遍源码：</p><p>直接进入Object.defineProperty的get方法：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-38e99bd80fd808b64fe65e89ef14ffd7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1842\" data-rawheight=\"1380\" class=\"origin_image zh-lightbox-thumb\" width=\"1842\" data-original=\"https://pic4.zhimg.com/v2-38e99bd80fd808b64fe65e89ef14ffd7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1842&#39; height=&#39;1380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1842\" data-rawheight=\"1380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1842\" data-original=\"https://pic4.zhimg.com/v2-38e99bd80fd808b64fe65e89ef14ffd7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-38e99bd80fd808b64fe65e89ef14ffd7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>考验你闭包能力的时候到了，这个dep对象就是一个闭包。记下来我们看看dep.depend()方法的实现。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8140c6bbb99d833a3bbe13698af09799_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1644\" data-rawheight=\"260\" class=\"origin_image zh-lightbox-thumb\" width=\"1644\" data-original=\"https://pic2.zhimg.com/v2-8140c6bbb99d833a3bbe13698af09799_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1644&#39; height=&#39;260&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1644\" data-rawheight=\"260\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1644\" data-original=\"https://pic2.zhimg.com/v2-8140c6bbb99d833a3bbe13698af09799_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8140c6bbb99d833a3bbe13698af09799_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>先暂停一下，上面两处都用到了 Dep.target ，我也说了它就是一个Watcher实例化对象，你是不是很想搞懂它到底在哪里赋值的呢，不急请跟着我下面的代码看看。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-beb0f0e19a96dd32d34523d0da17ba3f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2042\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb\" width=\"2042\" data-original=\"https://pic4.zhimg.com/v2-beb0f0e19a96dd32d34523d0da17ba3f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2042&#39; height=&#39;470&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2042\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2042\" data-original=\"https://pic4.zhimg.com/v2-beb0f0e19a96dd32d34523d0da17ba3f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-beb0f0e19a96dd32d34523d0da17ba3f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ef0e006325cbd8a78234d5d701ebc7c3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1802\" data-rawheight=\"1292\" class=\"origin_image zh-lightbox-thumb\" width=\"1802\" data-original=\"https://pic4.zhimg.com/v2-ef0e006325cbd8a78234d5d701ebc7c3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1802&#39; height=&#39;1292&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1802\" data-rawheight=\"1292\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1802\" data-original=\"https://pic4.zhimg.com/v2-ef0e006325cbd8a78234d5d701ebc7c3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ef0e006325cbd8a78234d5d701ebc7c3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bd7843490e169e8c46469ddffcb9ea81_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1562\" data-rawheight=\"228\" class=\"origin_image zh-lightbox-thumb\" width=\"1562\" data-original=\"https://pic2.zhimg.com/v2-bd7843490e169e8c46469ddffcb9ea81_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1562&#39; height=&#39;228&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1562\" data-rawheight=\"228\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1562\" data-original=\"https://pic2.zhimg.com/v2-bd7843490e169e8c46469ddffcb9ea81_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bd7843490e169e8c46469ddffcb9ea81_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>搞懂了Dep.target等于一个Watche对象，现在继续回到之前的思路看watcher.addDep做了什么。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ea9b2ff7307f2a6ef9b24ff48201db63_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1914\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb\" width=\"1914\" data-original=\"https://pic4.zhimg.com/v2-ea9b2ff7307f2a6ef9b24ff48201db63_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1914&#39; height=&#39;570&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1914\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1914\" data-original=\"https://pic4.zhimg.com/v2-ea9b2ff7307f2a6ef9b24ff48201db63_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ea9b2ff7307f2a6ef9b24ff48201db63_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a12f1abe63e0f1d4dc1332165f0e3752_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1642\" data-rawheight=\"218\" class=\"origin_image zh-lightbox-thumb\" width=\"1642\" data-original=\"https://pic3.zhimg.com/v2-a12f1abe63e0f1d4dc1332165f0e3752_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1642&#39; height=&#39;218&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1642\" data-rawheight=\"218\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1642\" data-original=\"https://pic3.zhimg.com/v2-a12f1abe63e0f1d4dc1332165f0e3752_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a12f1abe63e0f1d4dc1332165f0e3752_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>就这样依赖收集的流程就走完了，是否感觉很绕。</p><p>总结：依赖收集最终在 watcher.newDeps 中push了闭包中传过来的dep对象，在dep.subs中push了初始化Vue是简历的Watcher对象，这个对象的，this.getter = expOrFn,传过来的expOrFn是后期数据更新页面渲染的核心步骤，需要沉下心来好好去理理。</p><p>2、视图更新流程：</p><div class=\"highlight\"><pre><code class=\"language-text\">set -&gt; \ndep.notify() -&gt; \nsubs[i].update() -&gt; \nwatcher.run() || queueWatcher(this) -&gt; \nwatcher.get() || watcher.cb -&gt; \nwatcher.getter() -&gt; \nvm._update() -&gt; \nvm.__patch__()\n\n视图更新会经过以上流程，最终调用Vue的虚拟Dom diff过程实时更新界面视图</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8a125e2210fc5bca4c9f17eca3bd97ba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1888\" data-rawheight=\"686\" class=\"origin_image zh-lightbox-thumb\" width=\"1888\" data-original=\"https://pic3.zhimg.com/v2-8a125e2210fc5bca4c9f17eca3bd97ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1888&#39; height=&#39;686&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1888\" data-rawheight=\"686\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1888\" data-original=\"https://pic3.zhimg.com/v2-8a125e2210fc5bca4c9f17eca3bd97ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8a125e2210fc5bca4c9f17eca3bd97ba_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-94e9b7b4477ed9424c5fe7790675b538_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1724\" data-rawheight=\"374\" class=\"origin_image zh-lightbox-thumb\" width=\"1724\" data-original=\"https://pic1.zhimg.com/v2-94e9b7b4477ed9424c5fe7790675b538_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1724&#39; height=&#39;374&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1724\" data-rawheight=\"374\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1724\" data-original=\"https://pic1.zhimg.com/v2-94e9b7b4477ed9424c5fe7790675b538_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-94e9b7b4477ed9424c5fe7790675b538_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1ce15fa4071a5faef7f9b778615f4f6c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1434\" data-rawheight=\"566\" class=\"origin_image zh-lightbox-thumb\" width=\"1434\" data-original=\"https://pic1.zhimg.com/v2-1ce15fa4071a5faef7f9b778615f4f6c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1434&#39; height=&#39;566&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1434\" data-rawheight=\"566\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1434\" data-original=\"https://pic1.zhimg.com/v2-1ce15fa4071a5faef7f9b778615f4f6c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1ce15fa4071a5faef7f9b778615f4f6c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-91cf0d1d58c10d3bd5bb226dfcdd0ac7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1894\" data-rawheight=\"1174\" class=\"origin_image zh-lightbox-thumb\" width=\"1894\" data-original=\"https://pic4.zhimg.com/v2-91cf0d1d58c10d3bd5bb226dfcdd0ac7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1894&#39; height=&#39;1174&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1894\" data-rawheight=\"1174\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1894\" data-original=\"https://pic4.zhimg.com/v2-91cf0d1d58c10d3bd5bb226dfcdd0ac7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-91cf0d1d58c10d3bd5bb226dfcdd0ac7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a318e9daab56a25725c1c6b337ca821f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1954\" data-rawheight=\"1042\" class=\"origin_image zh-lightbox-thumb\" width=\"1954\" data-original=\"https://pic4.zhimg.com/v2-a318e9daab56a25725c1c6b337ca821f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1954&#39; height=&#39;1042&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1954\" data-rawheight=\"1042\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1954\" data-original=\"https://pic4.zhimg.com/v2-a318e9daab56a25725c1c6b337ca821f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a318e9daab56a25725c1c6b337ca821f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c38ffe206d3cce9e6e87bd5b14cfb18f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1870\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb\" width=\"1870\" data-original=\"https://pic4.zhimg.com/v2-c38ffe206d3cce9e6e87bd5b14cfb18f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1870&#39; height=&#39;1048&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1870\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1870\" data-original=\"https://pic4.zhimg.com/v2-c38ffe206d3cce9e6e87bd5b14cfb18f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c38ffe206d3cce9e6e87bd5b14cfb18f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>走到此处后面我就不去跟踪了，后面会调用vm.__patch__ 方法，进而执行虚拟DOM的diff过程实时的更新界面。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>总结：</p><h2>要很好的理解vue的数据双向绑定就要比较耐心，沉下心来慢慢理解，同时也需要对vue的源码有个大致的理解，不然你只会看的越来越烦躁越来越没有信心。</h2><p>vue很好的利用了Object.defineProperty方法的 get和set方法，订阅者发布者的设计思路，巧妙的组织代码，值得我们很深入的去学习和理解，从而促使我们更好的去使用它。谢谢尤大的无私奉献，让我们提高了生产力，把更多的精力花到业务逻辑中去。</p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }
            ], 
            "comments": [
                {
                    "userName": "子升", 
                    "userLink": "https://www.zhihu.com/people/d8a7f8a98f10ddbd05a5cde184002a41", 
                    "content": "<p>首先，给博主点赞，文章基本讲完了vuejs数据交互到原理，也提到了数据双向的关键点，addSub方法收集watch，这些都无疑问，不知道博主在具体研究过程中是否发现，在收集watch时，在watch.get()的第一步pushTarget()后，watch就被添加到了对应的subs中了，而此时调试时并未调用addSub方法，就想请教博主，这个是如何做到的？</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35442449", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 1, 
            "title": "vue.js源码解读系列 - Vue的自定义事件机制", 
            "content": "<p>先看一波使用方式：</p><h2>vm.$on 有两个参数，第一个参数可以是字符串也可以是数组，第二个是回调函数</h2><ul><li>监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">vm.$on(&#39;test&#39;, function (msg) {\n  console.log(msg)\n})\nvm.$on([&#39;test1&#39;,&#39;test2&#39;], function (msg) {\n  console.log(msg)\n})</code></pre></div><h2>vm.$once 有两个参数，第一个是时间名称只能是字符串，第二个是回调函数</h2><ul><li>监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器<br/></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">vm.$once(&#39;testonce&#39;, function (msg) {\n  console.log(msg)\n})</code></pre></div><h2>vm.$off 有两个参数，第一个参数可以是字符串也可以是数组，第二个是回调函数</h2><ul><li>如果没有提供参数，则移除所有的事件监听器；<br/></li><li>如果只提供了事件，则移除该事件所有的监听器；</li><li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">vm.$off()\nvm.$off(&#39;test&#39;)\nvm.$off(&#39;test1&#39;, function (msg) {\n  console.log(msg)\n})\nvm.$off([&#39;test1&#39;,&#39;test2&#39;], function (msg) {\n  console.log(msg)\n})</code></pre></div><h2>vm.$emit 有两个参数，第一个参数触发的事件名，第二参数传递的参数</h2><ul><li>触发当前实例上的事件。附加参数都会传给监听器回调。<br/></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">vm.$emit(&#39;test&#39;, &#39;触发自定义事件&#39;)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>下面从源码来看其实现，vue的自定义事件功能实现在 core/instance/events.js中</h2><h2>1、初始化事件，在vm下挂载_events属性对象，所有添加的自定义事件都会存放其中</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c5f77aff9427d741c3e62b39b2783145_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1566\" data-rawheight=\"396\" class=\"origin_image zh-lightbox-thumb\" width=\"1566\" data-original=\"https://pic2.zhimg.com/v2-c5f77aff9427d741c3e62b39b2783145_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1566&#39; height=&#39;396&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1566\" data-rawheight=\"396\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1566\" data-original=\"https://pic2.zhimg.com/v2-c5f77aff9427d741c3e62b39b2783145_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c5f77aff9427d741c3e62b39b2783145_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>2、$on事件的实现</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5d2fe4262328006023dce167bd286a40_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1878\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb\" width=\"1878\" data-original=\"https://pic1.zhimg.com/v2-5d2fe4262328006023dce167bd286a40_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1878&#39; height=&#39;700&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1878\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1878\" data-original=\"https://pic1.zhimg.com/v2-5d2fe4262328006023dce167bd286a40_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5d2fe4262328006023dce167bd286a40_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>根据以上分析可以看出 vm._events 的结构为：</p><div class=\"highlight\"><pre><code class=\"language-text\">vm._events={\n    &#39;test&#39;:[fn,fn...],\n    &#39;test1&#39;:[fn,fn...]\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>3、$once事件的实现</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3b64c8eb0675820bb6a683e9f54bf33a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2054\" data-rawheight=\"426\" class=\"origin_image zh-lightbox-thumb\" width=\"2054\" data-original=\"https://pic3.zhimg.com/v2-3b64c8eb0675820bb6a683e9f54bf33a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2054&#39; height=&#39;426&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2054\" data-rawheight=\"426\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2054\" data-original=\"https://pic3.zhimg.com/v2-3b64c8eb0675820bb6a683e9f54bf33a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3b64c8eb0675820bb6a683e9f54bf33a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>根据分析得出 $once绑定的事件 vm.events 的结构为：</p><div class=\"highlight\"><pre><code class=\"language-text\">vm._events={\n    &#39;oncetest&#39;:[ \n          function on(){\n              vm.$off(event,on)\n              fn.apply(vm,arguments)\n          } ,\n          ...\n     ]\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>4、$off事件的实现</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-785aa51a32a1df71048800a9936840f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2058\" data-rawheight=\"1456\" class=\"origin_image zh-lightbox-thumb\" width=\"2058\" data-original=\"https://pic3.zhimg.com/v2-785aa51a32a1df71048800a9936840f6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2058&#39; height=&#39;1456&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2058\" data-rawheight=\"1456\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2058\" data-original=\"https://pic3.zhimg.com/v2-785aa51a32a1df71048800a9936840f6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-785aa51a32a1df71048800a9936840f6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>一一的实现了下面的这三点：</p><ul><li>如果没有提供参数，则移除所有的事件监听器；</li><li>如果只提供了事件，则移除该事件所有的监听器；</li><li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>5、$emit事件的实现</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a9a1c77f645d67e34e497bc6fbae0ed6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2070\" data-rawheight=\"1096\" class=\"origin_image zh-lightbox-thumb\" width=\"2070\" data-original=\"https://pic3.zhimg.com/v2-a9a1c77f645d67e34e497bc6fbae0ed6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2070&#39; height=&#39;1096&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2070\" data-rawheight=\"1096\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2070\" data-original=\"https://pic3.zhimg.com/v2-a9a1c77f645d67e34e497bc6fbae0ed6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a9a1c77f645d67e34e497bc6fbae0ed6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>白话描述：匹配到json中相关key值的value,这个value先转换成真正的数组，再循环遍历数组，传入给的参数执行数组中的每个函数。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结：</h2><h2>整个自定义事件就是在vm下挂载一个_events的Object对象，可以理解为一个json，其中json的key值就是自定义事件的名称，一个key值可能对应着多个自定义事件，因此json中每个key对应的value都是一个数组，每次执行事件监听都会向数组中push相关的函数，最终通过$emit函数传入的参数，匹配到json中相应的key,val值，从而使用给定的参数执行数组中的函数。</h2><p>最终的vm._events可以是这样的值：</p><div class=\"highlight\"><pre><code class=\"language-text\">vm._events={\n    &#39;test1&#39;:[fn,fn,fn],\n    &#39;test2&#39;:[fn],\n    &#39;oncetest&#39;:[ \n          function on(){\n              vm.$off(event,on)\n              fn.apply(vm,arguments)\n          },\n          ... \n     ],\n     ...\n}</code></pre></div><p>vue中自定义事件的主要作用是组件间的通信，因为_events对象最终挂载在Vue的实例上，因此每个组件都能够访问到vm._events的值，也能向其中push相关的订阅函数。</p><p>最典型的用法就是vue组件间的组件通信，父组件使用 :foo.sync , 子组件使用 this.$emit(&#39;update:foo&#39;, option) 进行双向通信，如果你有看过vue的源码就会发现实际上，:foo.sync 最终会绑定一个 &#39;update:foo&#39; 的事件。</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;comp :foo.sync=&#34;bar&#34;&gt;&lt;/comp&gt;\n会被拓展为\n&lt;comp :foo=&#34;bar&#34; @update:foo=&#34;val =&gt; bar = val&#34;&gt;&lt;/comp&gt;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-22a2ac248cc8a885a0b5cc981336190f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1510\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb\" width=\"1510\" data-original=\"https://pic4.zhimg.com/v2-22a2ac248cc8a885a0b5cc981336190f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1510&#39; height=&#39;314&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1510\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1510\" data-original=\"https://pic4.zhimg.com/v2-22a2ac248cc8a885a0b5cc981336190f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-22a2ac248cc8a885a0b5cc981336190f_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "源碼", 
                    "tagLink": "https://api.zhihu.com/topics/20031938"
                }
            ], 
            "comments": [
                {
                    "userName": "xueyuan", 
                    "userLink": "https://www.zhihu.com/people/80dd63cc66b9fa4dc3f13d201a4e5b7e", 
                    "content": "。。。。", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35442263", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 3, 
            "title": "前端性能监控系统开发 附加完整代码", 
            "content": "<p>说起前端性能监控系统，绝大部分人应该不陌生，也许你正在使用，又或者你只是听说过。总之它就是这样频繁的出现在我们的工作之中。</p><p>那么做一个前端性能监控系统，我们应该统计一些什么维度的信息呢？那些数据真正对于我们有用呢？它适用的场景又有哪些呢？有很多的问题需要回答，再做之前我们应该回答一些问题，如果这些问题不能回答出来那就不要轻易去尝试。以下是我觉得需要想明白的一些问题。</p><h2>先想明白一些问题</h2><ul><li>我们为什么需要前端性能监控系统，是公司产品真的需要还是开发着玩玩？</li><li>业界有那么多的成熟产品，我可以直接使用吗？自己做一个是更好的方案吗？</li><li>我们应该统计一些什么纬度的信息？你确定你统计的数据的准确性吗？</li><li>你设计的这些维度信息，对于我们开发真的有参考价值吗？</li><li>你开发的产品能够推广给公司团队使用吗？别人需要你这个产品吗？他会配合你吗？</li><li>如果开始做，你了解过团队中其他人的需求吗？他们有没有什么意见对你有参考价值？</li><li>能对你或者团队在技术上有什么提升吗？有服务器资源吗？后期有迭代的打算吗？</li><li>能带领团队中其他人一起做吗？对他们是否有吸引力？</li></ul><p>以上是我个人觉得应该思考的一些问题，我们只要能给出一个合理的答案那就开始干吧。</p><h2>那么咋们开始做吧</h2><p>一个产品开始做之前我们应该想明白一些技术上或者UI上的一些问题</p><p>在产品上也许你应该画一些产品原型图，哪怕是简单的手绘素描图都是OK的。</p><p>在技术上我们要解决核心的统计问题，比如统计页面性能数据的API：performance，performance兼容IE9以上的浏览器，performance.timing统计页面性能，performance.getEntriesByType(&#39;resource&#39;) 统计页面资源性能。window.onerror统计页面错误信息。</p><h2>开发中遇到的问题：</h2><ul><li>如何统计页面所有AJAX性能数据，如何知道所有AJAX已加载完毕</li><li>如何统计页面所有资源性能详情（包括异步ajax和图片），浏览器api能搞定吗</li><li>如何知道一个用户访问了哪些页面，访问深度何如，怎么跟踪记录</li><li>获取用户IP网络信息使用的第三方接口，如何能更好的做好缓存，解决用户每次访问都调用的问题</li><li>一个页面资源，ajax，js同时报错，如何全部抓取并记录下来</li><li>如何解决数据频繁写入数据量太大的问题，数据库应该怎么设计或处理</li></ul><h2>针对于以上几个问题我简单的描述我的处理方式：</h2><p>   1、如何统计页面所有AJAX性能数据，如何知道所有AJAX已加载完毕？</p><p>   由于页面中ajax基本都是异步加载，因此我们并不能确定页面上的ajax是否真的已经加载完毕，<code>window.onload</code>并不能解决我们的问题。</p><p>鉴于绝大部分网页的ajax都是用的XMLHttpRequest对象，我们可以在页面加载之处重新定义XMLHttpRequest对象，对open，onload，onreadystatechange方法进行拦截。具体代码可参考本项目。</p><p>   2、如何统计页面所有资源性能详情（包括异步ajax和图片），浏览器api能搞定吗？</p><p>   在页面所有异步资源加载完毕之前，<code>performance.getEntriesByType(&#39;resource&#39;)</code> 方法得到的资源列表都是不完整的，如何尽可能的保证完整呢？</p><p>   页面的异步资源主要有两种：一种是ajax，另一种是图片，针对于ajax我们可以使用方法1得到最终的加载时间，对于图片我们可以获取当前页面所有图片资源列表，建立new Image()对象得到最终的时间。最后比较图片和ajax的加载时间，谁更长就代表谁更接近（或是）页面加载最终完成时间，如果图片和ajax资源都没有那就是用window.onload，最终调用performance.getEntriesByType(&#39;resource&#39;)得到最终的资源列表。</p><p>   3、如何知道一个用户访问了哪些页面，访问深度何如，怎么跟踪记录</p><p>   跨域打cookie，一个cookie代表用户信息，同一个会话窗口此值不会再改变，另一个cookie关联同一页面的性能数据，访问者信息，错误信息标识等，此cookie会跟着页面改变而改变</p><p>   4、获取用户IP网络信息使用的第三方接口，如何能更好的做好缓存，解决用户每次访问都调用的问题</p><p>   一：同上一题（3）可以打cookie，若有cookie者不用再请求， </p><p>   二：根据代表用户cookie的值去查找后端缓存里第一次请求后的ip，运营商信息。</p><p>   5、一个页面资源，ajax，js同时报错，如何全部抓取并记录下来</p><p>   写三个监控，一个监控XMLHttpRequest获得ajax错误信息，一个监控window.onerror获得页面js报错信息，还有一个监听error事件获得页面资源报错信息。</p><p>   6、如何解决数据频繁写入数据量太大的问题，数据库应该怎么设计或处理</p><p>   一：写定时任务，每晚几点钟对数据表进行备份，统计，或删除</p><p>   二：一个站点建立一张数据表</p><p>   三：页面给sql窗口或按钮，手动进行相应的任务</p><p>   四：集群处理（这个没那么大量，有些时候并不是所有数据都需要储存，公司也没那么多服务器，一般不考虑）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>就这样结尾了：全程无代码！！！</p><p>附属github地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/web-performance-monitoring-system\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/web-performance-monitoring-system</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>附上几张效果图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4b142f31f9794e3da8b71e6708c23173_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1906\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb\" width=\"1906\" data-original=\"https://pic4.zhimg.com/v2-4b142f31f9794e3da8b71e6708c23173_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1906&#39; height=&#39;632&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1906\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1906\" data-original=\"https://pic4.zhimg.com/v2-4b142f31f9794e3da8b71e6708c23173_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4b142f31f9794e3da8b71e6708c23173_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e9151822c4602379dafe2ec7c3633b78_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1892\" data-rawheight=\"876\" class=\"origin_image zh-lightbox-thumb\" width=\"1892\" data-original=\"https://pic1.zhimg.com/v2-e9151822c4602379dafe2ec7c3633b78_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1892&#39; height=&#39;876&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1892\" data-rawheight=\"876\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1892\" data-original=\"https://pic1.zhimg.com/v2-e9151822c4602379dafe2ec7c3633b78_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e9151822c4602379dafe2ec7c3633b78_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d758cebaba2357c0acfdbce9523a832a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1878\" data-rawheight=\"871\" class=\"origin_image zh-lightbox-thumb\" width=\"1878\" data-original=\"https://pic3.zhimg.com/v2-d758cebaba2357c0acfdbce9523a832a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1878&#39; height=&#39;871&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1878\" data-rawheight=\"871\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1878\" data-original=\"https://pic3.zhimg.com/v2-d758cebaba2357c0acfdbce9523a832a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d758cebaba2357c0acfdbce9523a832a_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-006b48bd09484bcd1e4726f0451e869f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1886\" data-rawheight=\"880\" class=\"origin_image zh-lightbox-thumb\" width=\"1886\" data-original=\"https://pic4.zhimg.com/v2-006b48bd09484bcd1e4726f0451e869f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1886&#39; height=&#39;880&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1886\" data-rawheight=\"880\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1886\" data-original=\"https://pic4.zhimg.com/v2-006b48bd09484bcd1e4726f0451e869f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-006b48bd09484bcd1e4726f0451e869f_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4ef28e99157b930c72e0e779f1a051cf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1583\" data-rawheight=\"745\" class=\"origin_image zh-lightbox-thumb\" width=\"1583\" data-original=\"https://pic4.zhimg.com/v2-4ef28e99157b930c72e0e779f1a051cf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1583&#39; height=&#39;745&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1583\" data-rawheight=\"745\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1583\" data-original=\"https://pic4.zhimg.com/v2-4ef28e99157b930c72e0e779f1a051cf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4ef28e99157b930c72e0e779f1a051cf_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "Node.js", 
                    "tagLink": "https://api.zhihu.com/topics/19569535"
                }, 
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35442045", 
            "userName": "zane", 
            "userLink": "https://www.zhihu.com/people/0abc1c5fe65dccbb4fa6989b786f7273", 
            "upvote": 2, 
            "title": "PC端时间日历插件 不依赖任何插件 功能完整、全面", 
            "content": "<p>先来找图看看时间选择器的效果：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8e8c4b9e1f46aa8d1665b128596e351a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"540\" data-rawheight=\"684\" class=\"origin_image zh-lightbox-thumb\" width=\"540\" data-original=\"https://pic3.zhimg.com/v2-8e8c4b9e1f46aa8d1665b128596e351a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;540&#39; height=&#39;684&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"540\" data-rawheight=\"684\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"540\" data-original=\"https://pic3.zhimg.com/v2-8e8c4b9e1f46aa8d1665b128596e351a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8e8c4b9e1f46aa8d1665b128596e351a_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-847c125cc218d73359419a812ca29b46_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"612\" class=\"origin_image zh-lightbox-thumb\" width=\"532\" data-original=\"https://pic3.zhimg.com/v2-847c125cc218d73359419a812ca29b46_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;532&#39; height=&#39;612&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"612\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"532\" data-original=\"https://pic3.zhimg.com/v2-847c125cc218d73359419a812ca29b46_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-847c125cc218d73359419a812ca29b46_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-18b2b7fb1a6ff4a9772bf56f01d317c7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"616\" class=\"origin_image zh-lightbox-thumb\" width=\"538\" data-original=\"https://pic4.zhimg.com/v2-18b2b7fb1a6ff4a9772bf56f01d317c7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;538&#39; height=&#39;616&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"616\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"538\" data-original=\"https://pic4.zhimg.com/v2-18b2b7fb1a6ff4a9772bf56f01d317c7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-18b2b7fb1a6ff4a9772bf56f01d317c7_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3d2a13c2c4d53909641783a4696517da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb\" width=\"532\" data-original=\"https://pic3.zhimg.com/v2-3d2a13c2c4d53909641783a4696517da_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;532&#39; height=&#39;692&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"532\" data-original=\"https://pic3.zhimg.com/v2-3d2a13c2c4d53909641783a4696517da_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3d2a13c2c4d53909641783a4696517da_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cb75f4e9bdbe225b879dc82619629d61_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1034\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb\" width=\"1034\" data-original=\"https://pic2.zhimg.com/v2-cb75f4e9bdbe225b879dc82619629d61_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1034&#39; height=&#39;700&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1034\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1034\" data-original=\"https://pic2.zhimg.com/v2-cb75f4e9bdbe225b879dc82619629d61_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cb75f4e9bdbe225b879dc82619629d61_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-45ae3479e9eea67a30fe6374a4e3d345_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1042\" data-rawheight=\"586\" class=\"origin_image zh-lightbox-thumb\" width=\"1042\" data-original=\"https://pic2.zhimg.com/v2-45ae3479e9eea67a30fe6374a4e3d345_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1042&#39; height=&#39;586&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1042\" data-rawheight=\"586\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1042\" data-original=\"https://pic2.zhimg.com/v2-45ae3479e9eea67a30fe6374a4e3d345_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-45ae3479e9eea67a30fe6374a4e3d345_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>没错就是这个吊样，如果你不需要这个色调，你可以fork我的github项目任意修改美美的色调。<br/></p><p>当然也欢迎你给我提很多很多的bug让我改不停😃 。</p><h2>npm地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/zane-calendar\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">npmjs.com/package/zane-</span><span class=\"invisible\">calendar</span><span class=\"ellipsis\"></span></a></h2><h2>github地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wangweianger/zane-data-time-calendar\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wangweianger</span><span class=\"invisible\">/zane-data-time-calendar</span><span class=\"ellipsis\"></span></a></h2><h2>demo地址：<a href=\"https://link.zhihu.com/?target=http%3A//www.seosiwei.com/zaneDate/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">seosiwei.com/zaneDate/i</span><span class=\"invisible\">ndex.html</span><span class=\"ellipsis\"></span></a></h2><p class=\"ztext-empty-paragraph\"><br/></p><h2>说明：</h2><ul><li>掉起插件DOM节点可以是input输入框，也可以是其他任意闭合的html标签 </li><li>此插件不依赖任何第三方插件，因此可以在任何地方单独使用</li><li>插件不兼容低版本的IE浏览器，IE浏览器请慎重</li><li>暂时只支持单个时间段选择，后期会推出多个时间段选择方式</li></ul><h2>使用方法：</h2><h2>浏览器端直接应用css,js</h2><div class=\"highlight\"><pre><code class=\"language-text\">&lt;link href=&#34;./dist/zane-calendar.css&#34;&gt;\n&lt;script src=&#34;./dist/zane-calendar.js&#34;&gt;&lt;/script&gt;\n\n&lt;!-- 需要加时间插件的输入框 --&gt;\n&lt;input type=&#34;text&#34; name=&#34;&#34; id=&#34;zane-calendar&#34;&gt;\n\n初始化\nzaneDate({\n\telem:&#39;#zane-calendar&#39;,\n})</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>webpack 开发引入方式</h2><div class=\"highlight\"><pre><code class=\"language-text\">const zaneDate = require(&#39;zane-calendar&#39;)\n或\nimport zaneDate from &#39;zane-calendar&#39;\n\n&lt;!-- 需要加时间插件的输入框 --&gt;\n&lt;input type=&#34;text&#34; name=&#34;&#34; id=&#34;zane-calendar&#34;&gt;\n\n初始化\nzaneDate({\n\telem:&#39;#zane-calendar&#39;,\n})</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>gitHub代码拉取下来运行方式</h2><div class=\"highlight\"><pre><code class=\"language-text\">git clone https://github.com/wangweianger/zane-data-time-calendar.git\nnpm install\nnpm run dev\nnpm run build</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>插件参数说明</h2><div class=\"highlight\"><pre><code class=\"language-text\">{\t\n        elem:&#39;#zane-calendar&#39;,   控件的dom原生 注意：仅限制于id选择器\n\ttype:&#39;day&#39;,   可选类型 day year month time oubleday doubleyear doublemonth doubletime\n\tlang:&#39;cn&#39;,   可选择语言类型 cn , en \n\twidth:280,  插件宽度配置\n\tformat:&#39;yyyy-MM-dd HH:mm:ss&#39;,  时间格式化\n\tbegintime:&#39;&#39;,  开始时间  （单选择器默认选择此项）\n\tendtime:&#39;&#39;,       结束时间  （double选择器需要）\n\tmin:&#39;&#39;,  可选取时间最小范围 1900-10-01\n\tmax: &#39;&#39;,  可选取时间最大范围 2099-12-31\n\tposition:&#39;fixed&#39;,  定位方式  暂时只支持 fixed\n\tevent:&#39;click&#39;,   事件方式 暂时只支持 click \n        zindex:100,  z-index的值\n\tshowtime:true,  是否显示选择时间\n\tshowclean:true,  是否显示清除按钮\n\tshownow:true,  是否显示当前按钮\n\tshowsubmit:true, 是否显示提交按钮\n\thaveBotBtns:true, 是否有底部按钮列表\n\tcalendarName:&#39;&#39;, 此参数勿动 表示当前时间插件实例化对象\n\tmounted:()=&gt;{}, 插件加载完成之后调用\n\tchange:(fulltime,begintime,endtime)=&gt;{}, 时间变更之后调用\n\tdone:(fulltime,begintime,endtime)=&gt;{}, 选择完成之后调用\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>参数具体配置可参考demo文件</p><h2>案例调用方式</h2><div class=\"highlight\"><pre><code class=\"language-text\">默认完整选项\n\tzaneDate({\n\t\telem:&#39;#zane-calendar&#39;,\n\t})\n\n\t只选择年月日\n\tzaneDate({\n\t\telem:&#39;#zane-calendar&#39;,\n\t\tshowtime:false,\n\t})\n\n\t使用英文\n\tzaneDate({\n\t\telem:&#39;#zane-calendar&#39;,\n\t\tlang:&#39;en&#39;,\n\t})\n\n\t只选择年\n\tzaneDate({\n\t\telem:&#39;#zane-calendar&#39;,\n\t\ttype:&#39;year&#39;,\n\t})\n\n\t只选择月\n\tzaneDate({\n\t\telem:&#39;#zane-calendar&#39;,\n\t\ttype:&#39;month&#39;,\n\t})\n\n\t只选择时间\n\tzaneDate({\n\t\telem:&#39;#zane-calendar&#39;,\n\t\ttype:&#39;time&#39;,\n\t})\n\n\t格式化方式\n\tzaneDate({\n\t\telem:&#39;#zane-calendar&#39;,\n\t\tformat:&#39;yyyy年MM月dd日 HH时mm分ss秒&#39;,\n\t})\n\n\t限定能选择的最小最大区间\n\tzaneDate({\n\t\telem:&#39;#zane-calendar&#39;,\n\t\tmin:&#39;2017-08-01&#39;,\n\t\tmax:&#39;2017-08-20&#39;,\n\t})</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>1.1.0 版本 新增double双选择时间配置</h2><div class=\"highlight\"><pre><code class=\"language-text\">config.type  新增double类型  可选类型如下：\nday year month time doubleday doubleyear doublemonth doubletime\n\n双日期范围选择\nzaneDate({\n\telem:&#39;#demo21&#39;,\n\ttype:&#39;doubleday&#39;,\n\tshowtime:false\n})\n\n双年范围选择\nzaneDate({\n\telem:&#39;#demo22&#39;,\n\ttype:&#39;doubleyear&#39;,\n})\n\n双月范围选择\nzaneDate({\n\telem:&#39;#demo23&#39;,\n\ttype:&#39;doublemonth&#39;,\n})\n\n双时间选择\nzaneDate({\n\telem:&#39;#demo24&#39;,\n\ttype:&#39;doubletime&#39;,\n})</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>1.2.0 </h2><ul><li>doubleday类型新增选择时间，支持时分秒选择</li><li>double类型检测距离右边window边线的距离，若不足，自动排列为上下两个日期</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">config.type doubleday支持选择时间范围\n\n双日期范围选择\nzaneDate({\n\telem:&#39;#demo25&#39;,\n\tformat:&#39;yyyy-MM-dd HH:mm:ss&#39;,\n\ttype:&#39;doubleday&#39;,\n\tshowtime:true\n})</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>1.2.1 版本 新增z-index 参数</h2><div class=\"highlight\"><pre><code class=\"language-text\">zaneDate({\n\telem:&#39;#zane-calendar&#39;,\n\tzindex:500,\n})</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>2.0.5 修复 double选择器 默认值</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>如果你有什么好的建议 或者疑问 请给我留言吧。</p>", 
            "topic": [
                {
                    "tag": "原生 JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19691834"
                }
            ], 
            "comments": [
                {
                    "userName": "猫于玫瑰i", 
                    "userLink": "https://www.zhihu.com/people/fc66b7c99ae3bd96aad25dc049391175", 
                    "content": "<p>好复杂</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/wangweianger"
}
