{
    "title": "野生cpp程序自学中", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/csp1223", 
        "https://www.zhihu.com/people/guo-quan-2-20", 
        "https://www.zhihu.com/people/jiang-nan-19-38", 
        "https://www.zhihu.com/people/zyx-34-10-45", 
        "https://www.zhihu.com/people/huaibingjian", 
        "https://www.zhihu.com/people/luoweisong", 
        "https://www.zhihu.com/people/yurfly", 
        "https://www.zhihu.com/people/chris-chris-2", 
        "https://www.zhihu.com/people/quan-bo-mian", 
        "https://www.zhihu.com/people/cingo-li", 
        "https://www.zhihu.com/people/liumen", 
        "https://www.zhihu.com/people/shao-lin-xiao-zi-24", 
        "https://www.zhihu.com/people/you-wei-98", 
        "https://www.zhihu.com/people/chen-kai-7-76", 
        "https://www.zhihu.com/people/sun-ming-hao-64", 
        "https://www.zhihu.com/people/reader2018", 
        "https://www.zhihu.com/people/minounou", 
        "https://www.zhihu.com/people/duan-mu-yue-dao", 
        "https://www.zhihu.com/people/hong-san-84", 
        "https://www.zhihu.com/people/ruide", 
        "https://www.zhihu.com/people/long-hong-xing", 
        "https://www.zhihu.com/people/jimleee", 
        "https://www.zhihu.com/people/pu.fuan", 
        "https://www.zhihu.com/people/yan-hui-60", 
        "https://www.zhihu.com/people/cheng-hai-38-83", 
        "https://www.zhihu.com/people/yu-hai-long-22", 
        "https://www.zhihu.com/people/gipong", 
        "https://www.zhihu.com/people/wei-jie-62", 
        "https://www.zhihu.com/people/xiao-yu-22-71-20", 
        "https://www.zhihu.com/people/chobits-63", 
        "https://www.zhihu.com/people/wan-le-bing", 
        "https://www.zhihu.com/people/wang-hui-76-5", 
        "https://www.zhihu.com/people/yang-lu-bing-30", 
        "https://www.zhihu.com/people/bin-28-11", 
        "https://www.zhihu.com/people/bu-zhi-dao-81-39", 
        "https://www.zhihu.com/people/cai-yue-cheng-95", 
        "https://www.zhihu.com/people/sun-shi-jie-52", 
        "https://www.zhihu.com/people/hong-ye-97-62", 
        "https://www.zhihu.com/people/chunhui-jia", 
        "https://www.zhihu.com/people/derek-zhang-30", 
        "https://www.zhihu.com/people/NessajHu", 
        "https://www.zhihu.com/people/zheng-yuan-qing-77", 
        "https://www.zhihu.com/people/ming.kernel", 
        "https://www.zhihu.com/people/luobuda", 
        "https://www.zhihu.com/people/huang-shan-5", 
        "https://www.zhihu.com/people/shuweiqun", 
        "https://www.zhihu.com/people/fish-yuls", 
        "https://www.zhihu.com/people/peng-wen-jian-1", 
        "https://www.zhihu.com/people/chen-zhi-chao-95-15", 
        "https://www.zhihu.com/people/shijiaqi88", 
        "https://www.zhihu.com/people/chengx-35", 
        "https://www.zhihu.com/people/ai-xiang-kui", 
        "https://www.zhihu.com/people/tao-li-81-53", 
        "https://www.zhihu.com/people/xiaofeng-duan", 
        "https://www.zhihu.com/people/zhuo-qiang", 
        "https://www.zhihu.com/people/123456-36-71", 
        "https://www.zhihu.com/people/equal-wan", 
        "https://www.zhihu.com/people/chingliu-yu", 
        "https://www.zhihu.com/people/wu-ba-ge", 
        "https://www.zhihu.com/people/adamcavendish", 
        "https://www.zhihu.com/people/fan-tao-68-23", 
        "https://www.zhihu.com/people/guy428135", 
        "https://www.zhihu.com/people/jiang-ye-15", 
        "https://www.zhihu.com/people/exat500g", 
        "https://www.zhihu.com/people/ronald-xie", 
        "https://www.zhihu.com/people/guo-zhong-ming-26", 
        "https://www.zhihu.com/people/zheng-si-wen", 
        "https://www.zhihu.com/people/invathia-ti", 
        "https://www.zhihu.com/people/ren-wo-xing-86", 
        "https://www.zhihu.com/people/luan-lin-bao", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/zhangkunhn", 
        "https://www.zhihu.com/people/jcyongqin", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/wu-bo-80-71", 
        "https://www.zhihu.com/people/celaox", 
        "https://www.zhihu.com/people/tingjiee", 
        "https://www.zhihu.com/people/AIBottle", 
        "https://www.zhihu.com/people/yang-kan-81", 
        "https://www.zhihu.com/people/feng1o", 
        "https://www.zhihu.com/people/liang-cai-55", 
        "https://www.zhihu.com/people/zeng-yan-jian", 
        "https://www.zhihu.com/people/oceanszhou", 
        "https://www.zhihu.com/people/bai-cao-quan-yu", 
        "https://www.zhihu.com/people/zhang-wei-3-49-41", 
        "https://www.zhihu.com/people/zhang-wei-13-8-26", 
        "https://www.zhihu.com/people/zhang-feng-duan", 
        "https://www.zhihu.com/people/yfaming", 
        "https://www.zhihu.com/people/bailloon", 
        "https://www.zhihu.com/people/Hu_Coco", 
        "https://www.zhihu.com/people/ofucis", 
        "https://www.zhihu.com/people/li-zi-da", 
        "https://www.zhihu.com/people/man-84-39", 
        "https://www.zhihu.com/people/zhu-forrest", 
        "https://www.zhihu.com/people/zhang-jie-29-48", 
        "https://www.zhihu.com/people/zilr", 
        "https://www.zhihu.com/people/yin-peng-yu-25", 
        "https://www.zhihu.com/people/bu-shi-lu-ren-jia", 
        "https://www.zhihu.com/people/shi-qiang-13-16", 
        "https://www.zhihu.com/people/wen-zhi-hong", 
        "https://www.zhihu.com/people/zhang-xiong-46-98", 
        "https://www.zhihu.com/people/chen-lei-dong", 
        "https://www.zhihu.com/people/liu-marvin-33", 
        "https://www.zhihu.com/people/li-yi-ming-9-55", 
        "https://www.zhihu.com/people/zi-yun-40", 
        "https://www.zhihu.com/people/struct-78", 
        "https://www.zhihu.com/people/edidada", 
        "https://www.zhihu.com/people/feng-ge-ren-62", 
        "https://www.zhihu.com/people/qian-tu-51", 
        "https://www.zhihu.com/people/li-yi-42-29", 
        "https://www.zhihu.com/people/liu-yong-tao-90", 
        "https://www.zhihu.com/people/qiao-hai-jun", 
        "https://www.zhihu.com/people/advstock", 
        "https://www.zhihu.com/people/suwei.air", 
        "https://www.zhihu.com/people/xie-meng-qiao", 
        "https://www.zhihu.com/people/zheng-dong-dong-75", 
        "https://www.zhihu.com/people/ATXON", 
        "https://www.zhihu.com/people/fullsail", 
        "https://www.zhihu.com/people/tangfengwuying", 
        "https://www.zhihu.com/people/wang-jun-shan-65", 
        "https://www.zhihu.com/people/mlsinx", 
        "https://www.zhihu.com/people/guesswhathhh", 
        "https://www.zhihu.com/people/rise-worlds", 
        "https://www.zhihu.com/people/liao-xin-65", 
        "https://www.zhihu.com/people/zhangjiang-35", 
        "https://www.zhihu.com/people/zebra17804", 
        "https://www.zhihu.com/people/an-zi-91-34", 
        "https://www.zhihu.com/people/bian-fu-41-16", 
        "https://www.zhihu.com/people/liu-meng-yin-68", 
        "https://www.zhihu.com/people/damo-43", 
        "https://www.zhihu.com/people/supersmallfat", 
        "https://www.zhihu.com/people/Jiantao-Xu", 
        "https://www.zhihu.com/people/xiao-yu-39-48", 
        "https://www.zhihu.com/people/qinghan-lin", 
        "https://www.zhihu.com/people/debug-44", 
        "https://www.zhihu.com/people/chen-hao-nan-42", 
        "https://www.zhihu.com/people/ruan-wen-feng-27", 
        "https://www.zhihu.com/people/si-wang-60-30", 
        "https://www.zhihu.com/people/jiahua-wu", 
        "https://www.zhihu.com/people/zhao-xiao-5", 
        "https://www.zhihu.com/people/shen-yiyang-de-ren-75", 
        "https://www.zhihu.com/people/zhang-nai-ge-33", 
        "https://www.zhihu.com/people/li-yu-long-47", 
        "https://www.zhihu.com/people/dong-tian-mo-mo", 
        "https://www.zhihu.com/people/jyc-1-91", 
        "https://www.zhihu.com/people/hunter-12-98", 
        "https://www.zhihu.com/people/postmic", 
        "https://www.zhihu.com/people/helloworld-88", 
        "https://www.zhihu.com/people/fei-zhu-ai-chi-yu", 
        "https://www.zhihu.com/people/fyibmsd", 
        "https://www.zhihu.com/people/qugeshaminzine", 
        "https://www.zhihu.com/people/michael.destiny", 
        "https://www.zhihu.com/people/a-si-pi-25", 
        "https://www.zhihu.com/people/tang-wen-7-58", 
        "https://www.zhihu.com/people/tan-bin-63-48", 
        "https://www.zhihu.com/people/viscly", 
        "https://www.zhihu.com/people/wtmgd", 
        "https://www.zhihu.com/people/sun-lai-bing", 
        "https://www.zhihu.com/people/yang-xa", 
        "https://www.zhihu.com/people/windyhoo", 
        "https://www.zhihu.com/people/7heaven", 
        "https://www.zhihu.com/people/da-da-18-6-40", 
        "https://www.zhihu.com/people/kai-yuan-ge", 
        "https://www.zhihu.com/people/lian-zhi-wen", 
        "https://www.zhihu.com/people/lc0604", 
        "https://www.zhihu.com/people/jamie-zjm", 
        "https://www.zhihu.com/people/ml-gp-13", 
        "https://www.zhihu.com/people/pan-peter-71-62", 
        "https://www.zhihu.com/people/lenged2016", 
        "https://www.zhihu.com/people/f4nyc", 
        "https://www.zhihu.com/people/tian-qi-yu-bao-62", 
        "https://www.zhihu.com/people/luo-feng-84-73", 
        "https://www.zhihu.com/people/zhml530", 
        "https://www.zhihu.com/people/GammaGo", 
        "https://www.zhihu.com/people/jun-curt", 
        "https://www.zhihu.com/people/wang-zi-jian-19-31", 
        "https://www.zhihu.com/people/iuhux", 
        "https://www.zhihu.com/people/jinyuelong", 
        "https://www.zhihu.com/people/godmaycry", 
        "https://www.zhihu.com/people/chen-fei-22-6", 
        "https://www.zhihu.com/people/qi-liao-yuan", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/kong-fan-fu-38", 
        "https://www.zhihu.com/people/_andy2046", 
        "https://www.zhihu.com/people/macronus", 
        "https://www.zhihu.com/people/liu-yu-31-9", 
        "https://www.zhihu.com/people/buerse", 
        "https://www.zhihu.com/people/yan-jin-tao", 
        "https://www.zhihu.com/people/adam-ji", 
        "https://www.zhihu.com/people/chenhao-light", 
        "https://www.zhihu.com/people/chen-jie-2-15", 
        "https://www.zhihu.com/people/shi-da-tou-95", 
        "https://www.zhihu.com/people/xiao-han-13-60", 
        "https://www.zhihu.com/people/fds-dsfs", 
        "https://www.zhihu.com/people/eta-100a", 
        "https://www.zhihu.com/people/ticktock-47", 
        "https://www.zhihu.com/people/zhang-yi-73-99-96", 
        "https://www.zhihu.com/people/xie-zi-99-47", 
        "https://www.zhihu.com/people/mai-yue", 
        "https://www.zhihu.com/people/liu-wen-yi-81", 
        "https://www.zhihu.com/people/zheng-chuan-jun", 
        "https://www.zhihu.com/people/liu-ling-50-67", 
        "https://www.zhihu.com/people/yubowen_x86", 
        "https://www.zhihu.com/people/wumoyany", 
        "https://www.zhihu.com/people/20tou", 
        "https://www.zhihu.com/people/liu-xiao-yao-12", 
        "https://www.zhihu.com/people/wang-yong-bo-94", 
        "https://www.zhihu.com/people/zhang-ming-feng-91", 
        "https://www.zhihu.com/people/ling-yiwang", 
        "https://www.zhihu.com/people/kyunsiu", 
        "https://www.zhihu.com/people/liu-yan-hua-85", 
        "https://www.zhihu.com/people/shengyinng", 
        "https://www.zhihu.com/people/zhang-yifeng", 
        "https://www.zhihu.com/people/dream-zhou", 
        "https://www.zhihu.com/people/tang-yan-gao-3", 
        "https://www.zhihu.com/people/yu-zhao-yang-87", 
        "https://www.zhihu.com/people/insight-jing", 
        "https://www.zhihu.com/people/lrc-gz", 
        "https://www.zhihu.com/people/xiangguangyan", 
        "https://www.zhihu.com/people/alen-7-63", 
        "https://www.zhihu.com/people/zhang-ming-ping-58", 
        "https://www.zhihu.com/people/xu-de-hua-88", 
        "https://www.zhihu.com/people/huang-li-7-66", 
        "https://www.zhihu.com/people/wang-xin-yao-23", 
        "https://www.zhihu.com/people/donewell", 
        "https://www.zhihu.com/people/xiao-kk-24-12"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/63632123", 
            "userName": "千寻", 
            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
            "upvote": 0, 
            "title": "msvc与递归头文件依赖的bug", 
            "content": "<h2>递归头文件依赖</h2><h2>互相依赖的对象</h2><p>最近看代码的时候，见到如下骨骼精奇的代码，两个类互相引用，却并没有通过指针和引用的方式。</p><p>首先是<code>array.h</code>,里面<code>Array</code>引用<code>Node</code>：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Node</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Array</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Array</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n\n    <span class=\"p\">}</span>\n    <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n    <span class=\"n\">Array</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">_data</span><span class=\"p\">);</span>\n    <span class=\"n\">Node</span> <span class=\"nf\">GetValue</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array.hpp&#34;</span><span class=\"cp\">\n</span></code></pre></div><p>然后是<code>node.h</code>， 里面<code>Node</code>引用<code>Array</code>:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Array</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Node</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Node</span><span class=\"p\">();</span>\n    <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n    <span class=\"n\">Node</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">_data</span><span class=\"p\">);</span>\n    <span class=\"n\">Array</span> <span class=\"nf\">GetArray</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&#34;node.hpp&#34;</span><span class=\"cp\">\n</span></code></pre></div><p>按照常理，我们使用前向声明的类的时候，只能使用前向声明的类的指针或者引用。如果直接传递类对象，同一个翻译单元内找不到这个前向声明类的定义的时候，会编译不通过，提示无法使用不完整的类型。但是下面的代码是可以通过编译并运行的</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">Array</span><span class=\"p\">();</span>\n    <span class=\"n\">temp</span><span class=\"p\">.</span><span class=\"n\">GetValue</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"o\">&lt;&lt;</span><span class=\"s\">&#34;wow&#34;</span><span class=\"o\">&lt;&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>同樣的，下面的代码也是可以通过编译并运行的：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;node.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">Node</span><span class=\"p\">();</span>\n    <span class=\"n\">temp</span><span class=\"p\">.</span><span class=\"n\">GetArray</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"o\">&lt;&lt;</span><span class=\"s\">&#34;wow&#34;</span><span class=\"o\">&lt;&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>互相include的头文件</h2><p>能编译通过的核心就在这两个头文件末尾<code>include</code>的相关文件里，这里我把相关文件的详细内容都贴一下：</p><p><code>node.h</code>包含了<code>node.hpp</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array_node_container.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">Node</span><span class=\"o\">::</span><span class=\"n\">Node</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p><code>node.hpp</code>包含了<code>array_node_container.h</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\"></span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Array</span><span class=\"p\">;</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">ArrayNodeContainer</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">ArrayNodeContainer</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n\n    <span class=\"p\">}</span>\n    <span class=\"n\">Array</span> <span class=\"n\">GetArray</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array_node_container.hpp&#34;</span><span class=\"cp\">\n</span></code></pre></div><p><code>array_node_container.hpp</code>包含了<code>array.h</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">Array</span> <span class=\"n\">ArrayNodeContainer</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">GetArray</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">Array</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><code>array.h</code>依赖于<code>array.hpp</code>， 而<code>array.hpp</code>依赖于<code>array_container.h</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array_container.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">Array</span><span class=\"o\">::</span><span class=\"n\">Array</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">_in_data</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p><code>array_container.h</code>依赖于<code>array_container.hpp</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\"></span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Node</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">ArrayContainer</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">ArrayContainer</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">a</span><span class=\"p\">);</span>\n    <span class=\"n\">Node</span> <span class=\"nf\">GetValue</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">index</span><span class=\"p\">);</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">_Array</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array_container.hpp&#34;</span><span class=\"cp\">\n</span></code></pre></div><p><code>array_container.hpp</code>依赖于<code>node.h</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&#34;node.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">ArrayContainer</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">ArrayContainer</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">_Array</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">Node</span> <span class=\"n\">ArrayContainer</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">GetValue</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">index</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"n\">_Array</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]};</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>上述的<code>hpp</code>文件都是用来定义类内部的模板函数，实现了一定程度上的声明与定义相分离原则。</p><p>另外还有两个简单的<code>cpp</code>文件，<code>array.cpp</code>和<code>node.cpp</code>，基本就是简单实现一下非模板接口。</p><p><code>array.cpp</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"n\">Node</span> <span class=\"n\">Array</span><span class=\"o\">::</span><span class=\"n\">GetValue</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">Node</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><code>node.cpp</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;node.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"n\">Node</span><span class=\"o\">::</span><span class=\"n\">Node</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n\n<span class=\"p\">}</span>\n<span class=\"n\">Array</span> <span class=\"n\">Node</span><span class=\"o\">::</span><span class=\"n\">GetArray</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">Array</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>至此我们跟踪<code>node.h</code>的所有依赖头文件，最终会依赖到自身<code>node.h</code>。</p><ol><li>node.h</li><li>node.hpp</li><li>array_node_container.h</li><li>array_node_container.hpp</li><li>array.h</li><li>array.hpp</li><li>array_container.h</li><li>array_container.hpp</li><li>node.h</li></ol><p>而单独跟踪<code>array.h</code>的依赖路径，也会产生类似的递归依赖：</p><ol><li>array.h</li><li>array.hpp</li><li>array_container.h</li><li>array_container.hpp</li><li>node.h</li><li>node.hpp</li><li>array_node_container.h</li><li>array_node_container.hpp</li><li>array.h</li></ol><h2>头文件展开</h2><p>我们可以通过<code>gcc/clang</code>的<code>-E -P</code>命令来处理这两个<code>cpp</code>文件，来查看最后生成的头文件展开结果。</p><p><code>clang -E -P node.cpp &gt; expand_node.txt</code>的结果太长，我就简单介绍一下最终展开结果中上述头文件正文内容的插入顺序：</p><ol><li>node.h </li><li>array_node_container.h</li><li>array.h</li><li>array_container.h</li><li>array_container.hpp</li><li>array.hpp</li><li>array_node_container.hpp</li><li>node.hpp</li><li>node.cpp</li></ol><p>类似的<code>clang -E -P array.cpp &gt; expand_array.txt</code>的结果如下：</p><ol><li>array.h</li><li>array_container.h</li><li>node.h</li><li>array_node_container.h</li><li>array_node_container.hpp</li><li>node.hpp</li><li>array_container.hpp</li><li>array.hpp</li><li>array.cpp</li></ol><p>之前我们看到了<code>node.h</code>和<code>array.h</code>是互相依赖的，按照常理展开的时候会递归展开，从而导致无限递归爆栈。阻止这个情况发生依赖于<code>#pragma once</code>这个声明， 从而起到了<code>python</code>的<code>import</code>的效果，引入一个头文件的时候会记录这个头文件已经被引入了，后续的引入检查这个标记，如果已经被引入则不做任何操作。除了<code>#pragma once</code>之外，等价的还有形式为<code>#ifndef __H_ARRAY_H__</code>的<code>header guard</code>。</p><h2>手工展开hpp文件</h2><p>之前的代码看上去很完美，用极其诡异的方式构造了互相引用。个人觉得里面的那个<code>hpp</code>文件比较多余，因此动歪脑筋想手动展开所有的<code>hpp</code>文件到<code>h</code>文件里面，结果如下。</p><p><code>array.h</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array_container.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Node</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Array</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Array</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n\n    <span class=\"p\">}</span>\n    <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n    <span class=\"n\">Array</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">_data</span><span class=\"p\">);</span>\n    <span class=\"n\">Node</span> <span class=\"nf\">GetValue</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">Array</span><span class=\"o\">::</span><span class=\"n\">Array</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">_in_data</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p><code>array_container.h</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;node.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Node</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">ArrayContainer</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">ArrayContainer</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">a</span><span class=\"p\">);</span>\n    <span class=\"n\">Node</span> <span class=\"nf\">GetValue</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">index</span><span class=\"p\">);</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">_Array</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">ArrayContainer</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">ArrayContainer</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">_Array</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">Node</span> <span class=\"n\">ArrayContainer</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">GetValue</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">index</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span> <span class=\"n\">_Array</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]</span> <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><code>array_node_container.h</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Array</span><span class=\"p\">;</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">ArrayNodeContainer</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">ArrayNodeContainer</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n\n    <span class=\"p\">}</span>\n    <span class=\"n\">Array</span> <span class=\"n\">GetArray</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">Array</span> <span class=\"n\">ArrayNodeContainer</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">GetArray</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">Array</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><code>node.h</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#pragma once\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;array_node_container.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Array</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Node</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Node</span><span class=\"p\">();</span>\n    <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n    <span class=\"n\">Node</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">_data</span><span class=\"p\">);</span>\n    <span class=\"n\">Array</span> <span class=\"nf\">GetArray</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">Node</span><span class=\"o\">::</span><span class=\"n\">Node</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p>其他的<code>cpp</code>文件都不变，执行<code>clang ./main.cpp ./array.cpp ./node.cpp</code>，是可以正常生成可执行文件并运行的。</p><p>可是<code>msvc</code>他不同意啊。。。。。。。</p><div class=\"highlight\"><pre><code class=\"language-text\">1&gt;array.cpp\n  array_node_container.h(17): error C2027: 使用了未定义类型“Array”\n  array_node_container.h(3): note: 参见“Array”的声明\n  array_node_container.h(18): error C2027: 使用了未定义类型“Array”\n  array_node_container.h(3): note: 参见“Array”的声明\n1&gt;main.cpp\n  array_node_container.h(17): error C2027: 使用了未定义类型“Array”\n  array_node_container.h(3): note: 参见“Array”的声明\n  array_node_container.h(18): error C2027: 使用了未定义类型“Array”\n  array_node_container.h(3): note: 参见“Array”的声明\n1&gt;node.cpp\n  array_container.h(23): error C2027: 使用了未定义类型“Node”\n  array_container.h(4): note: 参见“Node”的声明\n1&gt;正在生成代码...\n1&gt;已完成生成项目“test_recursive.vcxproj”的操作 - 失败。</code></pre></div><p>求各位路过的行行好指导一下如何改展开<code>hpp</code>之后的文件，让项目编译通过吧，卡这快一个礼拜了。</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "Visual C++", 
                    "tagLink": "https://api.zhihu.com/topics/19606058"
                }, 
                {
                    "tag": "编译", 
                    "tagLink": "https://api.zhihu.com/topics/19629384"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57355547", 
            "userName": "千寻", 
            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
            "upvote": 11, 
            "title": "性能优化----快速计算十进制表示的位数", 
            "content": "<h2>性能优化----快速计算十进制表示的位数</h2><p>之前在知乎上看到一篇关于<a href=\"https://zhuanlan.zhihu.com/p/33638344\" class=\"internal\">c++性能优化的文章</a>， 里面的引子是一段程序，目的是用来获得一个<code>uint64_t</code>的十进制表示的位数，最后引出了一些偏底层的微优化方向，例如减少分支预测、缓存miss、内存读写等，但是我最感兴趣的还是这个引子，于是就探究了一下如何最快的获取这个结果。</p><p>在原文中，作者提供了三个版本的代码，<code>v1</code>版本是最<code>vanilla</code>的实现方案，<code>v2</code> 尝试用了人工分支判断，<code>v3</code>则进一步进行了展开.</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">uint32_t</span> <span class=\"nf\">digits10_v1</span><span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">uint32_t</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">do</span> <span class=\"p\">{</span>\n        <span class=\"o\">++</span><span class=\"n\">result</span><span class=\"p\">;</span>\n        <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"n\">uint32_t</span> <span class=\"nf\">digits10_v2</span><span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">uint32_t</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(;;)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">result</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">result</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10000</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">result</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n        <span class=\"c1\">// Skip ahead by 4 orders of magnitude\n</span><span class=\"c1\"></span>        <span class=\"n\">v</span> <span class=\"o\">/=</span> <span class=\"mi\">10000U</span><span class=\"p\">;</span>\n        <span class=\"n\">result</span> <span class=\"o\">+=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">uint32_t</span> <span class=\"nf\">digits10_v3</span><span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000000000000</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// 10^12\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100000000</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// 10^8\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000000</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// 10^6\n</span><span class=\"c1\"></span>                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10000</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n                <span class=\"k\">return</span> <span class=\"mi\">5</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">100000</span><span class=\"p\">);</span> <span class=\"c1\">// 10^5\n</span><span class=\"c1\"></span>            <span class=\"p\">}</span>\n            <span class=\"k\">return</span> <span class=\"mi\">7</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">10000000</span><span class=\"p\">);</span> <span class=\"c1\">// 10^7\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10000000000</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// 10^10\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span> <span class=\"mi\">9</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">1000000000</span><span class=\"p\">);</span> <span class=\"c1\">// 10^9\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"mi\">11</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">100000000000</span><span class=\"p\">);</span> <span class=\"c1\">// 10^11\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"mi\">12</span> <span class=\"o\">+</span> <span class=\"n\">digits10_v3</span><span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">/</span> <span class=\"mi\">1000000000000</span><span class=\"p\">);</span> <span class=\"c1\">// 10^12\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>原作者的评测结果是：</p><blockquote> digits10_v2 比 digits10_v1快了45%, digits10_v3 比digits10_v1快了60%+。<br/> </blockquote><p>然而我自己测试结果却有点不一样，测试平台<code>win server 2016, 8086k  x64 Release</code>, 测试代码见下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">uint64_t</span> <span class=\"n\">max_num</span> <span class=\"o\">=</span> <span class=\"mi\">10000000</span><span class=\"p\">;</span>\n<span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">uint64_t</span><span class=\"o\">&gt;</span> <span class=\"n\">test_cases</span><span class=\"p\">;</span>\n<span class=\"n\">test_cases</span><span class=\"p\">.</span><span class=\"n\">reserve</span><span class=\"p\">(</span><span class=\"n\">max_num</span><span class=\"p\">);</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">random_device</span> <span class=\"n\">rd</span><span class=\"p\">;</span>  <span class=\"c1\">//Will be used to obtain a seed for the random number engine\n</span><span class=\"c1\"></span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mt19937</span> <span class=\"n\">gen</span><span class=\"p\">(</span><span class=\"n\">rd</span><span class=\"p\">());</span> <span class=\"c1\">//Standard mersenne_twister_engine seeded with rd()\n</span><span class=\"c1\"></span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">uniform_int_distribution</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">uint64_t</span><span class=\"o\">&gt;</span> <span class=\"n\">dis</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">numeric_limits</span><span class=\"o\">&lt;</span><span class=\"n\">uint64_t</span><span class=\"o\">&gt;::</span><span class=\"n\">max</span><span class=\"p\">());</span>\n\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">max_num</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">test_cases</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">dis</span><span class=\"p\">(</span><span class=\"n\">gen</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n<span class=\"k\">decltype</span><span class=\"p\">(</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">())</span> <span class=\"n\">start_time</span><span class=\"p\">,</span> <span class=\"n\">end_time</span><span class=\"p\">;</span>\n<span class=\"n\">uint64_t</span> <span class=\"n\">total_value</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"n\">start_time</span> <span class=\"o\">=</span> <span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">max_num</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">total_value</span> <span class=\"o\">+=</span> <span class=\"n\">digits10_v1</span><span class=\"p\">(</span><span class=\"n\">test_cases</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n<span class=\"p\">}</span>\n<span class=\"n\">end_time</span> <span class=\"o\">=</span> <span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;digits10_v1 cost &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end_time</span> <span class=\"o\">-</span> <span class=\"n\">start_time</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34; with total &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">total_value</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"n\">total_value</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"n\">start_time</span> <span class=\"o\">=</span> <span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">max_num</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">total_value</span> <span class=\"o\">+=</span> <span class=\"n\">digits10_v2</span><span class=\"p\">(</span><span class=\"n\">test_cases</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n<span class=\"p\">}</span>\n<span class=\"n\">end_time</span> <span class=\"o\">=</span> <span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;digits10_v2 cost &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end_time</span> <span class=\"o\">-</span> <span class=\"n\">start_time</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34; with total &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">total_value</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"n\">total_value</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"n\">start_time</span> <span class=\"o\">=</span> <span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">max_num</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">total_value</span> <span class=\"o\">+=</span> <span class=\"n\">digits10_v3</span><span class=\"p\">(</span><span class=\"n\">test_cases</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n<span class=\"p\">}</span>\n<span class=\"n\">end_time</span> <span class=\"o\">=</span> <span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;digits10_v3 cost &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end_time</span> <span class=\"o\">-</span> <span class=\"n\">start_time</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34; with total &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">total_value</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"n\">total_value</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n</code></pre></div><blockquote> digits10_v1 cost 198992914 with total 193977097 digits10_v2 cost 85027225 with total 193977097 digits10_v3 cost 108437931 with total 193977097<br/> </blockquote><p><code>v2</code>最快，<code>v3</code>比<code>v2</code>慢一点，个人怀疑<code>v3</code>里过多的<code>if</code>判断导致分支预测错误惩罚太大，为了验证一下这种猜测，我对<code>v3</code>的分支判断顺序更改了一下，新生成了下面的两个函数：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">uint32_t</span> <span class=\"nf\">digits10_v4</span><span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">6</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">7</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">8</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">9</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10000000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100000000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">11</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000000000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">12</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"mi\">12</span> <span class=\"o\">+</span> <span class=\"n\">digits10_v4</span><span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">/</span> <span class=\"mi\">1000000000000</span><span class=\"p\">);</span> <span class=\"c1\">// 10^12\n</span><span class=\"c1\"></span>\n<span class=\"p\">}</span>\n<span class=\"n\">uint32_t</span> <span class=\"nf\">digits10_v5</span><span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">1000000000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">12</span> <span class=\"o\">+</span> <span class=\"n\">digits10_v5</span><span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">/</span> <span class=\"mi\">1000000000000</span><span class=\"p\">);</span> <span class=\"c1\">// 10^12\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">100000000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">12</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">10000000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">11</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">1000000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">100000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">9</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">10000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">8</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">1000000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">7</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">100000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">6</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">10000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这两个case的结果也有点诡异：</p><blockquote> digits10_v4 cost 172406481 with total 193977097 digits10_v5 cost 139159196 with total 193977097<br/> </blockquote><p><code>v4</code>比<code>v3</code>慢这个很容易理解，因为分支判断从上到下，归属于这个分支的$10^n$ 到$10^{n+1}$区间内值也是越来越多，导致走过的<code>if</code>判断也越来越多，带来了更多的分支预测失败的代价。<code>v5</code>把整个判断顺序反转之后，比<code>v4</code>快了一点，但是却比<code>v3</code>慢，这点就很难去解释了，用尽平生所学也找不出所以然，只能黑人问号？</p><p>最搞笑的是上述方法都比下面这段代码慢......</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">uint32_t</span> <span class=\"nf\">digits10_by_log</span><span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">uint32_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">log10</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><blockquote> digits10_by_log cost 78063363 with total 193977097<br/> </blockquote><p>上面做的都是一些微优化，优化效率对于<code>vanilla</code>版本来说，只优化了一半多一点，但是代码可读性上来说已经没得看了。根据我以前参加优化比赛的经验，上层算法的选择远比在非最优算法框架内搞内存读取等微优化重要。而且上面的代码那么多<code>if else</code>，直觉告诉我最优代码肯定不是长这个样子，因此这里需要独辟蹊径，寻找更快的解法。</p><p>根据<code>bing</code>首页的计算结果<code>log10(2^64) = 19.26591972249480</code>，任何一个<code>uint64_t</code>的十进制表示都不会用超过21个字符。一种想法就是预先计算所有的21个符合此规律的值 <code>digits_v1(n) != digits_v1(n+1)</code>，存储为<code>vector</code>，然后对于任意一个输入<code>n</code>，直接二分查找这里的临界索引 <code>distance(upper_bound(vector.begin(), vector.end(), n) , vector.begin()) + 1</code>，即可获得最终的值。</p><p>但是这个算法其实内部还是有很多分支预测， 二分查找，木有办法的啊。我们的目标是，压缩所有分支预测到不能再压缩为止。</p><p>其实上面的算法已经是一个最优算法的雏形了，这里的分支判断在于获取临界值，除了一路比较过去没啥好方法。我们需要一个不怎么需要判断的临界值方案。这里我们把目光投向<code>uint64_t</code>的二进制表示，根据尝试我们知道<code>2^n</code> 到<code>2^{n+1} - 1</code>之间十进制表示的个数的值集合可能为1，也可能为2，但绝对不会大于2。所以我们只需要计算出<code>2^n</code> 到<code>2^{n+1} - 1</code>之间引起十进制表示个数变化的值及对应的十进制表示个数， 并放到一个<code>array&lt;pair&lt;uint64_t, uint32_t&gt;, 64&gt;</code>里供后续查找使用。</p><p>剩下的工作就是如何把一个<code>uint64_t a</code>映射到<code>n</code> ，使得<code>2^n&lt;= a&lt; 2^{n+1}</code>, 就是这个数的二进制表示的最高位1的从右到左位数。 听起来很像位操作奇技淫巧里面的某种，然而翻了翻<code>hacker&#39;s delight</code>并没有找到对应的解法。但是通过网络搜索到了<code>leading zero count</code>这个关键字，意思是二进制表示前导0的个数，<code>63 - lzcnt(a)</code>就是我们所想要找到的<code>n</code>， <code>problem solved</code>。最终最优方案的代码见下:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">uint64_t</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"o\">&gt;</span> <span class=\"n\">generate_delimit</span><span class=\"p\">()</span>\n<span class=\"c1\">// 生成分隔数组\n</span><span class=\"c1\"></span><span class=\"p\">{</span>\n    <span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">uint64_t</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"o\">&gt;</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n    <span class=\"kt\">int</span> <span class=\"n\">_pre</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">uint64_t</span> <span class=\"n\">temp_2</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"n\">uint64_t</span> <span class=\"n\">temp_10</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">64</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">temp_2</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">temp_2</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"n\">uint64_t</span> <span class=\"n\">current_bit</span> <span class=\"o\">=</span> <span class=\"n\">ceil</span><span class=\"p\">(</span><span class=\"n\">log10</span><span class=\"p\">(</span><span class=\"n\">temp_2</span><span class=\"p\">));</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">current_bit</span> <span class=\"o\">&lt;=</span> <span class=\"n\">_pre</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">temp_2</span><span class=\"p\">;</span>\n            <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">_pre</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">temp_10</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">_pre</span><span class=\"p\">;</span>\n            <span class=\"n\">_pre</span> <span class=\"o\">=</span> <span class=\"n\">current_bit</span><span class=\"p\">;</span>\n            <span class=\"n\">temp_10</span> <span class=\"o\">=</span> <span class=\"n\">temp_10</span> <span class=\"o\">*</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"p\">;</span>\n\n<span class=\"p\">};</span>\n<span class=\"n\">uint32_t</span> <span class=\"nf\">digits10_by_lzcnt</span><span class=\"p\">(</span><span class=\"n\">uint64_t</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"k\">static</span> <span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">uint64_t</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"o\">&gt;</span> <span class=\"n\">bit_table</span> <span class=\"o\">=</span> <span class=\"n\">generate_delimit</span><span class=\"p\">();</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"cp\">#ifdef _MSC_VER\n</span><span class=\"cp\"></span>    <span class=\"k\">auto</span> <span class=\"n\">cur_index</span> <span class=\"o\">=</span> <span class=\"mi\">63</span> <span class=\"o\">-</span> <span class=\"n\">__lzcnt64</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">);</span><span class=\"c1\">// 这行指令是msvc特有的 其他平台的名字不同\n</span><span class=\"c1\"></span><span class=\"cp\">#else\n</span><span class=\"cp\"></span>    <span class=\"k\">auto</span> <span class=\"n\">cur_index</span> <span class=\"o\">=</span> <span class=\"mi\">63</span> <span class=\"o\">-</span> <span class=\"n\">__builtin_clzll</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">);</span><span class=\"c1\">// 这行是gcc 特有的\n</span><span class=\"c1\"></span><span class=\"cp\">#endif\n</span><span class=\"cp\"></span>    <span class=\"k\">return</span> <span class=\"n\">bit_table</span><span class=\"p\">[</span><span class=\"n\">cur_index</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;</span> <span class=\"n\">bit_table</span><span class=\"p\">[</span><span class=\"n\">cur_index</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p>同样的数据集，得到的结果见下：</p><blockquote> digits10_by_lzcnt cost 21617940 with total 193977097<br/> </blockquote><p>是<code>vanilla</code>版本的十分之一，除了开头的判断是否是0，没有一次<code>if else</code>，代码浅显易懂，这才叫优化嘛。</p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "优化", 
                    "tagLink": "https://api.zhihu.com/topics/19570512"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "看到log一口老血", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "第一反应就是log呗", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "新泽西管风琴", 
                    "userLink": "https://www.zhihu.com/people/057ab670f1ee28792c2f63151ad63ce1", 
                    "content": "不同的方法对于各个区间的数的效率都不一样。文章里取的是均匀分布，但如果取几何分布，那结果就全都不一样了。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "JohnCocos", 
                    "userLink": "https://www.zhihu.com/people/18fd3b3f772100a3327a275f31f82798", 
                    "content": "<p>我用gcc 8 和 clang 7 跑了一下, 结果还是和comipler有很大关系的</p><p><br></p><p>⋊&gt; /tmp g++ -std=c++17 -march=skylake -O3 string.cpp; and ./a.out                                                                                      </p><p>digits10_v1 cost 244649426 with total 193976441</p><p>digits10_v2 cost 100317966 with total 193976441</p><p>digits10_v3 cost 27210700 with total 193976441</p><p>digits10_by_lzcnt cost 20108773 with total 193976441</p><p><br></p><p>⋊&gt; /tmp clang++ -std=c++17 -march=skylake -stdlib=libc++ -O3 string.cpp; and ./a.out </p><p>digits10_v1 cost 257745615 with total 193980751</p><p>digits10_v2 cost 95781584 with total 193980751</p><p>digits10_v3 cost 133650732 with total 193980751</p><p>digits10_by_lzcnt cost 12968145 with total 193980751</p><p></p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "千寻", 
                            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
                            "content": "clang居然优化了20倍……", 
                            "likes": 0, 
                            "replyToAuthor": "JohnCocos"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55585757", 
            "userName": "千寻", 
            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
            "upvote": 5, 
            "title": "enhanced future task system", 
            "content": "<h2>future介绍</h2><p>在多线程环境下，我们经常需要同时启动多个任务。有些任务是比较耗时，而且我们并不急于获得其结果。对于这些任务，我们可以使用<code>std::future</code>和<code>std::async</code>来封装其异步执行流程。通过<code>std::async</code>来注册异步任务，然后返回一个该异步结果的句柄<code>std::future</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span> <span class=\"o\">&lt;</span> <span class=\"kt\">double</span> <span class=\"o\">&gt;</span> <span class=\"n\">result_future</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">async</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">);</span>\n</code></pre></div><p>当我们需要得到这个异步过程的结果时，我们可以显示的请求。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">double</span> <span class=\"n\">result</span><span class=\"o\">=</span><span class=\"n\">result_future</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n</code></pre></div><p>如果该异步过程已经执行完，则可以直接获得结果；如果还未执行，则当前线程被阻塞，直到执行完成。</p><p>在后文中，我们将分为两个部分：</p><ul><li> 异步过程的执行，即处理<code>std::async</code>封装后的任务调度；<br/> </li><li> 异步过程的生成，即处理<code>future=async()</code>中异步过程的注册和结果句柄的生成；<br/> </li><li> 异步过程的串联，即处理<code>future=future.then(async())</code>中异步过程的序列化。<br/> </li></ul><h2>异步过程的执行</h2><h2>基本执行结构</h2><p>首先我们考虑无返回值、无参数的异步过程的执行。在这种情况下，最直接的处理方案就是利用一个队列来存储提交的异步任务，同时建立一个线程池来消费这个任务队列。为此，我们需要实现两个部分：多线程的任务队列，以及任务的提交和请求。</p><p>对于多线程的任务队列，可以参考下面代码</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">notification_queue</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">queue</span><span class=\"o\">&lt;</span><span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"p\">()</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">_q</span><span class=\"p\">;</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">_done</span><span class=\"p\">{</span> <span class=\"nb\">false</span> <span class=\"p\">};</span>\n    <span class=\"n\">mutex</span> <span class=\"n\">_mutex</span><span class=\"p\">;</span>\n    <span class=\"n\">condition_variable</span> <span class=\"n\">_ready</span><span class=\"p\">;</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">void</span> <span class=\"n\">done</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">{</span> <span class=\"n\">_mutex</span> <span class=\"p\">};</span>\n            <span class=\"n\">_done</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">_ready</span><span class=\"p\">.</span><span class=\"n\">notify_all</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">try_pop</span><span class=\"p\">(</span><span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"p\">()</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">unique_lock</span><span class=\"o\">&lt;</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">{</span> <span class=\"n\">_mutex</span> <span class=\"p\">};</span>\n        <span class=\"n\">_ready</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"p\">]()</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"o\">!</span><span class=\"n\">_q</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">()</span><span class=\"o\">||</span><span class=\"n\">_done</span><span class=\"p\">;</span>\n        <span class=\"p\">});</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">_q</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">()</span><span class=\"o\">||</span><span class=\"n\">done</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">_q</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">());</span>\n        <span class=\"n\">_q</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">();</span>\n        <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"o\">&gt;</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">try_push</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">{</span> <span class=\"n\">_mutex</span><span class=\"p\">,</span><span class=\"n\">try_to_lock</span> <span class=\"p\">};</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">lock</span><span class=\"o\">||</span><span class=\"n\">done</span><span class=\"p\">)</span>\n            <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"n\">_q</span><span class=\"p\">.</span><span class=\"n\">emplace_back</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">_ready</span><span class=\"p\">.</span><span class=\"n\">notify_one</span><span class=\"p\">();</span>\n        <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n<span class=\"p\">};</span>\n</code></pre></div><p>上述代码与一般的多线程队列的不同之处在于增加了<code>done</code>这个<code>bool</code>变量，用来停止任务的提交和请求。其实更好的多线程任务队列实现应该以<code>std::shared_ptr</code>作为返回值，以防止内存分配时异常所导致的数据不一致。当前文档只是为了做概念性说明作用，因此以最简实现作为展示。</p><p>在此多线程队列的支持下，初步的线程池系统可以有如下实现：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">task_system</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"n\">_count</span><span class=\"p\">{</span> <span class=\"kr\">thread</span><span class=\"o\">::</span><span class=\"n\">hardware_concurrency</span><span class=\"p\">()</span> <span class=\"p\">};</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kr\">thread</span><span class=\"o\">&gt;</span> <span class=\"n\">_threads</span><span class=\"p\">;</span>\n    <span class=\"n\">notification_queue</span> <span class=\"n\">_q</span><span class=\"p\">;</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">_done</span><span class=\"p\">{</span><span class=\"nb\">false</span><span class=\"p\">};</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">done</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"p\">()</span><span class=\"o\">&gt;</span> <span class=\"n\">f</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">_q</span><span class=\"p\">.</span><span class=\"n\">try_pop</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span>\n            <span class=\"p\">{</span>\n                <span class=\"n\">this_thread</span><span class=\"p\">.</span><span class=\"n\">yield</span><span class=\"p\">();</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">else</span>\n            <span class=\"p\">{</span>\n                <span class=\"n\">f</span><span class=\"p\">();</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">task_system</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"n\">_count</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">n</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">_threads</span><span class=\"p\">.</span><span class=\"n\">emplace_back</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]</span> <span class=\"p\">{</span> <span class=\"n\">run</span><span class=\"p\">();</span> <span class=\"p\">});</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"o\">~</span><span class=\"n\">task_system</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">_done</span><span class=\"o\">=</span><span class=\"nb\">true</span><span class=\"p\">;</span>\n        <span class=\"n\">_q</span><span class=\"p\">.</span><span class=\"n\">done</span><span class=\"p\">();</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span><span class=\"o\">&amp;</span> <span class=\"nl\">e</span> <span class=\"p\">:</span> <span class=\"n\">_threads</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"o\">&gt;</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">async_</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">_q</span><span class=\"p\">.</span><span class=\"n\">try_push</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">done</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">_done</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>上述代码虽然实现了一个简单的线程池，但是在效率上是有问题的。主要的原因就是所有的工作线程都在争夺任务队列的控制权，产生了<code>contention</code>。为了缓解<code>contention</code>现象，可以从以下两个方面来入手：</p><ul><li> 显式的以待头节点的链表来实现队列，从而使得任务的提交和请求所需要的锁分开；<br/> </li><li> 为每一个线程分配一个专有的任务队列，同时允许线程向其他任务队列请求任务，即 <code>work_steal</code>。<br/> </li></ul><h2>良构锁队列</h2><p>所谓良构锁队列，就是尽可能的减少不必要的锁占用时间。因此，我们采取链表来作为良构锁队列的底层数据结构，其数据结构如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">notification_queue</span>\n<span class=\"p\">{</span>\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"k\">struct</span> <span class=\"n\">node</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">data</span><span class=\"p\">;</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unique_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">node</span><span class=\"o\">&gt;</span> <span class=\"n\">next</span><span class=\"p\">;</span>\n    <span class=\"p\">};</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span> <span class=\"n\">head_mutex</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unique_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">node</span><span class=\"o\">&gt;</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span> <span class=\"n\">tail_mutex</span><span class=\"p\">;</span>\n    <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">tail</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里我们存储了链表的头节点和尾节点，同时为头节点和尾节点添加相应的锁。同时我们将链表初始化为有一个头节点的链表：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">notification_queue</span><span class=\"p\">()</span> <span class=\"o\">:</span><span class=\"n\">head</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"n\">node</span><span class=\"p\">),</span><span class=\"n\">tail</span><span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">())</span>\n<span class=\"p\">{</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p>此外，在此链表中加入一个头节点，以减少<code>pop</code>操作对于尾节点锁的争用。对于<code>push</code>操作来说，实现是很直白的，因为这个过程只涉及到了尾节点的锁。唯一需要注意的一点是在获得锁之前就通过<code>make_shared</code>分配好内存空间，以防止在锁的作用域内抛出异常，从而导致数据不一致。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"p\">(</span><span class=\"n\">T</span> <span class=\"n\">new_value</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">new_data</span><span class=\"p\">(</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">make_shared</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">new_value</span><span class=\"p\">)));</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unique_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">node</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"n\">node</span><span class=\"p\">);</span>\n    <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"k\">const</span> <span class=\"n\">new_tail</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">tail_lock</span><span class=\"p\">(</span><span class=\"n\">tail_mutex</span><span class=\"p\">);</span>\n    <span class=\"n\">tail</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">new_data</span><span class=\"p\">;</span>\n    <span class=\"n\">tail</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n    <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">new_tail</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>此时的<code>pop</code>操作则需要小心：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"nf\">get_tail</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">tail_lock</span><span class=\"p\">(</span><span class=\"n\">tail_mutex</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">tail</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"kt\">bool</span> <span class=\"nf\">try_pop</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;</span> <span class=\"n\">result</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">head_lock</span><span class=\"p\">(</span><span class=\"n\">head_mutex</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">get_tail</span><span class=\"p\">())</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unique_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">node</span><span class=\"o\">&gt;</span> <span class=\"n\">old_head</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">);</span>\n    <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">old_head</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">);</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">old_head</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在<code>try_pop</code>的过程中，我们首先判断当前链表是否为空，这里的<code>get_tail</code>必须放在<code>head_lock</code>之后。否则的话：我们获得<code>head</code>时，可能其他线程已经多次进行了<code>try_pop</code>和<code>push</code>。从而导致<code>head</code>获得时，队列可能已经为空，而之前获得的尾节点所指向的并非当前尾节点。在这种情况下<code>head</code>与 <code>tail</code>的比较失败，返回<code>head</code>，从而导致错误。</p><h2>work_steal线程池</h2><p><code>work_steal</code>的实现比较直白。首先我们修改其数据结构为:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">task_system</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"n\">_count</span><span class=\"p\">{</span> <span class=\"kr\">thread</span><span class=\"o\">::</span><span class=\"n\">hardware_concurrency</span><span class=\"p\">()</span> <span class=\"p\">};</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kr\">thread</span><span class=\"o\">&gt;</span> <span class=\"n\">_threads</span><span class=\"p\">;</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">notification_queue</span><span class=\"o\">&gt;</span> <span class=\"n\">_q</span><span class=\"p\">{</span> <span class=\"n\">_count</span> <span class=\"p\">};</span>\n    <span class=\"n\">atomic</span><span class=\"o\">&lt;</span><span class=\"kt\">unsigned</span><span class=\"o\">&gt;</span> <span class=\"n\">_index</span><span class=\"p\">{</span> <span class=\"mi\">0</span> <span class=\"p\">};</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">_done</span><span class=\"p\">{</span> <span class=\"nb\">false</span> <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>对于每一个逻辑执行单元，我们都分配一个专有任务队列。提交新任务时，我们直接采取轮转法来平衡负载，用<code>index</code>自增来实现：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">async_</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">_index</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"n\">_count</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">n</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">_q</span><span class=\"p\">[(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">_count</span><span class=\"p\">].</span><span class=\"n\">try_push</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)))</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">_q</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">%</span> <span class=\"n\">_count</span><span class=\"p\">].</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>而对于<code>run</code>函数，我们添加一个参数来指明该线程所对应的专有任务队列：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"p\">()</span><span class=\"o\">&gt;</span> <span class=\"n\">f</span><span class=\"p\">;</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"n\">_count</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">n</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">_q</span><span class=\"p\">[(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">_count</span><span class=\"p\">].</span><span class=\"n\">try_pop</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span>\n            <span class=\"p\">{</span>\n                <span class=\"k\">break</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">f</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">_q</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">try_pop</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">f</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>同时，线程池的构造函数和析构函数也要做相应的修改,以实现RAII：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">task_system</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"n\">_count</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">n</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">_threads</span><span class=\"p\">.</span><span class=\"n\">emplace_back</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">]</span> <span class=\"p\">{</span> <span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"o\">~</span><span class=\"n\">task_system</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span><span class=\"o\">&amp;</span> <span class=\"nl\">e</span> <span class=\"p\">:</span> <span class=\"n\">_q</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">done</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span><span class=\"o\">&amp;</span> <span class=\"nl\">e</span> <span class=\"p\">:</span> <span class=\"n\">_threads</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>至此，一个带<code>work_steal</code>的线程池就完成了</p><h2>异步过程的生成</h2><h2>返回值保存</h2><p>现有的代码处理的只是<code>function&lt;void()&gt;</code>类型的任务。对于普通函数来说，函数签名则是<code>function&lt;R(Args...)&gt;</code>的。但是异步提交任务时其参数列表就已经确定，需要处理的只是返回值，即<code>function&lt;R()&gt;</code>。为此，我们可以定义一个<code>shared_base</code>，来存储返回值相关信息。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">shared_base</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span> <span class=\"n\">_r</span><span class=\"p\">;</span> \n    <span class=\"n\">mutex</span> <span class=\"n\">_mutex</span><span class=\"p\">;</span>\n    <span class=\"n\">condition_variable</span> <span class=\"n\">_ready</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>这里的<code>optional&lt;R&gt; _r</code>用来存储异步过程的执行结果。</p><p>下面就是这个类所附带的几个函数：虚析构函数、<code>set</code>、<code>get</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">shared_base</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n<span class=\"kt\">void</span> <span class=\"n\">set</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">{</span> <span class=\"n\">_mutex</span> <span class=\"p\">};</span>\n        <span class=\"n\">_r</span><span class=\"o\">=</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">_ready</span><span class=\"p\">.</span><span class=\"n\">notify_all</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n<span class=\"k\">const</span> <span class=\"n\">R</span><span class=\"o\">&amp;</span> <span class=\"n\">get</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">{</span> <span class=\"n\">_mutex</span> <span class=\"p\">};</span>\n    <span class=\"n\">_ready</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"p\">]()</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_r</span><span class=\"p\">);</span>\n    <span class=\"p\">});</span>\n    <span class=\"k\">return</span> <span class=\"n\">_r</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这样，我们就可以在异步调用中调用<code>set</code>函数来填充返回值，同时在<code>future</code>中调用<code>get</code>来等待返回值。为了在等待线程和工作线程中同时操作这个<code>shared_base</code>对象，我们需要以 <code>shared_ptr</code>的形式来保存这个对象的指针。自此，<code>future</code>所需要的元素都已具备，定义<code>future</code>来保存异步过程的结果句柄，其简单实现如下所示：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">future</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span> <span class=\"n\">_p</span><span class=\"p\">;</span>\n    <span class=\"k\">explicit</span> <span class=\"nf\">future</span><span class=\"p\">(</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">_p</span><span class=\"p\">(</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n\n    <span class=\"p\">}</span>\n    <span class=\"n\">future</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"k\">default</span><span class=\"p\">;</span>\n    <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"o\">&gt;</span>\n    <span class=\"k\">const</span> <span class=\"n\">R</span><span class=\"o\">&amp;</span> <span class=\"n\">get</span><span class=\"p\">()</span> <span class=\"k\">const</span> \n    <span class=\"p\">{</span> \n        <span class=\"k\">return</span> <span class=\"n\">_p</span><span class=\"o\">-&gt;</span><span class=\"n\">get</span><span class=\"p\">();</span> \n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>这里的<code>R</code>就是<code>shared_base&lt;T&gt;</code>类型。</p><h2>异步过程封装</h2><p>由于线程池中只支持<code>function&lt;void()&gt;</code>类型的调用，为此我们需要在<code>shared_base</code>的基础上进一步做封装。</p><p>首先，我们将返回值封装起来：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">Args</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">shared</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"o\">&gt;</span> <span class=\"o\">:</span> <span class=\"n\">shared_base</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"o\">&gt;</span> <span class=\"n\">_f</span><span class=\"p\">;</span>\n    <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"o\">&gt;</span>\n    <span class=\"n\">shared</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">_f</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span> <span class=\"p\">{}</span>\n    <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">A</span><span class=\"o\">&gt;</span>\n    <span class=\"kt\">void</span> <span class=\"k\">operator</span><span class=\"p\">()(</span><span class=\"n\">A</span><span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"n\">_f</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)...));</span>\n        <span class=\"n\">_f</span> <span class=\"o\">=</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>当前的<code>shared</code>结构既保存了返回值相关信息，还保留了函数的相关信息，即当前类型是一个可调用对象。在这个对象之上,我们再定义一个<code>packaged_task</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"p\">...</span><span class=\"n\">Args</span> <span class=\"o\">&gt;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">packaged_task</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"o\">&gt;</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">weak_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">shared</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">_p</span><span class=\"p\">;</span>\n    <span class=\"k\">explicit</span> <span class=\"nf\">packaged_task</span><span class=\"p\">(</span><span class=\"n\">weak_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">shared</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">_p</span><span class=\"p\">(</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">))</span> <span class=\"p\">{}</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">packaged_task</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"k\">default</span><span class=\"p\">;</span>\n    <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">A</span><span class=\"o\">&gt;</span>\n    <span class=\"kt\">void</span> <span class=\"k\">operator</span><span class=\"p\">()(</span><span class=\"n\">A</span><span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"k\">const</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">auto</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">_p</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">();</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">)(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)...);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>这个<code>packaged_task</code>中存储了一个<code>weak_ptr&lt;shared&lt;R(Args...)&gt;&gt;</code>，用来保留所有的调用信息和返回值信息。至于这里为什么用<code>weak_ptr</code>，可能是为了处理某些特殊情况：例如异步结果直接被抛弃，此时则没有必要去执行该异步过程。即异步过程的所有者是其返回值的所有者，而不是过程本身。</p><p>至此，我们把异步结果的存储和异步过程的存储都解决了，剩下的问题就是：我们如何根据一个可调用对象生成<code>future</code>和<code>packaged_task</code>。为此，我们定义一个新的中间函数<code>package</code>来执行次任务：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">S</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"o\">&gt;</span>\n<span class=\"k\">auto</span> <span class=\"n\">package</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">pair</span><span class=\"o\">&lt;</span><span class=\"n\">packaged_task</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"n\">result_of_t_</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">make_shared</span><span class=\"o\">&lt;</span><span class=\"n\">shared</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n    <span class=\"k\">return</span> <span class=\"nf\">make_pair</span><span class=\"p\">(</span><span class=\"n\">packaged_task</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">),</span> <span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"n\">result_of_t_</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"p\">...</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span>\n<span class=\"k\">auto</span> <span class=\"n\">async</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">Args</span><span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">using</span> <span class=\"n\">result_type</span> <span class=\"o\">=</span> <span class=\"n\">result_of_t</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n    <span class=\"k\">using</span> <span class=\"n\">packaged_type</span> <span class=\"o\">=</span> <span class=\"n\">packaged_task</span><span class=\"o\">&lt;</span><span class=\"n\">result_type</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">pack</span> <span class=\"o\">=</span> <span class=\"n\">package</span><span class=\"o\">&lt;</span><span class=\"n\">result_type</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">),</span> <span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)...));</span>\n    <span class=\"n\">_system</span><span class=\"p\">.</span><span class=\"n\">async_</span><span class=\"p\">(</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">get</span><span class=\"o\">&lt;</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pack</span><span class=\"p\">)));</span>\n    <span class=\"k\">return</span> <span class=\"n\">get</span><span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pack</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这个<code>package</code>函数做了两件事：</p><ul><li> 根据所提供的函数参数<code>f</code>来生成一个保存了返回值和参数<code>f</code>的<code>shared&lt;S&gt;</code>，用<code>shared_ptr p</code>来控制其所有权。这里利用了<code>result_of_t</code>这个<code>type_traits</code>，其作用是根据函数签名返回该函数的返回值类型。<br/> </li><li> 根据上一步生成的<code>shared_ptr p</code>构造<code>packaged_task</code>和<code>future</code>对象。这里利用了两个自动类型转换：一个是由<code>shared_ptr&lt;shared&lt;result_type()&gt;&gt;</code>构造出一个<code>weak_ptr &lt;shared&lt;result_type()&gt;&gt;</code>，另外一个就是根据<code>shared_ptr&lt;shared&lt;result_type()&gt;&gt;</code> 构造出一个<code>shared_ptr&lt;shared_base&lt;result_type&gt;&gt;</code>。在自动类型转换之后，再调用这两个对象相应的构造函数。<br/> </li></ul><p>同时，在<code>async</code>中，主要包括四个过程。</p><ul><li> 通过<code>bind</code>将函数<code>f</code>与其相应的参数<code>args</code>绑定起来，生成了一个<code>function&lt;result_type()</code>类型的可调用对象。<br/> </li><li> 将上一步构造出的临时可调用对象作为<code>package</code>的参数，生成了包含<code>package_task&lt;result_type()&gt;</code> 和<code>future&lt;result_type&gt;</code>的<code>pair pack</code>。<br/> </li><li> 这个<code>pair</code>中所包含的<code>package_task</code>在当作一个可调用对象时，其函数签名为<code>void()</code>，因此可以直接向<code>_system</code>提交异步任务，这里的<code>_system</code>的类型就是前一节中所提到的<code>work_steal</code> 线程池任务系统。<br/> </li><li> 最后，将<code>pair</code>中的<code>future&lt;result_type&gt;</code>返回，作为结果句柄。<br/> </li></ul><p>自此，从可调用对象构造出了对应的异步执行对象<code>packaged_task</code>和<code>future</code>。这个<code>packaged_task</code>被提交到了系统的任务处理系统<code>_system</code>中，而<code>future</code>则返回到用户线程。</p><h2>异步过程的串联</h2><h2>单后继串联</h2><p>在处理多个异步任务的系统设计中，异步任务的串联（即任务之间的依赖)是很重要的一个特性。设想一下场景中，我们需要依次调用两个函数：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span> <span class=\"o\">&lt;</span> <span class=\"kt\">double</span> <span class=\"o\">&gt;</span> <span class=\"n\">result_future_1</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">async</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">);</span>\n<span class=\"kt\">double</span> <span class=\"n\">result_1</span><span class=\"o\">=</span><span class=\"n\">result_future_1</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span> <span class=\"o\">&lt;</span> <span class=\"kt\">double</span> <span class=\"o\">&gt;</span> <span class=\"n\">result_future_2</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">async</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"n\">result_1</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">);</span>\n<span class=\"kt\">double</span> <span class=\"n\">result_2</span><span class=\"o\">=</span><span class=\"n\">result_future_2</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n</code></pre></div><p>在上述实例中，<code>result_2</code>依赖于<code>result_1</code>。因此执行时我们必须显式的调用<code>future.get()</code>来获得<code>result_1</code>，然后才能提交第二个异步任务。这种显示的同步在依赖路径变长时就会显得非常繁杂，而且引入了多次同步的需求。理想情况下，我们想要的只是最后的执行结果，只需要调用一次<code>future.get()</code>就可以。简化的代码可以变成这样：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span> <span class=\"o\">&lt;</span> <span class=\"kt\">double</span> <span class=\"o\">&gt;</span> <span class=\"n\">result_future_1</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">async</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">);</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span> <span class=\"o\">&lt;</span> <span class=\"kt\">double</span> <span class=\"o\">&gt;</span> <span class=\"n\">result_future_2</span> <span class=\"o\">=</span> <span class=\"n\">result_future_1</span><span class=\"p\">.</span><span class=\"n\">then</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"n\">_1</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">));</span>\n<span class=\"kt\">double</span> <span class=\"n\">result_2</span><span class=\"o\">=</span><span class=\"n\">result_future_2</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n</code></pre></div><p>同时也可以变成这样</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span> <span class=\"o\">&lt;</span> <span class=\"kt\">double</span> <span class=\"o\">&gt;</span> <span class=\"n\">result_future_1</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">async</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">).</span><span class=\"n\">then</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"n\">_1</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">));</span>\n<span class=\"kt\">double</span> <span class=\"n\">result_1</span><span class=\"o\">=</span><span class=\"n\">result_future_1</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n</code></pre></div><p>但是<code>C++11</code>中的<code>std::future</code>并不支持串联，所以我们就不得不去造轮子。现在我们就来实现<code>future.then()</code>。</p><p>为了支持<code>then</code>操作，我们必须在<code>future</code>中保存后续的执行路径。我们来研究<code>future</code>中对<code>then</code>的处理：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"o\">&gt;</span>\n<span class=\"k\">auto</span> <span class=\"n\">then</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">pack</span> <span class=\"o\">=</span> <span class=\"n\">package</span><span class=\"o\">&lt;</span><span class=\"n\">result_of_t</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">([</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">_p</span><span class=\"p\">,</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)]()</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">_r</span><span class=\"p\">.</span><span class=\"n\">back</span><span class=\"p\">());</span>\n    <span class=\"p\">});</span>\n    <span class=\"n\">_p</span><span class=\"o\">-&gt;</span><span class=\"n\">then</span><span class=\"p\">(</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">pack</span><span class=\"p\">.</span><span class=\"n\">first</span><span class=\"p\">));</span>\n    <span class=\"k\">return</span> <span class=\"n\">pack</span><span class=\"p\">.</span><span class=\"n\">second</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的<code>then</code>操作每次生成一个新的<code>pair&lt;packaged_task,future&gt;</code>。其中的<code>packaged_task</code>部分捕获了调用者<code>future</code>的<code>shared_ptr&lt;shared_base&gt;</code>成员<code>_p</code>,同时这个<code>packaged_task</code>注册到了<code>_p._then</code>队列中。<code>pair</code>中的<code>future</code>则保留了新的返回值信息。现在剩下的任务就是实现<code>shared_base.then</code>了。</p><p>为此我们首先修改<code>share_base</code>，增加一个保存后续任务的<code>optional</code>，同样以<code>vector</code>的形式来实现。此时<code>shared_base&lt;R&gt;</code>的数据成员如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span> <span class=\"n\">_r</span><span class=\"p\">;</span> <span class=\"c1\">// optional\n</span><span class=\"c1\"></span><span class=\"n\">mutex</span> <span class=\"n\">_mutex</span><span class=\"p\">;</span>\n<span class=\"n\">condition_variable</span> <span class=\"n\">_ready</span><span class=\"p\">;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"p\">()</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">_then</span><span class=\"p\">;</span>\n</code></pre></div><p>这个<code>_then</code>成员就是用来保存后续的执行路径的。其实也不算路径，因为只保留路径中的直接子节点，可以当作路径中的<code>next</code>指针。</p><p>而<code>then</code>操作就比较直接了：</p><div class=\"highlight\"><pre><code class=\"language-text\">template &lt;typename F&gt;\nvoid then(F&amp;&amp; f)\n{\n    bool resolved{ false };\n    {\n        lock_guard&lt;mutex&gt; lock{ _mutex };\n        if (!_r)\n        {\n            _then=forward&lt;F&gt;(f);\n        }\n        else\n        {\n            resolved = true;\n        }\n    }\n    if (resolved)\n    {\n        _system.async_(forward&lt;F&gt;(f));\n    }\n}</code></pre></div><p>在执行<code>then</code>操作时，首先判断是否之前的异步任务已经执行完全。这个判断是通过<code>_r</code>来执行的，因为<code>optional</code>有一个到<code>bool</code>的自动类型转换。</p><p>如果之前的异步任务已执行，则提交当前任务到任务调度系统；否则将当前任务挂载在<code>next</code>下，即<code>_then</code>。</p><p>同时，<code>set</code>函数也要做一些修改：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"p\">()</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">then</span><span class=\"p\">;</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">{</span> <span class=\"n\">_mutex</span> <span class=\"p\">};</span>\n        <span class=\"n\">_r</span><span class=\"o\">=</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">);</span>\n        <span class=\"n\">swap</span><span class=\"p\">(</span><span class=\"n\">_then</span><span class=\"p\">,</span> <span class=\"n\">then</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">_ready</span><span class=\"p\">.</span><span class=\"n\">notify_all</span><span class=\"p\">();</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">then</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">_system</span><span class=\"p\">.</span><span class=\"n\">async_</span><span class=\"p\">(</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">then</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">()));</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这段代码也是比较直接：在当前<code>shared_base</code>获得了初始值之后，再去执行下一个异步过程。至于这里为什么用<code>swap</code>操作，目前还不是很清楚，需要测试一下才能知道这里的<code>swap</code>到底发生了什么。</p><h2>多后继串联</h2><p>之前的代码处理的只是包含了一个后续任务依赖的情况，但是当我们谈到依赖的时候，我们所提到的都是依赖树，而不是依赖序列。这种依赖树的情况，一个<code>packaged_task</code>可能有多个任务都在等待其完成。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span> <span class=\"o\">&lt;</span> <span class=\"kt\">double</span> <span class=\"o\">&gt;</span> <span class=\"n\">result_future_1</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">async</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">);</span>\n<span class=\"kt\">double</span> <span class=\"n\">result_1</span><span class=\"o\">=</span><span class=\"n\">result_future_1</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span> <span class=\"o\">&lt;</span> <span class=\"kt\">double</span> <span class=\"o\">&gt;</span> <span class=\"n\">result_future_2</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">async</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"n\">result_1</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">);</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span> <span class=\"o\">&lt;</span> <span class=\"kt\">double</span> <span class=\"o\">&gt;</span> <span class=\"n\">result_future_3</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">async</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">power</span><span class=\"p\">,</span><span class=\"n\">result_1</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">);</span>\n<span class=\"kt\">double</span> <span class=\"n\">result_2</span><span class=\"o\">=</span><span class=\"n\">result_future_2</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n<span class=\"kt\">double</span> <span class=\"n\">result_3</span><span class=\"o\">=</span><span class=\"n\">result_future_3</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n</code></pre></div><p>为了支持这种多后继的操作，我们需要对<code>shared_base</code>做修改。</p><p>首先，<code>_then</code>成员不再是一个<code>optional&lt;function&lt;void()&gt;&gt;</code>，而是一个<code>vector&lt;function&lt;void&gt;&gt;</code>，因为我们所存储的后续任务不再仅限于一个。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span> <span class=\"n\">_r</span><span class=\"p\">;</span> <span class=\"c1\">// optional\n</span><span class=\"c1\"></span><span class=\"n\">mutex</span> <span class=\"n\">_mutex</span><span class=\"p\">;</span>\n<span class=\"n\">condition_variable</span> <span class=\"n\">_ready</span><span class=\"p\">;</span>\n<span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"p\">()</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">_then</span><span class=\"p\">;</span>\n</code></pre></div><p>同时，我们也要修改对应的<code>then</code>和<code>set</code>的代码实现，从<code>optional</code>转换到<code>vector</code>上来。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">F</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">then</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">resolved</span><span class=\"p\">{</span> <span class=\"nb\">false</span> <span class=\"p\">};</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">{</span> <span class=\"n\">_mutex</span> <span class=\"p\">};</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">_r</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">_then</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">resolved</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">resolved</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">_system</span><span class=\"p\">.</span><span class=\"n\">async_</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"o\">:::</span><span class=\"n\">c</span><span class=\"o\">++</span>\n<span class=\"kt\">void</span> <span class=\"n\">set</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"p\">()</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">then</span><span class=\"p\">;</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">{</span> <span class=\"n\">_mutex</span> <span class=\"p\">};</span>\n        <span class=\"n\">_r</span><span class=\"o\">=</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">);</span>\n        <span class=\"n\">swap</span><span class=\"p\">(</span><span class=\"n\">_then</span><span class=\"p\">,</span> <span class=\"n\">then</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">_ready</span><span class=\"p\">.</span><span class=\"n\">notify_all</span><span class=\"p\">();</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"k\">auto</span><span class=\"o\">&amp;</span> <span class=\"nl\">f</span><span class=\"p\">:</span><span class=\"n\">then</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">_system</span><span class=\"p\">.</span><span class=\"n\">async_</span><span class=\"p\">(</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在经过这种修改之后，之前的示例代码可以这样写：</p><div class=\"highlight\"><pre><code class=\"language-text\">:::c++\nstd::future &lt; double &gt; result_future_1 = std::async(std::power,2, 100);\nstd::future &lt; double &gt; result_future_2 = result_future_1.then(bind(std::power,_1, 10));\nstd::future &lt; double &gt; result_future_3 = result_future_1.then(bind(std::power,_1, 10));\ndouble result_2=result_future_2.get();\ndouble result_3=result_future_3.get();</code></pre></div><h2>多前驱串联</h2><h2>wait_all 串联</h2><p>对于<code>wait_for_all</code>形式，一个任务的启动需要多个任务都已完成。我们需要等待所有过程的执行完全，所以需要显示的等待。为了支持这种显示的同步操作，我们继续修改之前的<code>shared_base</code>和<code>future</code>，都加入显示的等待<code>wait</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">shared_base</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;::</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">{</span> <span class=\"n\">_mutex</span> <span class=\"p\">};</span>\n    <span class=\"n\">_ready</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"p\">]()</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">!</span><span class=\"n\">_r</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">();</span>\n    <span class=\"p\">});</span>\n<span class=\"p\">}</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;::</span><span class=\"n\">wait</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">_p</span><span class=\"o\">-&gt;</span><span class=\"n\">wait</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这样我们可以以一下形式来实现<code>wait_for_all</code>：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">F1</span><span class=\"p\">,</span> <span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">Fs</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">wait_for_all</span><span class=\"p\">(</span><span class=\"n\">F1</span><span class=\"o\">&amp;</span> <span class=\"n\">f1</span><span class=\"p\">,</span> <span class=\"n\">Fs</span><span class=\"o\">&amp;</span><span class=\"p\">...</span> <span class=\"n\">fs</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">dummy</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"p\">(</span><span class=\"n\">f1</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(),</span> <span class=\"nb\">true</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">fs</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(),</span> <span class=\"nb\">true</span><span class=\"p\">)...</span> <span class=\"p\">};</span>\n\n    <span class=\"c1\">// prevent unused parameter warning\n</span><span class=\"c1\"></span>    <span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span> <span class=\"n\">dummy</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>虽然上述代码实现了<code>wait_for_all</code>这个接口，但是这种实现并不利于<code>future</code>的进一步组合。更好的实现应该是综合所依赖的<code>future</code>生成一个新的<code>future</code>，类似于如下形式:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span> <span class=\"k\">typename</span> <span class=\"n\">R</span><span class=\"p\">,</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">Arg</span><span class=\"o\">&gt;</span>\n<span class=\"k\">auto</span> <span class=\"n\">all_package</span><span class=\"p\">(</span><span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">Arg</span><span class=\"p\">...)</span><span class=\"o\">&gt;&amp;&amp;</span> <span class=\"n\">_f</span><span class=\"p\">,</span> <span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"n\">Arg</span><span class=\"o\">&gt;&amp;&amp;</span> <span class=\"n\">all_futures</span><span class=\"p\">...)</span>\n<span class=\"o\">-&gt;</span><span class=\"n\">pair</span><span class=\"o\">&lt;</span><span class=\"n\">packaged_task</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;&gt;</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">lambda_task</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">all</span><span class=\"o\">=</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">all_futures</span><span class=\"p\">)...,</span><span class=\"n\">f</span><span class=\"o\">=</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)]()</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">all</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">()...);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">make_shared</span><span class=\"o\">&lt;</span><span class=\"n\">shared</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">()</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">lambda_task</span><span class=\"p\">));</span>\n    <span class=\"k\">return</span> <span class=\"nf\">make_pair</span><span class=\"p\">(</span><span class=\"n\">packaged_task</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">),</span> <span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>同时添加<code>async_all</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">R</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"p\">...</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span>\n<span class=\"k\">auto</span> <span class=\"n\">async_all</span><span class=\"p\">(</span><span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"o\">&gt;&amp;&amp;</span> <span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">pack</span> <span class=\"o\">=</span> <span class=\"n\">all_package</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"n\">Args</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">function</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"p\">...)</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">),</span> <span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)...);</span>\n    <span class=\"n\">_system</span><span class=\"p\">.</span><span class=\"n\">async_</span><span class=\"p\">(</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">get</span><span class=\"o\">&lt;</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pack</span><span class=\"p\">)));</span>\n    <span class=\"k\">return</span> <span class=\"n\">get</span><span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pack</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>wait_any 串联</h2><p><code>wait_any</code>相对来说就比较麻烦了，需要实现一个通知机制。只要所等待的<code>future</code>其中一个有了信号，其他的<code>future</code>就不需要再执行了。我们可以采取<code>atomic_bool</code>的形式来实现这个<code>once_flag</code>，剩下的任务就是如何将这个<code>atomic_bool</code>挂载到各个<code>future</code>之上，这个挂载操作我们可以利用<code>then</code>。但是用<code>then</code>的话就无法控制其他<code>future</code>的执行，因为当我们执行<code>then</code>操作的时候之前的结果肯定已经计算完成。所以，我只能说毫无办法。</p><p>如果实在想这么做的话，需要在这些<code>future</code>生成之前就定义好这个<code>atomic_bool</code>。同时修改这些任务的执行逻辑，执行前首先判断<code>atomic_bool</code>是否已经<code>set</code>了，没有的话才执行后续任务。</p><h2>后记</h2><p>这篇文章基本翻译自<i>Sean</i> Parent的三年前的一个<code>ppt</code>，现在<code>c++17</code>已经出来了，文中提到的<code>future</code>基础设施基本已经添加进去了，可以直接用<code>stl</code>去调用了。</p><p>目前倒是有个想法，使用这个异步任务系统实现以下行为树的任务调度，看起来应该能行，核心还是在<code>action</code>的自动注册身上。</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "并行编程", 
                    "tagLink": "https://api.zhihu.com/topics/19580226"
                }, 
                {
                    "tag": "异步", 
                    "tagLink": "https://api.zhihu.com/topics/19571217"
                }
            ], 
            "comments": [
                {
                    "userName": "端木月岛", 
                    "userLink": "https://www.zhihu.com/people/80c1d1b9cf3441f33c54407b0e8c3c0f", 
                    "content": "<p>非常感谢您的这篇文章，我想请问您文章中packaged task和wait的推导是否有源码或者PPT提供呢？我有找到Sean Parent一场《Better Code: Concurrency》和一场《cpp seasoning》的演讲PPT，里面确实讲到了异步过程的执行(队列和线程池)，但是没有您文章中关于异步过程的生成和串联的内容。烦请您给一些更详细地介绍这些内容的链接，不胜感激。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "千寻", 
                            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
                            "content": "<p>好像是好久以前我自己写的。。。。。。 其实c++17里面 concurrency<i>ts 里面已经有then when</i>all这些东西了，你直接看下系统库的源代码就可以。类似的库还有intel tbb, microsoft的ppl, github上也有cpp-taskflow可以参考</p>", 
                            "likes": 0, 
                            "replyToAuthor": "端木月岛"
                        }, 
                        {
                            "userName": "端木月岛", 
                            "userLink": "https://www.zhihu.com/people/80c1d1b9cf3441f33c54407b0e8c3c0f", 
                            "content": "非常感谢，我只是看见您的推导觉得非常有意思，想看看完整版是怎样的。平时业务会用成熟的工具[爱]", 
                            "likes": 0, 
                            "replyToAuthor": "千寻"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55584285", 
            "userName": "千寻", 
            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
            "upvote": 11, 
            "title": "lock free hashtable", 
            "content": "<p>对于让<code>hashtable</code>变成无锁，主要需要解决如下几个问题：</p><ol><li><code>hash</code>表的核心就是探查方法，开链法在插入节点的时候会引入动态内存分配的问题，这个是在无锁里面很棘手的问题，所以没有采取开链法，同时二次探查在无锁和缓存上面很不友好，所以使用的就是线性探查。因此我们首先要使得线性探查无锁化。</li><li><code>hash</code>表插入的时候可能会导致过载。在<code>STL</code>的实现中是发现<code>map</code>内部装载率大于一定值时将<code>map</code>扩容。由于扩容的时候会出现迭代器失效的问题，所以这种方法在无锁的时候压根不可行。所以很多实现是直接开一个新的当前表大小的干净副本，通过指针将所有副本链接起来。查询和插入的时候需要遍历所有的副本</li></ol><h2>lockfree linear search</h2><p>在preshing的<a href=\"https://link.zhihu.com/?target=http%3A//preshing.com/20130529/a-lock-free-linear-search/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一篇文章</a>里面谈到了无锁线性扫描的实现，这里定义了一个基本的<code>Entry</code>:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">struct</span> <span class=\"n\">Entry</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">mint_atomic32_t</span> <span class=\"n\">key</span><span class=\"p\">;</span>\n    <span class=\"n\">mint_atomic32_t</span> <span class=\"n\">value</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"n\">Entry</span> <span class=\"o\">*</span><span class=\"n\">m_entries</span><span class=\"p\">;</span>\n</code></pre></div><p>在这个<code>Entry</code>里，我们规定如果<code>key</code>的值为0，则代表这个<code>entry</code>还没有被使用，所以插入的时候禁止传入为0的<code>key</code>。</p><p>在此结构之下，定义的<code>setItem</code>操作如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">ArrayOfItems</span><span class=\"o\">::</span><span class=\"n\">SetItem</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">uint32_t</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;;</span> <span class=\"n\">idx</span><span class=\"o\">++</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">uint32_t</span> <span class=\"n\">prevKey</span> <span class=\"o\">=</span> <span class=\"n\">mint_compare_exchange_strong_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"n\">prevKey</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"n\">prevKey</span> <span class=\"o\">==</span> <span class=\"n\">key</span><span class=\"p\">))</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">mint_store_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">);</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>类似的<code>getItem</code>的操作如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">uint32_t</span> <span class=\"n\">ArrayOfItems</span><span class=\"o\">::</span><span class=\"n\">GetItem</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;;</span> <span class=\"n\">idx</span><span class=\"o\">++</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">uint32_t</span> <span class=\"n\">probedKey</span> <span class=\"o\">=</span> <span class=\"n\">mint_load_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">==</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">mint_load_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">value</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>          \n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>现在的疑问在于，这里的原子操作使用的都是<code>relaxed</code>语义，这个语义在<code>x86</code>上基本等于没有任何作用，如何在使得<code>SetItem</code>里的第8行能够被<code>GetItem</code>的第7行可见。事实上这压根做不到，因为一个线程在执行到<code>SetItem</code>的第8行之前被换出， 然后另外一个线程执行到了<code>GetItem</code>的第7行，这里读取的还是老的值。除了这种情况之外，还可能出现<code>SetItem</code>里的<code>CAS</code>操作并没有将数据更新的通知发放到其他的<code>core</code>上去，然而第8行的<code>store</code>操作已经被另外一个执行<code>GetItem</code>的线程可见的情况，此时<code>GetItem</code>会返回0。这两种情况都是合法的，因为在多线程中读取数据的时机是不确定的，因此读取老数据也是正常的。甚至可以说在没有通知机制的情况下，是不是最新根本没有意义。如果要实现<code>publish-listen</code>的机制，则需要在<code>SetItem</code>的时候将一个原子的<code>bool</code>变量设置为<code>True</code>，同时这个<code>Store</code>操作要使用<code>Release</code>语义，同时另外一个线程在<code>CAS</code>这个值的时候，要使用<code>Acquire</code>语义。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Shared variables\n</span><span class=\"c1\"></span><span class=\"kt\">char</span> <span class=\"n\">message</span><span class=\"p\">[</span><span class=\"mi\">256</span><span class=\"p\">];</span>\n<span class=\"n\">ArrayOfItems</span> <span class=\"n\">collection</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">PublishMessage</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// Write to shared memory non-atomically.\n</span><span class=\"c1\"></span>    <span class=\"n\">strcpy</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"s\">&#34;I pity the fool!&#34;</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// Release fence: The only way to safely pass non-atomic data between threads using Mintomic.\n</span><span class=\"c1\"></span>    <span class=\"n\">mint_thread_fence_release</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// Set a flag to indicate to other threads that the message is ready.\n</span><span class=\"c1\"></span>    <span class=\"n\">collection</span><span class=\"p\">.</span><span class=\"n\">SetItem</span><span class=\"p\">(</span><span class=\"n\">SHARED_FLAG_KEY</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这样才能使得数据更改完并通知完之后，另外一方能够得到最新数据。因此，当前设计的无锁<code>hashtable</code>在多线程上唯一做的事情就是防止了多个线程对同一个<code>entry</code>同时做<code>SetItem</code>操作。</p><p>preshing对<code>SetItem</code>有一个优化：减少不必要的<code>CAS</code>操作。在原来的实现中会遍历所有的元素去执行<code>CAS</code>操作，其实只有<code>key == 0 or key == my_key</code>的时候我们才需要去做<code>CAS</code>。所以这里的优化就是预先作一次<code>load</code>，发现可以去<code>set</code>的时候才去<code>CAS</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">ArrayOfItems</span><span class=\"o\">::</span><span class=\"n\">SetItem</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">uint32_t</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;;</span> <span class=\"n\">idx</span><span class=\"o\">++</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"c1\">// Load the key that was there.\n</span><span class=\"c1\"></span>        <span class=\"n\">uint32_t</span> <span class=\"n\">probedKey</span> <span class=\"o\">=</span> <span class=\"n\">mint_load_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">!=</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"c1\">// The entry was either free, or contains another key.\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n                <span class=\"k\">continue</span><span class=\"p\">;</span>           <span class=\"c1\">// Usually, it contains another key. Keep probing.\n</span><span class=\"c1\"></span>\n            <span class=\"c1\">// The entry was free. Now let&#39;s try to take it using a CAS.\n</span><span class=\"c1\"></span>            <span class=\"n\">uint32_t</span> <span class=\"n\">prevKey</span> <span class=\"o\">=</span> <span class=\"n\">mint_compare_exchange_strong_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span>\n            <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"n\">prevKey</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"n\">prevKey</span> <span class=\"o\">!=</span> <span class=\"n\">key</span><span class=\"p\">))</span>\n                <span class=\"k\">continue</span><span class=\"p\">;</span>       <span class=\"c1\">// Another thread just stole it from underneath us.\n</span><span class=\"c1\"></span>\n            <span class=\"c1\">// Either we just added the key, or another thread did.\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n\n        <span class=\"c1\">// Store the value in this array entry.\n</span><span class=\"c1\"></span>        <span class=\"n\">mint_store_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>naive lockfree hashtable</h2><p>在上面的<code>lockfree linear scan</code>的基础上，做一个<code>lockfree hashtable</code>还是比较简单的。这里定义了三个函数<code>intergerHash, SetItem, GetItem</code>：</p><div class=\"highlight\"><pre><code class=\"language-text\">inline static uint32_t integerHash(uint32_t h)\n{\n    h ^= h &gt;&gt; 16;\n    h *= 0x85ebca6b;\n    h ^= h &gt;&gt; 13;\n    h *= 0xc2b2ae35;\n    h ^= h &gt;&gt; 16;\n    return h;\n}</code></pre></div><p>这个<code>hash</code>函数的来源是<a href=\"https://link.zhihu.com/?target=https%3A//code.google.com/p/smhasher/wiki/MurmurHash3\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MurmurHash3’s integer finalizer</a> ， 据说这样可以让每一位都起到差不多的作用。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">HashTable1</span><span class=\"o\">::</span><span class=\"n\">SetItem</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">uint32_t</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"n\">integerHash</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">);;</span> <span class=\"n\">idx</span><span class=\"o\">++</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">idx</span> <span class=\"o\">&amp;=</span> <span class=\"n\">m_arraySize</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n        <span class=\"c1\">// Load the key that was there.\n</span><span class=\"c1\"></span>        <span class=\"n\">uint32_t</span> <span class=\"n\">probedKey</span> <span class=\"o\">=</span> <span class=\"n\">mint_load_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">!=</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"c1\">// The entry was either free, or contains another key.\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n                <span class=\"k\">continue</span><span class=\"p\">;</span>           <span class=\"c1\">// Usually, it contains another key. Keep probing.\n</span><span class=\"c1\"></span>\n            <span class=\"c1\">// The entry was free. Now let&#39;s try to take it using a CAS.\n</span><span class=\"c1\"></span>            <span class=\"n\">uint32_t</span> <span class=\"n\">prevKey</span> <span class=\"o\">=</span> <span class=\"n\">mint_compare_exchange_strong_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">);</span>\n            <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"n\">prevKey</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"n\">prevKey</span> <span class=\"o\">!=</span> <span class=\"n\">key</span><span class=\"p\">))</span>\n                <span class=\"k\">continue</span><span class=\"p\">;</span>       <span class=\"c1\">// Another thread just stole it from underneath us.\n</span><span class=\"c1\"></span>\n            <span class=\"c1\">// Either we just added the key, or another thread did.\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n\n        <span class=\"c1\">// Store the value in this array entry.\n</span><span class=\"c1\"></span>        <span class=\"n\">mint_store_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的<code>SetItem</code>正确工作有一个前提：整个<code>hashtable</code>不是满的，是满的一定会出错。</p><p><code>GetItem</code>还是老样子：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">uint32_t</span> <span class=\"n\">HashTable1</span><span class=\"o\">::</span><span class=\"n\">GetItem</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"n\">integerHash</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">);;</span> <span class=\"n\">idx</span><span class=\"o\">++</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">idx</span> <span class=\"o\">&amp;=</span> <span class=\"n\">m_arraySize</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n        <span class=\"n\">uint32_t</span> <span class=\"n\">probedKey</span> <span class=\"o\">=</span> <span class=\"n\">mint_load_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">==</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">mint_load_32_relaxed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m_entries</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">].</span><span class=\"n\">value</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>          \n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>所谓的<code>publish</code>函数也是一样:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Shared variables\n</span><span class=\"c1\"></span><span class=\"kt\">char</span> <span class=\"n\">message</span><span class=\"p\">[</span><span class=\"mi\">256</span><span class=\"p\">];</span>\n<span class=\"n\">HashTable1</span> <span class=\"n\">collection</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">PublishMessage</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// Write to shared memory non-atomically.\n</span><span class=\"c1\"></span>    <span class=\"n\">strcpy</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"s\">&#34;I pity the fool!&#34;</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// Release fence: The only way to safely pass non-atomic data between threads using Mintomic.\n</span><span class=\"c1\"></span>    <span class=\"n\">mint_thread_fence_release</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// Set a flag to indicate to other threads that the message is ready.\n</span><span class=\"c1\"></span>    <span class=\"n\">collection</span><span class=\"p\">.</span><span class=\"n\">SetItem</span><span class=\"p\">(</span><span class=\"n\">SHARED_FLAG_KEY</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>至于<code>delete</code>操作，我们可以规定<code>value</code>是某个值的时候代表当前<code>entry</code>是被删除的，这样就可以用<code>SetItem(key, 0)</code>来模拟<code>delete</code>操作了。</p><h2>what about full</h2><p>上面的无锁<code>hashtable</code>有一个致命缺陷，他没有处理整个<code>hashtable</code>满了的情况。为了处理满的情况，我们需要设置最大探查数量为当前<code>hashtable</code>的容量, 同时维护多个独立的<code>hashtable</code>，用一个无锁的链表将所有的<code>hashtable</code>的指针串联起来。如果最大探查数量达到上限，且当前<code>hashtable</code>没有下一个<code>hashtable</code>的指针，且则先建立一个新的<code>hashtable</code>，并挂载到无锁链表上，回到了有下一个<code>hashtable</code>的情况，然后对下一个<code>hashtable</code>做递归遍历。</p><p>这样做的确解决了扩容的问题，但是会出现性能下降的问题。后面过来的<code>key</code>在查询的时候会变得越来越慢，因为经常需要查询多层的<code>hashtable</code>。为了避免这个问题，出现了一种新的设计：每次添加一层<code>hashtable</code>的时候，都将容量扩大一倍，然后将上一个<code>hashtable</code>的内容拷贝到新的<code>hashtable</code>里。这个新的<code>hashtable</code>也叫做<code>main_hashtable</code>，由于我们无法在无锁的情况下把整个<code>hashtable</code>拷贝过去，所以采用<code>lazy</code>的方式，这个方式的步骤如下:</p><ol><li>维持一个<code>hashtable</code>的无锁链表，链表的头节点就叫做<code>main_hashtable</code>，所有的<code>hashtable</code>通过一个<code>next</code>指针相连；</li><li>插入的时候如果发现当前的<code>main_hashtable</code>的装载因子（这个装载因子考虑了所有的<code>key</code>）已经大于0.5，则新建一个<code>hashtable</code>，然后插入到新的<code>hashtable</code>里；</li><li>扩容的时候设置一个标志位，表明当前正在扩容，避免多个线程同时扩容，浪费资源，扩容期间所有等待扩容的线程都忙等待，扩容完成之后清除正在扩容的标记；</li><li>新建立的<code>hashtable</code>是空的，大小为当前<code>main_hashtable</code>的两倍，每次新加入一个<code>hashtable</code>的时候都插入到头部，使之成为新的<code>main_hashtable</code>；</li><li>查询的时候，根据这些<code>next</code>指针一直查询，直到最后一个<code>hashtable</code>；</li><li>如果查询返回结果的时候发现返回结果的那个<code>hashtable</code>并不是<code>main_hashtable</code>，则把当前的<code>key value</code>对插入到<code>main_hashtable</code>里，这就是核心的<code>lazy copy</code>的过程</li></ol><p>这个<code>lazy</code>的过程代码如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">auto</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"n\">details</span><span class=\"o\">::</span><span class=\"n\">thread_id</span><span class=\"p\">();</span>\n        <span class=\"k\">auto</span> <span class=\"n\">hashedId</span> <span class=\"o\">=</span> <span class=\"n\">details</span><span class=\"o\">::</span><span class=\"n\">hash_thread_id</span><span class=\"p\">(</span><span class=\"n\">id</span><span class=\"p\">);</span>\n\n        <span class=\"k\">auto</span> <span class=\"n\">mainHash</span> <span class=\"o\">=</span> <span class=\"n\">implicitProducerHash</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">mainHash</span><span class=\"p\">;</span> <span class=\"n\">hash</span> <span class=\"o\">!=</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"o\">-&gt;</span><span class=\"n\">prev</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// Look for the id in this hash\n</span><span class=\"c1\"></span>            <span class=\"k\">auto</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">hashedId</span><span class=\"p\">;</span>\n            <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">)</span> <span class=\"p\">{</span>      <span class=\"c1\">// Not an infinite loop because at least one slot is free in the hash table\n</span><span class=\"c1\"></span>                <span class=\"n\">index</span> <span class=\"o\">&amp;=</span> <span class=\"n\">hash</span><span class=\"o\">-&gt;</span><span class=\"n\">capacity</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n                <span class=\"k\">auto</span> <span class=\"n\">probedKey</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"o\">-&gt;</span><span class=\"n\">entries</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_relaxed</span><span class=\"p\">);</span>\n                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">==</span> <span class=\"n\">id</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                    <span class=\"c1\">// Found it! If we had to search several hashes deep, though, we should lazily add it\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// to the current main hash table to avoid the extended search next time.\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// Note there&#39;s guaranteed to be room in the current hash table since every subsequent\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// table implicitly reserves space for all previous tables (there&#39;s only one\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// implicitProducerHashCount).\n</span><span class=\"c1\"></span>                    <span class=\"k\">auto</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"o\">-&gt;</span><span class=\"n\">entries</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">].</span><span class=\"n\">value</span><span class=\"p\">;</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">hash</span> <span class=\"o\">!=</span> <span class=\"n\">mainHash</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                        <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">hashedId</span><span class=\"p\">;</span>\n                        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                            <span class=\"n\">index</span> <span class=\"o\">&amp;=</span> <span class=\"n\">mainHash</span><span class=\"o\">-&gt;</span><span class=\"n\">capacity</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n                            <span class=\"n\">probedKey</span> <span class=\"o\">=</span> <span class=\"n\">mainHash</span><span class=\"o\">-&gt;</span><span class=\"n\">entries</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_relaxed</span><span class=\"p\">);</span>\n                            <span class=\"k\">auto</span> <span class=\"n\">empty</span> <span class=\"o\">=</span> <span class=\"n\">details</span><span class=\"o\">::</span><span class=\"n\">invalid_thread_id</span><span class=\"p\">;</span>\n<span class=\"cp\">#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED\n</span><span class=\"cp\"></span>                            <span class=\"k\">auto</span> <span class=\"n\">reusable</span> <span class=\"o\">=</span> <span class=\"n\">details</span><span class=\"o\">::</span><span class=\"n\">invalid_thread_id2</span><span class=\"p\">;</span>\n                            <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"n\">probedKey</span> <span class=\"o\">==</span> <span class=\"n\">empty</span>    <span class=\"o\">&amp;&amp;</span> <span class=\"n\">mainHash</span><span class=\"o\">-&gt;</span><span class=\"n\">entries</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">.</span><span class=\"n\">compare_exchange_strong</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"p\">,</span>    <span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_relaxed</span><span class=\"p\">))</span> <span class=\"o\">||</span>\n                                <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">==</span> <span class=\"n\">reusable</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">mainHash</span><span class=\"o\">-&gt;</span><span class=\"n\">entries</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">.</span><span class=\"n\">compare_exchange_strong</span><span class=\"p\">(</span><span class=\"n\">reusable</span><span class=\"p\">,</span> <span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">)))</span> <span class=\"p\">{</span>\n<span class=\"cp\">#else\n</span><span class=\"cp\"></span>                            <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"n\">probedKey</span> <span class=\"o\">==</span> <span class=\"n\">empty</span>    <span class=\"o\">&amp;&amp;</span> <span class=\"n\">mainHash</span><span class=\"o\">-&gt;</span><span class=\"n\">entries</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">].</span><span class=\"n\">key</span><span class=\"p\">.</span><span class=\"n\">compare_exchange_strong</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"p\">,</span>    <span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_relaxed</span><span class=\"p\">)))</span> <span class=\"p\">{</span>\n<span class=\"cp\">#endif\n</span><span class=\"cp\"></span>                                <span class=\"n\">mainHash</span><span class=\"o\">-&gt;</span><span class=\"n\">entries</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">].</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"p\">;</span>\n                                <span class=\"k\">break</span><span class=\"p\">;</span>\n                            <span class=\"p\">}</span>\n                            <span class=\"o\">++</span><span class=\"n\">index</span><span class=\"p\">;</span>\n                        <span class=\"p\">}</span>\n                    <span class=\"p\">}</span>\n\n                    <span class=\"k\">return</span> <span class=\"n\">value</span><span class=\"p\">;</span>\n                <span class=\"p\">}</span>\n                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">probedKey</span> <span class=\"o\">==</span> <span class=\"n\">details</span><span class=\"o\">::</span><span class=\"n\">invalid_thread_id</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                    <span class=\"k\">break</span><span class=\"p\">;</span>      <span class=\"c1\">// Not in this hash table\n</span><span class=\"c1\"></span>                <span class=\"p\">}</span>\n                <span class=\"o\">++</span><span class=\"n\">index</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n</code></pre></div><p>现在的核心则转移到了扩容的过程，扩容涉及到了动态内存分配和初始内容的填充，是比较耗的操作，所以要避免多个线程在争抢扩容的控制权。在<code>moodycamel</code>的设计里，是这样处理扩容的。</p><div class=\"highlight\"><pre><code class=\"language-text\">// Insert!\n            auto newCount = 1 + implicitProducerHashCount.fetch_add(1, std::memory_order_relaxed);\n            while (true)\n            {\n                if (newCount &gt;= (mainHash-&gt;capacity &gt;&gt; 1) &amp;&amp; !implicitProducerHashResizeInProgress.test_and_set(std::memory_order_acquire))\n                {\n                    // We&#39;ve acquired the resize lock, try to allocate a bigger hash table.\n                    // Note the acquire fence synchronizes with the release fence at the end of this block, and hence when\n                    // we reload implicitProducerHash it must be the most recent version (it only gets changed within this\n                    // locked block).\n                    mainHash = implicitProducerHash.load(std::memory_order_acquire);\n                    if (newCount &gt;= (mainHash-&gt;capacity &gt;&gt; 1))\n                    {\n                        auto newCapacity = mainHash-&gt;capacity &lt;&lt; 1;\n                        while (newCount &gt;= (newCapacity &gt;&gt; 1))\n                        {\n                            newCapacity &lt;&lt;= 1;\n                        }\n                        auto raw = static_cast&lt;char*&gt;((Traits::malloc)(sizeof(ImplicitProducerHash) + std::alignment_of&lt;ImplicitProducerKVP&gt;::value - 1 + sizeof(ImplicitProducerKVP) * newCapacity));\n                        if (raw == nullptr)\n                        {\n                            // Allocation failed\n                            implicitProducerHashCount.fetch_add(-1, std::memory_order_relaxed);\n                            implicitProducerHashResizeInProgress.clear(std::memory_order_relaxed);\n                            return nullptr;\n                        }\n\n                        auto newHash = new (raw) ImplicitProducerHash;\n                        newHash-&gt;capacity = newCapacity;\n                        newHash-&gt;entries = reinterpret_cast&lt;ImplicitProducerKVP*&gt;(details::align_for&lt;ImplicitProducerKVP&gt;(raw + sizeof(ImplicitProducerHash)));\n                        for (size_t i = 0; i != newCapacity; ++i)\n                        {\n                            new (newHash-&gt;entries + i) ImplicitProducerKVP;\n                            newHash-&gt;entries[i].key.store(details::invalid_thread_id, std::memory_order_relaxed);\n                        }\n                        newHash-&gt;prev = mainHash;\n                        implicitProducerHash.store(newHash, std::memory_order_release);\n                        implicitProducerHashResizeInProgress.clear(std::memory_order_release);\n                        mainHash = newHash;\n                    }\n                    else\n                    {\n                        implicitProducerHashResizeInProgress.clear(std::memory_order_release);\n                    }\n                }\n\n                // If it&#39;s &lt; three-quarters full, add to the old one anyway so that we don&#39;t have to wait for the next table\n                // to finish being allocated by another thread (and if we just finished allocating above, the condition will\n                // always be true)\n                if (newCount &lt; (mainHash-&gt;capacity &gt;&gt; 1) + (mainHash-&gt;capacity &gt;&gt; 2))\n                {\n                    bool recycled;\n                    auto producer = static_cast&lt;ImplicitProducer*&gt;(recycle_or_create_producer(false, recycled));\n                    if (producer == nullptr)\n                    {\n                        implicitProducerHashCount.fetch_add(-1, std::memory_order_relaxed);\n                        return nullptr;\n                    }\n                    if (recycled)\n                    {\n                        implicitProducerHashCount.fetch_add(-1, std::memory_order_relaxed);\n                    }\n\n#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED\n                    producer-&gt;threadExitListener.callback = &amp;ConcurrentQueue::implicit_producer_thread_exited_callback;\n                    producer-&gt;threadExitListener.userData = producer;\n                    details::ThreadExitNotifier::subscribe(&amp;producer-&gt;threadExitListener);\n#endif\n\n                    auto index = hashedId;\n                    while (true)\n                    {\n                        index &amp;= mainHash-&gt;capacity - 1;\n                        auto probedKey = mainHash-&gt;entries[index].key.load(std::memory_order_relaxed);\n\n                        auto empty = details::invalid_thread_id;\n#ifdef MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED\n                        auto reusable = details::invalid_thread_id2;\n                        if ((probedKey == empty    &amp;&amp; mainHash-&gt;entries[index].key.compare_exchange_strong(empty, id, std::memory_order_relaxed)) ||\n                            (probedKey == reusable &amp;&amp; mainHash-&gt;entries[index].key.compare_exchange_strong(reusable, id, std::memory_order_acquire)))\n                        {\n#else\n                        if ((probedKey == empty    &amp;&amp; mainHash-&gt;entries[index].key.compare_exchange_strong(empty, id, std::memory_order_relaxed)))\n                        {\n#endif\n                            mainHash-&gt;entries[index].value = producer;\n                            break;\n                        }\n                        ++index;\n                    }\n                    return producer;\n                }\n\n                // Hmm, the old hash is quite full and somebody else is busy allocating a new one.\n                // We need to wait for the allocating thread to finish (if it succeeds, we add, if not,\n                // we try to allocate ourselves).\n                mainHash = implicitProducerHash.load(std::memory_order_acquire);\n            }</code></pre></div><p>上面的第五行就是抢夺控制权的过程，进入扩容的条件就是当前装载因子已经大于<code>0.5</code>，且扩容标志位没有设置。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">newCount</span> <span class=\"o\">&gt;=</span> <span class=\"p\">(</span><span class=\"n\">mainHash</span><span class=\"o\">-&gt;</span><span class=\"n\">capacity</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">implicitProducerHashResizeInProgress</span><span class=\"p\">.</span><span class=\"n\">test_and_set</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">)</span>\n</code></pre></div><p>扩容的时候设置一个标志位，相当于一个锁，扩容完成之后清空标志位。但是由于线程换出的存在，这个标志位可能导致其他线程永远抢不到控制权，进入无限死循环。所以这里又对没有抢夺到扩容控制权的线程，还有另外的一个判断，如果装载因子小于0.75，则直接尝试插入，不用管。</p><div class=\"highlight\"><pre><code class=\"language-text\">newCount &lt; (mainHash-&gt;capacity &gt;&gt; 1) + (mainHash-&gt;capacity &gt;&gt; 2)</code></pre></div><p>这个分支里还做了一些事情，就是当真正的获得了一个<code>implicit producer</code>之后，注册一个线程退出的<code>callback</code>，这个<code>callback</code>会把当前<code>producer</code>销毁，并在<code>hashtable</code>里删除对应的<code>key</code>。</p><p>最后剩下的一种情况就是：拿不到扩容所有权，且当前装载因子已经上了<code>0.75</code>，此时除了死循环没有办法，约等于死锁。这种情况很罕见，但是仍然可以构造出来：正在扩容的线程被换出。不知原作者如何处理这个情况。</p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "并行编程", 
                    "tagLink": "https://api.zhihu.com/topics/19580226"
                }
            ], 
            "comments": [
                {
                    "userName": "peiwen", 
                    "userLink": "https://www.zhihu.com/people/33a837766e435e03f2bec288a5027e20", 
                    "content": "名字错了，lock", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "千寻", 
                            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
                            "content": "<p>wocao......</p><p></p>", 
                            "likes": 0, 
                            "replyToAuthor": "peiwen"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55583561", 
            "userName": "千寻", 
            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
            "upvote": 42, 
            "title": "Concurrent Queue", 
            "content": "<p></p><p>Herb Sutter在DDJ <code>pillars of concurrency</code>一文中抛出并行编程的三个简单论点，一是分离任务，使用更细粒度的锁或者无锁编程；二是尽量通过并行任务使用CPU资源，以提高系统吞吐量及扩展性；三是保证对共享资源访问的一致性。第三点已经被<code>atomic</code>、<code>mutex</code>、<code>lock</code>、<code>condition_variable</code>解决了，第一点和第二点则可以归结为如何对任务进行粒度划分并投递到任务的执行单元中去调度执行。任务划分依赖于各种不同业务的理解，例如网络和渲染，很难抽取出其共性。而任务的调度执行则是一种通用的结构，可以分为四个部分：</p><ol><li>任务的封装 在<code>c++11</code>里提供了三种最基本的任务封装形式<code>future, promise,packaged_task</code></li><li>任务的结构 在<code>c++17</code>里补全了任务结构控制，主要是提供了<code>then, when_all, when_any</code>这三个用来关联多个<code>future</code>的函数</li><li>任务的执行 任务执行者基本都是使用线程池，每个线程不断的尝试获取一个任务并执行，类似于一个while循环</li><li>任务的调度 这部分负责了任务的投递和分发，他在多线程之间维持了一个任务容器集合，提供的接口主要包括接受新任务、取出一个任务和判断容器是否为空</li></ol><p>在整个并发任务系统中，在任务容器集合之上的任务调度结构是核心。现在使用的最广泛的任务容器是<code>concurrent queue</code>，下面我们来对<code>concurrent queue</code>的多种实现来做一下分析。</p><h2>naive concurrent queue</h2><p><code>queue</code>是一个维持先进先出（<code>FIFO</code>）队列的结构，在很多STL的实现之中采取的是多块连续内存的双向链表来维持其先进先出结构。为了在多线程中使用<code>std::queue</code>，最简单的方法就是使用锁来解决<code>data race</code>，同时修改原始提供的接口，使得这个数据结构不会被用错。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;queue&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;atomic&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;mutex&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">concurrent_queue</span>\n<span class=\"p\">{</span>\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"k\">mutable</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span> <span class=\"n\">mut</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">queue</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">data_queue</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">condition_variable</span> <span class=\"n\">data_cond</span><span class=\"p\">;</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">concurrent_queue</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"c1\">// pass\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">T</span> <span class=\"n\">new_value</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lk</span><span class=\"p\">(</span><span class=\"n\">mut</span><span class=\"p\">);</span>\n        <span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">));</span>\n        <span class=\"n\">data_cond</span><span class=\"p\">.</span><span class=\"n\">notify_one</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">wait_and_pop</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unique_lock</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lk</span><span class=\"p\">(</span><span class=\"n\">mut</span><span class=\"p\">);</span>\n        <span class=\"n\">data_cond</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">lk</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"k\">this</span><span class=\"p\">]{</span>\n            <span class=\"k\">return</span> <span class=\"o\">!</span><span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">();</span>\n        <span class=\"p\">})</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">());</span>\n        <span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">wait_and_pop</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unique_lock</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lk</span><span class=\"p\">(</span><span class=\"n\">mut</span><span class=\"p\">);</span>\n        <span class=\"n\">data_cond</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">lk</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"k\">this</span><span class=\"p\">]{</span>\n            <span class=\"k\">return</span> <span class=\"o\">!</span><span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">();</span>\n        <span class=\"p\">})</span>\n        <span class=\"k\">auto</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">make_shared</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">()));</span>\n        <span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">();</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">try_pop</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lk</span><span class=\"p\">(</span><span class=\"n\">mut</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">());</span>\n        <span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"n\">True</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">try_pop</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lk</span><span class=\"p\">(</span><span class=\"n\">mut</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">auto</span> <span class=\"n\">res</span> <span class=\"o\">=</span>  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">make_shared</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">()));</span>\n        <span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">empty</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lk</span><span class=\"p\">(</span><span class=\"n\">mut</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">data_queue</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>上述代码的主要考量如下：</p><ol><li>由于多线程的干扰，常规的查询<code>empty</code>之后再<code>pop</code>的处理流程是错误的，这两个操作必须封装在一起，所以这里提供了<code>try_pop</code>和<code>wait_and_pop</code>这两个接口来获取数据。</li><li>为了避免在数据拷贝的时候出现异常导致的数据不一致，返回数据的时候采取两套方案，一个是调用者提供引用，一个是返回一个<code>shared_ptr</code>。这样就保证了如果在拷贝构造<code>front</code>的时候出了trace也能维持整个<code>queue</code>的结构完整。</li></ol><p>这个<code>concurrent_queue</code>并不是很高效，主要的<code>drawback</code>包括如下三个方面:</p><ol><li>每次访问接口的时候都需要调用锁，而且是同一个锁</li><li>在尝试获得数据的时候失败会触发<code>yield</code>，从而导致线程切换</li><li>维持了一个全局的先进先出序列，在多消费者的情况下这个强制唯一序是没有意义的，在单消费者的情况下也很少会有这种要求。</li></ol><p>对应的常见解决方案：</p><ol><li>使用无锁的方式去代替<code>mutex</code>，同时由于无锁最大的问题是内存分配，有些并发队列通过预先设置最大大小的方式来预分配内存，从而绕过了著名的<code>ABA</code>问题</li><li>使用双链表结构去维持队列，而不是使用<code>queue</code>，这样我们就可以分离头节点和尾节点的访问；如果是固定大小的队列则可以采取<code>ring buffer</code>的形式来维持队列结构。</li><li>当尝试获得数据失败的时候，先轮询一段时间，如果这段时间内还是没有数据，则调用<code>yield</code>，也就是对<code>condition_variable</code>封装了一层。</li><li>每个生产者维护其投递队列，每个消费者根据对各个生产者任务队列的优先级去遍历获取任务。</li></ol><p>事实上，在这是一个并发<code>queue</code>的时候，首先要明确如下几个问题：</p><ol><li> 这个<code>queue</code>的生产者和消费者各有多少个，常见的有单生产者单消费者(<code>SPSC</code>)、单生产者多消费者(<code>SPMC</code>)、多生产者单消费者(<code>MPSC</code>)和多生产者多消费者(<code>MPMC</code>)<br/> </li><li> 这个<code>queue</code>的最大元素大小是否确定，如果可以确定最大大小，则动态内存分配就可以避免，直接采取环形队列当作容器即可；如果无法确定最大大小，则只能通过动态内存分配的形式去处理，这里的难度加大了很多，因为要处理多线程的内存分配。<br/> </li></ol><p>下面我们来看一下现在主流的几种<code>concurrent_queue</code>的实现，来分析一下他们对<code>concurrent_queue</code>的实现优化。</p><h2>intel spsc concurrent queue</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//software.intel.com/en-us/articles/single-producer-single-consumer-queue\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">intel官方网站</a>上提供了一个<code>SPSC queue</code>，但是这个<code>queue</code>没有限制最大元素大小，如果临时内存不够的话会调用<code>new</code>，可能会触发锁。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// load with &#39;consume&#39; (data-dependent) memory ordering\n</span><span class=\"c1\"></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">T</span> <span class=\"n\">load_consume</span><span class=\"p\">(</span><span class=\"n\">T</span> <span class=\"k\">const</span><span class=\"o\">*</span> <span class=\"n\">addr</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// hardware fence is implicit on x86\n</span><span class=\"c1\"></span>  <span class=\"n\">T</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"k\">const_cast</span><span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"k\">const</span> <span class=\"k\">volatile</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">);</span>\n  <span class=\"n\">__memory_barrier</span><span class=\"p\">();</span> <span class=\"c1\">// compiler fence\n</span><span class=\"c1\"></span>  <span class=\"k\">return</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// store with &#39;release&#39; memory ordering\n</span><span class=\"c1\"></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">store_release</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">addr</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// hardware fence is implicit on x86\n</span><span class=\"c1\"></span>  <span class=\"n\">__memory_barrier</span><span class=\"p\">();</span> <span class=\"c1\">// compiler fence\n</span><span class=\"c1\"></span>  <span class=\"o\">*</span><span class=\"k\">const_cast</span><span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"k\">volatile</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// cache line size on modern x86 processors (in bytes)\n</span><span class=\"c1\"></span><span class=\"n\">size_t</span> <span class=\"k\">const</span> <span class=\"n\">cache_line_size</span> <span class=\"o\">=</span> <span class=\"mi\">64</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// single-producer/single-consumer queue\n</span><span class=\"c1\"></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">spsc_queue</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n  <span class=\"n\">spsc_queue</span><span class=\"p\">()</span>\n  <span class=\"p\">{</span>\n      <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">node</span><span class=\"p\">;</span>\n      <span class=\"n\">n</span><span class=\"o\">-&gt;</span><span class=\"n\">next_</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n      <span class=\"n\">tail_</span> <span class=\"o\">=</span> <span class=\"n\">head_</span> <span class=\"o\">=</span> <span class=\"n\">first_</span><span class=\"o\">=</span> <span class=\"n\">tail_copy_</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"o\">~</span><span class=\"n\">spsc_queue</span><span class=\"p\">()</span>\n  <span class=\"p\">{</span>\n      <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">first_</span><span class=\"p\">;</span>\n      <span class=\"k\">do</span>\n      <span class=\"p\">{</span>\n          <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">-&gt;</span><span class=\"n\">next_</span><span class=\"p\">;</span>\n          <span class=\"k\">delete</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n          <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n      <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"kt\">void</span> <span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"n\">T</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n      <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">alloc_node</span><span class=\"p\">();</span>\n      <span class=\"n\">n</span><span class=\"o\">-&gt;</span><span class=\"n\">next_</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n      <span class=\"n\">n</span><span class=\"o\">-&gt;</span><span class=\"n\">value_</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n      <span class=\"n\">store_release</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">head_</span><span class=\"o\">-&gt;</span><span class=\"n\">next_</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">);</span>\n      <span class=\"n\">head_</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// returns &#39;false&#39; if queue is empty\n</span><span class=\"c1\"></span>  <span class=\"kt\">bool</span> <span class=\"n\">dequeue</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">load_consume</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">tail_</span><span class=\"o\">-&gt;</span><span class=\"n\">next_</span><span class=\"p\">))</span>\n      <span class=\"p\">{</span>\n          <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">tail_</span><span class=\"o\">-&gt;</span><span class=\"n\">next_</span><span class=\"o\">-&gt;</span><span class=\"n\">value_</span><span class=\"p\">;</span>\n          <span class=\"n\">store_release</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">tail_</span><span class=\"p\">,</span> <span class=\"n\">tail_</span><span class=\"o\">-&gt;</span><span class=\"n\">next_</span><span class=\"p\">);</span>\n          <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n      <span class=\"k\">else</span>\n      <span class=\"p\">{</span>\n          <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n  <span class=\"c1\">// internal node structure\n</span><span class=\"c1\"></span>  <span class=\"k\">struct</span> <span class=\"n\">node</span>\n  <span class=\"p\">{</span>\n      <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">next_</span><span class=\"p\">;</span>\n      <span class=\"n\">T</span> <span class=\"n\">value_</span><span class=\"p\">;</span>\n  <span class=\"p\">};</span>\n\n  <span class=\"c1\">// consumer part\n</span><span class=\"c1\"></span>  <span class=\"c1\">// accessed mainly by consumer, infrequently be producer\n</span><span class=\"c1\"></span>  <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">tail_</span><span class=\"p\">;</span> <span class=\"c1\">// tail of the queue\n</span><span class=\"c1\"></span>\n  <span class=\"c1\">// delimiter between consumer part and producer part,\n</span><span class=\"c1\"></span>  <span class=\"c1\">// so that they situated on different cache lines\n</span><span class=\"c1\"></span>  <span class=\"kt\">char</span> <span class=\"n\">cache_line_pad_</span> <span class=\"p\">[</span><span class=\"n\">cache_line_size</span><span class=\"p\">];</span>\n\n  <span class=\"c1\">// producer part\n</span><span class=\"c1\"></span>  <span class=\"c1\">// accessed only by producer\n</span><span class=\"c1\"></span>  <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">head_</span><span class=\"p\">;</span> <span class=\"c1\">// head of the queue\n</span><span class=\"c1\"></span>  <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">first_</span><span class=\"p\">;</span> <span class=\"c1\">// last unused node (tail of node cache)\n</span><span class=\"c1\"></span>  <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">tail_copy_</span><span class=\"p\">;</span> <span class=\"c1\">// helper (points somewhere between first_ and tail_)\n</span><span class=\"c1\"></span>\n  <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"nf\">alloc_node</span><span class=\"p\">()</span>\n  <span class=\"p\">{</span>\n      <span class=\"c1\">// first tries to allocate node from internal node cache,\n</span><span class=\"c1\"></span>      <span class=\"c1\">// if attempt fails, allocates node via ::operator new()\n</span><span class=\"c1\"></span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">first_</span> <span class=\"o\">!=</span> <span class=\"n\">tail_copy_</span><span class=\"p\">)</span>\n      <span class=\"p\">{</span>\n          <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">first_</span><span class=\"p\">;</span>\n          <span class=\"n\">first_</span> <span class=\"o\">=</span> <span class=\"n\">first_</span><span class=\"o\">-&gt;</span><span class=\"n\">next_</span><span class=\"p\">;</span>\n          <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n      <span class=\"n\">tail_copy_</span> <span class=\"o\">=</span> <span class=\"n\">load_consume</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">tail_</span><span class=\"p\">);</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">first_</span> <span class=\"o\">!=</span> <span class=\"n\">tail_copy_</span><span class=\"p\">)</span>\n      <span class=\"p\">{</span>\n          <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">first_</span><span class=\"p\">;</span>\n          <span class=\"n\">first_</span> <span class=\"o\">=</span> <span class=\"n\">first_</span><span class=\"o\">-&gt;</span><span class=\"n\">next_</span><span class=\"p\">;</span>\n          <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n      <span class=\"n\">node</span><span class=\"o\">*</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">node</span><span class=\"p\">;</span>\n      <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">spsc_queue</span><span class=\"p\">(</span><span class=\"n\">spsc_queue</span> <span class=\"k\">const</span><span class=\"o\">&amp;</span><span class=\"p\">);</span>\n  <span class=\"n\">spsc_queue</span><span class=\"o\">&amp;</span> <span class=\"k\">operator</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">spsc_queue</span> <span class=\"k\">const</span><span class=\"o\">&amp;</span><span class=\"p\">);</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// usage example\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">spsc_queue</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">q</span><span class=\"p\">;</span>\n  <span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n  <span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n  <span class=\"kt\">int</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n  <span class=\"kt\">bool</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">dequeue</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">);</span>\n  <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">dequeue</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">);</span>\n  <span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n  <span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">);</span>\n  <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">dequeue</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">);</span>\n  <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">dequeue</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">);</span>\n  <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">dequeue</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这个代码的实现很简单粗暴，核心是一个单链表，对于单链表的任何操作都是<code>wait_free</code>的，这个链表有四个指针：</p><ol><li><code>tail</code>指针，指向下一个应该<code>dequeue</code>的位置</li><li><code>head</code>指针，指向最新的一个<code>enqueue</code>的位置</li><li><code>first_</code>指针，指向第一个可以回收<code>node</code>的位置</li><li><code>tail_copy</code>指针，指向一个安全的可以回收的<code>node</code>的<code>next</code>位置，他不一定指向<code>tail</code>。</li></ol><p>在这个链表里，指针之间有如下关系：$first \\le tail_copy \\le tail \\le head$ 。这里做的核心优化就是按需去更新<code>tail_copy</code>，没必要每次更新<code>tail</code>的时候都把<code>tail_copy</code>更新一遍，只有发现<code>first == tail_copy</code>的时候才去更新一下。每个操作都没有使用到<code>CAS</code>，因此都是<code>wait_free</code>的，当然那一行调用了<code>new</code>的除外。</p><p>这里为了避免<code>False Sharing</code>使用了<code>padding</code>。由于读线程只需要更改<code>tail</code>，所以只需要在<code>tail</code>之后加个<code>padding</code>即可。</p><h2>facebook spsc concurrent queue</h2><p><code>facebook</code>提供了固定大小的<code>SPSC queue</code>，代码在<code>folly</code>的<code>ProducerConsumerQueue</code>里。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cm\">/*\n</span><span class=\"cm\"> * Copyright 2017 Facebook, Inc.\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);\n</span><span class=\"cm\"> * you may not use this file except in compliance with the License.\n</span><span class=\"cm\"> * You may obtain a copy of the License at\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> *   http://www.apache.org/licenses/LICENSE-2.0\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * Unless required by applicable law or agreed to in writing, software\n</span><span class=\"cm\"> * distributed under the License is distributed on an &#34;AS IS&#34; BASIS,\n</span><span class=\"cm\"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n</span><span class=\"cm\"> * See the License for the specific language governing permissions and\n</span><span class=\"cm\"> * limitations under the License.\n</span><span class=\"cm\"> */</span>\n\n<span class=\"c1\">// @author Bo Hu (bhu@fb.com)\n</span><span class=\"c1\">// @author Jordan DeLong (delong.j@fb.com)\n</span><span class=\"c1\"></span>\n<span class=\"cp\">#pragma once\n</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;atomic&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cassert&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;memory&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdexcept&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;type_traits&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;utility&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;folly/concurrency/CacheLocality.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">namespace</span> <span class=\"n\">folly</span> <span class=\"p\">{</span>\n\n<span class=\"cm\">/*\n</span><span class=\"cm\"> * ProducerConsumerQueue is a one producer and one consumer queue\n</span><span class=\"cm\"> * without locks.\n</span><span class=\"cm\"> */</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">ProducerConsumerQueue</span> <span class=\"p\">{</span>\n  <span class=\"k\">typedef</span> <span class=\"n\">T</span> <span class=\"n\">value_type</span><span class=\"p\">;</span>\n\n  <span class=\"n\">ProducerConsumerQueue</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">ProducerConsumerQueue</span><span class=\"o\">&amp;</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">delete</span><span class=\"p\">;</span>\n  <span class=\"n\">ProducerConsumerQueue</span><span class=\"o\">&amp;</span> <span class=\"k\">operator</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">ProducerConsumerQueue</span><span class=\"o\">&amp;</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">delete</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// size must be &gt;= 2.\n</span><span class=\"c1\"></span>  <span class=\"c1\">//\n</span><span class=\"c1\"></span>  <span class=\"c1\">// Also, note that the number of usable slots in the queue at any\n</span><span class=\"c1\"></span>  <span class=\"c1\">// given time is actually (size-1), so if you start with an empty queue,\n</span><span class=\"c1\"></span>  <span class=\"c1\">// isFull() will return true after size-1 insertions.\n</span><span class=\"c1\"></span>  <span class=\"k\">explicit</span> <span class=\"nf\">ProducerConsumerQueue</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">size</span><span class=\"p\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">size_</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">)</span>\n    <span class=\"p\">,</span> <span class=\"n\">records_</span><span class=\"p\">(</span><span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">size</span><span class=\"p\">)))</span>\n    <span class=\"p\">,</span> <span class=\"n\">readIndex_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"p\">,</span> <span class=\"n\">writeIndex_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">size</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">records_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">bad_alloc</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"o\">~</span><span class=\"n\">ProducerConsumerQueue</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// We need to destruct anything that may still exist in our queue.\n</span><span class=\"c1\"></span>    <span class=\"c1\">// (No real synchronization needed at destructor time: only one\n</span><span class=\"c1\"></span>    <span class=\"c1\">// thread can be doing this.)\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">is_trivially_destructible</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">size_t</span> <span class=\"n\">readIndex</span> <span class=\"o\">=</span> <span class=\"n\">readIndex_</span><span class=\"p\">;</span>\n      <span class=\"n\">size_t</span> <span class=\"n\">endIndex</span> <span class=\"o\">=</span> <span class=\"n\">writeIndex_</span><span class=\"p\">;</span>\n      <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">readIndex</span> <span class=\"o\">!=</span> <span class=\"n\">endIndex</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">records_</span><span class=\"p\">[</span><span class=\"n\">readIndex</span><span class=\"p\">].</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">();</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">++</span><span class=\"n\">readIndex</span> <span class=\"o\">==</span> <span class=\"n\">size_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"n\">readIndex</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">records_</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> ...</span><span class=\"nc\">Args</span><span class=\"o\">&gt;</span>\n  <span class=\"kt\">bool</span> <span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Args</span><span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">recordArgs</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"k\">const</span> <span class=\"n\">currentWrite</span> <span class=\"o\">=</span> <span class=\"n\">writeIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_relaxed</span><span class=\"p\">);</span>\n    <span class=\"k\">auto</span> <span class=\"n\">nextRecord</span> <span class=\"o\">=</span> <span class=\"n\">currentWrite</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nextRecord</span> <span class=\"o\">==</span> <span class=\"n\">size_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">nextRecord</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nextRecord</span> <span class=\"o\">!=</span> <span class=\"n\">readIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n      <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">records_</span><span class=\"p\">[</span><span class=\"n\">currentWrite</span><span class=\"p\">])</span> <span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">forward</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">recordArgs</span><span class=\"p\">)...);</span>\n      <span class=\"n\">writeIndex_</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">nextRecord</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_release</span><span class=\"p\">);</span>\n      <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// queue is full\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// move (or copy) the value at the front of the queue to given variable\n</span><span class=\"c1\"></span>  <span class=\"kt\">bool</span> <span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;</span> <span class=\"n\">record</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"k\">const</span> <span class=\"n\">currentRead</span> <span class=\"o\">=</span> <span class=\"n\">readIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_relaxed</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">currentRead</span> <span class=\"o\">==</span> <span class=\"n\">writeIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// queue is empty\n</span><span class=\"c1\"></span>      <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">nextRecord</span> <span class=\"o\">=</span> <span class=\"n\">currentRead</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nextRecord</span> <span class=\"o\">==</span> <span class=\"n\">size_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">nextRecord</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">record</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">records_</span><span class=\"p\">[</span><span class=\"n\">currentRead</span><span class=\"p\">]);</span>\n    <span class=\"n\">records_</span><span class=\"p\">[</span><span class=\"n\">currentRead</span><span class=\"p\">].</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">();</span>\n    <span class=\"n\">readIndex_</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">nextRecord</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_release</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// pointer to the value at the front of the queue (for use in-place) or\n</span><span class=\"c1\"></span>  <span class=\"c1\">// nullptr if empty.\n</span><span class=\"c1\"></span>  <span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">frontPtr</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"k\">const</span> <span class=\"n\">currentRead</span> <span class=\"o\">=</span> <span class=\"n\">readIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_relaxed</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">currentRead</span> <span class=\"o\">==</span> <span class=\"n\">writeIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// queue is empty\n</span><span class=\"c1\"></span>      <span class=\"k\">return</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">&amp;</span><span class=\"n\">records_</span><span class=\"p\">[</span><span class=\"n\">currentRead</span><span class=\"p\">];</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// queue must not be empty\n</span><span class=\"c1\"></span>  <span class=\"kt\">void</span> <span class=\"n\">popFront</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"k\">const</span> <span class=\"n\">currentRead</span> <span class=\"o\">=</span> <span class=\"n\">readIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_relaxed</span><span class=\"p\">);</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">currentRead</span> <span class=\"o\">!=</span> <span class=\"n\">writeIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">));</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">nextRecord</span> <span class=\"o\">=</span> <span class=\"n\">currentRead</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nextRecord</span> <span class=\"o\">==</span> <span class=\"n\">size_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">nextRecord</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">records_</span><span class=\"p\">[</span><span class=\"n\">currentRead</span><span class=\"p\">].</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">();</span>\n    <span class=\"n\">readIndex_</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">nextRecord</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_release</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"kt\">bool</span> <span class=\"n\">isEmpty</span><span class=\"p\">()</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">readIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">)</span> <span class=\"o\">==</span>\n        <span class=\"n\">writeIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"kt\">bool</span> <span class=\"n\">isFull</span><span class=\"p\">()</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">nextRecord</span> <span class=\"o\">=</span> <span class=\"n\">writeIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nextRecord</span> <span class=\"o\">==</span> <span class=\"n\">size_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">nextRecord</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nextRecord</span> <span class=\"o\">!=</span> <span class=\"n\">readIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// queue is full\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// * If called by consumer, then true size may be more (because producer may\n</span><span class=\"c1\"></span>  <span class=\"c1\">//   be adding items concurrently).\n</span><span class=\"c1\"></span>  <span class=\"c1\">// * If called by producer, then true size may be less (because consumer may\n</span><span class=\"c1\"></span>  <span class=\"c1\">//   be removing items concurrently).\n</span><span class=\"c1\"></span>  <span class=\"c1\">// * It is undefined to call this from any other thread.\n</span><span class=\"c1\"></span>  <span class=\"n\">size_t</span> <span class=\"n\">sizeGuess</span><span class=\"p\">()</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">writeIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">)</span> <span class=\"o\">-</span>\n        <span class=\"n\">readIndex_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ret</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">ret</span> <span class=\"o\">+=</span> <span class=\"n\">size_</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n <span class=\"kt\">char</span> <span class=\"n\">pad0_</span><span class=\"p\">[</span><span class=\"n\">CacheLocality</span><span class=\"o\">::</span><span class=\"n\">kFalseSharingRange</span><span class=\"p\">];</span>\n <span class=\"k\">const</span> <span class=\"n\">uint32_t</span> <span class=\"n\">size_</span><span class=\"p\">;</span>\n <span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"k\">const</span> <span class=\"n\">records_</span><span class=\"p\">;</span>\n\n <span class=\"n\">FOLLY_ALIGN_TO_AVOID_FALSE_SHARING</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">atomic</span><span class=\"o\">&lt;</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">readIndex_</span><span class=\"p\">;</span>\n <span class=\"n\">FOLLY_ALIGN_TO_AVOID_FALSE_SHARING</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">atomic</span><span class=\"o\">&lt;</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">writeIndex_</span><span class=\"p\">;</span>\n\n <span class=\"kt\">char</span> <span class=\"n\">pad1_</span><span class=\"p\">[</span><span class=\"n\">CacheLocality</span><span class=\"o\">::</span><span class=\"n\">kFalseSharingRange</span> <span class=\"o\">-</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">writeIndex_</span><span class=\"p\">)];</span>\n<span class=\"p\">};</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p>这里就是使用环形队列来作为容器，双指针来作为头尾，读线程读取<code>readIndex</code>直接采用<code>relaxed</code>，写线程读取<code>writeIndex</code>的时候也是采取<code>relaxed</code>，因为这两个变量只会在对应的线程内修改，可以认为是对应线程的私有变量，如果要读取另外一个线程的变量则需要采取<code>acquire</code>，当然前提是修改的时候使用了<code>release</code>。为了避免<code>False Sharing</code>这里也使用了<code>padding</code>，只不过是用宏做的。</p><p>其实这里也可以做一点优化，就像前面<code>intel</code>的延迟处理<code>tail_copy</code>一样，首次读取另外一个线程变量的时候先用<code>relaxed</code>，如果发现不能操作了，则再使用<code>acquire</code>。</p><p>总的来说，这个无锁<code>spsc queue</code>也是<code>wait_free</code>的。</p><h2>moodycamel spsc concurrent queue</h2><p>moody camel 在上面的基础上做了一些改进：在支持无大小限制的情况下，将动态内存分配的需求降得很低，同时支持了容量的动态增长。其容器结构是两层的<code>queue of queue</code>，第一层是循环链表，第二层是循环队列。第一层循环链表的控制基本等价于<code>intel</code>的<code>spsc</code>里的代码，而第二层的循环队列的控制基本等价于<code>folly</code>的代码。当<code>enqueue</code>的时候，发现没有空闲内存的时候会调用<code>malloc</code>，不过这种动态内存分配比起<code>intel</code>的每个新<code>node</code>都分配来说简单多了，总的来说还是比较符合<code>wait_free</code>的。这个的代码我就不分析了，直接贴作者的解释吧。</p><div class=\"highlight\"><pre><code class=\"language-text\"># Enqueue\nIf room in tail block, add to tail\nElse check next block\n    If next block is not the head block, enqueue on next block\n    Else create a new block and enqueue there\n    Advance tail to the block we just enqueued to\n\n# Dequeue\nRemember where the tail block is\nIf the front block has an element in it, dequeue it\nElse\n    If front block was the tail block when we entered the function, return false\n    Else advance to next block and dequeue the item there</code></pre></div><h2>naive spmc concurrent queue</h2><p>在这前面介绍的<code>spsc</code>并发队列的基础上，我们可以比较容易的构建出一个<code>spmc</code>的并发队列，而构造一个<code>mpsc</code>的并发队列则难很多。其原因主要是在<code>enqueue</code>的时候，可能会涉及到动态内存分配，如果有好几个线程都抢着进行动态内存分配的话，就会出现<code>malloc</code>的锁征用。而多个线程抢占<code>dequeue</code>的时候，只需要采取<code>CAS</code>来保持<code>tail</code>的更新即可，虽说这个不是<code>waitfree</code>的，但是<code>lockfree</code>还是可以基本保证的。</p><h2>boost mpmc concurrent queue</h2><p><code>boost  concurrent queue</code>通过模板参数的方式来支持固定大小的队列和不定大小的队列。</p><p>如果是固定大小队列，则会使用一个带<code>dummy head</code>的<code>ring buffer</code>来存储内容，同时使用一个头节点索引和一个尾节点索引来标记队列的头尾位置。为了一次性的修改头尾节点索引，这里将队列大小的上限设置为了$2^{16} - 2$  ，这样两个索引就可以合并为一个<code>int32</code> 来处理，修改的时候可以使用<code>compare_exchange_</code>来同时修改。如果在支持<code>int64</code>类型的<code>compare_exchange_</code>操作的平台，队列大小的上限可以放到$2^{32} -2$ ，同时两个索引会被压缩为一个<code>int64</code>来做同时修改。</p><p>如果是不定大小的队列，则会使用链表的形式来维持队列结构, 代码见下。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">struct</span> <span class=\"n\">BOOST_LOCKFREE_CACHELINE_ALIGNMENT</span> <span class=\"n\">node</span>\n <span class=\"p\">{</span>\n   <span class=\"k\">typedef</span> <span class=\"k\">typename</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">select_tagged_handle</span><span class=\"o\">&lt;</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">node_based</span><span class=\"o\">&gt;::</span><span class=\"n\">tagged_handle_type</span> <span class=\"n\">tagged_node_handle</span><span class=\"p\">;</span>\n   <span class=\"k\">typedef</span> <span class=\"k\">typename</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">select_tagged_handle</span><span class=\"o\">&lt;</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">node_based</span><span class=\"o\">&gt;::</span><span class=\"n\">handle_type</span> <span class=\"n\">handle_type</span><span class=\"p\">;</span>\n\n   <span class=\"n\">node</span><span class=\"p\">(</span><span class=\"n\">T</span> <span class=\"k\">const</span> <span class=\"o\">&amp;</span> <span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">handle_type</span> <span class=\"n\">null_handle</span><span class=\"p\">)</span><span class=\"o\">:</span>\n   <span class=\"n\">data</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"c1\">//, next(tagged_node_handle(0, 0))\n</span><span class=\"c1\"></span>   <span class=\"p\">{</span>\n     <span class=\"cm\">/* increment tag to avoid ABA problem */</span>\n     <span class=\"n\">tagged_node_handle</span> <span class=\"n\">old_next</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">memory_order_relaxed</span><span class=\"p\">);</span>\n     <span class=\"n\">tagged_node_handle</span> <span class=\"nf\">new_next</span> <span class=\"p\">(</span><span class=\"n\">null_handle</span><span class=\"p\">,</span> <span class=\"n\">old_next</span><span class=\"p\">.</span><span class=\"n\">get_next_tag</span><span class=\"p\">());</span>\n     <span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">new_next</span><span class=\"p\">,</span> <span class=\"n\">memory_order_release</span><span class=\"p\">);</span>\n   <span class=\"p\">}</span>\n\n   <span class=\"n\">node</span> <span class=\"p\">(</span><span class=\"n\">handle_type</span> <span class=\"n\">null_handle</span><span class=\"p\">)</span><span class=\"o\">:</span>\n   <span class=\"n\">next</span><span class=\"p\">(</span><span class=\"n\">tagged_node_handle</span><span class=\"p\">(</span><span class=\"n\">null_handle</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n   <span class=\"p\">{}</span>\n\n   <span class=\"n\">node</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n   <span class=\"p\">{}</span>\n\n   <span class=\"n\">atomic</span><span class=\"o\">&lt;</span><span class=\"n\">tagged_node_handle</span><span class=\"o\">&gt;</span> <span class=\"n\">next</span><span class=\"p\">;</span>\n   <span class=\"n\">T</span> <span class=\"n\">data</span><span class=\"p\">;</span>\n <span class=\"p\">};</span>\n</code></pre></div><p>这里比较有意思的就是第九行的注释：对指针的<code>tag</code>位置进行自增来避免<code>ABA</code>问题。这里的<code>next</code>指针是一个<code>tagged_pointer</code>，其分配位置是内存对齐的，对齐的大小由<code>BOOST_LOCKFREE_CACHELINE_BYTES</code>定义，在<code>WIN</code>平台下，这个宏定义如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#define BOOST_LOCKFREE_CACHELINE_BYTES 64\n</span><span class=\"cp\">#ifdef _MSC_VER\n</span><span class=\"cp\">#define BOOST_LOCKFREE_CACHELINE_ALIGNMENT __declspec(align(BOOST_LOCKFREE_CACHELINE_BYTES))\n</span></code></pre></div><p>当这个指针是64字节对齐时，最底的6位是没有意义的，所以这6位我们可以用来存储额外的数据，这种指针就叫做<code>tagged_pointer</code>，在<code>llvm</code>里这个指针结构也很常见。</p><p>在<code>boost lockfree queue</code>里，数据成员定义如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">typedef</span> <span class=\"k\">typename</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">queue_signature</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"o\">&lt;</span><span class=\"n\">A0</span><span class=\"p\">,</span> <span class=\"n\">A1</span><span class=\"p\">,</span> <span class=\"n\">A2</span><span class=\"o\">&gt;::</span><span class=\"n\">type</span> <span class=\"n\">bound_args</span><span class=\"p\">;</span>\n<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">bool</span> <span class=\"n\">has_capacity</span> <span class=\"o\">=</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">extract_capacity</span><span class=\"o\">&lt;</span><span class=\"n\">bound_args</span><span class=\"o\">&gt;::</span><span class=\"n\">has_capacity</span><span class=\"p\">;</span>\n<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"n\">size_t</span> <span class=\"n\">capacity</span> <span class=\"o\">=</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">extract_capacity</span><span class=\"o\">&lt;</span><span class=\"n\">bound_args</span><span class=\"o\">&gt;::</span><span class=\"n\">capacity</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">// the queue uses one dummy node\n</span><span class=\"c1\"></span><span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">bool</span> <span class=\"n\">fixed_sized</span> <span class=\"o\">=</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">extract_fixed_sized</span><span class=\"o\">&lt;</span><span class=\"n\">bound_args</span><span class=\"o\">&gt;::</span><span class=\"n\">value</span><span class=\"p\">;</span>\n<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">bool</span> <span class=\"n\">node_based</span> <span class=\"o\">=</span> <span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">has_capacity</span> <span class=\"o\">||</span> <span class=\"n\">fixed_sized</span><span class=\"p\">);</span>\n<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">bool</span> <span class=\"n\">compile_time_sized</span> <span class=\"o\">=</span> <span class=\"n\">has_capacity</span><span class=\"p\">;</span>\n<span class=\"k\">typedef</span> <span class=\"k\">typename</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">extract_allocator</span><span class=\"o\">&lt;</span><span class=\"n\">bound_args</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"o\">&gt;::</span><span class=\"n\">type</span> <span class=\"n\">node_allocator</span><span class=\"p\">;</span>\n<span class=\"k\">typedef</span> <span class=\"k\">typename</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">select_freelist</span><span class=\"o\">&lt;</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">node_allocator</span><span class=\"p\">,</span> <span class=\"n\">compile_time_sized</span><span class=\"p\">,</span> <span class=\"n\">fixed_sized</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"o\">&gt;::</span><span class=\"n\">type</span> <span class=\"n\">pool_t</span><span class=\"p\">;</span>\n<span class=\"k\">typedef</span> <span class=\"k\">typename</span> <span class=\"n\">pool_t</span><span class=\"o\">::</span><span class=\"n\">tagged_node_handle</span> <span class=\"n\">tagged_node_handle</span><span class=\"p\">;</span>\n<span class=\"k\">typedef</span> <span class=\"k\">typename</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">select_tagged_handle</span><span class=\"o\">&lt;</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">node_based</span><span class=\"o\">&gt;::</span><span class=\"n\">handle_type</span> <span class=\"n\">handle_type</span><span class=\"p\">;</span>\n\n<span class=\"n\">atomic</span><span class=\"o\">&lt;</span><span class=\"n\">tagged_node_handle</span><span class=\"o\">&gt;</span> <span class=\"n\">head_</span><span class=\"p\">;</span>\n<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">padding_size</span> <span class=\"o\">=</span> <span class=\"n\">BOOST_LOCKFREE_CACHELINE_BYTES</span> <span class=\"o\">-</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">tagged_node_handle</span><span class=\"p\">);</span>\n<span class=\"kt\">char</span> <span class=\"n\">padding1</span><span class=\"p\">[</span><span class=\"n\">padding_size</span><span class=\"p\">];</span>\n<span class=\"n\">atomic</span><span class=\"o\">&lt;</span><span class=\"n\">tagged_node_handle</span><span class=\"o\">&gt;</span> <span class=\"n\">tail_</span><span class=\"p\">;</span>\n<span class=\"kt\">char</span> <span class=\"n\">padding2</span><span class=\"p\">[</span><span class=\"n\">padding_size</span><span class=\"p\">];</span>\n<span class=\"n\">pool_t</span> <span class=\"n\">pool</span><span class=\"p\">;</span> <span class=\"c1\">//代表node的pool 可以当作内存分配器\n</span></code></pre></div><p>因为<code>atomic&lt;T*&gt;</code>内部只包含一个<code>T*</code>作为成员变量，所以<code>atomic&lt;T*&gt;</code>与<code>T*</code>的内存布局是一样的，所以这里的<code>padding_size</code>才会这样计算出来。这里的<code>padding</code>的意义在于让<code>poll</code>的开始地址是<code>BOOST_LOCKFREE_CACHELINE_BYTES</code>对齐的，同时这里分为了两个<code>padding</code>而不是一个<code>padding</code>主要是考虑到将<code>tail head</code>分离在两个<code>cache_line</code>上，避免不同线程之间的缓存竞争。</p><p>现在我们来看这个<code>lockfree queue</code>提供的接口。</p><p>首先查看<code>empty</code>。</p><div class=\"highlight\"><pre><code class=\"language-text\">/** Check if the queue is empty\n*\n* \\return true, if the queue is empty, false otherwise\n* \\note The result is only accurate, if no other thread modifies the queue. Therefore it is rarely practical to use this\n*       value in program logic.\n* */\nbool empty(void)\n{\nreturn pool.get_handle(head_.load()) == pool.get_handle(tail_.load());\n}</code></pre></div><p>注释里写的很清楚了，这个函数的返回值是不准确的，因为在没有锁的情况下无法同时获得<code>head tail</code>的准确值。</p><p>现在来看<code>push</code>，这里分为了两个接口<code>push bounded_push</code>，区分在于如果内存池已经用完，第一个<code>push</code>在当前队列是大小固定的情况下会返回<code>false</code>，不固定的情况下会向操作系统尝试申请更多的内存并返回；而第二个<code>bounded_push</code>则直接返回<code>false</code>。</p><div class=\"highlight\"><pre><code class=\"language-text\">/** Pushes object t to the queue.\n*\n* \\post object will be pushed to the queue, if internal node can be allocated\n* \\returns true, if the push operation is successful.\n*\n* \\note Thread-safe. If internal memory pool is exhausted and the memory pool is not fixed-sized, a new node will be allocated\n*                    from the OS. This may not be lock-free.\n* */\nbool push(T const &amp; t)\n{\n    return do_push&lt;false&gt;(t);\n}\n\n/** Pushes object t to the queue.\n*\n* \\post object will be pushed to the queue, if internal node can be allocated\n* \\returns true, if the push operation is successful.\n*\n* \\note Thread-safe and non-blocking. If internal memory pool is exhausted, operation will fail\n* \\throws if memory allocator throws\n* */\nbool bounded_push(T const &amp; t)\n{\n    return do_push&lt;true&gt;(t);\n}</code></pre></div><p>这两个函数都调用了<code>do_push</code>，这个函数的定义如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"kt\">bool</span> <span class=\"n\">Bounded</span><span class=\"o\">&gt;</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">do_push</span><span class=\"p\">(</span><span class=\"n\">T</span> <span class=\"k\">const</span> <span class=\"o\">&amp;</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">using</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">likely</span><span class=\"p\">;</span>\n\n        <span class=\"n\">node</span> <span class=\"o\">*</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"k\">template</span> <span class=\"n\">construct</span><span class=\"o\">&lt;</span><span class=\"nb\">true</span><span class=\"p\">,</span> <span class=\"n\">Bounded</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">null_handle</span><span class=\"p\">());</span>\n        <span class=\"n\">handle_type</span> <span class=\"n\">node_handle</span> <span class=\"o\">=</span> <span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_handle</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n\n        <span class=\"k\">for</span> <span class=\"p\">(;;)</span> <span class=\"p\">{</span>\n            <span class=\"n\">tagged_node_handle</span> <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">tail_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n            <span class=\"n\">node</span> <span class=\"o\">*</span> <span class=\"n\">tail_node</span> <span class=\"o\">=</span> <span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_pointer</span><span class=\"p\">(</span><span class=\"n\">tail</span><span class=\"p\">);</span>\n            <span class=\"n\">tagged_node_handle</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">tail_node</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n            <span class=\"n\">node</span> <span class=\"o\">*</span> <span class=\"n\">next_ptr</span> <span class=\"o\">=</span> <span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_pointer</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">);</span>\n\n            <span class=\"n\">tagged_node_handle</span> <span class=\"n\">tail2</span> <span class=\"o\">=</span> <span class=\"n\">tail_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">likely</span><span class=\"p\">(</span><span class=\"n\">tail</span> <span class=\"o\">==</span> <span class=\"n\">tail2</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">next_ptr</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                    <span class=\"n\">tagged_node_handle</span> <span class=\"n\">new_tail_next</span><span class=\"p\">(</span><span class=\"n\">node_handle</span><span class=\"p\">,</span> <span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">get_next_tag</span><span class=\"p\">());</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">tail_node</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">compare_exchange_weak</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">,</span> <span class=\"n\">new_tail_next</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"p\">{</span>\n                        <span class=\"n\">tagged_node_handle</span> <span class=\"n\">new_tail</span><span class=\"p\">(</span><span class=\"n\">node_handle</span><span class=\"p\">,</span> <span class=\"n\">tail</span><span class=\"p\">.</span><span class=\"n\">get_next_tag</span><span class=\"p\">());</span>\n                        <span class=\"n\">tail_</span><span class=\"p\">.</span><span class=\"n\">compare_exchange_strong</span><span class=\"p\">(</span><span class=\"n\">tail</span><span class=\"p\">,</span> <span class=\"n\">new_tail</span><span class=\"p\">);</span>\n                        <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n                    <span class=\"p\">}</span>\n                <span class=\"p\">}</span>\n                <span class=\"k\">else</span> <span class=\"p\">{</span>\n                    <span class=\"n\">tagged_node_handle</span> <span class=\"n\">new_tail</span><span class=\"p\">(</span><span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_handle</span><span class=\"p\">(</span><span class=\"n\">next_ptr</span><span class=\"p\">),</span> <span class=\"n\">tail</span><span class=\"p\">.</span><span class=\"n\">get_next_tag</span><span class=\"p\">());</span>\n                    <span class=\"n\">tail_</span><span class=\"p\">.</span><span class=\"n\">compare_exchange_strong</span><span class=\"p\">(</span><span class=\"n\">tail</span><span class=\"p\">,</span> <span class=\"n\">new_tail</span><span class=\"p\">);</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n</code></pre></div><p>这里比较难理解的一点就是<code>tail tail2</code>，以及最后30行的<code>compare_exchange_strong</code>。这里在19行使用判断的意义是避免在内部做无用功，虽然不使用19行的判断， <code>tail</code>改变之后，20行所在分支的检测都会<code>fail</code>掉，对正确性没影响，对性能上来说提升很大。在一个完整的成功<code>push</code>流程中有两个<code>cas</code>操作，我们需要担心的是在两个<code>cas</code>操作之间线程被换出之后会出现何种结果，也就是在24行之前被换出。此时老的<code>tail</code>的<code>next</code>已经被修正为了新数据，而新<code>tail</code>却没有更新。在下一个线程进来的时候会发现<code>tail-&gt;next != 0</code>， 因此会进28号的分支，在此分支之内会尝试将<code>tail-&gt;next</code>更新为<code>tail</code>，这样就避免了数据更新到一半的尴尬局面。</p><p>对于<code>pop</code>则只有一个函数:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cm\">/** Pops object from queue.\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * \\pre type U must be constructible by T and copyable, or T must be convertible to U\n</span><span class=\"cm\">     * \\post if pop operation is successful, object will be copied to ret.\n</span><span class=\"cm\">     * \\returns true, if the pop operation is successful, false if queue was empty.\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * \\note Thread-safe and non-blocking\n</span><span class=\"cm\">     * */</span>\n    <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">U</span><span class=\"o\">&gt;</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">pop</span> <span class=\"p\">(</span><span class=\"n\">U</span> <span class=\"o\">&amp;</span> <span class=\"n\">ret</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">using</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">likely</span><span class=\"p\">;</span>\n        <span class=\"k\">for</span> <span class=\"p\">(;;)</span> <span class=\"p\">{</span>\n            <span class=\"n\">tagged_node_handle</span> <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">head_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n            <span class=\"n\">node</span> <span class=\"o\">*</span> <span class=\"n\">head_ptr</span> <span class=\"o\">=</span> <span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_pointer</span><span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">);</span>\n\n            <span class=\"n\">tagged_node_handle</span> <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">tail_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n            <span class=\"n\">tagged_node_handle</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">head_ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n            <span class=\"n\">node</span> <span class=\"o\">*</span> <span class=\"n\">next_ptr</span> <span class=\"o\">=</span> <span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_pointer</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">);</span>\n\n            <span class=\"n\">tagged_node_handle</span> <span class=\"n\">head2</span> <span class=\"o\">=</span> <span class=\"n\">head_</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">memory_order_acquire</span><span class=\"p\">);</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">likely</span><span class=\"p\">(</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"n\">head2</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_handle</span><span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_handle</span><span class=\"p\">(</span><span class=\"n\">tail</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">next_ptr</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n                        <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n\n                    <span class=\"n\">tagged_node_handle</span> <span class=\"nf\">new_tail</span><span class=\"p\">(</span><span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_handle</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">),</span> <span class=\"n\">tail</span><span class=\"p\">.</span><span class=\"n\">get_next_tag</span><span class=\"p\">());</span>\n                    <span class=\"n\">tail_</span><span class=\"p\">.</span><span class=\"n\">compare_exchange_strong</span><span class=\"p\">(</span><span class=\"n\">tail</span><span class=\"p\">,</span> <span class=\"n\">new_tail</span><span class=\"p\">);</span>\n\n                <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">next_ptr</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n                        <span class=\"cm\">/* this check is not part of the original algorithm as published by michael and scott\n</span><span class=\"cm\">                         *\n</span><span class=\"cm\">                         * however we reuse the tagged_ptr part for the freelist and clear the next part during node\n</span><span class=\"cm\">                         * allocation. we can observe a null-pointer here.\n</span><span class=\"cm\">                         * */</span>\n                        <span class=\"k\">continue</span><span class=\"p\">;</span>\n                    <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">copy_payload</span><span class=\"p\">(</span><span class=\"n\">next_ptr</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">ret</span><span class=\"p\">);</span>\n\n                    <span class=\"n\">tagged_node_handle</span> <span class=\"nf\">new_head</span><span class=\"p\">(</span><span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"n\">get_handle</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">),</span> <span class=\"n\">head</span><span class=\"p\">.</span><span class=\"n\">get_next_tag</span><span class=\"p\">());</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">head_</span><span class=\"p\">.</span><span class=\"n\">compare_exchange_weak</span><span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"n\">new_head</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n                        <span class=\"n\">pool</span><span class=\"p\">.</span><span class=\"k\">template</span> <span class=\"n\">destruct</span><span class=\"o\">&lt;</span><span class=\"nb\">true</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">);</span>\n                        <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n                    <span class=\"p\">}</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n</code></pre></div><p>这里就简单多了，成功的<code>pop</code>只需要一个<code>compare_exchange_weak</code>即可，所以就不需要担心数据更改到一半的问题，这里的28行处理的还是<code>tail</code>数据更新到一半的问题。</p><p>这里比较有意思的一点就是42行的<code>.template</code>，这个叫做<a href=\"https://link.zhihu.com/?target=http%3A//en.cppreference.com/w/cpp/language/dependent_name\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">template disambiguator</a>， 其作用就是通知编译器<code>destruct&lt;true&gt;</code>是一个模板，而不是<code>destruct &lt; true</code> 。</p><p>总的来说， <code>boost lockfree queue</code>的注意点完全在<code>lock free</code>上，并没有采取每个生产者单独一个<code>queue</code>的方式来解决争用，虽然我们可以在<code>lockfree queue</code>的基础上做一个这样的东西。</p><h2>intel tbb concurrent queue</h2><p>其实这个的总体实现与boost类似。占坑，以后填。粗看起来，这个东西的实现很具有<code>STL</code>的风格。</p><h2>moodycamel concurrent queue</h2><p>这个<code>concurrent queue</code>的实现被很多项目使用过， 值得重点分析。这个实现的突出之处在于，每个生产者都维持自己的专属<code>queue</code>，而不同的消费者会以不同的顺序去访问各个生产者的<code>queue</code>，直到遇到一个不为空的<code>queue</code>。简而言之，他所实现的<code>MPMC(multiple producer multiple consumer)</code>的队列建立在了<code>SPMC</code>的多线程队列的基础上。这个<code>SPMC</code>的实现是<code>lockfree</code>的，同时还增加了<code>bulk</code>操作。下面来慢慢介绍这个的设计。</p><p>首先就是在构建消费者的时候，尽可能的让消费者与生产者均衡绑定，内部实现是通过使用一个<code>token</code>来维持消费者与生产者之间的亲和性。其实最简单的亲和性分配的方法就是每个消费者分配一个生产者的编号，<code>dequeue</code>的时候采取轮询的方式，每次开始轮询的时候都以上次<code>dequeue</code>成功的生产者<code>queue</code>开始。</p><p>处理完了多生产者多消费者之间的映射，现在剩下的内容就是如何更高效的处理单生产者多消费者。moodycamel这里的主要改进就是单个<code>queue</code>的存储结构，这里采取的是两层的循环队列，第一层循环队列存储的是第二层循环队列的指针。一个队列只需要维护四个索引，考虑到原子性修改可以把消费者的两个索引合并为一个<code>uint64</code>或者<code>uint32t</code>，因为只有消费者会发生数据竞争，为了方便比较，也顺便把生产者的两个索引合并为一个<code>uint64t or uint32t</code>，这样就可以直接使用整数比较了。在<code>enqueue</code>的时候，数据复制完成之后，直接对生产者的索引自增即可。而<code>dequeue</code>的时候则没这么容易，此时首先自增消费者索引，然后判断当前消费者索引是否已经越过生产者索引，如果越过了，则对则对另外一个<code>overcommit</code>计数器进行自增，三个计数器合用才能获得真正的容量。</p><p>这里使用环形缓冲来扩容而不是采取列表来扩容，主要是因为连续的空间操作可以支持批量的<code>enqueue</code>和<code>dequeue</code>操作，直接预先占据一些索引就行了。</p><p>未完待续······················</p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "并行编程", 
                    "tagLink": "https://api.zhihu.com/topics/19580226"
                }
            ], 
            "comments": [
                {
                    "userName": "欧流全", 
                    "userLink": "https://www.zhihu.com/people/17bea0479e8eee1bc6fef3d05d096760", 
                    "content": "<p>moodycamel concurrent queue的效果实际测试也是最好的</p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "D Flip Flop", 
                    "userLink": "https://www.zhihu.com/people/83180a73aba7c2ac396197a14ece1dc1", 
                    "content": "如果是这种队列里扔任务的并行模式的话，最好支持batched enqueue / dequeue。核多的时候原子操作也会要命的。", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "黄瓜瓜", 
                    "userLink": "https://www.zhihu.com/people/53854b6a3e64a17532f75e9906d72e0c", 
                    "content": "写得很好👍", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "比较好的实现应该是一个M个生产者N个消费者的MPMC队列基于M*N个SPSC队列来实现，多核竞争激烈时其它方案蜕化都很厉害", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55503053", 
            "userName": "千寻", 
            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
            "upvote": 183, 
            "title": "Asio实现浅析", 
            "content": "<h2>Asio 介绍</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//think-async.com/Asio\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Asio</a>是一个建立在<a href=\"https://link.zhihu.com/?target=http%3A//www.boost.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Boost</a>所提供的相关组件之上的异步的网络库，可以运行在<code>Win/Linux/Unix</code>等各种平台之上。不过随着C++11的发布，其对于Boost的依赖也越来越少，作者又做了一个不依赖于boost的版本。对于Asio所提供的功能以及整体架构，可以从下图中可窥一斑：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-56fcbcb0ebf1c3ff9f06e036e9400097_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"509\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"509\" data-original=\"https://pic4.zhimg.com/v2-56fcbcb0ebf1c3ff9f06e036e9400097_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;509&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"509\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"509\" data-original=\"https://pic4.zhimg.com/v2-56fcbcb0ebf1c3ff9f06e036e9400097_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-56fcbcb0ebf1c3ff9f06e036e9400097_b.jpg\"/></figure><h2>网络IO模型</h2><p>在W. Richard Stevens 的Unix Network Programming中， 谈到了5种IO模型：</p><ul><li> 阻塞 blocking ,当前线程发出IO请求后阻塞在等待IO就绪，然后再发去数据复制请求，然后再阻塞在等待数据拷贝完成；<br/> </li><li> 非阻塞 non-blocking，不停的调用recv_some 或send_some，每次都能progress一点，最后仍然会在data copy这里阻塞在系统调用上；<br/> </li><li> IO多路复用 IO multiplexing，基本类似于blocking，只不过一个线程可以同时处理多个socket的请求，也就是所谓的线程复用了；<br/> </li><li> 异步 asynchronouse，线程提交IO请求之后直接返回，系统在执行完IO请求并复制到用户提供的数据区之后再通知完成<br/> </li><li> 信号驱动 singal-driven，没啥用，不说了<br/> </li></ul><p>总的来说，这几种IO模型下，线程的运行状态如下图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c7aa769540ac4c22d37faa8da4e492bb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb\" width=\"614\" data-original=\"https://pic4.zhimg.com/v2-c7aa769540ac4c22d37faa8da4e492bb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;614&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"614\" data-original=\"https://pic4.zhimg.com/v2-c7aa769540ac4c22d37faa8da4e492bb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c7aa769540ac4c22d37faa8da4e492bb_b.jpg\"/></figure><p>在三个主流的操作系统平台中，都采用了各自的主流IO模型。Windows上采用的的是IOCP,Linux上采用的是Epoll,Unix上采用的是kqueue。Asio通过一个中间层来实现在各个不同的平台上调用不同的底层实现。所以，为了更好的理解Asio，首先需要了解这几种不同的IO多路复用的机制。在此我只对IOCP和Epoll做一些介绍，kqueue因为不熟所以忽略。</p><h2>IOCP</h2><p>IOCP的全称是<code>IO Completion Port</code>，中文名叫做I/O完成端口。其模型简要来说就是：客户向操作系统提交IO任务，操作系统执行客户所发出的各项IO请求，在完成IO请求之后操作系统将对应的IO任务提交到完成队列中，同时一个线程池不断的监听该完成队列中是否有消息。具体的完成之后的业务逻辑依赖于线程池中的具体代码，系统提供的主要功能是这个完成队列。</p><p>在Windows，与IOCP关联最紧密的API主要有三个，分别是<code>CreateIoCompletionPort, GetQueuedCompletionStatus, PostQueueCompeltionStatus</code>。</p><p><code>CreateIoCompletionPort</code>的作用是建立一个IO完成端口，其函数签名如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">HANDLE</span>   <span class=\"nf\">CreateIoCompletionPort</span>   <span class=\"p\">(</span>   \n      <span class=\"n\">HANDLE</span>   <span class=\"n\">FileHandle</span><span class=\"p\">,</span>                                 <span class=\"c1\">//   handle   to   file   \n</span><span class=\"c1\"></span>      <span class=\"n\">HANDLE</span>   <span class=\"n\">ExistingCompletionPort</span><span class=\"p\">,</span>           <span class=\"c1\">//   handle   to   I/O   completion   port   \n</span><span class=\"c1\"></span>      <span class=\"n\">ULONG_PTR</span>   <span class=\"n\">CompletionKey</span><span class=\"p\">,</span>                 <span class=\"c1\">//   completion   key   \n</span><span class=\"c1\"></span>      <span class=\"n\">DWORD</span>   <span class=\"n\">NumberOfConcurrentThreads</span>   <span class=\"c1\">//   number   of   threads   to   execute   concurrently   \n</span><span class=\"c1\"></span>  <span class=\"p\">);</span>\n</code></pre></div><p>这个函数需要注意的是：他同时承担着建立完成端口和将设备绑定到完成端口这两个任务。当这个函数用于建立一个新的完成端口时，其参数调用是这样的：</p><div class=\"highlight\"><pre><code class=\"language-text\">CreateIoCompletionPort(INVALID_HANDLE_VALUE, nullptr, 0, 0)</code></pre></div><p>这里的<code>INVALID_HANDLE_VALUE</code>的值其实是-1。简而言之呢，如果我们给他的都是一些无效的值，则这个函数会创建一个新的完成端口。最后一个参数是代表的是允许应用程序同时执行的线程数量。需要注意的是，这个参数并不是我们线程池中线程的数量，而是完成端口允许的活动线程的数量。如果设置为0，就是说有多少个处理器，就允许同时多少个线程运行，这样就可以避免频繁的上下文切换。至于真正执行任务的线程池，需要我们自己设置线程数量，folklore说一般设置为<code>2*cpu+2</code>个工作线程。</p><p>如果我们想将一个IO设备绑定到现有的完成端口之上，则需要以另外的形式调用<code>CreateIoCompletionPort</code>。当前我们需要处理网络事件，因此需要将socket作为HANDLE和一个完成键（对你有意义的一个32位值，也就是一个指针， 操作系统并不关心你传什么）传进去。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">CreateIoCompletionPort</span><span class=\"p\">(</span><span class=\"n\">ioHandle</span><span class=\"p\">,</span> <span class=\"n\">iocp</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">ULONG_PTR</span><span class=\"p\">)</span><span class=\"n\">fn</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n</code></pre></div><p>每当你向端口关联一个设备时，系统向该完成端口的设备列表中加入一条信息纪录。   </p><p>一个函数来做两件事这种设计很不好！</p><p><code>GetQueuedCompletionStatus</code>是用来处理IO完成事件的，其函数签名如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">BOOL</span> <span class=\"n\">WINAPI</span> <span class=\"nf\">GetQueuedCompletionStatus</span><span class=\"p\">(</span>  \n  <span class=\"n\">__in</span>   <span class=\"n\">HANDLE</span>          <span class=\"n\">CompletionPort</span><span class=\"p\">,</span>    <span class=\"c1\">// 这个就是我们建立的那个唯一的完成端口   \n</span><span class=\"c1\"></span>  <span class=\"n\">__out</span>  <span class=\"n\">LPDWORD</span>         <span class=\"n\">lpNumberOfBytes</span><span class=\"p\">,</span>   <span class=\"c1\">//这个是操作完成后返回的字节数   \n</span><span class=\"c1\"></span>  <span class=\"n\">__out</span>  <span class=\"n\">PULONG_PTR</span>      <span class=\"n\">lpCompletionKey</span><span class=\"p\">,</span>   <span class=\"c1\">// 这个是我们建立完成端口的时候绑定的那个自定义结构体参数   \n</span><span class=\"c1\"></span>  <span class=\"n\">__out</span>  <span class=\"n\">LPOVERLAPPED</span>    <span class=\"o\">*</span><span class=\"n\">lpOverlapped</span><span class=\"p\">,</span>     <span class=\"c1\">// 这个是我们在连入Socket的时候一起建立的那个重叠结构   \n</span><span class=\"c1\"></span>  <span class=\"n\">__in</span>   <span class=\"n\">DWORD</span>           <span class=\"n\">dwMilliseconds</span>     <span class=\"c1\">// 等待完成端口的超时时间，如果线程不需要做其他的事情，那就INFINITE就行了   \n</span><span class=\"c1\"></span>   <span class=\"p\">);</span>\n</code></pre></div><p><code>GetQueuedCompletionStatus</code>使调用线程挂起，放入到等待线程队列中，直到指定的端口的I/O完成队列中出现了一项或直到超时。</p><ul><li> 当有任务成功时，返回TRUE，<code>dwCompletionKey</code>返回调用<code>CreateIOCompletionPort</code>将I/O设备（比如文件，套接字等等）句柄关联到完成端口时提供的<code>dwCompletionKey</code>参数,<code>lpOverlapped</code>返回异步调用时提供的<code>lpOverlapped</code>参数，<code>nBytesTransferred</code>返回写入或读取的字节数。<br/> </li><li> 当没有任务完成，也没有任务出现错误时，返回FALSE。<code>lpOverlapped</code>被设置为nil。调用<code>GetLastError</code>可以得到更详细的原因，如果<code>GetLastError</code>返回<code>WAIT_TIMEOUT</code>,表明超时了，如果是其他错误，可以查MSDN上的系统错误码，了解原因。<br/> </li><li> 如果有任务失败了，返回FALSE。<code>dwCompletionKey</code>和<code>lpOverlapped</code>的设置情况跟第一种结果一样。<code>GetLastError</code>返回任务失败的原因。对于<code>Winsock2</code>的<code>WSARecv</code>调用，如果<code>GetLastError</code>返回<code>ERROR_NETNAME_DELETED</code>，表示连接被通讯的另一方复位或者异常中断了，比如对方死机，此时应关闭套接字。对于<code>Winsock2</code>的<code>ConnectEx</code>调用，如果<code>GetLastError</code>返回<code>ERROR_CONNECTION_REFUSED</code>，表示远端主机没有在这一端口进行监听；如果返回<code>ERROR_HOST_UNREACHABLE</code>，表示网络不通。<br/> </li></ul><p>这里的线程等待队列其实不是一个队列，而是一个栈，后进先出。这样如果反复只有一个I/O操作而不是多个操作完成的话，内核就只需要唤醒同一个线程就可以了，而不需要轮着唤醒多个线程，节约了资源，而且可以把其他长时间睡眠的线程换出内存，提到资源利用率。</p><p><code>PostQueueCompeltionStatus</code>是用来通知完成端口的线程退出的函数，其函数签名如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">BOOL</span> <span class=\"n\">WINAPI</span> <span class=\"nf\">PostQueuedCompletionStatus</span><span class=\"p\">(</span>  \n   <span class=\"n\">__in</span>      <span class=\"n\">HANDLE</span> <span class=\"n\">CompletionPort</span><span class=\"p\">,</span>  \n   <span class=\"n\">__in</span>      <span class=\"n\">DWORD</span> <span class=\"n\">dwNumberOfBytesTransferred</span><span class=\"p\">,</span>  \n   <span class=\"n\">__in</span>      <span class=\"n\">ULONG_PTR</span> <span class=\"n\">dwCompletionKey</span><span class=\"p\">,</span>  \n   <span class=\"n\">__in_opt</span>  <span class=\"n\">LPOVERLAPPED</span> <span class=\"n\">lpOverlapped</span>  \n<span class=\"p\">);</span>\n</code></pre></div><p>这个函数的参数几乎和<code>GetQueuedCompletionStatus()</code>的一模一样，都是需要把我们建立的完成端口传进去，然后后面的三个参数是 传输字节数、结构体参数、重叠结构的指针。可以理解为一个是完成队列的push操作，一个是完成队列的pop操作。我们在push是加上一些标志性的参数，使得工作线程在检查结果时遇到这些参数就直接退出工作。因此，对于每一个工作线程，我们都需要push一次，即调用<code>PostQueuedCompletionStatus</code>一次：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">m_nThreads</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>  \n<span class=\"p\">{</span>  \n      <span class=\"n\">PostQueuedCompletionStatus</span><span class=\"p\">(</span><span class=\"n\">m_hIOCompletionPort</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">DWORD</span><span class=\"p\">)</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>  \n<span class=\"p\">}</span>\n</code></pre></div><p>综上，一个使用IOCP的接收服务器的整体工作流程可以以下图概括：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6d8aac75a07e8b45df130f528b81b346_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"642\" class=\"origin_image zh-lightbox-thumb\" width=\"868\" data-original=\"https://pic3.zhimg.com/v2-6d8aac75a07e8b45df130f528b81b346_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;868&#39; height=&#39;642&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"642\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"868\" data-original=\"https://pic3.zhimg.com/v2-6d8aac75a07e8b45df130f528b81b346_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6d8aac75a07e8b45df130f528b81b346_b.jpg\"/></figure><h2>Epoll</h2><p>在谈到epoll时，不得不谈他的演化史，即select-poll-epoll。这三者都是linux上的多路复用机制，通过监听描述符的就绪态来通知程序进行读写。其工作流程见下图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3ce62466174795f841b3cd2316cf1c32_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-3ce62466174795f841b3cd2316cf1c32_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;632&#39; height=&#39;368&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-3ce62466174795f841b3cd2316cf1c32_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3ce62466174795f841b3cd2316cf1c32_b.jpg\"/></figure><p>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间，正如前面提到的IOCP。</p><p>在调用select时，我们需要提供三个fd_set，分别代表可读、可写、可错三个感兴趣的文件描述符列表。调用时我们需要将这些fd_set 考入内核空间，然后对于每个fd都调用其poll方法来查看其是否就绪。如果有就绪的fd则直接返回，否则当前线程休眠直到timeout，timeout唤醒之后再扫描一遍fd_set查看是否有就绪fd，然后直接返回。返回时需要把fd_set从内核拷贝到用户空间中，这个fs_set的长度最大为1024。</p><p>poll相对与select的改进就是不再采用三个fd_set，而是采取了一个单独的pollfd来存储所有涉及到的文件描述符以及每个描述符上感兴趣的事件，并通过链表将所有的pollfd连接起来，因此fd的大小不再受限。但是select所拥有的缺点poll仍然完美的继承了下来：</p><ul><li> 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大;<br/> </li><li> 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大;<br/> </li></ul><p>而epoll的改进则更彻底一些，他提供了三个函数<code>epoll_create,epoll_ctl,epoll_wait</code>。<code>epoll_create</code>是创建一个epoll句柄；<code>epoll_ctl</code>是注册要监听的事件类型；<code>epoll_wait</code>则是等待事件的产生。在具体的执行机制上，epoll做了如下改进：</p><ul><li> 每次注册新的事件到epoll句柄中时（在<code>epoll_ctl</code>中指定<code>EPOLL_CTL_ADD</code>），会把所有的fd拷贝进内核，而不是在<code>epoll_wait</code>的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。<br/> </li><li> epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在<code>epoll_ctl</code>时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。<code>epoll_wait</code>的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用<code>schedule_timeout()</code>实现睡一会，判断一会的效果。<br/> </li><li> epoll所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看,一般来说这个数目和系统内存关系很大。<br/> </li></ul><h2>Asio 异步模型</h2><p>Asio使用的是Proactor（前摄器）模型，其模型图见下: </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7ea51409459ed7e6780520ad9f48d181_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-7ea51409459ed7e6780520ad9f48d181_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;402&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-7ea51409459ed7e6780520ad9f48d181_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7ea51409459ed7e6780520ad9f48d181_b.jpg\"/></figure><p>这里需要解释一下各个部分代表着什么:</p><ul><li> Asynchronous Operation:异步操作，调用后直接返回，不阻塞；<br/> </li><li> Asynchronous Operation Processor:异步操作执行单元，用来执行异步操作，异步操作执行完成之后将对应的完成事件放入完成事件队列<br/> </li><li> Completion Event Queue:存储完成事件的队列<br/> </li><li> Asynchronous Event Demultiplexer:异步事件多路复用单元，等待Completion Event Queue出现完成事件，然后返回一个完成事件<br/> </li><li> Proactor:调用异步事件多路复用单元来获得一个完成事件，然后分发这个完成事件所关联的完成操作句柄（回调函数）到具体的执行单元中<br/> </li><li> Initiator：初始化器，用来提供初始的异步操作。<br/> </li></ul><p>在windows上，这个模型很容易的就可以映射到IOCP之上：</p><ul><li> asynchrounous Operation Processor:这个是系统自己处理，我们直接将异步操作映射到操作系统自带的异步api即可委托给操作系统执行；<br/> </li><li> completion Event Queue: 这个完成事件队列也是由windows自己管理好了，我们只需要用GetQueuedCompletionStatus即可获得一个完成事件；<br/> </li><li> Asynchronous Event Demultiplexer: 这部分是由Asio调用GetQueuedCompletionStatus来获得完成事件以及相应的完成操作句柄。<br/> </li></ul><p>而在Linux/Unix上情况则不同了，因为这两个平台系统所提供的操作是同步的，其模型是Reactor模型，只能通知IO操作是否可以开始进行，而不能通知IO操作的完成。所以，Asio需要进行如下处理：</p><ul><li> Asynchronous Operation Processor： 当通过select/epoll/kqueue实现的reactorr通知某项IO操作可以进行时，这个processor执行这个异步操作，然后将完成事件和完成操作挂在到完成事件队列上；<br/> </li><li> Completion Event Queue : 一个以链表形式存在的完成操作句柄队列；<br/> </li><li> Asynchronous Event DemultiPlexer：这个是由Asio实现的一个等待机制，主要是通过条件变量来进行等待<br/> </li></ul><h2>Io service</h2><p>在Asio中，最重要的类就是io_service类，继承自nocopyable。这个类是一个接口类，主要提供了下面的几个操作：</p><ul><li> run<br/> </li><li> poll<br/> </li><li> stop<br/> </li><li> dispatch<br/> </li><li> post<br/> </li></ul><p>同时这个类只有三个成员：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">private</span><span class=\"o\">:</span>\n<span class=\"cp\">#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)\n</span><span class=\"cp\"></span>  <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">winsock_init</span><span class=\"o\">&lt;&gt;</span> <span class=\"n\">init_</span><span class=\"p\">;</span>\n<span class=\"cp\">#elif defined(__sun) || defined(__QNX__) || defined(__hpux) || defined(_AIX) \\\n</span><span class=\"cp\"></span>  <span class=\"o\">||</span> <span class=\"n\">defined</span><span class=\"p\">(</span><span class=\"n\">__osf__</span><span class=\"p\">)</span>\n  <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">signal_init</span><span class=\"o\">&lt;&gt;</span> <span class=\"n\">init_</span><span class=\"p\">;</span>\n<span class=\"cp\">#endif\n</span><span class=\"cp\"></span>\n  <span class=\"c1\">// The service registry.\n</span><span class=\"c1\"></span>  <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">service_registry</span><span class=\"o\">*</span> <span class=\"n\">service_registry_</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// The implementation.\n</span><span class=\"c1\"></span>  <span class=\"n\">impl_type</span><span class=\"o\">&amp;</span> <span class=\"n\">impl_</span><span class=\"p\">;</span>\n</code></pre></div><p>而这些操作最后都会委托到io_service 内的成员<code>impl_type&amp; impl</code>去执行，也就是说采取的是pimpl模式。至于这个<code>impl_type</code>，是io_service所定义的一个类型别名：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">typedef</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">io_service_impl</span> <span class=\"n\">impl_type</span><span class=\"p\">;</span>\n</code></pre></div><p>他的具体类型是与平台相关的：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">namespace</span> <span class=\"n\">detail</span> <span class=\"p\">{</span>\n<span class=\"cp\">#if defined(BOOST_ASIO_HAS_IOCP)\n</span><span class=\"cp\"></span>  <span class=\"k\">typedef</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">win_iocp_io_service</span> <span class=\"n\">io_service_impl</span><span class=\"p\">;</span>\n  <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">win_iocp_overlapped_ptr</span><span class=\"p\">;</span>\n<span class=\"cp\">#else\n</span><span class=\"cp\"></span>  <span class=\"k\">typedef</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">task_io_service</span> <span class=\"n\">io_service_impl</span><span class=\"p\">;</span>\n<span class=\"cp\">#endif\n</span><span class=\"cp\"></span>  <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">service_registry</span><span class=\"p\">;</span>\n<span class=\"p\">}</span> <span class=\"c1\">//\n</span></code></pre></div><p>至于<code>init_</code>成员，是用来做各个平台的各项网络初始化和销毁工作的，简单来说就是一个RAII类型。</p><p>而关于<code>service_registry_</code>类型，则没有那么简单了，首先我们看一下io_service的构造函数里这个成员是怎么使用的</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">io_service</span><span class=\"o\">::</span><span class=\"n\">io_service</span><span class=\"p\">()</span>\n  <span class=\"o\">:</span> <span class=\"n\">service_registry_</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">service_registry</span><span class=\"p\">(</span>\n        <span class=\"o\">*</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">impl_type</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">numeric_limits</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span><span class=\"o\">&gt;::</span><span class=\"n\">max</span><span class=\"p\">)())),</span>\n    <span class=\"n\">impl_</span><span class=\"p\">(</span><span class=\"n\">service_registry_</span><span class=\"o\">-&gt;</span><span class=\"n\">first_service</span><span class=\"o\">&lt;</span><span class=\"n\">impl_type</span><span class=\"o\">&gt;</span><span class=\"p\">())</span>\n<span class=\"p\">{</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的<code>static_cast&lt;impl_type*&gt;(0)</code>只是为了参数类型推导用的。通过分析service_registery的实现，可以看出他实际就是一个管理service的链表，impl_type也是一个service类型。每种service都有一个唯一id。在调用 use_service(io_service&amp;) 时，service_registry会查找链表，如果有对应类型的服务，就返回该类型服务实例的指针；否则就创建一个新的对象，并加入到链表末端，再返回此新创建的实例；通过这种形式，io_service确保每种类型的服务都只有一个实例存在。</p><p>对于不同的操作我们有不同的对应的service子类，所以加入某个特定的service的最佳时机便是对应操作的启动者的构造期，具体代码见下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">explicit</span> <span class=\"nf\">basic_io_object</span><span class=\"p\">(</span><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">io_service</span><span class=\"o\">&amp;</span> <span class=\"n\">io_service</span><span class=\"p\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">service</span><span class=\"p\">(</span><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">use_service</span><span class=\"o\">&lt;</span><span class=\"n\">IoObjectService</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">io_service</span><span class=\"p\">))</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">service</span><span class=\"p\">.</span><span class=\"n\">construct</span><span class=\"p\">(</span><span class=\"n\">implementation</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在构造过程中，使用<code>use_service</code>的返回值来初始化该service成员；我们知道，<code>use_service</code>会在<code>io_service</code>所维护的service链表中查找该类型，如果没有，就创建一个新的service实例；在此，就可以确保<code>resolve_service&lt;tcp&gt;</code>的实例已经被创建出来了，该服务就可以工作了。</p><p>这里还需要提到的一点是：<code>resolver</code>自己会创建一个<code>IOCP</code>，因为windows并没有提供<code>resolver</code>的重叠IO操作，这个<code>resolver</code>还会创建自己的线程来执行。但是会回调两次，一次是在<code>resolver</code>的线程中，其回调操作就是把结果发送到主线程的<code>IOCP</code>之中去，在主线程之中取出之后才会调用用户提供的回调函数。</p><h2>io objects</h2><p>这里的io objects是承载具体IO功能的对象，常见的有acceptor/resolver/timer/socket等。在Asio中主要的io object的关系图如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3a9ef3b5d2cb532914e19698a7c5ff48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb\" width=\"750\" data-original=\"https://pic1.zhimg.com/v2-3a9ef3b5d2cb532914e19698a7c5ff48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;750&#39; height=&#39;522&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"750\" data-original=\"https://pic1.zhimg.com/v2-3a9ef3b5d2cb532914e19698a7c5ff48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3a9ef3b5d2cb532914e19698a7c5ff48_b.jpg\"/></figure><p> 具体的类型及其功能包括：</p><ul><li><code>basic_deadline_timer</code> 提供定时器功能，可以同步等待，也可以异步等待。 <br/> </li><li><code>basic_waitable_timer</code> 和<code>basic_deadline_timer</code>具有同样的功能，主要区别为该定时器可以和C++ 11中引入的<code>chrono</code>库协作。 <br/> </li><li><code>basic_signal_set</code> 支持信号相关的操作，异步方式等待单个或者多个信号的发生。 <br/> </li><li><code>basic_socket_acceptor</code> 作为服务器进行侦听，接收连接请求。 <br/> </li><li><code>basic_serial_port</code> 对串口操作进行支持。 <br/> </li><li><code>basic_resolver</code> 地址解析类。 <br/> </li><li><code>basic_stream_socket</code> 提供同步、异步方式的基于流的socket操作。 <br/> </li><li><code>basic_datagram_socket</code> 提供同步、异步方式的基于数据报文的socket操作。 <br/> </li><li><code>basic_raw_socket</code>提供同步、异步方式的基于raw数据的socket操作 <br/> </li><li><code>basic_seq_packet_socket</code>提供同步、异步方式的基于有序包的socket操作 <br/> </li><li><code>basic_socket_streambuf</code> ? <br/> </li><li><code>basic_object_handle</code> 对windows handle的封装，可以以异步或者同步方式等待 <br/> </li><li><code>basic_random_access_handle</code>对windows 可随机访问的handle的封装，可以以异步或者同步方式等待 <br/> </li><li><code>basic_stream_handle</code>对windows面向流handle的封装，可以以异步或者同步方式等待 <br/> </li><li><code>basic_descriptor</code> 对POSIX描述符进行封装。<br/> </li></ul><p>最重要的一点：所有这些<code>io object</code>的构造函数，都要求有一个<code>io_service&amp;</code> 作为参数，使用这一参数，这些<code>io_object</code>对象知道了自己的归属，之后自己所要派发出去的同步、异步操作请求，都将通过自己所在的这个<code>io_service</code>对象来完成。这也就说明了，为什么创建<code>io_service</code>对象是整个Asio程序的第一步。</p><p>在使用时，我们并不直接使用这些basic 模板，而是使用这些basic模板的特化类型的别名，例如<code>resolver</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">typedef</span> <span class=\"n\">basic_resolver</span><span class=\"o\">&lt;</span><span class=\"n\">tcp</span><span class=\"o\">&gt;</span> <span class=\"n\">resolver</span><span class=\"p\">;</span>\n</code></pre></div><p>这个用法在stl中很常见，例如cout/cin/string等都是一些basic模板的特化别名。</p><p>事实上，这些basic模板所做的也只是作为一些接口类，其具体任务都会被层层转接到<code>asio::detail::service</code>上。以<code>resolver</code>为例，当我们调用<code>async_resolve</code>时，会继续调用下一层的<code>service</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">ResolveHandler</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">async_resolve</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">query</span><span class=\"o\">&amp;</span> <span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">BOOST_ASIO_MOVE_ARG</span><span class=\"p\">(</span><span class=\"n\">ResolveHandler</span><span class=\"p\">)</span> <span class=\"n\">handler</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"c1\">// If you get an error on the following line it means that your handler does\n</span><span class=\"c1\">// not meet the documented type requirements for a ResolveHandler.\n</span><span class=\"c1\"></span><span class=\"n\">BOOST_ASIO_RESOLVE_HANDLER_CHECK</span><span class=\"p\">(</span>\n    <span class=\"n\">ResolveHandler</span><span class=\"p\">,</span> <span class=\"n\">handler</span><span class=\"p\">,</span> <span class=\"n\">iterator</span><span class=\"p\">)</span> <span class=\"n\">type_check</span><span class=\"p\">;</span>\n\n<span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">service</span><span class=\"p\">.</span><span class=\"n\">async_resolve</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">implementation</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">,</span>\n    <span class=\"n\">BOOST_ASIO_MOVE_CAST</span><span class=\"p\">(</span><span class=\"n\">ResolveHandler</span><span class=\"p\">)(</span><span class=\"n\">handler</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的<code>this-&gt;service</code>的类型是<code>asio::ip::resolver_service</code>，然而<code>asio::ip::resolver_service</code>并不算真正的执行者，他下面还有一层：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">/// Asynchronously resolve a query to a list of entries.\n</span><span class=\"c1\"></span><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">ResolveHandler</span><span class=\"o\">&gt;</span>\n<span class=\"n\">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class=\"p\">(</span><span class=\"n\">ResolveHandler</span><span class=\"p\">,</span>\n  <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">,</span> <span class=\"n\">iterator_type</span><span class=\"p\">))</span>\n<span class=\"n\">async_resolve</span><span class=\"p\">(</span><span class=\"n\">implementation_type</span><span class=\"o\">&amp;</span> <span class=\"n\">impl</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">query_type</span><span class=\"o\">&amp;</span> <span class=\"n\">query</span><span class=\"p\">,</span>\n  <span class=\"n\">BOOST_ASIO_MOVE_ARG</span><span class=\"p\">(</span><span class=\"n\">ResolveHandler</span><span class=\"p\">)</span> <span class=\"n\">handler</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">async_result_init</span><span class=\"o\">&lt;</span>\n  <span class=\"n\">ResolveHandler</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">,</span> <span class=\"n\">iterator_type</span><span class=\"p\">)</span><span class=\"o\">&gt;</span> <span class=\"n\">init</span><span class=\"p\">(</span>\n    <span class=\"n\">BOOST_ASIO_MOVE_CAST</span><span class=\"p\">(</span><span class=\"n\">ResolveHandler</span><span class=\"p\">)(</span><span class=\"n\">handler</span><span class=\"p\">));</span>\n\n<span class=\"n\">service_impl_</span><span class=\"p\">.</span><span class=\"n\">async_resolve</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">,</span> <span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"p\">.</span><span class=\"n\">handler</span><span class=\"p\">);</span>\n\n<span class=\"k\">return</span> <span class=\"n\">init</span><span class=\"p\">.</span><span class=\"n\">result</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>然而，这里并不是终点，可以看出这里还有一层。这里的<code>service_impl_</code>的类型是<code>service_impl_type</code>，由这个类型名可以看出这个类型又是由宏定义的<code>typedef</code>，其真实类型是：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#if defined(BOOST_ASIO_WINDOWS_RUNTIME)\n</span><span class=\"cp\"></span>  <span class=\"k\">typedef</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">winrt_resolver_service</span><span class=\"o\">&lt;</span><span class=\"n\">InternetProtocol</span><span class=\"o\">&gt;</span>\n    <span class=\"n\">service_impl_type</span><span class=\"p\">;</span>\n<span class=\"cp\">#else\n</span><span class=\"cp\"></span>  <span class=\"k\">typedef</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">resolver_service</span><span class=\"o\">&lt;</span><span class=\"n\">InternetProtocol</span><span class=\"o\">&gt;</span>\n    <span class=\"n\">service_impl_type</span><span class=\"p\">;</span>\n<span class=\"cp\">#endif\n</span></code></pre></div><p>这样我们继续跟踪<code>boost::asio::detail::resolver_service&lt;InternetProtocol&gt;</code>的<code>async_resolve</code></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Asynchronously resolve a query to a list of entries.\n</span><span class=\"c1\"></span><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">Handler</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">async_resolve</span><span class=\"p\">(</span><span class=\"n\">implementation_type</span><span class=\"o\">&amp;</span> <span class=\"n\">impl</span><span class=\"p\">,</span>\n  <span class=\"k\">const</span> <span class=\"n\">query_type</span><span class=\"o\">&amp;</span> <span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">Handler</span><span class=\"o\">&amp;</span> <span class=\"n\">handler</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"c1\">// Allocate and construct an operation to wrap the handler.\n</span><span class=\"c1\"></span><span class=\"k\">typedef</span> <span class=\"n\">resolve_op</span><span class=\"o\">&lt;</span><span class=\"n\">Protocol</span><span class=\"p\">,</span> <span class=\"n\">Handler</span><span class=\"o\">&gt;</span> <span class=\"n\">op</span><span class=\"p\">;</span>\n<span class=\"k\">typename</span> <span class=\"n\">op</span><span class=\"o\">::</span><span class=\"n\">ptr</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">addressof</span><span class=\"p\">(</span><span class=\"n\">handler</span><span class=\"p\">),</span>\n  <span class=\"n\">boost_asio_handler_alloc_helpers</span><span class=\"o\">::</span><span class=\"n\">allocate</span><span class=\"p\">(</span>\n    <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">),</span> <span class=\"n\">handler</span><span class=\"p\">),</span> <span class=\"mi\">0</span> <span class=\"p\">};</span>\n<span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">,</span> <span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">io_service_impl_</span><span class=\"p\">,</span> <span class=\"n\">handler</span><span class=\"p\">);</span>\n\n<span class=\"n\">BOOST_ASIO_HANDLER_CREATION</span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"s\">&#34;resolver&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">impl</span><span class=\"p\">,</span> <span class=\"s\">&#34;async_resolve&#34;</span><span class=\"p\">));</span>\n\n<span class=\"n\">start_resolve_op</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">p</span><span class=\"p\">);</span>\n<span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的op是一个临时封装类，执行的时候最终还是由<code>start_resolve_op</code>:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">resolver_service_base</span><span class=\"o\">::</span><span class=\"n\">start_resolve_op</span><span class=\"p\">(</span><span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">start_work_thread</span><span class=\"p\">();</span>\n  <span class=\"n\">io_service_impl_</span><span class=\"p\">.</span><span class=\"n\">work_started</span><span class=\"p\">();</span>\n  <span class=\"n\">work_io_service_impl_</span><span class=\"p\">.</span><span class=\"n\">post_immediate_completion</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"nb\">false</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>前两个操作都是<code>one shot</code>的执行，即如果之前的操作已经启动了<code>thread</code>和<code>work</code>的话，则相当于什么都没干。所以最终是<code>post</code>这个<code>op</code>到<code>io_service</code>上了。</p><h2>Operation</h2><p>在前面的<code>resolver</code>分析中，我们知道了最后的执行者是<code>Operation</code>，但是<code>Operation</code>最后是怎么与<code>io_service</code>服务的并没有说明。我们先来看<code>Operation</code>的类型定义：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">namespace</span> <span class=\"n\">boost</span> <span class=\"p\">{</span>\n<span class=\"k\">namespace</span> <span class=\"n\">asio</span> <span class=\"p\">{</span>\n<span class=\"k\">namespace</span> <span class=\"n\">detail</span> <span class=\"p\">{</span>\n\n<span class=\"cp\">#if defined(BOOST_ASIO_HAS_IOCP)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"n\">win_iocp_operation</span> <span class=\"n\">operation</span><span class=\"p\">;</span>\n<span class=\"cp\">#else\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"n\">task_io_service_operation</span> <span class=\"n\">operation</span><span class=\"p\">;</span>\n<span class=\"cp\">#endif\n</span><span class=\"cp\"></span>\n<span class=\"p\">}</span> <span class=\"c1\">// namespace detail\n</span><span class=\"c1\"></span><span class=\"p\">}</span> <span class=\"c1\">// namespace asio\n</span><span class=\"c1\"></span><span class=\"p\">}</span> <span class=\"c1\">// namespace boost\n</span></code></pre></div><p>想必大家都已经开始呵呵了吧，在<code>Asio</code>里面要习惯这种事情啊。简单来说，在<code>IOCP</code>平台下，<code>Operation</code>的类型是<code>win_iocp_operation</code>；而在<code>linux/unix</code>平台下，Operation的类型是<code>task_io_service_operation</code>。</p><p>在Asio中，主要有如下的一些operation类型，这里标红色的是与IOCP有关的，白色的是与select/epoll/kqueue有关的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9e2e20ae342a4bf472f9d780dd0f0780_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"780\" class=\"origin_image zh-lightbox-thumb\" width=\"750\" data-original=\"https://pic1.zhimg.com/v2-9e2e20ae342a4bf472f9d780dd0f0780_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;750&#39; height=&#39;780&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"780\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"750\" data-original=\"https://pic1.zhimg.com/v2-9e2e20ae342a4bf472f9d780dd0f0780_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9e2e20ae342a4bf472f9d780dd0f0780_b.jpg\"/></figure><h2>windows IO Operation</h2><p>在<code>win_iocp_operation</code>中，主要的内部函数及数据成员有如下几个：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">complete</span><span class=\"p\">(</span><span class=\"n\">win_iocp_io_service</span><span class=\"o\">&amp;</span> <span class=\"n\">owner</span><span class=\"p\">,</span>\n<span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">,</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">bytes_transferred</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">func_</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">owner</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">ec</span><span class=\"p\">,</span> <span class=\"n\">bytes_transferred</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">destroy</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">func_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">(),</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"k\">typedef</span> <span class=\"nf\">void</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">func_type</span><span class=\"p\">)(</span>\n<span class=\"n\">win_iocp_io_service</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">win_iocp_operation</span><span class=\"o\">*</span><span class=\"p\">,</span>\n<span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span><span class=\"p\">);</span>\n\n<span class=\"n\">win_iocp_operation</span><span class=\"p\">(</span><span class=\"n\">func_type</span> <span class=\"n\">func</span><span class=\"p\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">next_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n<span class=\"n\">func_</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">reset</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n<span class=\"n\">win_iocp_operation</span><span class=\"o\">*</span> <span class=\"n\">next_</span><span class=\"p\">;</span>\n<span class=\"n\">func_type</span> <span class=\"n\">func_</span><span class=\"p\">;</span>\n</code></pre></div><p>从这几个核心成员可以看出，整个<code>win_iocp_operation</code>是一个侵入式的链表，封装了一个<code>func_</code>。从这个<code>func_</code>的类型签名就可以看出这非常像我们使用<code>Asio</code>时的回调函数，但又有一些区别。这个<code>func_</code>的初始化是在<code>win_iocp_operation</code>的各个子类的构造函数中进行的，同样以<code>resolver_op</code>为例:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">resolve_op</span><span class=\"p\">(</span><span class=\"n\">socket_ops</span><span class=\"o\">::</span><span class=\"n\">weak_cancel_token_type</span> <span class=\"n\">cancel_token</span><span class=\"p\">,</span>\n<span class=\"k\">const</span> <span class=\"n\">query_type</span><span class=\"o\">&amp;</span> <span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">io_service_impl</span><span class=\"o\">&amp;</span> <span class=\"n\">ios</span><span class=\"p\">,</span> <span class=\"n\">Handler</span><span class=\"o\">&amp;</span> <span class=\"n\">handler</span><span class=\"p\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">operation</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">resolve_op</span><span class=\"o\">::</span><span class=\"n\">do_complete</span><span class=\"p\">),</span>\n<span class=\"n\">cancel_token_</span><span class=\"p\">(</span><span class=\"n\">cancel_token</span><span class=\"p\">),</span>\n<span class=\"n\">query_</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">),</span>\n<span class=\"n\">io_service_impl_</span><span class=\"p\">(</span><span class=\"n\">ios</span><span class=\"p\">),</span>\n<span class=\"n\">handler_</span><span class=\"p\">(</span><span class=\"n\">BOOST_ASIO_MOVE_CAST</span><span class=\"p\">(</span><span class=\"n\">Handler</span><span class=\"p\">)(</span><span class=\"n\">handler</span><span class=\"p\">)),</span>\n<span class=\"n\">addrinfo_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的构造函数使用了自身的<code>resolve_op::do_complete</code>来初始化<code>func_</code>，其他类型的<code>operation</code>也会定义一个<code>do_complete</code>来初始化<code>func_</code>。也就是说，<code>func_</code>其实等价于一个虚函数，我们可以直接将其替换为<code>virtual do_complete=0</code>之类的函数声明，这样构造的时候就不再需要去赋值了。</p><p>将其修改为虚函数的解决方案看上去很美，但是这里我们忽略了一点，事实上<code>win_iocp_operation</code>是继承自OVERLAPPED这个类的：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">win_iocp_operation</span>\n  <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">OVERLAPPED</span>\n</code></pre></div><p>至于<code>OVERLAPPED</code>,之前谈及<code>IOCP</code>时也间接提到了，在<code>GetQueuedCompletionStatus</code>的签名中的第四个参数就是这个结构。该结构是Win32进行交叠IO一个非常重要的结构，用以异步执行过程中的参数传递。如果我们将<code>func_</code>更改为虚函数<code>do_complete</code>的话，<code>win_iocp_operation</code>的地址则不再是<code>OVERLAPPED</code>的地址，中间还差一个虚函数表的指针，改变了POD的内存布局。这样使得传参时必须使用<code>dynamic_cast</code>，这样有损效率，而且容易出错。所以<code>Asio</code>这里回避了虚函数这个<code>monster</code>，而是手动初始化<code>func_</code>。还需要注意一点，子类中的<code>do_complete</code>都是声明为静态函数的，这样才能与<code>func</code>的类型匹配。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"n\">do_complete</span><span class=\"p\">(</span><span class=\"n\">io_service_impl</span><span class=\"o\">*</span> <span class=\"n\">owner</span><span class=\"p\">,</span> <span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">base</span><span class=\"p\">,</span>\n<span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"cm\">/*ec*/</span><span class=\"p\">,</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"cm\">/*bytes_transferred*/</span><span class=\"p\">)</span>\n</code></pre></div><p>如果不是声明为<code>static</code>的话,则需要修改<code>func</code>的类型从函数指针到成员函数指针去，同时子类在构造的时候还需要使用<code>reinteprete_cast</code>将<code>son::*</code>转换为<code>father::*</code>。这样使用起来非常不优雅，所以最后选择了<code>static</code>这种机制。</p><p>至于<code>operation</code>具体做了什么，我们以<code>recieve</code>操作为例来讲解。在<code>win_iocp_socket_service_base</code>中，为了启动一个<code>receive</code>的异步操作, <code>start_receive_op</code>函数就直接把传递进来的<code>operation</code>指针作为<code>OVERLAPPED</code>结构传递给<code>::WSARecv</code>函数，从而发起一个异步服务请求。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">win_iocp_socket_service_base</span><span class=\"o\">::</span><span class=\"n\">start_receive_op</span><span class=\"p\">(</span>\n    <span class=\"n\">win_iocp_socket_service_base</span><span class=\"o\">::</span><span class=\"n\">base_implementation_type</span><span class=\"o\">&amp;</span> <span class=\"n\">impl</span><span class=\"p\">,</span>\n    <span class=\"n\">WSABUF</span><span class=\"o\">*</span> <span class=\"n\">buffers</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">buffer_count</span><span class=\"p\">,</span>\n    <span class=\"n\">socket_base</span><span class=\"o\">::</span><span class=\"n\">message_flags</span> <span class=\"n\">flags</span><span class=\"p\">,</span> <span class=\"kt\">bool</span> <span class=\"n\">noop</span><span class=\"p\">,</span> <span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">update_cancellation_thread_id</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">);</span>\n  <span class=\"n\">iocp_service_</span><span class=\"p\">.</span><span class=\"n\">work_started</span><span class=\"p\">();</span>\n \n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">noop</span><span class=\"p\">)</span>\n    <span class=\"n\">iocp_service_</span><span class=\"p\">.</span><span class=\"n\">on_completion</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">);</span>\n  <span class=\"k\">else</span> <span class=\"nf\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">is_open</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">))</span>\n    <span class=\"n\">iocp_service_</span><span class=\"p\">.</span><span class=\"n\">on_completion</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">error</span><span class=\"o\">::</span><span class=\"n\">bad_descriptor</span><span class=\"p\">);</span>\n  <span class=\"k\">else</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">DWORD</span> <span class=\"n\">bytes_transferred</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"n\">DWORD</span> <span class=\"n\">recv_flags</span> <span class=\"o\">=</span> <span class=\"n\">flags</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">WSARecv</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">.</span><span class=\"n\">socket_</span><span class=\"p\">,</span> <span class=\"n\">buffers</span><span class=\"p\">,</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">DWORD</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">buffer_count</span><span class=\"p\">),</span>\n        <span class=\"o\">&amp;</span><span class=\"n\">bytes_transferred</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">recv_flags</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"n\">DWORD</span> <span class=\"n\">last_error</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">WSAGetLastError</span><span class=\"p\">();</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">last_error</span> <span class=\"o\">==</span> <span class=\"n\">ERROR_NETNAME_DELETED</span><span class=\"p\">)</span>\n      <span class=\"n\">last_error</span> <span class=\"o\">=</span> <span class=\"n\">WSAECONNRESET</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span> <span class=\"nf\">if</span> <span class=\"p\">(</span><span class=\"n\">last_error</span> <span class=\"o\">==</span> <span class=\"n\">ERROR_PORT_UNREACHABLE</span><span class=\"p\">)</span>\n      <span class=\"n\">last_error</span> <span class=\"o\">=</span> <span class=\"n\">WSAECONNREFUSED</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">result</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">last_error</span> <span class=\"o\">!=</span> <span class=\"n\">WSA_IO_PENDING</span><span class=\"p\">)</span>\n      <span class=\"n\">iocp_service_</span><span class=\"p\">.</span><span class=\"n\">on_completion</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"n\">last_error</span><span class=\"p\">,</span> <span class=\"n\">bytes_transferred</span><span class=\"p\">);</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">iocp_service_</span><span class=\"p\">.</span><span class=\"n\">on_pending</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这个函数做了一系列的错误判断之后，之后才通过<code>on_pending</code>操作把<code>op</code>挂在在完成端口上：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">win_iocp_io_service</span><span class=\"o\">::</span><span class=\"n\">on_pending</span><span class=\"p\">(</span><span class=\"n\">win_iocp_operation</span><span class=\"o\">*</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">InterlockedCompareExchange</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">ready_</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"c1\">// Enqueue the operation on the I/O completion port.\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!::</span><span class=\"n\">PostQueuedCompletionStatus</span><span class=\"p\">(</span><span class=\"n\">iocp_</span><span class=\"p\">.</span><span class=\"n\">handle</span><span class=\"p\">,</span>\n          <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">overlapped_contains_result</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n      <span class=\"c1\">// Out of resources. Put on completed queue instead.\n</span><span class=\"c1\"></span>      <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">dispatch_mutex_</span><span class=\"p\">);</span>\n      <span class=\"n\">completed_ops_</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">);</span>\n      <span class=\"o\">::</span><span class=\"n\">InterlockedExchange</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">dispatch_required_</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>当然，如果挂在不成功的话（系统忙时可能出现），我们就暂时存储这个<code>op</code>在一个备用队列上<code>completed_ops_</code>。</p><p>除了recieve_op，还有很多其他类型的op。各个op与async函数的对应关系见下表</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a7f518eff1a18f2e0825d6edc6a5d830_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb\" width=\"776\" data-original=\"https://pic1.zhimg.com/v2-a7f518eff1a18f2e0825d6edc6a5d830_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;776&#39; height=&#39;365&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"776\" data-original=\"https://pic1.zhimg.com/v2-a7f518eff1a18f2e0825d6edc6a5d830_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a7f518eff1a18f2e0825d6edc6a5d830_b.jpg\"/></figure><h2>Linux IO Operation</h2><p>这里我们先来看一下回调函数的封装类，也就是<code>operation</code>对应的类，这个是放在<code>task_io_service_operation</code>中的。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">task_io_service_operation</span> <span class=\"n\">BOOST_ASIO_INHERIT_TRACKED_HANDLER</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n  <span class=\"kt\">void</span> <span class=\"n\">complete</span><span class=\"p\">(</span><span class=\"n\">task_io_service</span><span class=\"o\">&amp;</span> <span class=\"n\">owner</span><span class=\"p\">,</span>\n      <span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">bytes_transferred</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">func_</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">owner</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">ec</span><span class=\"p\">,</span> <span class=\"n\">bytes_transferred</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"kt\">void</span> <span class=\"n\">destroy</span><span class=\"p\">()</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">func_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">(),</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n<span class=\"k\">protected</span><span class=\"o\">:</span>\n  <span class=\"k\">typedef</span> <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">func_type</span><span class=\"p\">)(</span><span class=\"n\">task_io_service</span><span class=\"o\">*</span><span class=\"p\">,</span>\n      <span class=\"n\">task_io_service_operation</span><span class=\"o\">*</span><span class=\"p\">,</span>\n      <span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span><span class=\"p\">);</span>\n\n  <span class=\"n\">task_io_service_operation</span><span class=\"p\">(</span><span class=\"n\">func_type</span> <span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">next_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n      <span class=\"n\">func_</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">),</span>\n      <span class=\"n\">task_result_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// Prevents deletion through this type.\n</span><span class=\"c1\"></span>  <span class=\"o\">~</span><span class=\"n\">task_io_service_operation</span><span class=\"p\">()</span>\n  <span class=\"p\">{</span>\n  <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n  <span class=\"k\">friend</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">op_queue_access</span><span class=\"p\">;</span>\n  <span class=\"n\">task_io_service_operation</span><span class=\"o\">*</span> <span class=\"n\">next_</span><span class=\"p\">;</span>\n  <span class=\"n\">func_type</span> <span class=\"n\">func_</span><span class=\"p\">;</span>\n<span class=\"k\">protected</span><span class=\"o\">:</span>\n  <span class=\"k\">friend</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">task_io_service</span><span class=\"p\">;</span>\n  <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">task_result_</span><span class=\"p\">;</span> <span class=\"c1\">// Passed into bytes transferred.\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n</code></pre></div><p>其实这个类看上去与<code>operation</code>类差不多，内部也包含了一个<code>func_type</code>的回调函数，也是使用子类的静态函数来做初始化的，也有一个<code>next</code>指针构造了一个侵入性链表。只不过不再继承自<code>OVERLAPD</code>结构体。这样，我们就定义了一个<code>CompletionHandle</code>。</p><p>这个类型只是参与管理回调的，我们还需要记录真正的<code>IO</code>操作是什么，执行<code>IO</code>然后再进行回调。同时记录了<code>IO</code>与<code>Completion Handle</code>的类型是<code>descriptor_state</code>,首先查看<code>descriptor_state</code>的类型定义：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">descriptor_state</span> <span class=\"o\">:</span> <span class=\"n\">operation</span>\n  <span class=\"p\">{</span>\n    <span class=\"k\">friend</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">epoll_reactor</span><span class=\"p\">;</span>\n    <span class=\"k\">friend</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">object_pool_access</span><span class=\"p\">;</span>\n\n    <span class=\"n\">descriptor_state</span><span class=\"o\">*</span> <span class=\"n\">next_</span><span class=\"p\">;</span>\n    <span class=\"n\">descriptor_state</span><span class=\"o\">*</span> <span class=\"n\">prev_</span><span class=\"p\">;</span>\n\n    <span class=\"n\">mutex</span> <span class=\"n\">mutex_</span><span class=\"p\">;</span>\n    <span class=\"n\">epoll_reactor</span><span class=\"o\">*</span> <span class=\"n\">reactor_</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">descriptor_</span><span class=\"p\">;</span>\n    <span class=\"n\">uint32_t</span> <span class=\"n\">registered_events_</span><span class=\"p\">;</span>\n    <span class=\"n\">op_queue</span><span class=\"o\">&lt;</span><span class=\"n\">reactor_op</span><span class=\"o\">&gt;</span> <span class=\"n\">op_queue_</span><span class=\"p\">[</span><span class=\"n\">max_ops</span><span class=\"p\">];</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">shutdown_</span><span class=\"p\">;</span>\n\n    <span class=\"n\">BOOST_ASIO_DECL</span> <span class=\"nf\">descriptor_state</span><span class=\"p\">();</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">set_ready_events</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">events</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">task_result_</span> <span class=\"o\">=</span> <span class=\"n\">events</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"n\">BOOST_ASIO_DECL</span> <span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"nf\">perform_io</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">events</span><span class=\"p\">);</span>\n    <span class=\"n\">BOOST_ASIO_DECL</span> <span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">do_complete</span><span class=\"p\">(</span>\n        <span class=\"n\">io_service_impl</span><span class=\"o\">*</span> <span class=\"n\">owner</span><span class=\"p\">,</span> <span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">base</span><span class=\"p\">,</span>\n        <span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">bytes_transferred</span><span class=\"p\">);</span>\n  <span class=\"p\">};</span>\n</code></pre></div><p>这个类型继承自<code>operation</code>，而<code>do_complete</code>与之前我们提到的回调很像，同样的签名同样是<code>static</code>的，都是在构造函数中被传入<code>operation</code>之中。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">epoll_reactor</span><span class=\"o\">::</span><span class=\"n\">descriptor_state</span><span class=\"o\">::</span><span class=\"n\">descriptor_state</span><span class=\"p\">()</span>\n  <span class=\"o\">:</span> <span class=\"n\">operation</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">epoll_reactor</span><span class=\"o\">::</span><span class=\"n\">descriptor_state</span><span class=\"o\">::</span><span class=\"n\">do_complete</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"n\">epoll_reactor</span><span class=\"o\">::</span><span class=\"n\">descriptor_state</span><span class=\"o\">::</span><span class=\"n\">do_complete</span><span class=\"p\">(</span>\n    <span class=\"n\">io_service_impl</span><span class=\"o\">*</span> <span class=\"n\">owner</span><span class=\"p\">,</span> <span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">base</span><span class=\"p\">,</span>\n    <span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">bytes_transferred</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">owner</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">descriptor_state</span><span class=\"o\">*</span> <span class=\"n\">descriptor_data</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">descriptor_state</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">);</span>\n    <span class=\"n\">uint32_t</span> <span class=\"n\">events</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">uint32_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">bytes_transferred</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">descriptor_data</span><span class=\"o\">-&gt;</span><span class=\"n\">perform_io</span><span class=\"p\">(</span><span class=\"n\">events</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n      <span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">complete</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">owner</span><span class=\"p\">,</span> <span class=\"n\">ec</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的<code>perform_io</code>函数便是执行这项工作的：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">epoll_reactor</span><span class=\"o\">::</span><span class=\"n\">descriptor_state</span><span class=\"o\">::</span><span class=\"n\">perform_io</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">events</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">mutex_</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">();</span>\n  <span class=\"n\">perform_io_cleanup_on_block_exit</span> <span class=\"nf\">io_cleanup</span><span class=\"p\">(</span><span class=\"n\">reactor_</span><span class=\"p\">);</span>\n  <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">descriptor_lock</span><span class=\"p\">(</span><span class=\"n\">mutex_</span><span class=\"p\">,</span> <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span><span class=\"o\">::</span><span class=\"n\">adopt_lock</span><span class=\"p\">);</span>\n\n  <span class=\"c1\">// Exception operations must be processed first to ensure that any\n</span><span class=\"c1\"></span>  <span class=\"c1\">// out-of-band data is read before normal data.\n</span><span class=\"c1\"></span>  <span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"n\">max_ops</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"n\">EPOLLIN</span><span class=\"p\">,</span> <span class=\"n\">EPOLLOUT</span><span class=\"p\">,</span> <span class=\"n\">EPOLLPRI</span> <span class=\"p\">};</span>\n  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">max_ops</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"o\">--</span><span class=\"n\">j</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">events</span> <span class=\"o\">&amp;</span> <span class=\"p\">(</span><span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"n\">EPOLLERR</span> <span class=\"o\">|</span> <span class=\"n\">EPOLLHUP</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n      <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">reactor_op</span><span class=\"o\">*</span> <span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">op_queue_</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">].</span><span class=\"n\">front</span><span class=\"p\">())</span>\n      <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">perform</span><span class=\"p\">())</span>\n        <span class=\"p\">{</span>\n          <span class=\"n\">op_queue_</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">].</span><span class=\"n\">pop</span><span class=\"p\">();</span>\n          <span class=\"n\">io_cleanup</span><span class=\"p\">.</span><span class=\"n\">ops_</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span>\n          <span class=\"k\">break</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// The first operation will be returned for completion now. The others will\n</span><span class=\"c1\"></span>  <span class=\"c1\">// be posted for later by the io_cleanup object&#39;s destructor.\n</span><span class=\"c1\"></span>  <span class=\"n\">io_cleanup</span><span class=\"p\">.</span><span class=\"n\">first_op_</span> <span class=\"o\">=</span> <span class=\"n\">io_cleanup</span><span class=\"p\">.</span><span class=\"n\">ops_</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">();</span>\n  <span class=\"n\">io_cleanup</span><span class=\"p\">.</span><span class=\"n\">ops_</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">();</span>\n  <span class=\"k\">return</span> <span class=\"n\">io_cleanup</span><span class=\"p\">.</span><span class=\"n\">first_op_</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的流程就是首先处理异常事件，这里的<code>EPOLLERR</code>和<code>EPOLLDHUP</code>好像都是处理异常断线的。然后开始处理存储在<code>op_queue_</code>中的<code>IO</code>任务，分别是如下几种：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">enum</span> <span class=\"n\">op_types</span> <span class=\"p\">{</span> <span class=\"n\">read_op</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">write_op</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"n\">connect_op</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">except_op</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">max_ops</span> <span class=\"o\">=</span> <span class=\"mi\">3</span> <span class=\"p\">};</span>\n</code></pre></div><p>这三个队列的初始化到没有看见，估计都放在<code>async</code>之类操作里建立各种子类型然后初始化了。这个<code>reactor_op</code>的类型定义如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">reactor_op</span>\n  <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">operation</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n  <span class=\"c1\">// The error code to be passed to the completion handler.\n</span><span class=\"c1\"></span>  <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span> <span class=\"n\">ec_</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// The number of bytes transferred, to be passed to the completion handler.\n</span><span class=\"c1\"></span>  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">bytes_transferred_</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// Perform the operation. Returns true if it is finished.\n</span><span class=\"c1\"></span>  <span class=\"kt\">bool</span> <span class=\"nf\">perform</span><span class=\"p\">()</span>\n  <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">perform_func_</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n<span class=\"k\">protected</span><span class=\"o\">:</span>\n  <span class=\"k\">typedef</span> <span class=\"kt\">bool</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">perform_func_type</span><span class=\"p\">)(</span><span class=\"n\">reactor_op</span><span class=\"o\">*</span><span class=\"p\">);</span>\n\n  <span class=\"n\">reactor_op</span><span class=\"p\">(</span><span class=\"n\">perform_func_type</span> <span class=\"n\">perform_func</span><span class=\"p\">,</span> <span class=\"n\">func_type</span> <span class=\"n\">complete_func</span><span class=\"p\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">operation</span><span class=\"p\">(</span><span class=\"n\">complete_func</span><span class=\"p\">),</span>\n      <span class=\"n\">bytes_transferred_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n      <span class=\"n\">perform_func_</span><span class=\"p\">(</span><span class=\"n\">perform_func</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n  <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n  <span class=\"n\">perform_func_type</span> <span class=\"n\">perform_func_</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>这里的完成函数是放在<code>operation</code>里的，而<code>io</code>函数是放在自身的数据成员之中。</p><p>每次执行完<code>IO</code>之后，把对应的回调<code>operation</code>放入一个完成队列之中，等待进一步处理。</p><h2>strand</h2><p>这个<code>strand</code>类型的用途是用来序列化执行流的。在<code>Asio</code>中，由于回调函数是由线程池分发执行的，所以多个回调函数可能在不同的线程中操作一些公共的数据成员，例如共用标准输出导致输出错乱，这就引入了多线程同步的问题。要解决这种多线程同步的问题一般是使用同步原语，例如<code>mutex</code>和<code>cond_var</code>等。但是这些都是比较低级的原语，很容易用错，而我们所要求的仅仅是不可同时执行而已。所以<code>Asio</code>中引入了<code>strand</code>这个类型，来串行化回调函数的执行。</p><p>如果要使用<code>strand</code>，我们首先需要声明一个<code>strand</code>类型的对象，然后通过<code>strand.wrap</code>将回调函数包裹起来：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">io_service</span><span class=\"o\">::</span><span class=\"n\">strand</span> <span class=\"n\">strand_</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">io</span><span class=\"p\">);</span> <span class=\"c1\">//注意io_service对象地址作为他的参数。\n</span><span class=\"c1\"></span><span class=\"n\">timer1_</span><span class=\"p\">.</span><span class=\"n\">async_wait</span><span class=\"p\">(</span><span class=\"n\">strand_</span><span class=\"p\">.</span><span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">printer</span><span class=\"o\">::</span><span class=\"n\">print1</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">)));</span>\n<span class=\"n\">timer2_</span><span class=\"p\">.</span><span class=\"n\">async_wait</span><span class=\"p\">(</span><span class=\"n\">strand_</span><span class=\"p\">.</span><span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">printer</span><span class=\"o\">::</span><span class=\"n\">print2</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">)));</span>\n</code></pre></div><p>这里的<code>wrap</code>会生成一个<code>wrapped_handler</code>对象：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">Handler</span><span class=\"o\">&gt;</span>\n<span class=\"cp\">#if defined(GENERATING_DOCUMENTATION)\n</span><span class=\"cp\"></span><span class=\"n\">unspecified</span>\n<span class=\"cp\">#else\n</span><span class=\"cp\"></span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">wrapped_handler</span><span class=\"o\">&lt;</span><span class=\"n\">strand</span><span class=\"p\">,</span> <span class=\"n\">Handler</span><span class=\"p\">,</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">is_continuation_if_running</span><span class=\"o\">&gt;</span>\n<span class=\"cp\">#endif\n</span><span class=\"cp\"></span><span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"n\">Handler</span> <span class=\"n\">handler</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"k\">return</span> <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">wrapped_handler</span><span class=\"o\">&lt;</span><span class=\"n\">io_service</span><span class=\"o\">::</span><span class=\"n\">strand</span><span class=\"p\">,</span> <span class=\"n\">Handler</span><span class=\"p\">,</span>\n    <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">is_continuation_if_running</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">handler</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>而这个<code>wrapped_handler</code>的主要内容见下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">wrapped_handler</span><span class=\"p\">(</span><span class=\"n\">Dispatcher</span> <span class=\"n\">dispatcher</span><span class=\"p\">,</span> <span class=\"n\">Handler</span><span class=\"o\">&amp;</span> <span class=\"n\">handler</span><span class=\"p\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">dispatcher_</span><span class=\"p\">(</span><span class=\"n\">dispatcher</span><span class=\"p\">),</span>\n  <span class=\"n\">handler_</span><span class=\"p\">(</span><span class=\"n\">BOOST_ASIO_MOVE_CAST</span><span class=\"p\">(</span><span class=\"n\">Handler</span><span class=\"p\">)(</span><span class=\"n\">handler</span><span class=\"p\">))</span>\n<span class=\"p\">{</span>\n<span class=\"p\">}</span>\n<span class=\"kt\">void</span> <span class=\"k\">operator</span><span class=\"p\">()()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">dispatcher_</span><span class=\"p\">.</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"n\">BOOST_ASIO_MOVE_CAST</span><span class=\"p\">(</span><span class=\"n\">Handler</span><span class=\"p\">)(</span><span class=\"n\">handler_</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>所以到头来还是调用了<code>strand.dispatch</code>函数：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">CompletionHandler</span><span class=\"o\">&gt;</span>\n<span class=\"n\">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class=\"p\">(</span><span class=\"n\">CompletionHandler</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"p\">())</span>\n<span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"n\">BOOST_ASIO_MOVE_ARG</span><span class=\"p\">(</span><span class=\"n\">CompletionHandler</span><span class=\"p\">)</span> <span class=\"n\">handler</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// If you get an error on the following line it means that your handler does\n</span><span class=\"c1\"></span>    <span class=\"c1\">// not meet the documented type requirements for a CompletionHandler.\n</span><span class=\"c1\"></span>    <span class=\"n\">BOOST_ASIO_COMPLETION_HANDLER_CHECK</span><span class=\"p\">(</span><span class=\"n\">CompletionHandler</span><span class=\"p\">,</span> <span class=\"n\">handler</span><span class=\"p\">)</span> <span class=\"n\">type_check</span><span class=\"p\">;</span>\n\n    <span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">async_result_init</span><span class=\"o\">&lt;</span>\n      <span class=\"n\">CompletionHandler</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"p\">()</span><span class=\"o\">&gt;</span> <span class=\"n\">init</span><span class=\"p\">(</span>\n        <span class=\"n\">BOOST_ASIO_MOVE_CAST</span><span class=\"p\">(</span><span class=\"n\">CompletionHandler</span><span class=\"p\">)(</span><span class=\"n\">handler</span><span class=\"p\">));</span>\n\n    <span class=\"n\">service_</span><span class=\"p\">.</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"n\">impl_</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"p\">.</span><span class=\"n\">handler</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">init</span><span class=\"p\">.</span><span class=\"n\">result</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里又根据pimpl模式转接到了<code>boost::asio::detail::strand_service</code>上，这个<code>strand_service</code>里面有一个<code>io_service</code>的引用，但是实际任务还是根据pimpl规则放在<code>strand_impl</code>之中。这个类才真正承载了互斥操作：</p><div class=\"highlight\"><pre><code class=\"language-text\">class strand_impl\n: public operation\n{\n    public:\n    strand_impl();\n\n    private:\n    // Only this service will have access to the internal values.\n    friend class strand_service;\n    friend struct on_do_complete_exit;\n    friend struct on_dispatch_exit;\n\n    // Mutex to protect access to internal data.\n    boost::asio::detail::mutex mutex_;\n\n    // Indicates whether the strand is currently &#34;locked&#34; by a handler. This\n    // means that there is a handler upcall in progress, or that the strand\n    // itself has been scheduled in order to invoke some pending handlers.\n    bool locked_;\n\n    // The handlers that are waiting on the strand but should not be run until\n    // after the next time the strand is scheduled. This queue must only be\n    // modified while the mutex is locked.\n    op_queue&lt;operation&gt; waiting_queue_;\n\n    // The handlers that are ready to be run. Logically speaking, these are the\n    // handlers that hold the strand&#39;s lock. The ready queue is only modified\n    // from within the strand and so may be accessed without locking the mutex.\n    op_queue&lt;operation&gt; ready_queue_;\n};</code></pre></div><p>继承了<code>operation</code>，同时还有<code>mutex</code>，就是他了！这个<code>mutex_</code>就是用来保护队列用的，而<code>waiting_queue</code>则是所有的等待执行的回调队列，<code>ready_queue_</code>则是可以执行的回调。而<code>locked_</code>则是表明这个<code>strand</code>里面是否已经有函数在执行。</p><p>而执行操作仍然把持在<code>strand_service</code>中：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">Handler</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">strand_service</span><span class=\"o\">::</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"n\">strand_service</span><span class=\"o\">::</span><span class=\"n\">implementation_type</span><span class=\"o\">&amp;</span> <span class=\"n\">impl</span><span class=\"p\">,</span>\n    <span class=\"n\">Handler</span><span class=\"o\">&amp;</span> <span class=\"n\">handler</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// If we are already in the strand then the handler can run immediately.\n</span><span class=\"c1\"></span>  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">call_stack</span><span class=\"o\">&lt;</span><span class=\"n\">strand_impl</span><span class=\"o\">&gt;::</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">))</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">fenced_block</span> <span class=\"n\">b</span><span class=\"p\">(</span><span class=\"n\">fenced_block</span><span class=\"o\">::</span><span class=\"n\">full</span><span class=\"p\">);</span>\n    <span class=\"n\">boost_asio_handler_invoke_helpers</span><span class=\"o\">::</span><span class=\"n\">invoke</span><span class=\"p\">(</span><span class=\"n\">handler</span><span class=\"p\">,</span> <span class=\"n\">handler</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// Allocate and construct an operation to wrap the handler.\n</span><span class=\"c1\"></span>  <span class=\"k\">typedef</span> <span class=\"n\">completion_handler</span><span class=\"o\">&lt;</span><span class=\"n\">Handler</span><span class=\"o\">&gt;</span> <span class=\"n\">op</span><span class=\"p\">;</span>\n  <span class=\"k\">typename</span> <span class=\"n\">op</span><span class=\"o\">::</span><span class=\"n\">ptr</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">addressof</span><span class=\"p\">(</span><span class=\"n\">handler</span><span class=\"p\">),</span>\n    <span class=\"n\">boost_asio_handler_alloc_helpers</span><span class=\"o\">::</span><span class=\"n\">allocate</span><span class=\"p\">(</span>\n      <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">),</span> <span class=\"n\">handler</span><span class=\"p\">),</span> <span class=\"mi\">0</span> <span class=\"p\">};</span>\n  <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"n\">handler</span><span class=\"p\">);</span>\n\n  <span class=\"n\">BOOST_ASIO_HANDLER_CREATION</span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"s\">&#34;strand&#34;</span><span class=\"p\">,</span> <span class=\"n\">impl</span><span class=\"p\">,</span> <span class=\"s\">&#34;dispatch&#34;</span><span class=\"p\">));</span>\n\n  <span class=\"kt\">bool</span> <span class=\"n\">dispatch_immediately</span> <span class=\"o\">=</span> <span class=\"n\">do_dispatch</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">p</span><span class=\"p\">);</span>\n  <span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">o</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">p</span><span class=\"p\">;</span>\n  <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">dispatch_immediately</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"c1\">// Indicate that this strand is executing on the current thread.\n</span><span class=\"c1\"></span>    <span class=\"n\">call_stack</span><span class=\"o\">&lt;</span><span class=\"n\">strand_impl</span><span class=\"o\">&gt;::</span><span class=\"n\">context</span> <span class=\"n\">ctx</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// Ensure the next handler, if any, is scheduled on block exit.\n</span><span class=\"c1\"></span>    <span class=\"n\">on_dispatch_exit</span> <span class=\"n\">on_exit</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"o\">&amp;</span><span class=\"n\">io_service_</span><span class=\"p\">,</span> <span class=\"n\">impl</span> <span class=\"p\">};</span>\n    <span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"n\">on_exit</span><span class=\"p\">;</span>\n\n    <span class=\"n\">completion_handler</span><span class=\"o\">&lt;</span><span class=\"n\">Handler</span><span class=\"o\">&gt;::</span><span class=\"n\">do_complete</span><span class=\"p\">(</span>\n        <span class=\"o\">&amp;</span><span class=\"n\">io_service_</span><span class=\"p\">,</span> <span class=\"n\">o</span><span class=\"p\">,</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">(),</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的执行流程是：首先判断当前线程是否已经在执行<code>strand</code>所包裹的函数。如果是的话，则说明当前函数是在<code>strand</code>内部被调用的，可以理解为尾递归。此时我们的句柄可以直接执行，类似于递归锁的机制。</p><p>否则我们就调用<code>do_dispatch</code>:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">bool</span> <span class=\"n\">strand_service</span><span class=\"o\">::</span><span class=\"n\">do_dispatch</span><span class=\"p\">(</span><span class=\"n\">implementation_type</span><span class=\"o\">&amp;</span> <span class=\"n\">impl</span><span class=\"p\">,</span> <span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// If we are running inside the io_service, and no other handler already\n</span><span class=\"c1\"></span>  <span class=\"c1\">// holds the strand lock, then the handler can run immediately.\n</span><span class=\"c1\"></span>  <span class=\"kt\">bool</span> <span class=\"n\">can_dispatch</span> <span class=\"o\">=</span> <span class=\"n\">io_service_</span><span class=\"p\">.</span><span class=\"n\">can_dispatch</span><span class=\"p\">();</span>\n  <span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex_</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">();</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">can_dispatch</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">locked_</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"c1\">// Immediate invocation is allowed.\n</span><span class=\"c1\"></span>    <span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">locked_</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex_</span><span class=\"p\">.</span><span class=\"n\">unlock</span><span class=\"p\">();</span>\n    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">locked_</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"c1\">// Some other handler already holds the strand lock. Enqueue for later.\n</span><span class=\"c1\"></span>    <span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">waiting_queue_</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">);</span>\n    <span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex_</span><span class=\"p\">.</span><span class=\"n\">unlock</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"k\">else</span>\n  <span class=\"p\">{</span>\n    <span class=\"c1\">// The handler is acquiring the strand lock and so is responsible for\n</span><span class=\"c1\"></span>    <span class=\"c1\">// scheduling the strand.\n</span><span class=\"c1\"></span>    <span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">locked_</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex_</span><span class=\"p\">.</span><span class=\"n\">unlock</span><span class=\"p\">();</span>\n    <span class=\"n\">impl</span><span class=\"o\">-&gt;</span><span class=\"n\">ready_queue_</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">);</span>\n    <span class=\"n\">io_service_</span><span class=\"p\">.</span><span class=\"n\">post_immediate_completion</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">,</span> <span class=\"nb\">false</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里才开始利用之前的<code>mutex</code>和<code>locked_</code>。另外还有一个标志位是<code>can_dispatch</code>，这个变量的值表示当前线程是否是<code>io_service</code>开的线程。如果不是<code>io_service</code>的运行线程则我们不能执行这个操作。话说这种情况好诡异。</p><p>然后获取队列锁，如果此时<code>strand</code>中没有函数在执行且当前线程可以调度的话，则我们直接返回<code>true</code>，让调用方直接执行<code>op</code>。执行完成之后会有一个<code>RAII</code>类<code>on_dispatch_exit</code>来将<code>locked_</code>设置为<code>false</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">struct</span> <span class=\"n\">strand_service</span><span class=\"o\">::</span><span class=\"n\">on_dispatch_exit</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">io_service_impl</span><span class=\"o\">*</span> <span class=\"n\">io_service_</span><span class=\"p\">;</span>\n  <span class=\"n\">strand_impl</span><span class=\"o\">*</span> <span class=\"n\">impl_</span><span class=\"p\">;</span>\n\n  <span class=\"o\">~</span><span class=\"n\">on_dispatch_exit</span><span class=\"p\">()</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">impl_</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex_</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">();</span>\n    <span class=\"n\">impl_</span><span class=\"o\">-&gt;</span><span class=\"n\">ready_queue_</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">impl_</span><span class=\"o\">-&gt;</span><span class=\"n\">waiting_queue_</span><span class=\"p\">);</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">more_handlers</span> <span class=\"o\">=</span> <span class=\"n\">impl_</span><span class=\"o\">-&gt;</span><span class=\"n\">locked_</span> <span class=\"o\">=</span> <span class=\"o\">!</span><span class=\"n\">impl_</span><span class=\"o\">-&gt;</span><span class=\"n\">ready_queue_</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">();</span>\n    <span class=\"n\">impl_</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex_</span><span class=\"p\">.</span><span class=\"n\">unlock</span><span class=\"p\">();</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">more_handlers</span><span class=\"p\">)</span>\n      <span class=\"n\">io_service_</span><span class=\"o\">-&gt;</span><span class=\"n\">post_immediate_completion</span><span class=\"p\">(</span><span class=\"n\">impl_</span><span class=\"p\">,</span> <span class=\"nb\">false</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>饿，好像跟我设想的不太一样啊，执行完成之后直接把等待队列的全扔进就绪队列，如果最后的就绪队列里面还有任务，则当前线程不停的执行这些任务。这样的设计简直机智啊。</p><p>如果其他的线程正在执行当前<code>strand</code>中的一个函数，则将当前函数放入等待队列；否则放在就绪队列，并将此<code>impl</code>放入完成事件中进行等待。</p><h2>Asio 实现概览</h2><p>总的来说，这些io object 都算 initiator的范畴,启动一个异步操作之后，转接相应的服务类最后到具体的平台相关的xxx_service_impl post 对应的op到io_service上。</p><p>因此<code>Asio</code>的总体体系结构可以分为3层：<code>io object</code> 层，<code>basic</code> 模板层和服务层。</p><ul><li> io object 层，作为应用程序直接使用的对象，是各种basic模板类的<code>typedef</code>实例类型；<br/> </li><li> basic 模板类层，提供对外操作的接口，并把具体操作转发给服务层；<br/> </li><li> 服务层，提供具体操作的底层实现，又可分为操作转接层和平台实现层。<br/> </li></ul><p>通过对Asio中主要对象类型的交互，我们可以推断出整个异步操作的执行流程就是：</p><ul><li> 建立<code>io_service</code>，并在此<code>io_service</code>之上建立一些<code>io objects</code><br/> </li><li> 通过<code>io objects</code>调用异步操作，例如<code>async_connect</code>;<br/> </li><li> 通过多层的service转接，最后生成对应的operation，并把完成handle托付给这个operation；<br/> </li><li> 发起异步操作，并将operation对象传递给平台实现相关的service，最后调用平台原生操作;<br/> </li><li> 操作系统接受IO请求，执行IO操作；<br/> </li><li> IOCP是等待异步等待操作完成，其他平台是等待<code>IO</code>可以进行；<br/> </li><li> 等待条件满足之后，执行下一个函数，IOCP是回调函数，非IOCP是真正的IO函数之后串联回调函数；<br/> </li></ul><h2>win io service 实现</h2><p>在windows平台上，IOCP已经提供了很多异步操作的功能，所以相对来说 <code>win_iocp_io_service</code>比 <code>task_io_service</code>简单点，所以我们先来分析<code>win_iocp_io_service</code>的实现。</p><p>根据我们在之前对IOCP的分析，IOCP的使用流程可以分为如下几个步骤：</p><ul><li> 使用Win函数<code>CreateIoCompletionPort()</code>创建一个完成端口对象； <br/> </li><li> 创建一个IO对象，如用于listen的socket对象,并通过<code>CreateIoCompletionPort()</code>函数将创建的对象绑定到第一步中的完成端口中。<br/> </li><li> 创建一个线程或者线程池，用以服务完成端口事件；所有这些线程调用<code>GetQueuedCompletionStatus()</code>函数等待一个完成端口事件的到来；<br/> </li><li> IO对象进行异步调用，例如<code>WSASend()</code>等操作。 <br/> </li><li> 在系统执行完异步操作并把事件投递到端口上，或者客户自己调用了<code>PostQueuedCompletionStatus()</code>函数，使得在完成端口上等待的一个线程苏醒，执行后续的服务操作。<br/> </li></ul><p>现在我们去<code>Asio</code>中寻找执行这些流程的具体代码。首先我们来看完成端口的创建，这个是在<code>win_iocp_io_service</code>的构造函数中调用的：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">win_iocp_io_service</span><span class=\"o\">::</span><span class=\"n\">win_iocp_io_service</span><span class=\"p\">(</span>\n    <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">io_service</span><span class=\"o\">&amp;</span> <span class=\"n\">io_service</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">concurrency_hint</span><span class=\"p\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">service_base</span><span class=\"o\">&lt;</span><span class=\"n\">win_iocp_io_service</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">io_service</span><span class=\"p\">),</span>\n    <span class=\"n\">iocp_</span><span class=\"p\">(),</span>\n    <span class=\"n\">outstanding_work_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n    <span class=\"n\">stopped_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n    <span class=\"n\">stop_event_posted_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n    <span class=\"n\">shutdown_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n    <span class=\"n\">gqcs_timeout_</span><span class=\"p\">(</span><span class=\"n\">get_gqcs_timeout</span><span class=\"p\">()),</span>\n    <span class=\"n\">dispatch_required_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">BOOST_ASIO_HANDLER_TRACKING_INIT</span><span class=\"p\">;</span>\n\n  <span class=\"n\">iocp_</span><span class=\"p\">.</span><span class=\"n\">handle</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">CreateIoCompletionPort</span><span class=\"p\">(</span><span class=\"n\">INVALID_HANDLE_VALUE</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n      <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">DWORD</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">concurrency_hint</span> <span class=\"o\">&lt;</span> <span class=\"n\">DWORD</span><span class=\"p\">(</span><span class=\"o\">~</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"o\">?</span> <span class=\"nl\">concurrency_hint</span> <span class=\"p\">:</span> <span class=\"n\">DWORD</span><span class=\"p\">(</span><span class=\"o\">~</span><span class=\"mi\">0</span><span class=\"p\">)));</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">iocp_</span><span class=\"p\">.</span><span class=\"n\">handle</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">DWORD</span> <span class=\"n\">last_error</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">GetLastError</span><span class=\"p\">();</span>\n    <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span> <span class=\"n\">ec</span><span class=\"p\">(</span><span class=\"n\">last_error</span><span class=\"p\">,</span>\n        <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">error</span><span class=\"o\">::</span><span class=\"n\">get_system_category</span><span class=\"p\">());</span>\n    <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">detail</span><span class=\"o\">::</span><span class=\"n\">throw_error</span><span class=\"p\">(</span><span class=\"n\">ec</span><span class=\"p\">,</span> <span class=\"s\">&#34;iocp&#34;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的<code>iocp_</code>是一个RAII类型，封装了完成端口的析构操作：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">struct</span> <span class=\"n\">auto_handle</span>\n<span class=\"p\">{</span>\n<span class=\"n\">HANDLE</span> <span class=\"n\">handle</span><span class=\"p\">;</span>\n<span class=\"n\">auto_handle</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">handle</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n<span class=\"o\">~</span><span class=\"n\">auto_handle</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">handle</span><span class=\"p\">)</span> <span class=\"o\">::</span><span class=\"n\">CloseHandle</span><span class=\"p\">(</span><span class=\"n\">handle</span><span class=\"p\">);</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// The IO completion port used for queueing operations.\n</span><span class=\"c1\"></span><span class=\"n\">auto_handle</span> <span class=\"n\">iocp_</span><span class=\"p\">;</span>\n</code></pre></div><p>因此，每一个<code>io_service</code>都会对应着一个完成端口。</p><p>现在我们来考虑完成端口的绑定问题。在创建<code>io objects</code>时，我们需要把这些对象绑定到完成端口之上，这里<code>win_iocp_io_service</code>提供了绑定服务：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span> <span class=\"n\">win_iocp_io_service</span><span class=\"o\">::</span><span class=\"n\">register_handle</span><span class=\"p\">(</span>\n    <span class=\"n\">HANDLE</span> <span class=\"n\">handle</span><span class=\"p\">,</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">CreateIoCompletionPort</span><span class=\"p\">(</span><span class=\"n\">handle</span><span class=\"p\">,</span> <span class=\"n\">iocp_</span><span class=\"p\">.</span><span class=\"n\">handle</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">DWORD</span> <span class=\"n\">last_error</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">GetLastError</span><span class=\"p\">();</span>\n    <span class=\"n\">ec</span> <span class=\"o\">=</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">(</span><span class=\"n\">last_error</span><span class=\"p\">,</span>\n        <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">error</span><span class=\"o\">::</span><span class=\"n\">get_system_category</span><span class=\"p\">());</span>\n  <span class=\"p\">}</span>\n  <span class=\"k\">else</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">ec</span> <span class=\"o\">=</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"k\">return</span> <span class=\"n\">ec</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>所以这些对象的构造函数都会带有<code>io_service&amp;</code>的参数，就是为了绑定完成端口使用的。我们来看一下这个函数的调用方是如何使用<code>register_handle</code>的：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span> <span class=\"n\">win_iocp_socket_service_base</span><span class=\"o\">::</span><span class=\"n\">do_open</span><span class=\"p\">(</span>\n    <span class=\"n\">win_iocp_socket_service_base</span><span class=\"o\">::</span><span class=\"n\">base_implementation_type</span><span class=\"o\">&amp;</span> <span class=\"n\">impl</span><span class=\"p\">,</span>\n    <span class=\"kt\">int</span> <span class=\"n\">family</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">type</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">protocol</span><span class=\"p\">,</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">is_open</span><span class=\"p\">(</span><span class=\"n\">impl</span><span class=\"p\">))</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">ec</span> <span class=\"o\">=</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">error</span><span class=\"o\">::</span><span class=\"n\">already_open</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">ec</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">socket_holder</span> <span class=\"n\">sock</span><span class=\"p\">(</span><span class=\"n\">socket_ops</span><span class=\"o\">::</span><span class=\"n\">socket</span><span class=\"p\">(</span><span class=\"n\">family</span><span class=\"p\">,</span> <span class=\"n\">type</span><span class=\"p\">,</span> <span class=\"n\">protocol</span><span class=\"p\">,</span> <span class=\"n\">ec</span><span class=\"p\">));</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">invalid_socket</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">ec</span><span class=\"p\">;</span>\n\n  <span class=\"n\">HANDLE</span> <span class=\"n\">sock_as_handle</span> <span class=\"o\">=</span> <span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"n\">HANDLE</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">());</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">iocp_service_</span><span class=\"p\">.</span><span class=\"n\">register_handle</span><span class=\"p\">(</span><span class=\"n\">sock_as_handle</span><span class=\"p\">,</span> <span class=\"n\">ec</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">ec</span><span class=\"p\">;</span>\n\n  <span class=\"n\">impl</span><span class=\"p\">.</span><span class=\"n\">socket_</span> <span class=\"o\">=</span> <span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">release</span><span class=\"p\">();</span>\n  <span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"n\">type</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n  <span class=\"k\">case</span> <span class=\"nl\">SOCK_STREAM</span><span class=\"p\">:</span> <span class=\"n\">impl</span><span class=\"p\">.</span><span class=\"n\">state_</span> <span class=\"o\">=</span> <span class=\"n\">socket_ops</span><span class=\"o\">::</span><span class=\"n\">stream_oriented</span><span class=\"p\">;</span> <span class=\"k\">break</span><span class=\"p\">;</span>\n  <span class=\"k\">case</span> <span class=\"nl\">SOCK_DGRAM</span><span class=\"p\">:</span> <span class=\"n\">impl</span><span class=\"p\">.</span><span class=\"n\">state_</span> <span class=\"o\">=</span> <span class=\"n\">socket_ops</span><span class=\"o\">::</span><span class=\"n\">datagram_oriented</span><span class=\"p\">;</span> <span class=\"k\">break</span><span class=\"p\">;</span>\n  <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"n\">impl</span><span class=\"p\">.</span><span class=\"n\">state_</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"k\">break</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n  <span class=\"n\">impl</span><span class=\"p\">.</span><span class=\"n\">cancel_token_</span><span class=\"p\">.</span><span class=\"n\">reset</span><span class=\"p\">(</span><span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">socket_ops</span><span class=\"o\">::</span><span class=\"n\">noop_deleter</span><span class=\"p\">());</span>\n  <span class=\"n\">ec</span> <span class=\"o\">=</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">();</span>\n  <span class=\"k\">return</span> <span class=\"n\">ec</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>简而言之呢，就是每个<code>socket</code>打开之后都会绑定在完成端口上。其实还有一个<code>do_assign</code>函数也调用了<code>register_handle</code>，这可函数可以当作拷贝构造函数吧，反正执行流与<code>do_open</code>差不多，只不过不会再构造一个新的<code>socket</code>了。</p><p>服务和对象都创建好了之后，我们需要一个线程池来执行任务。创建线程池在<code>Asio</code>中还是比较简单的：</p><div class=\"highlight\"><pre><code class=\"language-text\">thread1=std::thread(&amp;io_service.run);\nthread1.join();</code></pre></div><p>这样就可以为这个<code>io_service</code>增加一个线程执行单元了。</p><p>到具体平台执行层，这个<code>run</code>函数会委托到<code>win_io_iocp_service::run</code>来执行，这个函数的实现见下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">size_t</span> <span class=\"n\">win_iocp_io_service</span><span class=\"o\">::</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">InterlockedExchangeAdd</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">outstanding_work_</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">stop</span><span class=\"p\">();</span>\n    <span class=\"n\">ec</span> <span class=\"o\">=</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">();</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n \n  <span class=\"n\">win_iocp_thread_info</span> <span class=\"n\">this_thread</span><span class=\"p\">;</span>\n  <span class=\"n\">thread_call_stack</span><span class=\"o\">::</span><span class=\"n\">context</span> <span class=\"n\">ctx</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">this_thread</span><span class=\"p\">);</span>\n \n  <span class=\"n\">size_t</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n   <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">do_one</span><span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">,</span> <span class=\"n\">ec</span><span class=\"p\">))</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">numeric_limits</span><span class=\"o\">&lt;</span><span class=\"n\">size_t</span><span class=\"o\">&gt;::</span><span class=\"n\">max</span><span class=\"p\">)())</span>\n      <span class=\"o\">++</span><span class=\"n\">n</span><span class=\"p\">;</span>\n  <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>首先检查是否有未完成的操作，如果没有直接返回。否则将当前线程加入线程列表，然后开始循环的<code>do_one</code>来完成一个回调，每完成一个计数加一。</p><p>所有的任务都委托到了<code>do_one</code>中，这个才会与完成队列直接交互。这个函数的实现大约有110多行，这里我们分部分来分析。这个函数的整个函数体都被放在一个无限循环之中：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">for</span> <span class=\"p\">(;;)</span>\n</code></pre></div><p>每次循环的头部是首先获得由于系统忙而导致未投递出的任务：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Try to acquire responsibility for dispatching timers and completed ops.\n</span><span class=\"c1\"></span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">InterlockedCompareExchange</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">dispatch_required_</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">dispatch_mutex_</span><span class=\"p\">);</span>\n\n  <span class=\"c1\">// Dispatch pending timers and operations.\n</span><span class=\"c1\"></span>  <span class=\"n\">op_queue</span><span class=\"o\">&lt;</span><span class=\"n\">win_iocp_operation</span><span class=\"o\">&gt;</span> <span class=\"n\">ops</span><span class=\"p\">;</span>\n  <span class=\"n\">ops</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">completed_ops_</span><span class=\"p\">);</span>\n  <span class=\"n\">timer_queues_</span><span class=\"p\">.</span><span class=\"n\">get_ready_timers</span><span class=\"p\">(</span><span class=\"n\">ops</span><span class=\"p\">);</span>\n  <span class=\"n\">post_deferred_completions</span><span class=\"p\">(</span><span class=\"n\">ops</span><span class=\"p\">);</span>\n  <span class=\"n\">update_timeout</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的<code>dispatch_required_</code>记录了是否有未投递出去的任务，取值范围只有0和1。而<code>completed_ops_</code>则存储了这些未成功投递的任务，每次循环都要把这些任务重新投递一次。</p><p>处理完未投递任务之后，我们开始在完成端口上等待一个事件的完成，或者超时：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Get the next operation from the queue.\n</span><span class=\"c1\"></span><span class=\"n\">DWORD</span> <span class=\"n\">bytes_transferred</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"n\">dword_ptr_t</span> <span class=\"n\">completion_key</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"n\">LPOVERLAPPED</span> <span class=\"n\">overlapped</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"o\">::</span><span class=\"n\">SetLastError</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"n\">BOOL</span> <span class=\"n\">ok</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">GetQueuedCompletionStatus</span><span class=\"p\">(</span><span class=\"n\">iocp_</span><span class=\"p\">.</span><span class=\"n\">handle</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">bytes_transferred</span><span class=\"p\">,</span>\n    <span class=\"o\">&amp;</span><span class=\"n\">completion_key</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">overlapped</span><span class=\"p\">,</span> <span class=\"n\">block</span> <span class=\"o\">?</span> <span class=\"nl\">gqcs_timeout_</span> <span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"n\">DWORD</span> <span class=\"n\">last_error</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">GetLastError</span><span class=\"p\">();</span>\n</code></pre></div><p>在得到了一个完成事件或者超时之后，我们检查返回的<code>OVERLAPPED</code>结构。如果有效的话，则转换为<code>operation</code>结构，因为<code>operation</code>结构是直接继承自<code>OVERLAPPED</code>的。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">win_iocp_operation</span><span class=\"o\">*</span> <span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">win_iocp_operation</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">overlapped</span><span class=\"p\">);</span>\n<span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span> <span class=\"n\">result_ec</span><span class=\"p\">(</span><span class=\"n\">last_error</span><span class=\"p\">,</span>\n  <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">asio</span><span class=\"o\">::</span><span class=\"n\">error</span><span class=\"o\">::</span><span class=\"n\">get_system_category</span><span class=\"p\">());</span>\n</code></pre></div><p>在做任何操作之间首先检查是否异常，然后再做后续的操作：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// We may have been passed the last_error and bytes_transferred in the\n</span><span class=\"c1\">// OVERLAPPED structure itself.\n</span><span class=\"c1\"></span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">completion_key</span> <span class=\"o\">==</span> <span class=\"n\">overlapped_contains_result</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"n\">result_ec</span> <span class=\"o\">=</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">(</span><span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">Offset</span><span class=\"p\">),</span>\n    <span class=\"o\">*</span><span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_category</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">Internal</span><span class=\"p\">));</span>\n<span class=\"n\">bytes_transferred</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">OffsetHigh</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// Otherwise ensure any result has been saved into the OVERLAPPED\n</span><span class=\"c1\">// structure.\n</span><span class=\"c1\"></span><span class=\"k\">else</span>\n<span class=\"p\">{</span>\n<span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">Internal</span> <span class=\"o\">=</span> <span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"n\">ulong_ptr_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">result_ec</span><span class=\"p\">.</span><span class=\"n\">category</span><span class=\"p\">());</span>\n<span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">Offset</span> <span class=\"o\">=</span> <span class=\"n\">result_ec</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">();</span>\n<span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">OffsetHigh</span> <span class=\"o\">=</span> <span class=\"n\">bytes_transferred</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这个所谓的后续操作就是调用我们之前设置的回调函数，即<code>operation.complete</code>:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Dispatch the operation only if ready. The operation may not be ready\n</span><span class=\"c1\">// if the initiating function (e.g. a call to WSARecv) has not yet\n</span><span class=\"c1\">// returned. This is because the initiating function still wants access\n</span><span class=\"c1\">// to the operation&#39;s OVERLAPPED structure.\n</span><span class=\"c1\"></span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">InterlockedCompareExchange</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">ready_</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// Ensure the count of outstanding work is decremented on block exit.\n</span><span class=\"c1\"></span>    <span class=\"n\">work_finished_on_block_exit</span> <span class=\"n\">on_exit</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"k\">this</span> <span class=\"p\">};</span>\n    <span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"n\">on_exit</span><span class=\"p\">;</span>\n\n    <span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">complete</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">result_ec</span><span class=\"p\">,</span> <span class=\"n\">bytes_transferred</span><span class=\"p\">);</span>\n    <span class=\"n\">ec</span> <span class=\"o\">=</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">();</span>\n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的<code>work_finished_on_block_exit</code>又是一个<code>RAII</code>类，其唯一动作就是将<code>outstanding_work_</code>减1。自此，一个IO事件就算彻底完成了。</p><p>上面的代码已经说明了任务是怎么消费的，但是任务是如何添加的我们还没有搞清楚。在<code>windows</code>上，我们可通过两种形式往完成队列添加信息：</p><ul><li> 一个是异步操作完成，操作系统自己通过完成端口添加完成事件；<br/> </li><li> 另外一个是手动调用<code>PostQueuedCompletionStatus</code>函数往完成端口添加完成事件。<br/> </li></ul><p>一般的异步操作都是第一种情形，例如<code>async_read</code>和<code>async_write</code>。但是有些操作并没有利用重叠IO机制，需要手动添加完成事件。例如：</p><ul><li><code>async_resolver</code> 这个操作系统并没有提供对应的重叠IO操作；<br/> </li><li><code>async_connect</code> 这个是<code>Asio</code>作者并没有采用支持重叠IO的<code>ConnectEx</code>函数；<br/> </li><li><code>io_service</code>自带的<code>post</code>和<code>dispatch</code>操作，压根就不属于IO范围，只不过复用了多线程处理队列而已。<br/> </li></ul><p>对于这些类型的完成事件的提交，都会调用<code>post_immediate_completion</code>来处理。这个函数只会将<code>outstanding_work_</code>加1，然后调用<code>post_deferred_completion</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">win_iocp_io_service</span><span class=\"o\">::</span><span class=\"n\">post_deferred_completion</span><span class=\"p\">(</span><span class=\"n\">win_iocp_operation</span><span class=\"o\">*</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// Flag the operation as ready.\n</span><span class=\"c1\"></span>  <span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">ready_</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// Enqueue the operation on the I/O completion port.\n</span><span class=\"c1\"></span>  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!::</span><span class=\"n\">PostQueuedCompletionStatus</span><span class=\"p\">(</span><span class=\"n\">iocp_</span><span class=\"p\">.</span><span class=\"n\">handle</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">))</span>\n  <span class=\"p\">{</span>\n    <span class=\"c1\">// Out of resources. Put on completed queue instead.\n</span><span class=\"c1\"></span>    <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">dispatch_mutex_</span><span class=\"p\">);</span>\n    <span class=\"n\">completed_ops_</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">);</span>\n    <span class=\"o\">::</span><span class=\"n\">InterlockedExchange</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">dispatch_required_</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这个函数只是将这些完成事件放到一个待处理的队列之中，最后一整批的放入系统的完成端口上：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">win_iocp_io_service</span><span class=\"o\">::</span><span class=\"n\">post_deferred_completions</span><span class=\"p\">(</span>\n    <span class=\"n\">op_queue</span><span class=\"o\">&lt;</span><span class=\"n\">win_iocp_operation</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">ops</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">win_iocp_operation</span><span class=\"o\">*</span> <span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">ops</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">())</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">ops</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// Flag the operation as ready.\n</span><span class=\"c1\"></span>    <span class=\"n\">op</span><span class=\"o\">-&gt;</span><span class=\"n\">ready_</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n    <span class=\"c1\">// Enqueue the operation on the I/O completion port.\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!::</span><span class=\"n\">PostQueuedCompletionStatus</span><span class=\"p\">(</span><span class=\"n\">iocp_</span><span class=\"p\">.</span><span class=\"n\">handle</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n      <span class=\"c1\">// Out of resources. Put on completed queue instead.\n</span><span class=\"c1\"></span>      <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">dispatch_mutex_</span><span class=\"p\">);</span>\n      <span class=\"n\">completed_ops_</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">);</span>\n      <span class=\"n\">completed_ops_</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">ops</span><span class=\"p\">);</span>\n      <span class=\"o\">::</span><span class=\"n\">InterlockedExchange</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">dispatch_required_</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这个函数的调用时机就是每次<code>do_one</code>循环的开头，通过检查<code>dispatch_required_</code>来判断这个<code>ops</code>是不是空，如果不为空则调用此函数。</p><h2>task io service 实现</h2><p>在无<code>IOCP</code>支持的情况下，<code>Asio</code>可用的只有<code>select/poll/epoll/kqueue</code>之类的多路复用模式（windows也支持select，不过较弱，限制较多）。</p><p>而<code>task_io_service</code>这个类本身也是一个接口类，基本提供了与<code>win_iocp_io_service</code>等价的接口，同时会把操作转接到<code>select/poll/epoll/kqueue</code>之上去，我们这里就分析一下基于<code>epoll</code>的实现。</p><p>同样的，我们都以<code>run</code>这个函数为入口：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">task_io_service</span><span class=\"o\">::</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">ec</span> <span class=\"o\">=</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"p\">();</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">outstanding_work_</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">stop</span><span class=\"p\">();</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">thread_info</span> <span class=\"n\">this_thread</span><span class=\"p\">;</span>\n  <span class=\"n\">this_thread</span><span class=\"p\">.</span><span class=\"n\">private_outstanding_work</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"n\">thread_call_stack</span><span class=\"o\">::</span><span class=\"n\">context</span> <span class=\"n\">ctx</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">this_thread</span><span class=\"p\">);</span>\n\n  <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">mutex_</span><span class=\"p\">);</span>\n\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"k\">for</span> <span class=\"p\">(;</span> <span class=\"n\">do_run_one</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">,</span> <span class=\"n\">this_thread</span><span class=\"p\">,</span> <span class=\"n\">ec</span><span class=\"p\">);</span> <span class=\"n\">lock</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">())</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">numeric_limits</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span><span class=\"o\">&gt;::</span><span class=\"n\">max</span><span class=\"p\">)())</span>\n      <span class=\"o\">++</span><span class=\"n\">n</span><span class=\"p\">;</span>\n  <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>首先构造一个<code>thread_info</code>，和<code>first_idle_thread_</code>类型相同，即通过<code>first_idle_thread_</code>将所有线程串联起来，它这个串联不是立即串联的，当该线程无任务可做是加入到<code>first_idle_thread_</code>的首部，有任务执行时，从<code>first_idle_thread_</code>中断开。这很正常，因为<code>first_idle_thread_</code>维护的是当前空闲线程。</p><p>这里与<code>iocp_service</code>不同的地方就是有了一个<code>lock</code>，这个lock是用来互斥访问<code>task_io_service</code>的数据的；同时<code>do_one</code>函数改为了<code>do_run_one</code>。所有的四个具体的执行函数的参数中都有这个<code>lock</code>:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Run at most one operation. May block.\n</span><span class=\"c1\"></span><span class=\"n\">BOOST_ASIO_DECL</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">do_run_one</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span><span class=\"o\">&amp;</span> <span class=\"n\">lock</span><span class=\"p\">,</span>\n  <span class=\"n\">thread_info</span><span class=\"o\">&amp;</span> <span class=\"n\">this_thread</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// Poll for at most one operation.\n</span><span class=\"c1\"></span><span class=\"n\">BOOST_ASIO_DECL</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">do_poll_one</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span><span class=\"o\">&amp;</span> <span class=\"n\">lock</span><span class=\"p\">,</span>\n  <span class=\"n\">thread_info</span><span class=\"o\">&amp;</span> <span class=\"n\">this_thread</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// Stop the task and all idle threads.\n</span><span class=\"c1\"></span><span class=\"n\">BOOST_ASIO_DECL</span> <span class=\"kt\">void</span> <span class=\"nf\">stop_all_threads</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span><span class=\"o\">&amp;</span> <span class=\"n\">lock</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// Wake a single idle thread, or the task, and always unlock the mutex.\n</span><span class=\"c1\"></span><span class=\"n\">BOOST_ASIO_DECL</span> <span class=\"kt\">void</span> <span class=\"nf\">wake_one_thread_and_unlock</span><span class=\"p\">(</span>\n  <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span><span class=\"o\">&amp;</span> <span class=\"n\">lock</span><span class=\"p\">);</span>\n</code></pre></div><p>这里我们继续跟进<code>do_run_one</code>函数，看看他干了些什么：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">task_io_service</span><span class=\"o\">::</span><span class=\"n\">do_run_one</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span><span class=\"o\">&amp;</span> <span class=\"n\">lock</span><span class=\"p\">,</span>\n    <span class=\"n\">task_io_service</span><span class=\"o\">::</span><span class=\"n\">thread_info</span><span class=\"o\">&amp;</span> <span class=\"n\">this_thread</span><span class=\"p\">,</span>\n    <span class=\"k\">const</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"o\">::</span><span class=\"n\">error_code</span><span class=\"o\">&amp;</span> <span class=\"n\">ec</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">stopped_</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">op_queue_</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span>\n    <span class=\"p\">{</span>\n      <span class=\"c1\">// Prepare to execute first handler from queue.\n</span><span class=\"c1\"></span>      <span class=\"n\">operation</span><span class=\"o\">*</span> <span class=\"n\">o</span> <span class=\"o\">=</span> <span class=\"n\">op_queue_</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">();</span>\n      <span class=\"n\">op_queue_</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">();</span>\n      <span class=\"kt\">bool</span> <span class=\"n\">more_handlers</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">op_queue_</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">());</span>\n\n      <span class=\"c1\">//执行具体任务\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n    <span class=\"k\">else</span>\n    <span class=\"p\">{</span>\n      <span class=\"n\">wakeup_event_</span><span class=\"p\">.</span><span class=\"n\">clear</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">);</span>\n      <span class=\"n\">wakeup_event_</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n  <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里的操作就是每次从<code>op_queue</code>（其实是一个侵入性链表）里拿出头节点，然后处理。如果这个队列为空，那么就等待。</p><p>又根据与一个特殊的<code>task_operation_</code>的比较结果，这里的具体执行任务分为了两种情况。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">o</span> <span class=\"o\">==</span> <span class=\"o\">&amp;</span><span class=\"n\">task_operation_</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">task_interrupted_</span> <span class=\"o\">=</span> <span class=\"n\">more_handlers</span><span class=\"p\">;</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">more_handlers</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">one_thread_</span><span class=\"p\">)</span>\n      <span class=\"n\">wakeup_event_</span><span class=\"p\">.</span><span class=\"n\">unlock_and_signal_one</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">);</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">lock</span><span class=\"p\">.</span><span class=\"n\">unlock</span><span class=\"p\">();</span>\n\n    <span class=\"n\">task_cleanup</span> <span class=\"n\">on_exit</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">lock</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">this_thread</span> <span class=\"p\">};</span>\n    <span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"n\">on_exit</span><span class=\"p\">;</span>\n\n    <span class=\"c1\">// Run the task. May throw an exception. Only block if the operation\n</span><span class=\"c1\"></span>    <span class=\"c1\">// queue is empty and we&#39;re not polling, otherwise we want to return\n</span><span class=\"c1\"></span>    <span class=\"c1\">// as soon as possible.\n</span><span class=\"c1\"></span>    <span class=\"n\">task_</span><span class=\"o\">-&gt;</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">more_handlers</span><span class=\"p\">,</span> <span class=\"n\">this_thread</span><span class=\"p\">.</span><span class=\"n\">private_op_queue</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>这里的逻辑就比较诡异了，首先做的是：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Operation object to represent the position of the task in the queue.\n</span><span class=\"c1\"></span><span class=\"k\">struct</span> <span class=\"nl\">task_operation</span> <span class=\"p\">:</span> <span class=\"n\">operation</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">task_operation</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">operation</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n<span class=\"p\">}</span> <span class=\"n\">task_operation_</span><span class=\"p\">;</span>\n</code></pre></div><p>如果我们得到的<code>operation</code>就是这个特殊的<code>task_operation_</code>的话，再根据队列是否还有剩下的任务以及是否是单线程执行的做下一步操作。如果有剩下的任务且是多线程环境，则使用<code>wake_one_thread_and|unlock</code>尝试唤醒可能休眠的线程；否则直接释放锁。可以看出，这个<code>task_operation_</code>的用途肯定是说明当前线程不适合执行任务了。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">task_io_service</span><span class=\"o\">::</span><span class=\"n\">wake_one_thread_and_unlock</span><span class=\"p\">(</span>\n    <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span><span class=\"o\">&amp;</span> <span class=\"n\">lock</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">wakeup_event_</span><span class=\"p\">.</span><span class=\"n\">maybe_unlock_and_signal_one</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">))</span>\n  <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">task_interrupted_</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">task_</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n      <span class=\"n\">task_interrupted_</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n      <span class=\"n\">task_</span><span class=\"o\">-&gt;</span><span class=\"n\">interrupt</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">lock</span><span class=\"p\">.</span><span class=\"n\">unlock</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这个<code>wakeup_event</code>是<code>event</code>类型的，这又是一个各种实现的别名：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#if !defined(BOOST_ASIO_HAS_THREADS)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"n\">null_event</span> <span class=\"n\">event</span><span class=\"p\">;</span>\n<span class=\"cp\">#elif defined(BOOST_ASIO_WINDOWS)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"n\">win_event</span> <span class=\"n\">event</span><span class=\"p\">;</span>\n<span class=\"cp\">#elif defined(BOOST_ASIO_HAS_PTHREADS)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"n\">posix_event</span> <span class=\"n\">event</span><span class=\"p\">;</span>\n<span class=\"cp\">#elif defined(BOOST_ASIO_HAS_STD_MUTEX_AND_CONDVAR)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"n\">std_event</span> <span class=\"n\">event</span><span class=\"p\">;</span>\n<span class=\"cp\">#endif\n</span></code></pre></div><p>这里我就尝试去查看<code>std</code>的实现。实现上来说还是非常简单的，用条件变量来等待和通知，我就不贴代码了。</p><p>整个流程就是：若有空闲线程，则唤醒空闲线程；若没有空闲线程，但是有线程在执行<code>task-&gt;run</code>，即阻塞在<code>epoll_wait</code>上，那么先中断<code>epoll_wait</code>执行任务队列完成后再执行<code>epoll_wait</code>。这个阻塞标记位就是<code>task_interrupted_</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// The task to be run by this service.\n</span><span class=\"c1\"></span><span class=\"n\">reactor</span><span class=\"o\">*</span> <span class=\"n\">task_</span><span class=\"p\">;</span>\n</code></pre></div><p>然后就是让<code>reactor</code>执行当前线程的私有任务队列，最后返回的时候利用<code>task_cleanup</code>这个<code>RAII</code>类型去做一些清理工作：</p><div class=\"highlight\"><pre><code class=\"language-text\">struct task_io_service::task_cleanup\n{\n  ~task_cleanup()\n  {\n    if (this_thread_-&gt;private_outstanding_work &gt; 0)\n    {\n      boost::asio::detail::increment(\n          task_io_service_-&gt;outstanding_work_,\n          this_thread_-&gt;private_outstanding_work);\n    }\n    this_thread_-&gt;private_outstanding_work = 0;\n\n    // Enqueue the completed operations and reinsert the task at the end of\n    // the operation queue.\n    lock_-&gt;lock();\n    task_io_service_-&gt;task_interrupted_ = true;\n    task_io_service_-&gt;op_queue_.push(this_thread_-&gt;private_op_queue);\n    task_io_service_-&gt;op_queue_.push(&amp;task_io_service_-&gt;task_operation_);\n  }\n\n  task_io_service* task_io_service_;\n  mutex::scoped_lock* lock_;\n  thread_info* this_thread_;\n};</code></pre></div><p>这里的操作就是将本线程的私有队列放入全局队列中，然后用<code>task_operation_</code>来标记一个线程私有队列的结束。</p><p>以上这些操作中唯一可疑的就是<code>reactor.run</code>函数了，我们继续顺藤摸瓜。在<code>Asio</code>中，<code>reactor</code>有多种实现模式，是一个代理类：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#if defined(BOOST_ASIO_WINDOWS_RUNTIME)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">null_reactor</span> <span class=\"n\">reactor</span><span class=\"p\">;</span>\n<span class=\"cp\">#elif defined(BOOST_ASIO_HAS_IOCP)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">select_reactor</span> <span class=\"n\">reactor</span><span class=\"p\">;</span>\n<span class=\"cp\">#elif defined(BOOST_ASIO_HAS_EPOLL)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">epoll_reactor</span> <span class=\"n\">reactor</span><span class=\"p\">;</span>\n<span class=\"cp\">#elif defined(BOOST_ASIO_HAS_KQUEUE)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">kqueue_reactor</span> <span class=\"n\">reactor</span><span class=\"p\">;</span>\n<span class=\"cp\">#elif defined(BOOST_ASIO_HAS_DEV_POLL)\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">dev_poll_reactor</span> <span class=\"n\">reactor</span><span class=\"p\">;</span>\n<span class=\"cp\">#else\n</span><span class=\"cp\"></span><span class=\"k\">typedef</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">select_reactor</span> <span class=\"n\">reactor</span><span class=\"p\">;</span>\n<span class=\"cp\">#endif\n</span></code></pre></div><p>我们这里就查看一下<code>epoll.run</code>的实现吧，这个函数也比较长，我们分部分的来解析。首先是其签名：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">epoll_reactor</span><span class=\"o\">::</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"kt\">bool</span> <span class=\"n\">block</span><span class=\"p\">,</span> <span class=\"n\">op_queue</span><span class=\"o\">&lt;</span><span class=\"n\">operation</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">ops</span><span class=\"p\">)</span>\n  <span class=\"c1\">// This code relies on the fact that the task_io_service queues the reactor\n</span><span class=\"c1\"></span>  <span class=\"c1\">// task behind all descriptor operations generated by this function. This\n</span><span class=\"c1\"></span>  <span class=\"c1\">// means, that by the time we reach this point, any previously returned\n</span><span class=\"c1\"></span>  <span class=\"c1\">// descriptor operations have already been dequeued. Therefore it is now safe\n</span><span class=\"c1\"></span>  <span class=\"c1\">// for us to reuse and return them for the task_io_service to queue again.\n</span></code></pre></div><p>这里首先对时钟的<code>time_out</code>做处理，设置好正确的<code>time_out</code>参数。如果有<code>timer_fd</code>在等待队列内且调用设置为非阻塞，则我们设置为立即返回；否则设置为阻塞。没有使用<code>timer_fd</code>的话则获取之前设置的<code>time_out</code>参数。  </p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Calculate a timeout only if timerfd is not used.\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">timeout</span><span class=\"p\">;</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">timer_fd_</span> <span class=\"o\">!=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"n\">block</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"k\">else</span>\n<span class=\"p\">{</span>\n<span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">mutex_</span><span class=\"p\">);</span>\n<span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"n\">block</span> <span class=\"o\">?</span> <span class=\"n\">get_timeout</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>然后我们开始设置好<code>epoll_wait</code>的参数，开始等待。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Block on the epoll descriptor.\n</span><span class=\"c1\"></span><span class=\"n\">epoll_event</span> <span class=\"n\">events</span><span class=\"p\">[</span><span class=\"mi\">128</span><span class=\"p\">];</span>\n<span class=\"kt\">int</span> <span class=\"n\">num_events</span> <span class=\"o\">=</span> <span class=\"n\">epoll_wait</span><span class=\"p\">(</span><span class=\"n\">epoll_fd_</span><span class=\"p\">,</span> <span class=\"n\">events</span><span class=\"p\">,</span> <span class=\"mi\">128</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">);</span>\n</code></pre></div><p>等待完成之后，我们开始分发事件:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#if defined(BOOST_ASIO_HAS_TIMERFD)\n</span><span class=\"cp\"></span>  <span class=\"kt\">bool</span> <span class=\"n\">check_timers</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">timer_fd_</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"cp\">#else </span><span class=\"c1\">// defined(BOOST_ASIO_HAS_TIMERFD)\n</span><span class=\"c1\"></span>  <span class=\"kt\">bool</span> <span class=\"n\">check_timers</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"cp\">#endif </span><span class=\"c1\">// defined(BOOST_ASIO_HAS_TIMERFD)\n</span><span class=\"c1\"></span>\n  <span class=\"c1\">// Dispatch the waiting events.\n</span><span class=\"c1\"></span>  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">num_events</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"n\">events</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ptr</span> <span class=\"o\">==</span> <span class=\"o\">&amp;</span><span class=\"n\">interrupter_</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n      <span class=\"c1\">// No need to reset the interrupter since we&#39;re leaving the descriptor\n</span><span class=\"c1\"></span>      <span class=\"c1\">// in a ready-to-read state and relying on edge-triggered notifications\n</span><span class=\"c1\"></span>      <span class=\"c1\">// to make it so that we only get woken up when the descriptor&#39;s epoll\n</span><span class=\"c1\"></span>      <span class=\"c1\">// registration is updated.\n</span><span class=\"c1\"></span>\n<span class=\"cp\">#if defined(BOOST_ASIO_HAS_TIMERFD)\n</span><span class=\"cp\"></span>      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">timer_fd_</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">check_timers</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"cp\">#else </span><span class=\"c1\">// defined(BOOST_ASIO_HAS_TIMERFD)\n</span><span class=\"c1\"></span>      <span class=\"n\">check_timers</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"cp\">#endif </span><span class=\"c1\">// defined(BOOST_ASIO_HAS_TIMERFD)\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n<span class=\"cp\">#if defined(BOOST_ASIO_HAS_TIMERFD)\n</span><span class=\"cp\"></span>    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ptr</span> <span class=\"o\">==</span> <span class=\"o\">&amp;</span><span class=\"n\">timer_fd_</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n      <span class=\"n\">check_timers</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"cp\">#endif </span><span class=\"c1\">// defined(BOOST_ASIO_HAS_TIMERFD)\n</span><span class=\"c1\"></span>    <span class=\"k\">else</span>\n    <span class=\"p\">{</span>\n      <span class=\"c1\">// The descriptor operation doesn&#39;t count as work in and of itself, so we\n</span><span class=\"c1\"></span>      <span class=\"c1\">// don&#39;t call work_started() here. This still allows the io_service to\n</span><span class=\"c1\"></span>      <span class=\"c1\">// stop if the only remaining operations are descriptor operations.\n</span><span class=\"c1\"></span>      <span class=\"n\">descriptor_state</span><span class=\"o\">*</span> <span class=\"n\">descriptor_data</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">descriptor_state</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">);</span>\n      <span class=\"n\">descriptor_data</span><span class=\"o\">-&gt;</span><span class=\"n\">set_ready_events</span><span class=\"p\">(</span><span class=\"n\">events</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">events</span><span class=\"p\">);</span>\n      <span class=\"n\">ops</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">descriptor_data</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>这里处理了三种<code>event</code>：<code>interrupt</code>,<code>timer</code>和普通的<code>IO</code>事件。这里需要特别说明的就是<code>interrupt</code>，这个是一个特别的文件描述符。如果我们想要人工的终止<code>epoll_wait</code>，可以通过<code>select_interrupter</code>函数来将这个描述符加入到监听列表之中去。<code>select_interrupter</code>实际上实现是<code>eventfd_select_interrupter</code>，在构造的时候通过<code>pipe</code>系统调用创建两个文件描述符，然后预先通过<code>write_fd</code>写8个字节，这8个字节一直保留。在添加到<code>epoll_wait</code>中采用<code>EPOLLET</code>水平触发，这样只要<code>select_interrupter</code>的读文件描述符添加到<code>epoll_wait</code>中，立即中断<code>epoll_wait</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">epoll_reactor</span><span class=\"o\">::</span><span class=\"n\">interrupt</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">epoll_event</span> <span class=\"n\">ev</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"mi\">0</span> <span class=\"p\">}</span> <span class=\"p\">};</span>\n  <span class=\"n\">ev</span><span class=\"p\">.</span><span class=\"n\">events</span> <span class=\"o\">=</span> <span class=\"n\">EPOLLIN</span> <span class=\"o\">|</span> <span class=\"n\">EPOLLERR</span> <span class=\"o\">|</span> <span class=\"n\">EPOLLET</span><span class=\"p\">;</span>\n  <span class=\"n\">ev</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">interrupter_</span><span class=\"p\">;</span>\n  <span class=\"n\">epoll_ctl</span><span class=\"p\">(</span><span class=\"n\">epoll_fd_</span><span class=\"p\">,</span> <span class=\"n\">EPOLL_CTL_MOD</span><span class=\"p\">,</span> <span class=\"n\">interrupter_</span><span class=\"p\">.</span><span class=\"n\">read_descriptor</span><span class=\"p\">(),</span> <span class=\"o\">&amp;</span><span class=\"n\">ev</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里会调用<code>set_ready_event</code>来做一些工作，只是简单将当前事件放入可执行队列里而已。最后的结果是可执行的操作都放入了<code>this_thread</code>的<code>private_op_queue</code>之中去了，等待线程去处理。</p><p>如果不是<code>task_operation</code>，即普通的完成事件，初始处理也是类似。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">else</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">task_result</span> <span class=\"o\">=</span> <span class=\"n\">o</span><span class=\"o\">-&gt;</span><span class=\"n\">task_result_</span><span class=\"p\">;</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">more_handlers</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">one_thread_</span><span class=\"p\">)</span>\n      <span class=\"n\">wake_one_thread_and_unlock</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">);</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">lock</span><span class=\"p\">.</span><span class=\"n\">unlock</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// Ensure the count of outstanding work is decremented on block exit.\n</span><span class=\"c1\"></span>    <span class=\"n\">work_cleanup</span> <span class=\"n\">on_exit</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">lock</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">this_thread</span> <span class=\"p\">};</span>\n    <span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"n\">on_exit</span><span class=\"p\">;</span>\n\n    <span class=\"c1\">// Complete the operation. May throw an exception. Deletes the object.\n</span><span class=\"c1\"></span>    <span class=\"n\">o</span><span class=\"o\">-&gt;</span><span class=\"n\">complete</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">ec</span><span class=\"p\">,</span> <span class=\"n\">task_result</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>最后就是调用回调函数<code>operation.complete</code>，具体内容在前面的代码里也说明了：先执行<code>IO</code>，然后执行回调。至此整个线程调度可以说是完美结束。</p><p>而<code>stop</code>操作就比较简单了，直接调用<code>stop_all_threads</code>：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">task_io_service</span><span class=\"o\">::</span><span class=\"n\">stop_all_threads</span><span class=\"p\">(</span>\n    <span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span><span class=\"o\">&amp;</span> <span class=\"n\">lock</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">stopped_</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n  <span class=\"n\">wakeup_event_</span><span class=\"p\">.</span><span class=\"n\">signal_all</span><span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"p\">);</span>\n\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">task_interrupted_</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">task_</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">task_interrupted_</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"n\">task_</span><span class=\"o\">-&gt;</span><span class=\"n\">interrupt</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>直接设置<code>stopped</code>为<code>true</code>，然后唤醒所有休眠线程，这是通过<code>single</code>和<code>interrupt</code>一起实现的。</p><h2><b>the global epoll_wait lock</b></h2><p><code>epoll_wait</code> 有两种触发模式，水平触发(LT)和边缘触发(ET)， 平常我们使用的都是水平触发模式，这种模式处理起来简单，当某个fd就绪之后，对于此fd的状态查询会一直返回ready，而采取边缘触发的情况下，只有此fd变成ready态的那一次会返回ready。从工作方式上来说，边缘触发对多线程友好，不会出现多个线程在同时操作同一个fd的情况，但是使用边缘触发的代码很难写对写好，所以一般都是用水平触发，关于此内容讨论参考<u><a href=\"https://www.zhihu.com/question/20502870\" class=\"internal\">知乎链接</a></u>，asio选用的就是水平触发这种方案。使用水平触发需要做好多线程互斥，所以<code>asio</code>在设计上把<code>epoll_wait</code>所在的<code>epoll_reactor::run</code>用一个大<code>mutex</code>包裹起来，避免多个线程同时调用这个函数。</p><h2>后记</h2><p>这些内容是三年多以前搜罗网上相关内容和自己阅读asio的代码整理而成，对于asio内部实现机制有兴趣的人来说，看了之后囫囵吞枣也基本能体会出一个大概。然而本文只是浅读，想具体了解的推荐自己开着Visual Studio 一个一个函数跟进去看看。(因为这个文章里的有些东西我现在又看不懂了。。。。。)</p>", 
            "topic": [
                {
                    "tag": "计算机网络", 
                    "tagLink": "https://api.zhihu.com/topics/19572894"
                }, 
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "Boost（C++ 库）", 
                    "tagLink": "https://api.zhihu.com/topics/19698263"
                }
            ], 
            "comments": [
                {
                    "userName": "zhangt", 
                    "userLink": "https://www.zhihu.com/people/d2464f59baf9a7e775306edf45d10ebc", 
                    "content": "总感觉asio对实现太扭曲了", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "子猫", 
                            "userLink": "https://www.zhihu.com/people/345d3b856a4ba89a1192e9e68270aa96", 
                            "content": "<p>实现用的各种模板、宏的手法太多了，但使用起来很不错</p>", 
                            "likes": 0, 
                            "replyToAuthor": "zhangt"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "cpp就这点烦人，要花几倍精力去搞明白作者为什么封装成这样，要不又不放心，因为cpp项目经常又爱改源码", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "主要是 CPP 毛病太多，就这这样复杂的asio，还不能很方便的支持其他语言的绑定，照 libuv 差远了", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "amd64", 
                    "userLink": "https://www.zhihu.com/people/41164e06e0c7f5553ee412bb0c65a3bf", 
                    "content": "不得不说协程真的非常好用", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "「已注销」", 
                    "userLink": "https://www.zhihu.com/people/14aac0cd2e17e129478b1101fe540aa8", 
                    "content": "请问asio中，如何才能使用真正的异步dns请求呢？目前的resolver实际上是在一个隐藏线程中跑getaddrinfo来模拟的异步，不能做到真正的并发，不能真正处理超时。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "千寻", 
                            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
                            "content": "<p>Stackoverflow的回答是开多个ioservice......<a href=\"http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/18824746/how-to-run-boost-asio-resolver-service-on-more-threads\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">stackoverflow.com/quest</span><span class=\"invisible\">ions/18824746/how-to-run-boost-asio-resolver-service-on-more-threads</span><span class=\"ellipsis\"></span></a></p><p></p>", 
                            "likes": 0, 
                            "replyToAuthor": "「已注销」"
                        }, 
                        {
                            "userName": "「已注销」", 
                            "userLink": "https://www.zhihu.com/people/14aac0cd2e17e129478b1101fe540aa8", 
                            "content": "并不是一个好的方案，因为我的场景要求严格限制线程数量。感觉就没有好用的方案。asio的resolver是封装了getaddrinfo，这其实不仅仅是一个单纯的dns resolver了，要做到行为完全相同很难。然后是c ares，dns.c，getdns这类dns resolver，但是都缺少跟asio事件循环结合的成熟方案。", 
                            "likes": 0, 
                            "replyToAuthor": "千寻"
                        }
                    ]
                }, 
                {
                    "userName": "林荣彬", 
                    "userLink": "https://www.zhihu.com/people/5defa6edc386d873808e3154041fbaaf", 
                    "content": "<p>知乎上很少看到这么细致的技术文章，赞一个</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>真是研究的很透彻啊，这得花多长时间</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "阿兰", 
                    "userLink": "https://www.zhihu.com/people/310e2fbb9bdc1a4159d6656272d59c0e", 
                    "content": "<p>我好像记得epoll选用的是边缘触发，不是水平触发。</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Irons Du", 
                    "userLink": "https://www.zhihu.com/people/c7f04c6ec66e025b53dff356525d0581", 
                    "content": "<p>请问封装asio有什么好的姿势么？需要很好的实现gather write。我弄了一个，测试性能还将就，不知道是否最佳实践。<a href=\"http://link.zhihu.com/?target=https%3A//paste.ubuntu.com/p/CGmmnKhw7x/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">paste.ubuntu.com/p/CGmm</span><span class=\"invisible\">nKhw7x/</span><span class=\"ellipsis\"></span></a></p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55484374", 
            "userName": "千寻", 
            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
            "upvote": 3, 
            "title": "简单安全http中继服务", 
            "content": "<h2>简单http安全proxy服务</h2><h2>http代理概念</h2><p>HTTP 代理存在两种形式，分别简单介绍如下：</p><ol><li>第一种是 <a href=\"https://link.zhihu.com/?target=http%3A//tools.ietf.org/html/rfc7230\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">RFC 7230 - HTTP/1.1: Message Syntax and Routing</a>（即修订后的 RFC 2616，HTTP/1.1 协议的第一部分）描述的普通代理。这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文， 负责http相关报文的解析。</li><li>第二种是 <a href=\"https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Tunneling TCP based protocols through Web proxy servers</a>（通过 Web 代理服务器用隧道方式传输基于 TCP 的协议）描述的隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接，当原始服务器返回连接成功之后，浏览器与最终服务器之间的消息通信不再采用http协议来封装数据，而是直接传递字节流，代理服务器的作用就是进行数据转发。</li></ol><p>通过代理访问 A 网站，对于 A 来说，它会把代理当做客户端，完全察觉不到真正客户端的存在，这实现了隐藏客户端 IP 的目的。代理也可以修改 HTTP 请求头部，通过 <code>X-Forwarded-IP</code> 这样的自定义头部告诉服务端真正的客户端 IP。但服务器无法验证这个自定义头部真的是由代理添加，还是客户端修改了请求头。</p><p>给浏览器显式的指定代理，需要手动修改浏览器或操作系统相关设置，或者指定 PAC（Proxy  Auto-Configuration，自动配置代理）文件自动设置，还有些浏览器支持 WPAD（Web Proxy Autodiscovery Protocol，Web 代理自动发现协议）。显式指定浏览器代理这种方式一般称之为正向代理，浏览器启用正向代理后，会对 HTTP 请求报文做一些修改，来规避老旧代理服务器的一些问题。</p><p>还有一种情况是访问 A 网站时，实际上访问的是代理，代理收到请求报文后，再向真正提供服务的服务器发起请求，并将响应转发给浏览器。这种情况一般被称之为反向代理，它可以用来隐藏服务器 IP 及端口。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。反向代理是 Web 系统最为常见的一种部署方式，一般使用nginx来当反向代理以处理负载均衡问题。</p><h2>HTTP 协议解析</h2><p>http 报文可以分为两种：请求报文和应答报文，对于报文结构不再赘述，网上有很多资料，这里就简单贴一下图。</p><p>http 请求的格式如下:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-63dbf7f34ddf4ee61ed47a9e0e358986_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-63dbf7f34ddf4ee61ed47a9e0e358986_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;553&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-63dbf7f34ddf4ee61ed47a9e0e358986_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-63dbf7f34ddf4ee61ed47a9e0e358986_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>http 响应的格式如下:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b985168d4ed5500ce0a8f28079ef00af_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"563\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-b985168d4ed5500ce0a8f28079ef00af_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;563&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"563\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-b985168d4ed5500ce0a8f28079ef00af_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b985168d4ed5500ce0a8f28079ef00af_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里提一下自己解析协议时候的一些关键点:</p><ol><li>同一个packet内，可能存在重复的首部字段名，所有字段值是可以用逗号分割的都可以转换成多行描述的形式， 所以存储的时候不能用简单的<code>unordered_map</code>， 而要用<code>unordered_multimap</code>；</li><li>报文内的Content-Length字段给出了entity body的长度， 但是有些报文可能压根没有这个字段，采取的可能是不定的,例如<code>Transfer-Encoding:chunked</code>，此时采取的是游程编码，客户端需要不停的读取数据流，直到读取到<code>\\r\\n\\r\\n</code>，此时才代表一个packet的结束。</li><li>connect方法返回ok之后，后续流量不再是http协议，代理服务器也不要试图去解析。</li></ol><h2>连接管理</h2><p>最早的http协议里面，一个请求就要开一个tcp链接，等待请求结果回来之后，关闭这个连接。由于tcp链接的三次握手和四次握手的问题，导致延迟和消耗都非常大，所以<code>http1.1</code>版本中，加入了keep-alive选项。如果开启了<code>keep-alive</code>，则客户端收到请求之后，不再关闭链接，后续对于同站点的相关请求可以复用此链接。</p><p>对于显示的代理服务器来说，客户端发过来的请求头并没有<code>Connection: keep-alive</code>, 取而代之的是&#39;Proxy-Connection: keep-alive&#39;，代理服务器在收到这个字段之后，才能对最终服务器的链接开启<code>keep-alive</code>，否则收到返回之后直接断开与原始服务器的链接。至于为什么不复用<code>Connection</code>而采用<code>Proxy-Connection</code>，参考<a href=\"https://link.zhihu.com/?target=https%3A//imququ.com/post/the-proxy-connection-header-in-http-request.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个链接</a>。</p><h2>流量加密</h2><p>上面所说的代理服务器从原理上来说比较简单，配合一些脚本语言可能一两行就可以跑起来一个localhost的代理服务器，但是一旦代理服务器跨越了我国公网，则几乎100%的概率是连接超时。因为代理所发出来的http包是很容易识别的，所以基于这种方式通过vps搭建简单代理来走向世界是不行的，为此我们需要对http请求的tcp流量进行加密，即模拟一个轻量版（漏洞百出版）的<code>https</code>。</p><p>加密又分为两种：对称加密和非对称加密。对称加密里的加密和解密key是一样的，而非对称加密则分为公钥和私钥之分，两个密钥的内容不同，公钥公开给其他使用当前加密服务的人员使用，私钥则自己存储，一份数据经过公钥加密后可以通过私钥解密，同样的经过私钥加密之后可以通过公钥解密。这种公钥分享系统也叫做PKI。</p><p>由于非对称加密的复杂度一般远远大于对称加密的复杂度， 所以实际使用时一般是首先通过公钥加密系统来握手，同时商定对称加密的key， 之后的处理都走对称加密流程。这样既确保了对称密钥的私密性，又加大了数据处理的速度。</p><p>这里我们使用openssl来进行流量的加密传输，非对称加密系统采取RSA， 对称加密系统则采用AES，同时对称加密的分组模式提供ECB、CBC、CFB、OFB四种选项，具体选项的含义就不要去追究了，直接调用相关api就好。</p><h2>工作流程</h2><p>由于我们现在加入了加密这个流程，简单的一个代理服务器已经无法满足我们当前的需求，所以当前程序设计成了两个部分：本地代理客户端和远程代理服务端。本地代理客户端充当原来的简单代理服务端，但是他接收到浏览器请求之后并不直接代理访问，而是转发到远程代理服务端，中继代理请求。其实本地的代理就是一个中继器，负责请求转发和流量加密。</p><p>现在的整个流程可以分为四个部分：</p><ol><li>代理客户端与代理服务端握手</li><li>代理客户端中继浏览器请求到代理服务端</li><li>代理服务端收到请求之后执行http访问，将结果返回代理客户端</li><li>代理客户端将代理服务端返回结果通知到浏览器</li></ol><h2>代理客户端与代理服务端握手</h2><p>这里的握手过程就是协商密钥的过程， 流程可以分为如下几步：</p><ol><li>代理客户端 读取服务端RSA公钥，选择一个合适的对称加密算法和生成对应的加密密钥，通过RSA公钥加密之后，发送到加密服务端，此时客户端记录的链接状态是negotiating，</li><li>服务端验证数据有效性、密钥合法性、账户合法性，如果验证结果错误，直接断开连接。否则当前客户端准备同时接收浏览器和代理服务端的数据， 代理服务端开始等待代理客户端转发过来的请求。</li></ol><h2>代理客户端与代理服务端数据交换</h2><p>在握手成功之后，代理客户端线程处于双工的状态，同时发送和接受服务端和浏览器的数据。由于<code>http pipeline</code>基本不怎么受支持，所以其实也不算双工。这里使用了四个函数接口：</p><ol><li><code>async_read_from_ua</code>从浏览器这里读取数据，每次读取到数据之后都直接进行加密，然后调用<code>async_wirte_to_server</code>将这些数据发送出去</li><li><code>async_write_to_proxy_server</code>则不停的读取当前的发送缓冲，并发送到server端， 当所有都发送完成之后，调用<code>async_read_from_ua</code>等待浏览器数据</li><li><code>async_read_from_proxy_server</code> 不断的接受<code>proxy_server</code>断端发送过来的数据并解密，然后立即调用<code>async_write_to_ua</code>发送回浏览器</li><li><code>async_write_to_ua</code> 则是不断的调用自身将发送缓冲清空，然后调用<code>async_read_from_proxy_server</code> 继续等待proxy_server的数据</li></ol><p>这里的代码实现时将这四个操作都用一个<code>strand</code>串联起来了，主要是因为<code>openssl</code>内的<code>decrypt</code>和<code>encrypt</code>函数对于多线程的支持不好，官方网站也说对于<code>openssl</code>的多线程不要抱太大希望。所以对于一个线程内的所有操作都用同一个<code>strand</code>。同时<code>asio</code>那边对于<code>connection</code>的处理也是推荐使用strand去管理，否则会出现各种稀奇古怪的bug。</p><p>握手成功后，代理服务端线程则只能处于单工状态，接受代理客户端请求，解析之后向原始服务器请求，原始服务器请求回来之后，解析返回的数据，然后发送回代理客户端。这里的逻辑就比客户端的纯连接转发功能复杂多了:</p><ol><li><code>async_read_from_proxy_client</code> 从client读取数据，</li><li><code>on_proxy_client_data_read</code> 解密从代理客户端获取的数据：</li><li>如果当前状态是<code>tunnel</code>（就是<code>connect</code> 请求成功之后的状态) 则直接调用<code>async_write_to_origin_server</code>发送数据；</li><li>否则解析请求头，获取目标服务器的地址：</li><ol><li>如果当前已经在与目标服务器的<code>keep-alive</code>状态，则调用<code>on_origin_server_connected</code>处理后续数据的发送，</li><li>否则调用<code>async_connect_to_origin_server</code>去连接目标服务器;</li></ol><br/><li><code>async_connect_to_origin_server</code>，遍历所有目标服务器的<code>endpoint</code>去链接，成功之后调用<code>on_origin_server_connected</code>处理之前的数据；</li><li><code>on_origin_server_connected</code>，</li><li>如果之前的请求方法是<code>connect</code>，则向代理客户端发送链接成功的响应，同时将当前链接的状态设置为<code>tunnel</code>,</li><li>否则，处理连接之前收取的数据，当获取到一个完整的请求头或者任意数量的内容之后，调用<code>async_wtite_to_origin_server</code>；</li><li><code>async_write_to_origin_server</code> 不断的调用底层的发送接口去发送数据，当发送完成之后，调用<code>on_origin_server_data_send</code></li><li><code>on_origin_server_data_send</code></li><li>如果当前在<code>tunnel</code>状态，则直接调用 <code>async_read_from_proxy_client</code> 等待数据</li><li>如果当前刚好发送完一个完整的packet，则调用<code>async_read_from_origin_server</code>等待目标服务器的应答</li><li>当前正在读取<code>packet</code>之中，继续调用<code>async_read_from_proxy_client</code>等待数据</li><li><code>async_read_from_origin_server</code> 从目标服务器等待响应数据</li><li><code>on_origin_server_data_read</code> 处理目标服务器的数据返回</li><li>如果当前状态是<code>tunnel</code>，则加密数据之后直接调用<code>async_write_to_proxy_client</code>发送加密后数据</li><li>如果当前已读数据不足以构造<code>packet</code>头部，则继续调用<code>async_read_from_origin_server</code>等待数据</li><li>把已读数据加密，调用<code>async_write_to_proxy_client</code>发送加密后数据。</li><li><code>async_write_to_proxy_client</code>调用底层的发送接口把数据发送到客户端，发送完成之后调用<code>on_proxy_client_data_send</code>；</li><li><code>on_proxy_client_data_send</code>：</li><ol><li>如果当前状态在<code>tunnel</code>，直接调用<code>async_read_from_origin_server</code></li><li>如果当前发送的数据并不能组成一个<code>packet</code>，则调用<code>async_read_from_origin_server</code>等待剩余数据</li><li>如果完整发送了一个<code>packet</code>，则根据是否接受keep-alive选项来决定是否关闭链接，如果不关闭，则调用<code>async_read_from_proxy_client</code>等待下一个<code>packet</code>请求。</li></ol></ol><h2>更多改进</h2><p>实现这些接口之后，一个极简且可用的加密代理服务搭建完成。使用者可以将本机启动client，远程vps启动server，同时将浏览器设置为以client作为代理服务器，就可以解决部分网络不好的问题了。但是，当前服务也只是能用而已，目前还有很多问题，有很多改进的点：</p><ol><li>每次浏览器发起一个请求的时候，client都会新建一个connection去连接服务器，以处理这个请求。虽然我们目前支持了keep-alive，但是正常使用过程中，多开几个页面，同时连接数经常在30多个以上。可以考虑client和server维持一个连接池，每个请求的session绑定到其中一个连接上，这样就进一步减少了ping-pong延迟。最佳情况是可以达到ftp的链接速率。</li><li>国内网络环境还是比较恶劣的，在外租用的vps经常时不时网络抽风，可以尝试把多个server组成一个集群，动态调整各个server的连接优先级，甚至可以做一个serverlist的服务发现</li><li>client和server之间的连接流量模式还是过于明显，可以考虑在连接池的基础上，client-server之间加入稳定的随机流量，同时把每个packet做一下padding到1024的整数倍。</li></ol><h2>相关链接</h2><ol><li>本文最早参考的项目<a href=\"https://link.zhihu.com/?target=https%3A//github.com/lxrite/azure-http-proxy\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">azure http proxy 一个基于boost.asio和c++11的加密代理</a></li><li>我自己对于此项目的修改版<a href=\"https://link.zhihu.com/?target=https%3A//github.com/huangfeidian/azure-http-proxy\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">azure_http_proxy 基于asio和c++17</a></li><li>关于http代理的更详细的说明<a href=\"https://link.zhihu.com/?target=https%3A//imququ.com/post/web-proxy.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">imququ.com/post/web-pro</span><span class=\"invisible\">xy.html</span><span class=\"ellipsis\"></span></a></li></ol>", 
            "topic": [
                {
                    "tag": "HTTP", 
                    "tagLink": "https://api.zhihu.com/topics/19588535"
                }, 
                {
                    "tag": "计算机网络", 
                    "tagLink": "https://api.zhihu.com/topics/19572894"
                }
            ], 
            "comments": [
                {
                    "userName": "sky快跑", 
                    "userLink": "https://www.zhihu.com/people/ec306186a98648002b7b01247918b151", 
                    "content": "我想自己搞一个很久了，一直不知道怎么写。赞👍", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52898952", 
            "userName": "千寻", 
            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
            "upvote": 0, 
            "title": "cmake", 
            "content": "<h2>cmake第三方库的创建与使用</h2><p>之前使用<code>cmake</code>的时候一般都是用来生成<code>exe</code>，没有尝试生成<code>lib,dll</code>等库文件。做自己的小玩具的时候发现其中一部分可以单独拿出来作为独立的组件给其他人使用，因此抽取出代码单独作为一个<code>lib</code>。在构建与引用这个库的时候，<code>cmake</code>的使用走了很多弯路，因此在这里记录一下。</p><h2>创建第三方库</h2><p>首先，如果作为一个第三方库，它的安装路径应该通过<code>cmake</code>去指定，否则就默认安装在当前<code>build</code>的目录了。这个的指定方式是通过传递<code>-DCMAKE_INSTALL_PREFIX</code>变量来实现的。在我的本机上，建立了一个目录，环境变量里使用<code>usr</code>来引用，因此构建的时候一般输入：</p><div class=\"highlight\"><pre><code class=\"language-cmake\"><span class=\"err\">cmake</span> <span class=\"err\">..</span> <span class=\"err\">-DCMAKE_INSTALL_PREFIX=&#34;$env:usr&#34;</span></code></pre></div><p>这个路径是配合<code>cmake</code>的<code>INSTALL</code>指令来使用的：</p><div class=\"highlight\"><pre><code class=\"language-cmake\"><span class=\"nb\">INSTALL</span><span class=\"p\">(</span><span class=\"s\">TARGETS</span> <span class=\"s\">hello</span> <span class=\"s\">hello_static</span> \n<span class=\"s\">LIBRARY</span> <span class=\"s\">DESTINATION</span> <span class=\"s\">lib</span> \n<span class=\"s\">ARCHIVE</span> <span class=\"s\">DESTINATION</span> <span class=\"s\">lib</span><span class=\"p\">)</span> <span class=\"err\">\n</span><span class=\"err\"></span><span class=\"nb\">INSTALL</span><span class=\"p\">(</span><span class=\"s\">FILES</span> <span class=\"s\">hello.h</span> <span class=\"s\">DESTINATION</span> <span class=\"s\">include/hello</span><span class=\"p\">)</span></code></pre></div><p>这里的<code>INSTALL TARGETS</code>的意思就是把后面的生成目标按照规则安装到特定路径下，上面的意思就是动态库和静态库都放在<code>lib</code>文件夹下，<code>DESTINATION</code>后面的路径如果不是绝对路径，则会把对应的路径拼接到<code>CMAKE_INSTALL_PREFIX</code>下， 如果对应的文件夹不存在，则会自动创建。</p><p><code>INSTALL(FILES)</code>指令一般是用来拷贝接口头文件到安装目录里的，这里的路径也是按照前述规则来确定的。类似的也有安装整个文件夹的的指令，更为方便点，适合整个接口头文件目录的安装：</p><div class=\"highlight\"><pre><code class=\"language-cmake\"><span class=\"nb\">install</span><span class=\"p\">(</span><span class=\"s\">DIRECTORY</span> <span class=\"o\">${</span><span class=\"nv\">PROJECT_HEADER_DIR</span><span class=\"o\">}</span><span class=\"s\">/</span> <span class=\"s\">DESTINATION</span> <span class=\"s\">include/</span><span class=\"o\">${</span><span class=\"nv\">PROJECT_NAME</span><span class=\"o\">}</span><span class=\"p\">)</span></code></pre></div><p>这里的<code>${PROJECT_HEADER_DIR}/</code>最后的<code>/</code>是有意义的，代表拷贝这个文件夹下的所有文件，如果没有这个斜杠，则会把当前文件夹拷贝过去。</p><p>现在有个问题就是我们想区分<code>Debug</code>和<code>Release</code>模式下的对应二进制文件，常用的方法是加一个后缀<code>d</code>，这里在<code>cmake</code>可以这样来设置:</p><p>然后我们如果想生成同名的动态库<code>xxx</code>和静态库<code>xxx</code>的话，还需要额外设置对应<code>target</code>的输出文件名字:</p><p>但是<code>cmake</code>还有一个蛋疼的规则，在构建一个新的<code>target</code>时， 会尝试清理掉其他使用这个名字的库文件，所以我们需要禁用这个功能:</p><p>还是这个指令，可以制定生成动态库的版本号:</p><div class=\"highlight\"><pre><code class=\"language-cmake\"><span class=\"nb\">SET_TARGET_PROPERTIES</span><span class=\"p\">(</span><span class=\"s\">hello</span> <span class=\"s\">PROPERTIES</span> <span class=\"s\">VERSION</span> <span class=\"s\">1.1</span> <span class=\"s\">SOVERSION</span> <span class=\"s\">1</span><span class=\"p\">)</span></code></pre></div><p>这里的<code>VERSION</code>是构建版本号， <code>SOVERSION</code>是接口版本号，可以理解为具体版本和大版本。经过这样处理之后，会生成<code>libhello.so.1.1 libhello.so.1 libhello.so</code>三个文件，其中之后<code>libhello.so.1.1</code>是真正的文件，其他两个都是链接文件。</p><p>至此，这个库生成的二进制文件和公开的头文件都已经安装到对应位置，下面来介绍如何在新的项目中引用这个库。</p><h2>引用第三方库</h2><p><code>cmake</code>里引用第三方库都是使用<code>find_package</code>指令来的，<code>cmake</code>内置了一些常见库的搜索，例如<code>zlib,libpng,openssl</code>等，寻找的结果在<code>xxx_FOUND</code>符号里。找到之后可以通过<code>xxx_include_dirs xxx_libraries</code>这些符号去引用头文件目录和库文件。但是对于自己编译生成的第三方库，默认的<code>find_package</code>基本无效了。此时我们需要给<code>find_package</code>提供<code>hint</code>。<code>find_package</code>有两种搜索模式：<code>Module mode</code>和<code>Config mode</code>。默认的是<code>Module mode</code>，对于自己通过<code>cmake --build ./ --target install</code>的第三方库，需要采取<code>Config mode</code>。为此，首先需要提供第三方库的搜索目录<code>-DCMAKE_PREFIX_PATH</code>，上面的库我们安装在<code>$env:usr</code>目录下，所以在构建的时候需要这样处理:</p><div class=\"highlight\"><pre><code class=\"language-cmake\"><span class=\"err\">cmake</span> <span class=\"err\">..</span> <span class=\"err\">-DCMAKE_PREFIX_PATH=&#34;$env:usr&#34;</span></code></pre></div><p>然后<code>cmake</code>会在这个目录下的<code>lib</code>里搜索<code>cmake</code>文件夹，然后定位<code>&lt;PackageName&gt;Config.cmake</code> 或者 <code>&lt;lower-case-package-name&gt;-config.cmake</code>。这个<code>.cmake</code>文件里会记录项目在安装过程中的所有相关信息，现在问题就是，我们自己的库如何生成这个文件。</p><p>答案是使用<code>cmake(export)</code>指令和<code>install(EXPORT)</code>指令，搞起来比较复杂。</p><div class=\"highlight\"><pre><code class=\"language-cmake\"><span class=\"nb\">export</span><span class=\"p\">(</span><span class=\"s\">TARGETS</span>  <span class=\"o\">${</span><span class=\"nv\">CMAKE_PROJECT_NAME</span><span class=\"o\">}</span> <span class=\"s\">FILE</span> <span class=\"o\">${</span><span class=\"nv\">CMAKE_BINARY_DIR</span><span class=\"o\">}</span><span class=\"s\">/</span><span class=\"o\">${</span><span class=\"nv\">CMAKE_PROJECT_NAME</span><span class=\"o\">}</span><span class=\"s\">Targets.cmake</span><span class=\"p\">)</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"nb\">file</span><span class=\"p\">(</span><span class=\"s\">WRITE</span>\n    <span class=\"o\">${</span><span class=\"nv\">CMAKE_BINARY_DIR</span><span class=\"o\">}</span><span class=\"s\">/</span><span class=\"o\">${</span><span class=\"nv\">CMAKE_PROJECT_NAME</span><span class=\"o\">}</span><span class=\"s\">Config.cmake</span>\n    <span class=\"s2\">&#34;include(\\${CMAKE_CURRENT_LIST_DIR}/${CMAKE_PROJECT_NAME}Targets.cmake)\\n&#34;</span><span class=\"p\">)</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"nb\">install</span><span class=\"p\">(</span><span class=\"s\">FILES</span>\n        <span class=\"o\">${</span><span class=\"nv\">CMAKE_BINARY_DIR</span><span class=\"o\">}</span><span class=\"s\">/</span><span class=\"o\">${</span><span class=\"nv\">CMAKE_PROJECT_NAME</span><span class=\"o\">}</span><span class=\"s\">Config.cmake</span>\n        <span class=\"s\">DESTINATION</span> <span class=\"s\">lib/cmake/</span><span class=\"o\">${</span><span class=\"nv\">CMAKE_PROJECT_NAME</span><span class=\"o\">}</span><span class=\"p\">)</span><span class=\"err\">\n</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"nb\">install</span><span class=\"p\">(</span><span class=\"s\">TARGETS</span> <span class=\"o\">${</span><span class=\"nv\">PROJECT_NAME</span><span class=\"o\">}</span> <span class=\"s\">EXPORT</span> <span class=\"o\">${</span><span class=\"nv\">PROJECT_NAME</span><span class=\"o\">}</span><span class=\"s\">Targets</span>\n    <span class=\"s\">ARCHIVE</span>  <span class=\"s\">DESTINATION</span> <span class=\"s\">lib</span>\n    <span class=\"s\">LIBRARY</span> <span class=\"s\">DESTINATION</span> <span class=\"s\">lib</span>\n    <span class=\"p\">)</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"nb\">install</span><span class=\"p\">(</span><span class=\"s\">EXPORT</span> <span class=\"o\">${</span><span class=\"nv\">CMAKE_PROJECT_NAME</span><span class=\"o\">}</span><span class=\"s\">Targets</span>\n        <span class=\"s\">DESTINATION</span> <span class=\"s\">lib/cmake/</span><span class=\"o\">${</span><span class=\"nv\">CMAKE_PROJECT_NAME</span><span class=\"o\">}</span><span class=\"p\">)</span></code></pre></div><p>上述一大段代码的意思就是：</p><ol><li>首先创建<code>xxxConfig.cmake</code>文件，</li><li>往<code>xxxConfig.cmake</code>里写内容，内容就是<code>include xxxTargets.cmake</code>。</li><li>把<code>xxxConfig.cmake</code>文件拷贝到安装目录下的<code>lib/cmake/xxx下</code></li><li>把所有相关二进制放到安装目录下，并把这些相关的路径信息导出到<code>xxxTargets.cmake</code>下</li><li>把导出目标信息<code>xxxTargets.cmake</code>复制到<code>lib/cmake/xxx</code>目录下</li></ol><p>反正就是这样一顿操作之后，<code>find_package</code>的<code>Config mode</code>就可以找到对应的<code>xxxConfig.cmake</code>文件了。</p><p>虽然现在<code>find_package</code>可以正确找到这个库了，但是我们不能像<code>Module mode</code>一样使用<code>xxx_include_dir, xxx_libraries</code>这些变量，但是可以直接使用<code>target_link_libraries(aaa xxx)</code>了，相当于之前的<code>export</code>的符号在当前文件里可见了。</p>", 
            "topic": [
                {
                    "tag": "CMake", 
                    "tagLink": "https://api.zhihu.com/topics/19834837"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52879324", 
            "userName": "千寻", 
            "userLink": "https://www.zhihu.com/people/32e63a184da3d60511222c4a5400064f", 
            "upvote": 3, 
            "title": "实现一个异构容器", 
            "content": "<p>本文内容在于实现一个最小化的类json容器的demo，语言版本 c++17。这个容器的基础定义是这样的：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">my_container</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">value_type</span><span class=\"p\">;</span> <span class=\"c1\">// 1 for v_int 2 for v_list 0 empty\n</span><span class=\"c1\"></span>    <span class=\"k\">union</span>\n    <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">v_int</span><span class=\"p\">;</span>\n    <span class=\"p\">};</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">my_container</span><span class=\"o\">*&gt;</span> <span class=\"n\">v_list</span><span class=\"p\">;</span>\n    <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n    <span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">expect_value</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>目前为了简略起见，里面的<code>union</code>只支持<code>int</code>,读者自己可以扩展支持所有的<code>pod</code>格式。<code>v_list</code>里存了这个对象的一些指针，从而实现嵌套结构。获取这个容器的内容的接口是<code>expect_value</code>，调用时使用者需要手动传入类型<code>T</code>以实例化模板。这里我们对<code>T</code>类型限定为<code>int, tuple&lt;args...&gt;, vector&lt;T&gt;</code>三种类型之一，读者也可以自己额外增加<code>list, map, unordered_map</code>等容器格式，只要自己能解释<code>v_list</code>内部的数据要求即可。</p><p>对于<code>expect_value&lt;T&gt;</code>中<code>T</code>为<code>POD</code>的情形，则比较简单，当前仅支持<code>int</code>，所以对<code>T</code>进行特化即可，通过判断<code>value_type</code>是否等于1来构造返回值，其他的<code>POD</code>类型直接返回<code>nullopt</code>。</p><p>对于<code>vector&lt;T&gt;</code>我们无法通过特化<code>expect_value</code>来实现了， 只能通过偏特化来定义下面的这个函数:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n</code></pre></div><p>然而上面的这个特化是不合法的语句，我们是无法直接对<code>expect_value</code>做仍然有模板参数的特化操作，所以这里需要定义另外一个函数来处理  <code>vector&lt;T&gt;</code>：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">expect_vector_value</span><span class=\"p\">()</span><span class=\"k\">const</span><span class=\"p\">;</span>\n</code></pre></div><p>另外定义<code>expect_simple_value</code>来处理原来的<code>T</code>类型：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">expect_simple_value</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n</code></pre></div><p>当调用到<code>expect_value&lt;vector&lt;T&gt;&gt;</code>的时候转接到<code>expect_vector_value&lt;T&gt;</code>之上, 这里需要一个<code>vector&lt;T&gt; -&gt; T</code>的类型推导，此时就需要一个辅助类型来处理这个推导。在此，定义:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"k\">struct</span> <span class=\"n\">deduce_type</span> <span class=\"p\">{};</span>\n</code></pre></div><p>利用上面的类型来做<code>expect_value&lt;T&gt;</code>的分发：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">my_container</span><span class=\"o\">::</span><span class=\"n\">expect_value</span><span class=\"p\">()</span><span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">expect_value_dispatch</span><span class=\"p\">(</span><span class=\"n\">deduce_type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">());</span>\n<span class=\"p\">}</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">auto</span> <span class=\"n\">expect_value_dispatch</span><span class=\"p\">(</span><span class=\"n\">deduce_type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">expect_simple_value</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">auto</span> <span class=\"n\">expect_value_dispatch</span><span class=\"p\">(</span><span class=\"n\">deduce_type</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">)</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">expect_vector_value</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">my_container</span><span class=\"o\">::</span><span class=\"n\">expect_simple_value</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">nullopt</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;&gt;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">my_container</span><span class=\"o\">::</span><span class=\"n\">expect_simple_value</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">value_type</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">v_int</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">nullopt</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">my_container</span><span class=\"o\">::</span><span class=\"n\">expect_vector_value</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">value_type</span> <span class=\"o\">!=</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">nullopt</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">result</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"nl\">i</span> <span class=\"p\">:</span> <span class=\"n\">v_list</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">i</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">nullopt</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">auto</span> <span class=\"n\">temp_value</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">temp_value</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">nullopt</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">temp_value</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">());</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>转成<code>vector</code>算是一个阶段性成果，但是<code>vector</code>不足以表达这个异构容器里的内容，例如下面的例子：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">my_container</span> <span class=\"n\">test_value_1</span><span class=\"p\">;</span>\n<span class=\"n\">test_value_1</span><span class=\"p\">.</span><span class=\"n\">value_type</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"n\">test_value_1</span><span class=\"p\">.</span><span class=\"n\">v_int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"n\">my_container</span> <span class=\"n\">test_value_2</span><span class=\"p\">;</span>\n<span class=\"n\">test_value_2</span><span class=\"p\">.</span><span class=\"n\">value_type</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"n\">test_value_2</span><span class=\"p\">.</span><span class=\"n\">v_int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"n\">my_container</span> <span class=\"n\">test_value_3</span><span class=\"p\">;</span>\n<span class=\"n\">test_value_3</span><span class=\"p\">.</span><span class=\"n\">value_type</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"n\">test_value_3</span><span class=\"p\">.</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">test_value_2</span><span class=\"p\">);</span>\n<span class=\"n\">my_container</span> <span class=\"n\">test_value_4</span><span class=\"p\">;</span>\n<span class=\"n\">test_value_4</span><span class=\"p\">.</span><span class=\"n\">value_type</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"n\">test_value_4</span><span class=\"p\">.</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">test_value_2</span><span class=\"p\">);</span>\n<span class=\"n\">test_value_4</span><span class=\"p\">.</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">test_value_3</span><span class=\"p\">);</span>\n</code></pre></div><p><code>test_value_4</code>如果要转成<code>vector</code>，则无法给出一个合适的<code>T</code>去同时匹配<code>test_value_2</code>和<code>test_value_3</code>。对于<code>test_value_4</code>，更合适的描述是<code>tuple&lt;int, vector&lt;int&gt;&gt;</code>, 因此这里需要提供<code>expect_tuple_value</code>函数去尝试转换为<code>tuple</code>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"o\">&gt;</span>\n<span class=\"k\">auto</span> <span class=\"n\">expect_value_dispatch</span><span class=\"p\">(</span><span class=\"n\">deduce_type</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">tuple</span><span class=\"o\">&lt;</span><span class=\"n\">args</span><span class=\"p\">...</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">)</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">expect_tuple_value</span><span class=\"o\">&lt;</span><span class=\"n\">args</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"o\">&gt;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">tuple</span><span class=\"o\">&lt;</span><span class=\"n\">args</span><span class=\"p\">...</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">my_container</span><span class=\"o\">::</span><span class=\"n\">expect_tuple_value</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">nullopt</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"nl\">i</span> <span class=\"p\">:</span> <span class=\"n\">v_list</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">i</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">nullopt</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">the_tuple_size</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">...(</span><span class=\"n\">args</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">!=</span> <span class=\"n\">the_tuple_size</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">nullopt</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">get_tuple_value_from_vector</span><span class=\"o\">&lt;</span><span class=\"n\">args</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">v_list</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>现在的核心内容就是如何实现<code>get_tuple_value_from_vector</code>, 这个是一个变参模板函数，其内容就是对<code>v_list</code>的每个元素都尝试做一次<code>v_list[i].expect_value&lt;args[i]&gt;()</code>，任何一个返回<code>nullopt</code>则整个函数返回<code>nullopt</code>。为了获得这个<code>i</code>，需要利用<code>std::index_sequence</code>，以及利用<code>...</code>的黑魔法。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">size_t</span><span class=\"p\">...</span> <span class=\"n\">arg_idx</span><span class=\"o\">&gt;</span>\n<span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">tuple</span><span class=\"o\">&lt;</span><span class=\"n\">args</span><span class=\"p\">...</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">get_tuple_value_from_vector</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">my_container</span><span class=\"o\">*&gt;&amp;</span> <span class=\"n\">v_list</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">index_sequence</span><span class=\"o\">&lt;</span><span class=\"n\">arg_idx</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">temp_result</span> <span class=\"o\">=</span> <span class=\"n\">make_tuple</span><span class=\"p\">((</span><span class=\"o\">*</span><span class=\"n\">v_list</span><span class=\"p\">[</span><span class=\"n\">arg_idx</span><span class=\"p\">]).</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"n\">args</span><span class=\"o\">&gt;</span><span class=\"p\">()...);</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">get</span><span class=\"o\">&lt;</span><span class=\"n\">arg_idx</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">temp_result</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">...))</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">nullopt</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">make_tuple</span><span class=\"p\">(</span><span class=\"n\">get</span><span class=\"o\">&lt;</span><span class=\"n\">arg_idx</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">temp_result</span><span class=\"p\">).</span><span class=\"n\">value</span><span class=\"p\">()...);</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p>而<code>expect_tuple_value</code>在调用<code>get_tuple_value_from_vector</code>的时候，要手动提供<code>args</code>和<code>arg_idx</code>:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">return</span> <span class=\"n\">get_tuple_value_from_vector</span><span class=\"o\">&lt;</span><span class=\"n\">args</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">v_list</span><span class=\"p\">,</span> <span class=\"n\">index_sequence_for</span><span class=\"o\">&lt;</span><span class=\"n\">args</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"p\">{});</span>\n</code></pre></div><p>至此，一个基本的异构容器就此完成，下面是一些测试代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">my_container</span> <span class=\"n\">test_value_1</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_1</span><span class=\"p\">.</span><span class=\"n\">value_type</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_1</span><span class=\"p\">.</span><span class=\"n\">v_int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">expect_value_1</span> <span class=\"o\">=</span> <span class=\"n\">test_value_1</span><span class=\"p\">.</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;test_value_1.expect_value&lt;int&gt;() with result &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"kt\">bool</span><span class=\"p\">(</span><span class=\"n\">expect_value_1</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"n\">my_container</span> <span class=\"n\">test_value_2</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_2</span><span class=\"p\">.</span><span class=\"n\">value_type</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_2</span><span class=\"p\">.</span><span class=\"n\">v_int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">expect_value_2</span> <span class=\"o\">=</span> <span class=\"n\">test_value_2</span><span class=\"p\">.</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;test_value_2.expect_value&lt;int&gt;() result &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"kt\">bool</span><span class=\"p\">(</span><span class=\"n\">expect_value_2</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"n\">my_container</span> <span class=\"n\">test_value_3</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_3</span><span class=\"p\">.</span><span class=\"n\">value_type</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_3</span><span class=\"p\">.</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">test_value_2</span><span class=\"p\">);</span>\n    <span class=\"k\">auto</span> <span class=\"n\">expect_value_3</span> <span class=\"o\">=</span> <span class=\"n\">test_value_3</span><span class=\"p\">.</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"n\">tuple</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;test_value_3.expect_value&lt;tuple&lt;int&gt;&gt;() with result &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"kt\">bool</span><span class=\"p\">(</span><span class=\"n\">expect_value_3</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">expect_value_4</span> <span class=\"o\">=</span> <span class=\"n\">test_value_3</span><span class=\"p\">.</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;test_value_3.expect_value&lt;vector&lt;int&gt;&gt;() with result &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"kt\">bool</span><span class=\"p\">(</span><span class=\"n\">expect_value_4</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n\n\n    <span class=\"n\">my_container</span> <span class=\"n\">test_value_4</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_4</span><span class=\"p\">.</span><span class=\"n\">value_type</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_4</span><span class=\"p\">.</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">test_value_2</span><span class=\"p\">);</span>\n    <span class=\"n\">test_value_4</span><span class=\"p\">.</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">test_value_1</span><span class=\"p\">);</span>\n    <span class=\"k\">auto</span> <span class=\"n\">expect_value_5</span> <span class=\"o\">=</span> <span class=\"n\">test_value_4</span><span class=\"p\">.</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"n\">tuple</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;test_value_4.expect_value&lt;tuple&lt;int, int&gt;&gt;() with result &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"kt\">bool</span><span class=\"p\">(</span><span class=\"n\">expect_value_5</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">expect_value_6</span> <span class=\"o\">=</span> <span class=\"n\">test_value_4</span><span class=\"p\">.</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;test_value_4.expect_value&lt;vector&lt;int&gt;&gt;() with result &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"kt\">bool</span><span class=\"p\">(</span><span class=\"n\">expect_value_6</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"n\">my_container</span> <span class=\"n\">test_value_5</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_5</span><span class=\"p\">.</span><span class=\"n\">value_type</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">test_value_5</span><span class=\"p\">.</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">test_value_4</span><span class=\"p\">);</span>\n    <span class=\"n\">test_value_5</span><span class=\"p\">.</span><span class=\"n\">v_list</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">test_value_3</span><span class=\"p\">);</span>\n    <span class=\"k\">auto</span> <span class=\"n\">expect_value_7</span> <span class=\"o\">=</span> <span class=\"n\">test_value_5</span><span class=\"p\">.</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"n\">tuple</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;test_value_5.expect_value&lt;tuple&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt;&gt;() with result &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"kt\">bool</span><span class=\"p\">(</span><span class=\"n\">expect_value_7</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">expect_value_8</span> <span class=\"o\">=</span> <span class=\"n\">test_value_5</span><span class=\"p\">.</span><span class=\"n\">expect_value</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;test_value_5.expect_value&lt;vector&lt;int&gt;&gt;() with result &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"kt\">bool</span><span class=\"p\">(</span><span class=\"n\">expect_value_8</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1058665148515950592"
}
