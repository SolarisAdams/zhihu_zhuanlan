{
    "title": "程序员基础知识", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/li-yi-mu-69-56", 
        "https://www.zhihu.com/people/karl-96-85", 
        "https://www.zhihu.com/people/ge-ge-ge-15-10", 
        "https://www.zhihu.com/people/shi-li-de-ren-sheng-26", 
        "https://www.zhihu.com/people/nixun-81", 
        "https://www.zhihu.com/people/ng-ng-ng-ng-87-8-1", 
        "https://www.zhihu.com/people/mzh-24-25", 
        "https://www.zhihu.com/people/chen-peng-65-46-60", 
        "https://www.zhihu.com/people/bei-zi-50-5", 
        "https://www.zhihu.com/people/ga-ga-50-21", 
        "https://www.zhihu.com/people/peng-cheng-mo", 
        "https://www.zhihu.com/people/lu-guo-43-3-76", 
        "https://www.zhihu.com/people/zou-guo-long-dao-gong", 
        "https://www.zhihu.com/people/shang-jue-53-77", 
        "https://www.zhihu.com/people/ren-lu-1-1", 
        "https://www.zhihu.com/people/dai-wei-jie-de-shao-nian", 
        "https://www.zhihu.com/people/cindy-69-81-35", 
        "https://www.zhihu.com/people/meng-xing-shi-fen-23-21", 
        "https://www.zhihu.com/people/ou-yu-ge-lu-da-shen", 
        "https://www.zhihu.com/people/shi-qi-27-42-85", 
        "https://www.zhihu.com/people/wu-wen-xi-dong-86-33-72", 
        "https://www.zhihu.com/people/wo-xiang-gen-ren-shuo-shuo-hua", 
        "https://www.zhihu.com/people/xiao-du-14-52", 
        "https://www.zhihu.com/people/qian-fa-18-1", 
        "https://www.zhihu.com/people/kyan-58-96", 
        "https://www.zhihu.com/people/lily-58-47-62", 
        "https://www.zhihu.com/people/cbl-1", 
        "https://www.zhihu.com/people/ty999888", 
        "https://www.zhihu.com/people/xing-ge-666-42", 
        "https://www.zhihu.com/people/huan-meng-36-35", 
        "https://www.zhihu.com/people/lizhanhui", 
        "https://www.zhihu.com/people/Timlun-62", 
        "https://www.zhihu.com/people/psychopunk-66", 
        "https://www.zhihu.com/people/mycoid", 
        "https://www.zhihu.com/people/shao-lin-xiao-zi-24", 
        "https://www.zhihu.com/people/leon-38-8", 
        "https://www.zhihu.com/people/chen-jing-yao-88", 
        "https://www.zhihu.com/people/yao-rui-73", 
        "https://www.zhihu.com/people/xi-guo-hai-yao", 
        "https://www.zhihu.com/people/xiao-ming-i-15", 
        "https://www.zhihu.com/people/qiao-hai-jun", 
        "https://www.zhihu.com/people/zcdtyj", 
        "https://www.zhihu.com/people/healer-65-4", 
        "https://www.zhihu.com/people/blake-4-82", 
        "https://www.zhihu.com/people/song-ge-ge-93-16", 
        "https://www.zhihu.com/people/Zou.yu", 
        "https://www.zhihu.com/people/ruan-jian-wei-68", 
        "https://www.zhihu.com/people/glg-82-50", 
        "https://www.zhihu.com/people/rhanqtl", 
        "https://www.zhihu.com/people/qqangel-86", 
        "https://www.zhihu.com/people/lu-ming-51-57", 
        "https://www.zhihu.com/people/manorsuperman", 
        "https://www.zhihu.com/people/lius.ac.cn", 
        "https://www.zhihu.com/people/shi-kong-han-wei-zhe-8hao", 
        "https://www.zhihu.com/people/chen-xiao-dong-72-56", 
        "https://www.zhihu.com/people/leehyb", 
        "https://www.zhihu.com/people/yong-heng-zhi-hun", 
        "https://www.zhihu.com/people/pan-xuan-xuan-jun", 
        "https://www.zhihu.com/people/obr-zhou", 
        "https://www.zhihu.com/people/dian-po-dan-de-xiao-hou-zi", 
        "https://www.zhihu.com/people/noeltoby", 
        "https://www.zhihu.com/people/hao_yuan", 
        "https://www.zhihu.com/people/qin-qin-7-5", 
        "https://www.zhihu.com/people/struct-78", 
        "https://www.zhihu.com/people/ai-xue-xi-de-kai-kai-3", 
        "https://www.zhihu.com/people/justinhan", 
        "https://www.zhihu.com/people/tianbao-zhang", 
        "https://www.zhihu.com/people/shi-fang-xiao-zhen", 
        "https://www.zhihu.com/people/ji-kai-qiang", 
        "https://www.zhihu.com/people/yang-qing-chun-59", 
        "https://www.zhihu.com/people/paranoid-h", 
        "https://www.zhihu.com/people/zai-zheng-wu-guang-jie-de-ai-si-qia-nuo", 
        "https://www.zhihu.com/people/mao-ri-xing-guan-74", 
        "https://www.zhihu.com/people/xi-li-ke-87", 
        "https://www.zhihu.com/people/zhou-sui-26", 
        "https://www.zhihu.com/people/wang-sen-89-26", 
        "https://www.zhihu.com/people/tou-ni-jia-de-xing-xing", 
        "https://www.zhihu.com/people/aaaala", 
        "https://www.zhihu.com/people/zhu-xu-chun-ling-xu-li-xing", 
        "https://www.zhihu.com/people/ren-shu-peng-30", 
        "https://www.zhihu.com/people/newaristotle", 
        "https://www.zhihu.com/people/summerzhu-22-4", 
        "https://www.zhihu.com/people/lilijun-96", 
        "https://www.zhihu.com/people/yang-jun-yi-98-1", 
        "https://www.zhihu.com/people/li-kai-lun-33-84", 
        "https://www.zhihu.com/people/zeng-zhi-an", 
        "https://www.zhihu.com/people/yang-shu-18-31-69", 
        "https://www.zhihu.com/people/an-jia-hao-69", 
        "https://www.zhihu.com/people/mo-qing-chen", 
        "https://www.zhihu.com/people/zhangsan-97-39", 
        "https://www.zhihu.com/people/wu-ming-39-5-23", 
        "https://www.zhihu.com/people/luo-bing-31-48", 
        "https://www.zhihu.com/people/zhaowzxp", 
        "https://www.zhihu.com/people/liu-dao-dao-77", 
        "https://www.zhihu.com/people/limh909", 
        "https://www.zhihu.com/people/guoqiang-zheng-81", 
        "https://www.zhihu.com/people/wei-ruan-bing", 
        "https://www.zhihu.com/people/chu-gen-shen", 
        "https://www.zhihu.com/people/crazyfeng-91", 
        "https://www.zhihu.com/people/lan-se-tian-kong-42-16", 
        "https://www.zhihu.com/people/lifengcai", 
        "https://www.zhihu.com/people/honor_of_kings_18", 
        "https://www.zhihu.com/people/zhao-yu-50-4-38", 
        "https://www.zhihu.com/people/lin-sheng-piao-yang", 
        "https://www.zhihu.com/people/zheng-zai-jian-fei-de-xiong", 
        "https://www.zhihu.com/people/mu-jian-17-32", 
        "https://www.zhihu.com/people/buerse", 
        "https://www.zhihu.com/people/jiajun-24-94", 
        "https://www.zhihu.com/people/yang-kan-81", 
        "https://www.zhihu.com/people/tama-kim", 
        "https://www.zhihu.com/people/Struggler_lr", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/gao-shuai-42-19", 
        "https://www.zhihu.com/people/liu-nan-bing", 
        "https://www.zhihu.com/people/lian-zhi-wen", 
        "https://www.zhihu.com/people/wan-meng-sheng", 
        "https://www.zhihu.com/people/sam-70-11-58", 
        "https://www.zhihu.com/people/angkor-w", 
        "https://www.zhihu.com/people/gui-man-zi", 
        "https://www.zhihu.com/people/tan-adam", 
        "https://www.zhihu.com/people/fly2018-16", 
        "https://www.zhihu.com/people/martinstone", 
        "https://www.zhihu.com/people/hua-wu-38-71", 
        "https://www.zhihu.com/people/du-xu-dong-33", 
        "https://www.zhihu.com/people/hellomonkey-69", 
        "https://www.zhihu.com/people/i-am-mr-shen", 
        "https://www.zhihu.com/people/liu-dan-62-9", 
        "https://www.zhihu.com/people/ku-long-15-81", 
        "https://www.zhihu.com/people/zzz-97-95-26", 
        "https://www.zhihu.com/people/ban-yue-yu-58", 
        "https://www.zhihu.com/people/zhou-min-jun-1011-", 
        "https://www.zhihu.com/people/demons-24-1", 
        "https://www.zhihu.com/people/duan-duan-44-45", 
        "https://www.zhihu.com/people/yi-xiao-lang-ran-11", 
        "https://www.zhihu.com/people/yiming-xin-shou", 
        "https://www.zhihu.com/people/xiao-huo-long-84-91", 
        "https://www.zhihu.com/people/li-shen-zhen-9", 
        "https://www.zhihu.com/people/long-long-89-75-31", 
        "https://www.zhihu.com/people/simon-yuen"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/54544989", 
            "userName": "程序员", 
            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
            "upvote": 1, 
            "title": "Performanced C++ 经验规则（5）：再谈重载、覆盖和隐藏", 
            "content": "<p>在C++中，无论在类作用域内还是外，两个（或多个）同名的函数，可能且仅可能是以下三种关系：重载（Overload）、覆盖（Override）和隐藏（Hide），因为同名，区分这些关系则是根据参数是否相同、是否带有const成员函数性质、是否有virtual关键字修饰以及是否在同一作用域来判断。在第四条中，我们曾提到了一些关于重载、覆盖的概念，但只是一带而过，也没有提到隐藏，这一篇我们将详细讨论。</p><p>1、首先说的是<b>重载</b>，有一个前提必须要弄清楚的是，如果不在类作用域内进行讨论，两个（或多个）同名函数之间的关系只可能是重载或隐藏，这里先说重载。考虑以下事实：</p><blockquote>int foo(char c){...}<br/>void foo(int x){...}</blockquote><p>这两个函数之间的关系是重载（overload），即相同函数名但参数不同，并注意返回类型是否相同并不会对重载产生任何影响。</p><p>也就是说，如果仅仅是返回类型不相同，而函数名和参数都完全相同的两个函数，不能构成重载，编译器会告知”ambiguous”（二义性）等词以表达其不满：</p><blockquote>//Can&#39;t be compiled!<br/><br/>int fooo(char c){...}<br/>void fooo(char c){...}<br/><br/>char c = &#39;A&#39;;<br/>fooo(c); // Which one? ambiguous</blockquote><p>在第四条中，已经讲述过，重载是编译期绑定的静态行为，不是真正的多态性，那么，编译器是根据什么来进行静态绑定呢？又是如何确定两个（或多个）函数之间的关系是重载呢？</p><p>有以下判定依据：</p><p>（1）相同的范围：即作用域，这里指在同一个类中，或同一个名字空间，即C++的函数重载不支持跨越作用域进行（读者可再次对比Java在这问题上的神奇处理，既上次Java给我们提供了未卜先知的动态绑定能力后，Java超一流的意识和大局观再次给Java程序员提供了跨类重载的能力，如有兴趣可详细阅读《Thinking in Java》的相关章节，其实对于学好C++来讲，去学一下Java是很有帮助的，它会告诉你，同样或类似的问题，为什么Java要做这样的改进），这也是区别重载和隐藏的最重要依据。</p><p>关于“C++不能支持跨类重载”，稍后笔者会给出代码来例证这一点。</p><p>（2）函数名字相同（基本前提）</p><p>（3）函数参数不同（基本前提，否则在同一作用域内有两个或多个同名同参数的函数，将产生ambiguous，另外注意，对于成员函数，是否是const成员函数，即函数声明之后是否带有const标志， 可理解为“参数不同“），第（2）和第（3）点统称“函数特征标”不同</p><p>（4）virtual关键字可有可无不产生影响（因为第（1）点已经指出，这是在同一个类中）</p><p>即“相同的范围，特征标不同（当然同名是肯定的），发生重载“。</p><p>2、<b>覆盖（override）</b>，真正的多态行为，通过虚函数来实现，所以，编译器根据以下依据来进行判定两个（注意只可能是两个，即使在继承链中，也只是最近两个为一组）函数之间的关系是覆盖：</p><p>（1）不同的范围：即使用域，两个函数分别位于基类和派生类中</p><p>（2）函数名字相同（基本前提）</p><p>（3）函数参数也相同（基本前提），第（2）和第（3）点统称“函数特征标”相同</p><p>（4）基类函数必须用virtual关键字修饰</p><p>即“不同的范围，特征标相同，且基类有virtual声明，发生覆盖“。</p><p>3、<b>隐藏（Hide）</b>，即：</p><p>（1）如果派生类函数与基类函数同名，但参数不同（特征标不同），此时，无论是否有virtual关键字，基类的所有同名函数都将被隐藏，而不会重载，因为不在同一个类中；</p><p>（2）如果派生类函数与基类函数同名，且参数也相同（特征标相同），但基类函数没有用virtual关键字声明，则基类的所有同名函数都将被隐藏，而不会覆盖，因为没有声明为虚函数。</p><p>即“不同的范围，特征标不同（当然同名是肯定的），发生隐藏”，或“不同的范围，特征标相同，但基类没有virtual声明，发生隐藏“。</p><p>可见有两种产生隐藏的情况，分别对应不能满足重载和覆盖条件的情况。</p><p>另外必须要注意的是，在类外讨论时，也可能发生隐藏，如在名字空间中，如下述代码所示：</p><blockquote>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>void foo(void) { cout &lt;&lt; &#34;global foo()&#34; &lt;&lt; endl; }<br/>int foo(int x) { cout &lt;&lt; &#34;global foo(int)&#34; &lt;&lt; endl; return x; }<br/>namespace a<br/>{<br/>        void foo(void) { cout &lt;&lt; &#34;a::foo()&#34; &lt;&lt; endl; }<br/>        void callFoo(void)<br/>        { foo();<br/>           // foo(10); Can&#39;t be compiled! }<br/>}<br/><br/>int main(int argc, char** argv)<br/>{<br/>        foo();<br/>        a::callFoo();<br/>        return 0;<br/>}</blockquote><p>输出结果：</p><blockquote>global foo()<br/>a::foo()</blockquote><p>注意，名字空间a中的foo隐藏了其它作用域（这里是全局作用域）中的所有foo名称，foo(10)不能通过编译，因为全局作用域中的int foo(int)版本也已经被a::foo()隐藏了，除非使用::foo(10)显式进行调用。</p><p>这也告诉我们，无论何时，都使用完整名称修饰（作用域解析符调用函数，或指针、对象调用成员函数）是一种好的编程习惯。</p><p> 好了，上面零零散散说了太多理论的东西，我们需要一段实际的代码，来验证上述所有的结论：</p><blockquote>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class Other<br/>{<br/>        void* p;<br/>};<br/><br/>class Base<br/>{<br/>public:<br/>        int iBase;<br/>        Base():iBase(10){}<br/>        virtual void f(int x = 20){ cout &lt;&lt; &#34;Base::f()--&#34; &lt;&lt; x &lt;&lt; endl; }<br/>        virtual void g(float f) { cout &lt;&lt; &#34;Base::g(float)--&#34; &lt;&lt; f &lt;&lt; endl; }<br/>        void g(Other&amp; o) { cout &lt;&lt; &#34;Base::g(Other&amp;)&#34; &lt;&lt; endl; }<br/>        void g(Other&amp; o) const { cout &lt;&lt; &#34;Base::g(Other&amp;) const&#34; &lt;&lt; endl;}<br/>};<br/><br/>class Derived : public Base<br/>{<br/>public:<br/>        int iDerived;<br/>        Derived():iDerived(100){}<br/>        void f(int x = 200){ cout &lt;&lt; &#34;Derived::f()--&#34; &lt;&lt; x &lt;&lt; endl; }<br/>        virtual void g(int x) { cout &lt;&lt; &#34;Derived::g(int)--&#34; &lt;&lt; x &lt;&lt; endl; }<br/>};<br/><br/>int main(int argc, char** argv)<br/>{<br/>        Base* pBase = NULL;<br/>        Derived* pDerived = NULL;<br/>        Base b;<br/>        Derived d;<br/>        pBase = &amp;b;<br/>        pDerived = &amp;d;<br/>        Base* pBD = &amp;d;<br/>        const Base* pC = &amp;d;<br/>        const Base* const pCCP = &amp;d;<br/>        Base* const pCP = &amp;d;<br/><br/>        int x = 5;<br/>        Other o;<br/>        float f = 3.1415926;<br/><br/>        b.f();<br/>        pBase-&gt;f();<br/>        d.f();<br/>        pDerived-&gt;f();<br/>        pBD-&gt;f();<br/><br/>        b.g(x);<br/>        b.g(o);<br/>        d.g(x);<br/>        d.g(f);<br/>        // Can&#39;t be compiled!<br/>        // d.g(o);<br/><br/>        pBD-&gt;g(x);<br/>        pBD-&gt;g(f);<br/>        pC-&gt;g(o);<br/>        pCCP-&gt;g(o);<br/>        pCP-&gt;g(o);<br/><br/>        return 0;<br/>}</blockquote><p>在笔者Ubuntu 12.04 + gcc 4.6.3运行结果：</p><blockquote>Base::f()--20 //b.f()，通过对象调用，无虚特性，静态绑定<br/>Base::f()--20 //基类指针指向基类对象，虽然是动态绑定，但没有使用到覆盖<br/>Derived::f()--200 //d.f，通过对象调用，无虚特性，静态绑定<br/>Derived::f()--200 //子类指针指向子类对象，虽然是动态绑定，但没有使用到覆盖<br/>Derived::f()--20 //基类指针指向子类对象，动态绑定，子类f()覆盖基类版本。但函数参数默认值，是静态联编行为，pBD的类型是基类指针，所以使用了基类的参数默认值，注意此处！<br/><br/>Base::g(float)--5 //通过对象调用，int被提升为float<br/>Base::g(Other&amp;) //没什么问题，基类中三个g函数之间的关系是重载<br/>Derived::g(int)--5 //没什么问题<br/>Derived::g(int)--3 //注意基类的g(float)已经被隐藏！所以传入的float参数调用的却是子类的g(int)方法！<br/>Base::g(float)--5 //注意！pBD是基类指针，虽然它指向了子类对象，但基类中的所有g函数版本它是可见的！所以pBD-&gt;g(5)调用到了g(float)！虽然产生了动态联编也发生了隐藏，但子类对象的虚表中，仍可以找到g(float)的地址，即基类版本！<br/>Base::g(float)--3.14159 //原理同上<br/><br/>//d.g(o)<br/>//注意此处！再注意代码中被注释了的一行，d.g(o)不能通过编译，因为d是子类对象，在子类中，基类中定义的三个g函数版本都被隐藏了，编译时不可见！不会重载<br/><br/>Base::g(Other&amp;) const //pC是指向const对象的指针，将调用const版本的g函数<br/>Base::g(Other&amp;) const //pCCP是指向const对象的const指针，也调用const版本的g函数<br/>Base::g(Other&amp;) //pCP是指向非cosnt对象的const指针，由于不指向const对象，调用非const版本的g函数</blockquote><p>上述结果，是否和预想的是否又有些出入呢？问题主要集中于结果的第5、12、13和15行。</p><p>第5行输出结果证明：当函数参数有默认值，又发生多态行为时，函数参数默认值是静态行为，在编译时就已经确定，将使用基类版本的函数参数默认值而不是子类的。</p><p>而第12、13、15行输出结果则说明，尽管已经证明我们之前说的隐藏是正确的（因为d.g(o)不可以通过编译，确实发生了隐藏），但却可以利用基类指针指向派生类对象后，来绕开这种限制！也就是说，编译器根据参数匹配函数原型的时候，是在编译时根据指针的类型，或对象的类型来确定，指针类型是基类，那么基类中的g函数版本就是可见的；指针类型是子类，由于发生了隐藏，基类中的g函数版本就是不可见的。而到动态绑定时，基类指针指向了子类对象，在子类对象的虚函数表中，就可以找到基类中g虚函数的地址。</p><p>写到这里，不知道读者是否已经明白，这些绕来绕去的关系。在实际代码运用中，可能并不会写出含有这么多“陷阱”的测试代码，我们只要弄清楚重载、覆盖和隐藏的具体特征，并头脑清醒地知道，我现在需要的是哪一种功能（通常也不会需要隐藏），就能写出清析的代码。上面的代码其实是一个糟糕的例子，因为在这个例子中，重载、覆盖、隐藏并存，我们编写代码，就是要尽可能防止这种含混不清的情况发生。</p><p>记住一个原则：每一个方法，功能和职责尽可能单一，否则，尝试将它拆分成为多个方法。</p>", 
            "topic": [
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "编程学习", 
                    "tagLink": "https://api.zhihu.com/topics/19593616"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54512659", 
            "userName": "程序员", 
            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
            "upvote": 0, 
            "title": "Performanced C++ 经验规则（4）：静态和多态，亦敌亦友", 
            "content": "<p>这一篇，我们讨论C++中静态和多态的关系。我们都知道，C++并不是一门“动态”语言，虽然它提供了同样强大于其它动态语言的多态性，但很多时候，我们之所以选择C++，看重中正是其“静态”所带来的High Performance。所谓静态，通常是指，在程序运行的过程，是“静止”不变，固定的（特别是内存地址），当然“多态”就是与之对立的概念。这一篇我们并不讨论静态（成员）变量或静态（成员）函数有什么作用，而是讨论“静态”的行为，对比“多态”。我们这里所说的静态，是指：compiler time，即编译时绑定、早绑定、静态联编；而“多态”就是真正的runtime绑定、晚绑定、动态联编。</p><p>很奇妙，这一组对立的概念，却可以在C++中和平共存，时而协同工作。</p><p>像以前一样，还是一小段代码提出问题，当一个虚成员函数（多态性）在其子类中被声明为静态成员函数时（或相反过来），会发生什么？</p><h2>1、当虚函数遭遇静态函数</h2><blockquote>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class Base<br/>{<br/>public:<br/>    virtual void foo(void){ cout &lt;&lt; &#34;Base::foo()&#34; &lt;&lt; endl; }<br/>};<br/><br/>class Derived : public Base<br/>{<br/>public:<br/>    void foo(void){ cout &lt;&lt; &#34;Derived::foo()&#34; &lt;&lt; endl; }<br/>} ;<br/><br/>class DerivedAgain : public Derived<br/>{<br/>public:<br/>    static void foo(void){ cout &lt;&lt; &#34;DerivedAgain::foo()&#34;&lt;&lt; endl; }<br/>} ;<br/><br/>int main(int argc, char** argv)<br/>{<br/>    DerivedAgain da;<br/>    Base* pB = &amp;da;<br/><br/>    da.foo();<br/>    pB-&gt;foo();<br/>    return 0;<br/>}</blockquote><p>上述代码运行结果是什么？等等，你确定上述代码能通过编译？在笔者Ubuntu 12.04 + gcc 4.6.3的机器上，上述代码<b>编译不能通过</b>。显示如下信息：</p><blockquote>stawithvir.cpp:19:17: error: ‘static void DerivedAgain::foo()’ cannot be declared<br/>stawithvir.cpp:13:10: error:   since ‘virtual void Derived::foo()’ declared in base class</blockquote><p>很明显，<b>编译不能通过的原因，是在DerivedAgain类中将虚函数声明为static</b>，编译器拒绝此“静态”与“多态”的和平共处。此时理由很简单，static成员函数，是类级共享的，不属于任何对象，也不会传入this指针，不能访问非静态成员；然而，虚函数的要求与此正相反，需要绑定对象（this指针），进而获得虚表，然后进行调用。如此矛盾的行为，编译器情何以堪，因为选择报错来表达其不满。我们可以暂时记住结论：<b>不能将虚函数声明为静态的</b>。</p><p>接下来你可能会问，编译都不能通过的东西，对错不是明摆着的吗？为什么还要拿来讨论，这是因为，在某些编译器上（可以在VC6，VC2008等尝试），该代码能编译通过，并输出结果，不可思议？不过这些编译器同时也给出了一个警告（参与MSDN warning c4526），指出静态函数不能用做虚函数进行调用。虽然通过了编译，但思想与上述Gcc是一致的。</p><blockquote>//输出结果<br/>DerivedAgain::foo()<br/>Derived::foo()</blockquote><p>da.foo()输出DerivedAgain::foo()没有疑问（通过对象调用方法，无论是否虚方法，本来就不会产生动态绑定，即无虚特性）；而pB-&gt;foo()输出Derived::foo()则需要解释一下，因为pB是指针调用虚方法，产生“多态”，动态绑定时发现pB指向的对象类型为DerivedAgain，于是去查找DerivedAgain对象虚表中foo()的地址，但此时发现DerivedAgain的虚表中foo()的地址其实是Derived::foo()，<b>因为DerivedAgain中的foo已经被声明为static，不会更新此函数在虚表中的地址</b>（实际上，由于DerivedAgain没有声明任何新的虚函数，它对象的虚表同Derived对象是完全一样的，如果有兴趣，可以通过汇编查看），所以输出的是Derived::foo()，也从一个侧面证明了：在继承链中，使用最”新”的虚函数版本。</p><p>至此，这个问题已经解释清楚，再次记住结论：<b>静态成员函数，不能同时也是虚函数</b>。</p><h2>2、重载（overload）并非真正的多态，其本质是静态行为</h2><p>笔者曾不止一次的看到，许多书籍、资料，在谈到C++多态性的时候，经常把“重载”（overload）归入多态行为中。这种说法看似也没什么不正确，实际上我认为十分不妥。虽然重载，通过区分特征标的不同（注意，同函数名而参数不同、或同函数名但是否是const成员函数，都是重载依据），而使相同函数名的方法调用产生了不同的行为，确实体现了“多态”的思想，但<b>重载的本质是静态绑定，是编译期就能确定调用哪个方法，而非动态绑定，所以不是真正的多态</b>。所以，头脑要清醒，即如果两个（或多个）方法之间的关系是“重载”（overload），那么就不会有真正的多态行为产生。</p><h2>3、何时产生真正的多态？</h2><p>讨论重载之后，就要谈到，何时产生真正的多态行为，即动态绑定呢？笔者归纳三个必要条件如下：</p><p>（1）方法是虚的；</p><p>（2）有覆盖（override）产生；</p><p>（3）通过指针或引用调用相应的虚方法，而非通过对象调用；通过对象调用方法，无论方法是否是虚方法，均是静态联编行为。</p><p>条件（1）（2）很明显，如果方法是虚的也没有覆盖，何来“多”的“态”？而条件（3）容易被新手忽视，因为<b>通过对象调用，对象的类型已经确知，所以静态绑定，不会再产生多态。而通过指针或引用调用相应虚方法，由于在编译期不能确定指针或引用指向的具体类型，所以只能动态联编，从而产生多态</b>。</p><h2>4、不正确的代码将阻止多态行为</h2><p>好了，接下来我们看一小段代码，来自《C++ Primer Plus》：</p><blockquote>class Base<br/>{<br/>public:<br/>    virtual void foo(void) {...}<br/>    ...<br/>};<br/><br/>class Derived : public Base<br/>{<br/>public:<br/>    void foo(void) {...}<br/>    ...<br/>};<br/><br/>//版本1<br/>void show1(const Base&amp; b)<br/>{<br/>    b.foo();<br/>}<br/><br/>//版本2<br/>void show2(Base b)<br/>{<br/>   b.foo();<br/>}<br/><br/>int main(int argc, char** argv)<br/>{<br/>    Derived d;<br/>    show1(d);<br/>    show2(d);<br/>    return 0;<br/>}</blockquote><p>上述代码有什么问题？我们看到，两个版本的show函数唯一不同之处，就是版本1按引用传递对象，版本2按值传递对象。在main函数中，新建了一个Derived对象并传给版本1函数，由于版本1中的参数b是引用类型，OK，没有问题，b.foo()将按照b实际指向的对象调用，即可以正确调用Derived::foo()；而版本2参数b是对象类型（b是Base(const Base&amp;)拷贝构造创建的一个Base对象，自动向上的强制类型转换使得基类拷贝构造函数可以引用一个子类对象），根据上述第3点，则b.foo()将按对象类型（Base）调用到Base::foo()，不产生多态行为。即，<b>由于按值传递，在此处阻止了动态绑定，阻止了多态行为</b>。</p><p>说到这里的话，又是老生常谈的问题，即<b>除非必须要这样做，否则不要按值方式传递参数，而应选择指针或引用</b>，关于这个问题，后面还会再谈。</p>", 
            "topic": [
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "静态方法", 
                    "tagLink": "https://api.zhihu.com/topics/19598002"
                }, 
                {
                    "tag": "多态", 
                    "tagLink": "https://api.zhihu.com/topics/20011238"
                }
            ], 
            "comments": [
                {
                    "userName": "Code Hz", 
                    "userLink": "https://www.zhihu.com/people/47e576ec2146043540ced49919387f6d", 
                    "content": "<p>多态这个我感觉主要还是定义的问题，不同的书定义是有不同的，广义多态里重载也是多态的一种。。。（如wikipedia</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54466078", 
            "userName": "程序员", 
            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
            "upvote": 4, 
            "title": "Performanced C++ 经验规则（3）：你不知道的构造函数（下）", 
            "content": "<p>前面两篇，我们已经讨论了C++构造函数中诸多细枝末节，但百密一疏，还有一些地方我们没有考虑到。这一篇将对这些问题进行完结。</p><h2>7、构造函数中的异常</h2><p>当你在构造函数中写代码的时候，你有没有想过，如果构造函数中出现异常（别告诉我，你不抛异常。“必要”时系统会替你抛的），那会出现怎样的情况？</p><p>对象还能构建完成吗？构造函数中已经执行的代码产生的负面效应（如动态分配内存）如何解决？对象退出其作用域时，其析构函数能被调用吗？</p><p>上述这些问题，正是构造函数中产生异常要面临的问题。让我们先看结论，再分析过程：<b>尽可能不要在构造函数中产生（抛出）异常，否则，一定会产生问题</b>。</p><p>我们先看一段代码：</p><blockquote>#include &lt;iostream&gt;<br/>#include &lt;exception&gt;<br/>#include &lt;stdexcept&gt;<br/>using namespace  std;<br/><br/>class ConWithException<br/>{<br/>public:<br/>    ConWithException() : _pBuf(NULL)<br/>    {<br/>        _pBuf = new int[100];<br/>        throw std::runtime_error(&#34;Exception in Constructor!&#34;);<br/>    }<br/><br/>    ~ConWithException()<br/>    {<br/>        cout &lt;&lt; &#34;Destructor!&#34; &lt;&lt; endl;<br/>        if( _pBuf != NULL )<br/>        {<br/>            cout &lt;&lt;  &#34;Delete buffer...&#34; &lt;&lt; endl;;<br/>            delete[] _pBuf;<br/>            _pBuf = NULL;<br/>        }<br/>    }<br/><br/>private:<br/>    int* _pBuf;<br/>};<br/><br/>int main(int argc, char** argv)<br/>{<br/>    ConWithException* cwe = NULL;<br/>    try<br/>    {<br/>        cwe = new ConWithException;<br/>    }<br/>    catch( std::runtime_error&amp; e )<br/>    {<br/>        cout&lt;&lt; e.what() &lt;&lt; endl;<br/>    }<br/><br/>    delete cwe;<br/><br/>    return 0;<br/>}</blockquote><p>这段代码运行结果是什么呢？</p><p>输出</p><p>Exception in Constructor!</p><p>输出“Exception in Constructor!”说明，我们抛出的异常已经成功被捕获，但有没有发现什么问题呢？有一个很致命的问题，那就是，对象的析构函数没有被调用！也就是说，delete cwe这一句代码没有起任何作用，相当于对delete NULL指针。再往上推，我们知道cwe值还是初始化的NULL，说明对象没有成功的构建出来，因为<b>在构造函数中抛出了异常，终止了构造函数的正确执行，没有返回对象</b>。即使我们把cwe = new ConWithException换成在栈中分配（ConWithException cwe;），仍是相同的结果，但cwe退出其作用域时，其析构函数也不会被调用，因为cwe根本不是一个正确的对象！继续看，在这个构造函数中，为成员指针_pBuf动态申请了内存，并计划在析构函数中释放这一块内存。然而，由于构造函数抛出异常，没有返回对象，析构函数也没有被调用，_pBuf指向的内存就发生了泄露！每调用一次这个构造函数，就泄露一块内存，产生严重的问题。现在，你知道了，为什么不能在构造函数中抛出异常，即使没有_pBuf这样需要动态申请内存的指针成员存在。</p><p>然而很多时候，异常并不是由你主动抛出的，也就是说，将上述构造函数改造成这样：</p><blockquote>ConWithException() : _pBuf(NULL)<br/>{<br/>    _pBuf = new int[100];<br/>}</blockquote><p>这是我们十分熟悉的格式吧？没错，但是，这样的写法仍然可能产生异常，因为这取决于编译器的实现。当动态内存分配失败时，编译器可能返回一个NULL指针（这也是惯用方式），OK，那没有问题。但是，有些编译器也有可能引发bad_alloc异常，如果对异常进行捕获（通常也不会这样做），结果将同上述例子所示。而如果未对异常进行捕获，结果更加糟糕，这将产生Uncaught exception，通常将导致程序终止。并且，此类问题是运行阶段可能出现的问题，这将更难发现和处理。</p><p>说了半天，就是认为上述写法，还不够好，不OK，接下来讲述解决方案。</p><p>解决方案一：使用智能指针shared_ptr（c++0x后STL提供，c++0x以前可采用boost），注意，在此处不能使用auto_ptr（因为要申请100个int，而即使申请的是单个对象，也不建议使用auto_ptr，关于智能指针，本系列后面的规则会有讲述）；</p><p>解决方案二：就是前面多次提到的，采用<b>“工厂模式”替换公有构造函数，从而尽可能使构造函数“轻量级“</b>。</p><blockquote>class ConWithException //为和前面比对，类名没改，糟糕的类名<br/>{<br/>public:<br/>    ConWithException* factory(some parameter...)<br/>    {<br/>        ConWithException* cwe = new ConWithException;<br/>        if(cwe)<br/>        {<br/>            cwe-&gt;_pBuf = new int[100];<br/>            //other initialization...<br/>        }<br/>        return cwe;<br/>    }<br/><br/>    ~ConWithException()<br/>    {<br/>        if(cwe-&gt;_pBuf)<br/>        {<br/>            delete[] cwe-&gt;_pBuf;<br/>            _pBuf = NULL;<br/>        }<br/>        //other destory process...<br/>    }<br/>private:<br/>    ConWithException() : _pBuf(NULL) {} //如果有非静态const成员还需要在初始化列表中进行初始化，否则什么也不做<br/>    int* _pBuf;<br/>};</blockquote><p>使用“工厂模式”的好处是显而易见的，上述构造函数中异常的问题可以得到完美解决？why？因为构造函数十分轻量级，可轻松的完成对象的构建，“重量级”的工作都交由“工厂”（factory）方法完成，这是一个公有的普通成员函数，如果在这个函数中产生任何异常，因为对象已经正确构建，可以完美的进行异常处理，也能保证对象的析构函数被正确地调用，杜绝memory leak。构造函数被声明为私有，以保证从工厂“安全”地产生对象，使用“工厂模式”，还可以禁止从栈上分配对象（其实Java、Objective-C都是这么做的），在必要的时候，这会很有帮助。</p><p>8、构造函数不能被继承：虽然子类对象中包含了基类对象，但并不能代表构造函数被继承，即，除了在子类构造函数的初始化列表里，你可以显式地调用基类的构造函数，在子类的其它地方调用父类的构造函数都是非法的。</p><p>9、当类中有需要动态分配内存的成员指针时，需要使用“深拷贝“重写拷贝构造函数和赋值操作符，杜绝编译器“用心良苦”的产生自动生成版本，以防资源申请、释放不正确。</p><p>10、除非必要，否则最好在构造函数前添加explicit关键字，杜绝隐式使构造函数用作自动类型转换。</p><p>终于写完了，这三篇有关构造函数的“经验”之谈，其实，这些问题，也是老生常谈了。经过这三篇的学习，为敲开C++的壁垒，我们又添加了一把强有力的斧头。希望小编的文章能对大家有所帮助！</p>", 
            "topic": [
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "函数构造", 
                    "tagLink": "https://api.zhihu.com/topics/20030822"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": [
                {
                    "userName": "二大爷", 
                    "userLink": "https://www.zhihu.com/people/4a0006f20a1bc2787095787ff80a52f4", 
                    "content": "太好了，说的！", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "const", 
                    "userLink": "https://www.zhihu.com/people/7a17fa7a25fc52b383cdf4d4cd1240f3", 
                    "content": "构造函数里的异常为什么要catch(", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "程序员", 
                            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
                            "content": "<p>1. 要把可能出现异常的，要检查的语句放在try后面的花括号中，或者说有throw关键字抛出异常的程序段。</p><p>2.异常信息提供给try-catch语句结构，系统会去寻找与try匹配的catch语句，try和catch是成对出现的，类似if和else。</p><p>3.异常抛出后，程序就跳到了catch语句中。</p><p>4.被检测的部分必须用try括起来，要不然throw抛出的异常不起作用。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "const"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54446034", 
            "userName": "程序员", 
            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
            "upvote": 3, 
            "title": "Performanced C++ 经验规则（2）：你不知道的构造函数（中）", 
            "content": "<p>上一篇你不知道的构造函数（上）主要讲述了，C++构造函数在进入构造函数体之前，你可能不知道的一些细节。这一篇将讲述，进入构造函数体后，又发生了什么。</p><h2>4、虚表初始化</h2><p>上一篇曾提到，如果一个类有虚函数，那么虚表的初始化工作，无论构造函数是你定义的还是由编译器产生的，这部分工作都将由编译器隐式“合成”到构造函数中，以表示其良苦用心。上一篇还提到，这部分工作，在“刚”进入构造函数的时候，就开始了，之后，编译器才会理会，你构造函数体的第一行代码。这一点，通过反汇编，我们已经看的非常清楚。</p><p>虚表初始化的主要内容是：将虚表指针置于对象的首4字节；用该类的虚函数实际地址替换虚表中该同特征标（同名、同参数）函数的地址，以便在调用的时候实现多态，如果有新的虚函数（派生类中新声明的），则依次添加至虚表的后面位置。</p><h2>5、构造函数中有虚特性（即多态、即动态绑定、晚绑定）产生吗？</h2><p>这个问题，看似简单，答案却比较复杂，正确答案是：对于构造函数，构造函数中没有虚特性产生（在C++中答案是<b>NO</b>，但在Java中，答案是YES，非常的奇葩）。</p><p>先从基类构造函数说起，为什么要提基类构造函数呢，因为，派生类总是要调用一个基类的构造函数（无论是显式调用还是由编译器隐式地调用默认构造函数，因为这里讨论的是有虚函数的情况，所以一定会有基类构造函数产生并调用），而此时，在基类构造函数中，派生类对象根本没有创建，也就是说，基类根本不知道派生类中产生了override，即多态，故没有虚特性产生。</p><p>这一段非常让人疑惑。让我们再看一小段代码，事实胜于雄辩。</p><blockquote>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class Base<br/>{<br/>public:<br/>        Base() { foo(); }<br/>        virtual void foo(void) { cout &lt;&lt; &#34;Base::foo(void)&#34; &lt;&lt; endl; }<br/>        virtual void callFoo(void) { foo(); }<br/>};<br/><br/>class Derived : public Base<br/>{<br/>public:<br/>        Derived() { foo(); }<br/>        void foo(void) { cout &lt;&lt; &#34;Derived::foo(void)&#34; &lt;&lt; endl; }<br/>};<br/><br/>int main(int argc, char** argv)<br/>{<br/>        Base* pB = new Derived;<br/>        pB-&gt;callFoo();<br/>        if(pB)<br/>                delete pB;<br/>        return 0;<br/>}</blockquote><p>在Ubuntu 12.04 + gcc 4.6.3输出结果如下：</p><blockquote>Base::foo(void)<br/>Derived::foo(void)<br/>Derived::foo(void)</blockquote><p>这个结果可以很好的解释上述问题，第一行，由于在Base构造函数中，看不到Derived的存在，所以<b>根本不会产生虚特性</b>；而第二行，虽然输出了Derived::foo(void)，但因为在派生类直接调用方法名，调用的就是本类的方法，（当然，也可认为在Derived构造函数中，执行foo()前，虚表已经OK，故产生多态，输出的是派生类的行为）。再看第三行，也产生多态，因为，此时，派生类对象已经构建完成，虚表同样也已经OK，所以产生多态是必然。</p><p>这个问题其实是C++比较诟病的陷阱问题之一，但我们只要记住结论：<b>不要在构造函数内调用其它的虚成员函数，否则，当这个类被继承后，在构造函数内调用的这些虚成员函数就没有了虚特性（丧失多态性）</b>。（非虚成员函数本来就没有多态性，不在此讨论范围）</p><p>解决此类问题的方法，是使用“工厂模式”，在后续篇幅中笔者会继续提到，这也是《Effective C++》中阐述的精神：尽可能以工厂方法替换公有构造函数。</p><p>另外，有兴趣的同学，可以将上述代码稍加修改成Java跑一跑，你会惊喜的发现，三个输出都是Derived::foo(void)，也就是说，JVM为你提供了一种未卜先知的超自然能力。</p><h2>6、构造函数中调用构造函数、析构函数</h2><p>上面已经提到，不要在构造函数内调用其它成员函数，那么调用一些“特殊”的函数，情况又如何呢？我知道，有同学想到了，在构造函数中调用本类的析构函数，情况如何？如下面的代码</p><blockquote>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class A<br/>{<br/>public:<br/>        ~A() { cout &lt;&lt; hex &lt;&lt; (int)this &lt;&lt;&#34;destructed!&#34; &lt;&lt; endl; }<br/>        A() { cout &lt;&lt; hex &lt;&lt; (int)this &lt;&lt; &#34;constructed!&#34; &lt;&lt; endl;<br/>                ~A();  }<br/><br/>};<br/><br/>int main(int argc, char** argv)<br/>{<br/>        A a;<br/>        return 0;<br/>}</blockquote><p>虽然我对有这种想法的同学有强拖之去精神病院的冲动，但还是本着研究精神，把上述“疯子”代码跑一遍，还特地把析构函数的定义提到构造函数之前以防构造函数不认识它。结论是：<b>构造函数中调用析构函数，编译器拒绝接受~A()是析构函数，从而拒绝这一不讲理行为。</b>此时编译器认为，你是在重载~操作符，并给出没有找到operator ~()声明的错误提示。其实，无论是在构造函数A()里面调用~A()不行，在成员函数里，也是不行的（编译器仍认为你要调用operator ~()，而你并没有声明这个函数）。但是，有个小诡计，却可以编译通过，就是通过this-&gt;~A()来调用析构函数，这将导致对象a被析构多次，隐藏着巨大的安全隐患。</p><p>总之，在构造函数中调用析构函数，是十分不道德的行为，应严格禁止。</p><p>好了，接下来是，构造函数中，调用构造函数，情况又如何呢？</p><p>（1）首先，如果构造函数中递归调用本构造函数，产生无限递归调用，很快就栈溢出（栈上分配）或其它crash，应严格禁止；</p><p>（2）如果构造函数中，调用另一个构造函数，情况如何？</p><blockquote>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class ConAndCon<br/>{<br/>public:<br/>    int _i;<br/>    ConAndCon( int i ) : _i(i){}<br/>    ConAndCon()<br/>    {<br/>        ConAndCon(0);<br/>    }<br/>};<br/><br/>int main(int argc, char** argv)<br/>{<br/>    ConAndCon cac;<br/>    cout &lt;&lt; cac._i &lt;&lt; endl;<br/>    return 0;<br/>}</blockquote><p>上面代码，输出为0吗？</p><p>答案是：不一定。输出结果是不确定的。根据C++类非静态成员是没有默认值的规则，可以推定，上述代码里，<b>在无参构造函数中调用另一个构造函数，并没有成功完成对成员的初始化工作</b>，也就是说，这个调用，是不正确的。</p><p>那么，由ConAndCon产生的对象哪里去了？如果用gdb跟踪调试或在上述类的构造、析构函数中打印出对象信息就会发现，在构造函数中调用另一个构造函数，会产生一个匿名的临时对象，然后这个对象又被销毁，而调用它的cac对象，仍未得到本意的初始化（设置_i为0）。这也是应严格禁止的。</p><p>通常解决此问题的三个方案是：</p><p><b>方案一</b>，我们称为一根筋方案，即，我仍要继续在构造函数中调用另一个构造函数，还要让它正确工作，即“一根筋”，解决思路：不要产生新分配的对象，即在第一个构造函数产生了对象的内存分配之后，仍在此内存上调用另一个构造函数，通过布局new操作符（replacement new）可以做到：</p><blockquote>//标准库中replacement new操作符的定义：<br/>//需要#include &lt;new&gt;<br/><br/>inline void *__cdecl operator new(size_t, void *_P)<br/>{<br/>    return (_P);<br/>}<br/><br/>//那么修改ConAndCon()为：<br/><br/>    ConAndCon()<br/>    {<br/>        new (this)ConAndCon(0);<br/>    }</blockquote><p>即在第一次分配好的内存上再次分配。</p><p>某次在Ubuntu 12.04 + gcc 4.6.3运行结果如下（修改后的代码）：</p><blockquote>#include &lt;iostream&gt;<br/>#include &lt;new&gt;<br/>using namespace std;<br/><br/>class ConAndCon<br/>{<br/>public:<br/>    int _i;<br/>    ConAndCon( int i ) : _i(i){cout &lt;&lt; hex &lt;&lt; (int)this &lt;&lt;&#34;constructed!&#34; &lt;&lt; endl;}<br/>    ConAndCon()<br/>    {<br/>        cout &lt;&lt; hex &lt;&lt; (int)this &lt;&lt;&#34;constructed!&#34; &lt;&lt; endl;<br/>        new (this)ConAndCon(0);<br/>    }<br/>        ~ConAndCon() { cout &lt;&lt; hex &lt;&lt; (int)this &lt;&lt;&#34;destructed!&#34; &lt;&lt; endl; }<br/>};<br/><br/>int main(int argc, char** argv)<br/>{<br/>    ConAndCon cac;<br/>    cout &lt;&lt; cac._i &lt;&lt; endl;<br/>    return 0;<br/>}<br/><br/>//运行结果：<br/>bfd1ae9cconstructed!<br/>bfd1ae9cconstructed!<br/>0<br/>bfd1ae9cdestructed!</blockquote><p>可以看到，成功在第一次分配的内存上调用了另一个构造函数，且无需手动为replacement new调用析构函数（此处不同于在申请的buffer上应用replacement new，需要手动调用对象析构函数后，再释放申请的buffer）</p><p><b>方案二</b>，我们称为“AllocAndCall”方案，即构造函数只完成对象的内存分配和调用初始化方法的功能，即把在多个构造函数中都要初始化的部分“提取”出来，通常做为一个private和非虚方法（为什么不能是虚的参见上面第5点），然后在每个构造函数中调用此方法完成初始化。通常，这样的方法取名为init，initialize之类。</p><blockquote>class AllocAndCall<br/>{<br/>private:<br/>    void initial(...) {...} //初始化集中这里<br/>public:<br/>    AllocAndCall() { initial(); ...}<br/>    AllocAndCall(int x) { initail(); ...}<br/>};</blockquote><p>这个方案和后面要详述的“工厂模式”，在一些思想上类似。</p><p>这个方案最大的不足，是在于，initial()初始化方法不是构造函数而<b>不能使用初始化列表，对于非静态const成员的初始化将无能为力</b>。也就是说，如果该类包含非静态的const成员（静态的成员初始化参看上一篇中的第2点），则<b>对这些非静态const成员的初始化，必须要在每个构造函数的初始化列表完成</b>，无法“抽取“到初始化方法中。</p><p>方案三，我们称为“C++ 0x“方案，这是C++ 0x中的新特性，叫做“委托构造函数”，通过在构造函数的初始化列表（注意不是构造函数体内）中调用其它构造函数，来得到相应目的。感谢C++ 0x！</p><blockquote>class CPerson<br/>{<br/>public:<br/>CPerson() : CPerson(0, &#34;&#34;) { NULL; }<br/>CPerson(int nAge) : CPerson(nAge, &#34;&#34;) { NULL; }<br/>CPerson(int nAge, const string &amp;strName)<br/>{<br/>  stringstream ss;<br/>  ss &lt;&lt; strName &lt;&lt; &#34;is &#34; &lt;&lt; nAge &lt;&lt; &#34;years old.&#34;;<br/>  m_strInfo = ss.str();<br/>}<br/><br/>private:<br/>string m_strInfo;<br/>};</blockquote><p>其实，对于这样的问题，笔者认为，最好的解决方式，没有在这几种方案中讨论，仍是——使用“工厂模式”，替换公有构造函数。</p><p>中篇到此结束，下一篇将会有更多精彩内容——in C++ Constructor！。谢谢大家！</p>", 
            "topic": [
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }, 
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "performance", 
                    "tagLink": "https://api.zhihu.com/topics/19624510"
                }
            ], 
            "comments": [
                {
                    "userName": "AngkorW", 
                    "userLink": "https://www.zhihu.com/people/dc17d7304367e68697aae4438e5612ba", 
                    "content": "事在人为， 筚路蓝缕，以启山林！", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54440420", 
            "userName": "程序员", 
            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
            "upvote": 5, 
            "title": "Performanced C++ 经验规则（1）：你不知道的构造函数（上）", 
            "content": "<p><b>Performanced C++ 经验规则</b></p><p>前言：Performanced C++，意为“高性能C++“编程，是笔者和所在团队多年C++编程总结的经验规则，按条款方式讲述（参考了《Effective C++》的方式），希望能对初入C++的程序员提供帮助，少走弯路，站在前人的肩膀上，看得更高走的更远。我们也同样是脚踩许许多多大牛的经典著作，还有无数默默付出的程序员的辛劳，以及自己许许多多惨痛的编程体验，才有了这些“规则”。</p><p><b>第一条：你不知道的构造函数（上）</b></p><p>首先来看，我们“知道”的构造函数，C++构造函数究竟做了哪些事情？</p><p>1、创建一个类的对象时，编译器为对象分配内存空间，然后调用该类的构造函数；</p><p>2、构造函数的目的，是完成对象非静态成员的初始化工作（静态成员如何初始化？记住以下要点：<b>在类外进行、默认值为0、在程序开始时、在主函数之前、单线程方式、主线程完成</b>），记住：C++类非静态成员是没有默认值的（可对比Java）。</p><p>3、如果构造函数有初始化列表，则先<b>按照成员声明顺序</b>（非初始化列表中的顺序）执行初始化列表中的内容，然后再进入构造函数体。这里又有疑问了，如果类本身没有非虚拟的基类，应显式地调用直接基类的某个构造函数，否则，将会自动其直接基类的默认构造函数（如果此时直接基类没有默认构造函数，得到编译错误）；如果类本身有虚拟基类，也应显式地调用虚拟基类的某个构造函数，否则，将会自动调用虚拟基类的默认构造函数；如果成员有其它类的对象，则应显式地调用成员所属类的相应构造函数，否则对于没有在初始化列表中出现的类成员，<b>也会自动调用其默认的构造函数</b>。</p><p>注意上述调用顺序，编程时应按照“<b>先祖再客最后自己</b>”的原则进行，即，首先完成自身包含的“祖先对象”的初始化，之后，完成自身包含的成员是其它类型（客人）的初始化，最后才是自身非类类型成员的初始化工作。</p><p>再注意，上面多次提到了术语“默认构造函数”，默认构造函数是指：无参构造函数或每个参数均有默认值的构造函数。当且仅当，一个类没有声明<b>任何</b>构造函数时，可认为编译器会自动为该类创建一个默认构造函数（无参的，注意“可认为”，即实际情况并非如此，编译器并不一定总是会自动创建默认构造函数，除非必要，这涉及到更深的汇编层面。当然，在写代码的时候，这个“可认为”是正确的）。</p><p>这一小部分内容可能信息量过大，让我们看一段代码以加深理解。</p><blockquote>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class Base<br/>{<br/>private:<br/>        int _x;<br/>public:<br/>        Base(int x) : _x(x) { cout &lt;&lt; &#34;Base(x) _x=&#34; &lt;&lt; _x &lt;&lt; endl; }<br/>        Base() {}<br/>};<br/><br/>class DerivedA :virtual  public Base<br/>{<br/>        int _y;<br/>public:<br/>        DerivedA(int x = 0, int y = 1) : Base(x), _y(y)<br/>        { cout &lt;&lt; &#34;DerivedA(x,y) _y=&#34; &lt;&lt; _y &lt;&lt; endl; }<br/>};<br/><br/>class DerivedB :virtual  public Base<br/>{<br/>        int _z;<br/>public:<br/>        DerivedB(int x = 0, int z = 2) : Base(x), _z(z)<br/>        { cout &lt;&lt; &#34;DerivedB(x,z) _z=&#34; &lt;&lt; _z &lt;&lt; endl; }<br/>};<br/><br/>class Other<br/>{<br/>        int _o;<br/>public:<br/>        Other() : _o(3) { cout &lt;&lt; &#34;Other() _o=&#34; &lt;&lt; _o &lt;&lt; endl; }<br/>};<br/><br/>class DerivedFinal : public DerivedB, public DerivedA<br/>{<br/>        int _xyz;<br/>        Other _other;<br/>public:<br/>        DerivedFinal(int x = 10, int y = 20, int z = 30, int o = 50) : DerivedA(x,y), DerivedB(x,z), Base(x), _xyz(x * y * z)<br/>        { cout &lt;&lt; &#34;DerivedFinal(x,y,z,o) _xyz=&#34; &lt;&lt; _xyz &lt;&lt; endl; }<br/>};<br/><br/>int main(int argc, char** argv)<br/>{<br/>        DerivedFinal df;<br/>        return 0;<br/>}</blockquote><p>输出结果(Ubuntu 12.04 + gcc 4.6.3)：</p><blockquote>Base(x) _x=10<br/>DerivedB(x,z) _z=30<br/>DerivedA(x,y) _y=20<br/>Other() _o=3<br/>DerivedFinal(x,y,z,o) _xyz=6000</blockquote><p>和你心中的答案是否一致呢？</p><p>一切从DerivedFinal的调用顺序说起，首先，这是虚继承，故虚基类Base的构造函数将首先被调用，尽管它在DerivedFinal构造函数的初始化列表顺序中排在后面的位置（再次记住，调用顺序与初始化列表中的顺序无关），接下来是DerivedB(x,z)，因为它先被继承；之后是DerivedA(x,z)，再之后，DerivedFinal自身非类类型成员_xyz被初始化，最后是Other()，other成员并没有出现在DerivedFinal的初始化列表中，所以它的默认构造函数将被自动调用。另外，如果不是虚继承，调用间接基类Base的构造函数将是非法的，但此处是虚继承，必须这样做。</p><p>接下来继续讨论，上面提到，编译器不一定总是会产生默认构造函数，虽然在编写代码时，你“可以这么认为”，这听起来太玄乎了，那么，到底什么时候，编译器才会真正在你没有定义任何构造函数时，为你产生一个默认构造函数呢？有以下三种情况，编译器<b>一定</b>会产生默认构造函数：</p><p>（1）该类、该类的基类或该类中定义的类类型成员对象中，有虚函数存在。</p><p>发生这种情况时，由于必须要完成对象的虚表初始化工作（关于虚函数的原理，笔者建议参考<a href=\"https://link.zhihu.com/?target=http%3A//blog.csdn.net/haoel/article/details/1948051\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">陈皓的《C++虚函数表解析》</a>），所以编译器在没有任何构造函数的时候，会产生一个默认构造函数来完成这部分工作；然而，如果已经有任何构造函数，编译器则把初始化虚表这部分工作“合成”到你已定义的构造函数之中（用心良苦）。</p><p>让我们稍稍进入汇编领域（笔者强烈建议，要精通C/C++，一定的汇编和反汇编能力是必须的，能精通更好）看一下，一个有虚函数的类，构造函数的x86反汇编代码：</p><blockquote>class VirtualTest<br/>{<br/>public:<br/>    virtual void foo(int x) { cout &lt;&lt; x &lt;&lt; endl; }<br/>};<br/><br/>int main(int argc, char** argv)<br/>{<br/>    VirtualTest vt;<br/>lea ecx, [ebp-4]  ;获取对象首地址<br/>call @ILT+15(VitrualTest::VirtualTest) (0048A500)<br/>;调用构造函数，由于该类没有定义任何构造函数又包含虚函数，编译器产生了一个默认构造函数并调用<br/><br/>    return 0;<br/>}<br/><br/>//下面是默认构造函数反汇编<br/><br/>004013D0 55               push        ebp<br/><br/>004013D1 8B EC            mov         ebp,esp<br/><br/>004013D3 51               push        ecx<br/>;头三句，初始化函数调用过程，详见汇编知识<br/><br/>004013D4 89 4D FC         mov         dword ptr [ebp-4],ecx<br/>;获取对象首地址，即this指针<br/><br/>004013D7 8B 45 FC         mov         eax,dword ptr [this]<br/>;取出this指针，这个地址将会作为指针保存到虚表首地址<br/><br/>004013DA C7 00 60 68 40 00 mov         dword ptr [eax],offset VirtualTest::`vftable&#39; (0042201c)<br/>;取虚表首地址，保存到虚表指针中（即对象头4字节）<br/><br/>004013E0 8B 45 FC         mov         eax,dword ptr [this]<br/>;再次取出this指针地址，返回函数调用，即得到对象<br/>004013E3 8B E5            mov         esp,ebp<br/><br/>004013E5 5D               pop         ebp<br/><br/>004013E6 C3               ret</blockquote><p>由该汇编代码还可以看出，虚表指针初始化，在构造函数初始化列表之后，进入构造函数体代码之前。</p><p>（2）该类、该类的基类中所定义的类类型成员对象中，带有构造函数。</p><p>发生这种情况时，由于需要显式地调用这些类类型成员的构造函数，编译器在没有任何构造函数的时候，也会产生一个默认构造函数来完成这个过程；同样，如果你已经定义一个构造函数但没有对这些类类型成员显式调用构造函数，编译器则把这部分工作“合成”到你定义的构造函数中（调用它们的默认构造函数，再次用心良苦）。</p><p>（3）该类拥有虚基类。</p><p>发生这种情况，需要维护“独此一份”的虚基类继承而来的对象，所以也需要通过构造函数完成。方式同（1）（2）。</p><p>除上述3种情况外，“可认为在没有任何构造函数时候，编译器产生一个默认构造函数”是不对的，因为这样的默认构造函数是“无用”的，编译器也就不会再用心良苦去做没用的工作。这部分涉及汇编较多，如果想详细了解，建议阅读钱林松所著的《C++反汇编与逆向分析技术揭秘》，机械工业出版社，2012.5。</p><p>这里只要记住结论就可以了。</p><p>终于讲述完了，进入构造函数体之前的奥秘，你是否觉得不过瘾呢？不着急，下一篇将讲述C++进入构造函数体之后，那些你不知道的内容。</p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "函数构造", 
                    "tagLink": "https://api.zhihu.com/topics/20030822"
                }, 
                {
                    "tag": "编程学习", 
                    "tagLink": "https://api.zhihu.com/topics/19593616"
                }
            ], 
            "comments": [
                {
                    "userName": "奇点创客", 
                    "userLink": "https://www.zhihu.com/people/55989690e349b69513e00dd46e8f0a41", 
                    "content": "期待续更！", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "程序员", 
                            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
                            "content": "<p>嗯嗯   谢谢支持</p>", 
                            "likes": 0, 
                            "replyToAuthor": "奇点创客"
                        }
                    ]
                }, 
                {
                    "userName": "暮无井见铃", 
                    "userLink": "https://www.zhihu.com/people/443c193a7d764c7cf0cc40891d853f48", 
                    "content": "<p>其实不需要代码的默认构造函数在语义上也存在，不过标准称之为“平凡”。</p><p>默认构造函数具体是否平凡其实是有语言规定的： <a href=\"http://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/default_constructor\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Default constructors</a></p>", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54434425", 
            "userName": "程序员", 
            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
            "upvote": 32, 
            "title": "C编程技巧：如何写出优美的 C 代码", 
            "content": "<p>面向对象的语言更接近人的思维方式，而且在很大程度上降低了代码的复杂性，同时提高了代码的可读性和可维护性，传统的 C 代码同样可以设计出比较易读，易维护，复杂度较低的优美代码，本文将通过一个实际的例子来说明这一点。</p><h2>基础知识</h2><h2>结构体</h2><p>除了提供基本数据类型外，C 语言还提供给用户自己定制数据类型的能力，那就是结构体，在 C 语言中，你可以用结构体来表示任何实体。结构体正是面向对象语言中的类的概念的雏形，比如：</p><blockquote>typedef struct{<br/>    float x;<br/>    float y;<br/>}Point;</blockquote><p>定义了一个平面坐标系中的一个点，点中有两个域，x 坐标和 y 坐标。</p><p>结构体中的域称为结构体的<i>成员</i>。结构体中的数据类型可以是简单数据类型，也可以是其他的结构体，甚至结构体本身还可以嵌套，比如，一个标准的链表结构可以进行如下定义：</p><blockquote>typedef struct node{<br/>    void *data;// 数据指针<br/>    int dataLength;// 数据长度<br/>    struct node *next;// 指向下一个节点<br/>}Node;</blockquote><p>可以看到，结构体 node 中的 next 指针的类型又是 node 类型。</p><h2>函数指针</h2><p>指针是 C 语言的灵魂，是 C 比其他语言更灵活，更强大的地方。所以学习 C 语言必须很好的掌握指针。函数指针，即指向函数在内存映射中的首地址的指针，通过函数指针，可以将函数作为参数传递给另一个函数，并在适当的时候调用，从而实现异步通信等功能。</p><p>比如， UNIX/Linux 系统中的信号注册函数，其原型如下：</p><blockquote>void (*signal(int signo,void (*func)(int))) (int)</blockquote><p>使用的时候，需要自己在外部定义一个信号处理函数 (signal handler), 然后使用 signal(sigNo, handler) 将处理程序注册在进程上，当信号发生时，进程就可以回调信号处理函数。</p><h2>将函数指针作为结构体的成员</h2><p>正如前面提到的，结构体的成员可以是简单的数据结构，也可以是其他的结构体，当然，也可以是指针。当将函数指针作为结构体的成员，并且这些函数只用来操作<i>本</i>结构体中的数据时，就可以形成一个独立的实体，这个实体中既有数据，也有对数据的操作，这样自然就可以引出<b>类(class)</b>的概念。</p><h2>面向对象语言的特性</h2><p>一般而言，继承，封装和多态被认为是面向对象语言所必须支持的三种特征，也正是通过这三种特征才可以体现出面向对象在哪些方面优于面向过程。由于语言开发商的宣传或其他的各种原因，使的表面上面向对象的思想要通过语言为载体而得以实现，然而实际上，面向对象是一种软件设计思想，完全是可以与具体实现无关的。</p><p>虽然如此，但是不可否认，这些所谓的纯面向对象的语言，在其代码的可读性以及与人的自然思维的匹配方面，比面向过程的语言要好的多。</p><h2>语言层次的面向对象</h2><p>我们一般要描述一个对象，一般需要描述这个对象的一些属性，比如盒子(box) 是一个实体，它有 6 个面，有颜色，重量，是否为空等属性，并且可以<i>放</i>东西进去，可以<i>取</i>东西出来。在面向对象的语言中，通常将这样的对象抽象成一个类 (class):</p><blockquote>class Box{<br/>    clolr color;<br/>    int weight;<br/>    boolean empty;<br/><br/>    put(something);<br/>    something get();<br/>}</blockquote><p>对盒子进行操作时，可以做一下动作：</p><blockquote>Box.put(cake);<br/>Box.get();// 取到某个东西，从盒子中。</blockquote><p>而面向过程的语言中，通常是将实体传递给一个贯穿全局的函数来进行的，同样以 Box 为例，对 Box 进行操作时，往往是这样：</p><blockquote>Put(Box, cake);// 将一个蛋糕放到盒子中<br/>Get(Box);// 从盒子中取出某个东西来</blockquote><p>而显然，第一种代码形式更符合常理，所以面向对象的语言大都提供这种语言层面的细节的支持，使得代码的可读性，可理解性大大增加。 C 语言，作为一个灵活而简单的语言，我们完全可以通过 C 提供的简单机制，实现这样的比较优美的代码形式。</p><h2>C 语言的面向对象</h2><p>如前所说，面向对象是一种软件设计的思想，是语言无关的。在本节中，我举一个链表(list)的例子来说明如何在 C 语言中的设计出有面向对象风格的代码。</p><h2>定义接口</h2><p>接口是面向对象语言中的一个比较重要的概念，接口只对外部承诺实现该接口的实体可以完成什么样的功能，但是不暴露实现的方式。这样的好处是，实现者可以在不接触接口使用者的代码的情况下，对实现进行调整。</p><p>我们来看看链表的接口定义：</p><p><b>清单 1. 链表的接口定义</b></p><blockquote>#ifndef _ILIST_H<br/>#define _ILIST_H<br/><br/>// 定义链表中的节点结构<br/>typedef struct node{<br/>    void *data;<br/>    struct node *next;<br/>}Node;<br/><br/>// 定义链表结构<br/>typedef struct list{<br/>    struct list *_this;<br/>    Node *head;<br/>    int size;<br/>    void (*insert)(void *node);// 函数指针<br/>    void (*drop)(void *node);<br/>    void (*clear)();<br/>    int (*getSize)();<br/>    void* (*get)(int index);<br/>    void (*print)();<br/>}List;<br/><br/>void insert(void *node);<br/>void drop(void *node);<br/>void clear();<br/>int getSize();<br/>void* get(int index);<br/>void print();<br/><br/>#endif /* _ILIST_H */</blockquote><p>IList 接口中，可以清晰的看到，对于一个 list 实体 ( 也就是对象 ) 来说，可以在<i>其上</i>进行 insert, drop, clear, getSize, get(index) 以及 print 等操作。</p><h2>接口的实现</h2><p><b>清单 2. 构造方法</b></p><blockquote>Node *node = NULL;<br/>List *list = NULL;<br/><br/>void insert(void *node);<br/>void drop(void *node);<br/>void clear();<br/>int getSize();<br/>void print();<br/>void* get(int index);<br/><br/>List *ListConstruction(){<br/>    list = (List*)malloc(sizeof(List));<br/>    node = (Node*)malloc(sizeof(Node));<br/>    list-&gt;head = node;<br/>    list-&gt;insert = insert;// 将 insert 函数实现注册在 list 实体上<br/>    list-&gt;drop = drop;<br/>    list-&gt;clear = clear;<br/>    list-&gt;size = 0;<br/>    list-&gt;getSize = getSize;<br/>    list-&gt;get = get;<br/>    list-&gt;print = print;<br/>    list-&gt;_this = list;// 用 _this 指针将 list 本身保存起来<br/><br/>    return (List*)list;<br/>}</blockquote><p>需要注意的是此处的 _this 指针，_this 指针可以保证外部对 list 的操作映射到对 _this 的操作上，从而使得代码得到简化。</p><p><b>清单 3. 插入及删除</b></p><blockquote>// 将一个 node 插入到一个 list 对象上<br/>void insert(void *node){<br/>    Node *current = (Node*)malloc(sizeof(Node));<br/><br/>    current-&gt;data = node;<br/>    current-&gt;next = list-&gt;_this-&gt;head-&gt;next;<br/>    list-&gt;_this-&gt;head-&gt;next = current;<br/>    (list-&gt;_this-&gt;size)++;<br/>}<br/><br/>// 删除一个指定的节点 node<br/>void drop(void *node){<br/>    Node *t = list-&gt;_this-&gt;head;<br/>    Node *d = NULL;<br/>    int i = 0;<br/>    for(i;i &lt; list-&gt;_this-&gt;size;i++){<br/>        d = list-&gt;_this-&gt;head-&gt;next;<br/>        if(d-&gt;data == ((Node*)node)-&gt;data){<br/>            list-&gt;_this-&gt;head-&gt;next = d-&gt;next;<br/>            free(d);<br/>            (list-&gt;_this-&gt;size)--;<br/>            break;<br/>        }else{<br/>            list-&gt;_this-&gt;head = list-&gt;_this-&gt;head-&gt;next;<br/>        }<br/>    }<br/>    list-&gt;_this-&gt;head = t;<br/>}</blockquote><p>其他的实现代码可以参看下载部分，这里限于篇幅就不再意义列举出来。</p><h2>测试</h2><h2>测试代码</h2><p>好了，前面做的一切工作都是为了保证我们的暴露给使用者的 API 可以尽量的简洁，优美，现在到测试的时候了：</p><p><b>清单 4. 测试代码</b></p><blockquote>int main(int argc, char** argv) {<br/>    List *list = (List*)ListConstruction();// 构造一个新的链表<br/><br/>// 插入一些值做测试<br/>    list-&gt;insert(&#34;Apple&#34;);<br/>    list-&gt;insert(&#34;Borland&#34;);<br/>    list-&gt;insert(&#34;Cisco&#34;);<br/>    list-&gt;insert(&#34;Dell&#34;);<br/>    list-&gt;insert(&#34;Electrolux&#34;);<br/>    list-&gt;insert(&#34;FireFox&#34;);<br/>    list-&gt;insert(&#34;Google&#34;);<br/><br/>    list-&gt;print();// 打印整个列表<br/><br/>    printf(&#34;list size = %d\\n&#34;,list-&gt;getSize());<br/><br/>    Node node;<br/>    node.data = &#34;Electrolux&#34;;<br/>    node.next = NULL;  <br/>    list-&gt;drop(&amp;node);// 删除一个节点<br/><br/>    node.data = &#34;Cisco&#34;;<br/>    node.next = NULL;<br/>    list-&gt;drop(&amp;node);// 删除另一个节点<br/><br/>    list-&gt;print();// 再次打印<br/>    printf(&#34;list size = %d\\n&#34;,list-&gt;getSize());<br/>    list-&gt;clear();// 清空列表<br/><br/>    return 0;<br/>}</blockquote><p>图 1. 运行结果</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3f29c508e4028168f2a80c9c89e79af6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"256\" class=\"content_image\" width=\"358\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;358&#39; height=&#39;256&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"256\" class=\"content_image lazy\" width=\"358\" data-actualsrc=\"https://pic3.zhimg.com/v2-3f29c508e4028168f2a80c9c89e79af6_b.jpg\"/></figure><h2><br/>结束语</h2><p>C 语言所诞生的<i>UNIX</i>平台提倡这样一种设计哲学：尽量进行简单的设计，让使用者如同搭积木一样的将这些简单的工具连接成强大的，完整的应用。 应该说，C 比较好的继承了这一点，C 语言非常简洁，非常强大，而由于 C 语言诞生的比较早，当时的面向对象的思想还不成熟，所以出现了大量的过程式的 C 应用，从而给人们一种 C 语言是面向过程的语言的错觉，其实 C 只是提供了一些简单，强大而通用的能力，至于你想将其搭成什么样的积木，则全靠你自己了。</p>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "写代码", 
                    "tagLink": "https://api.zhihu.com/topics/19686336"
                }, 
                {
                    "tag": "编程学习", 
                    "tagLink": "https://api.zhihu.com/topics/19593616"
                }
            ], 
            "comments": [
                {
                    "userName": "Zombie110year", 
                    "userLink": "https://www.zhihu.com/people/a1cd971efb1c7c3ca3d28871ce7509b8", 
                    "content": "c语言和c++不要搞混了。", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "已注销", 
                            "userLink": "https://www.zhihu.com/people/722ac173fe8b08eea2016e6089b0ae03", 
                            "content": "这个就是 C 语言", 
                            "likes": 4, 
                            "replyToAuthor": "Zombie110year"
                        }, 
                        {
                            "userName": "Zombie110year", 
                            "userLink": "https://www.zhihu.com/people/a1cd971efb1c7c3ca3d28871ce7509b8", 
                            "content": "<p>抱歉抱歉, 知识水平不够... 我看到有 class 关键字再加上根本不知道 C 语言可以通过函数指针来实现 \"成员函数\" 的功能, 所以看到一半就关了...</p><a class=\"comment_sticker\" href=\"https://pic1.zhimg.com/v2-12562ad40366818a1ea39bcecb2599a0.gif\" data-width=\"\" data-height=\"\">[害羞]</a>", 
                            "likes": 3, 
                            "replyToAuthor": "已注销"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "这方面不妨学 Python，某种结构体的成员函数第一个形参永远是结构体指针类型名为的 self 变量，再加上有规则的命名大约能不必要向结构体节点内加入函数指针，这样实现 C 的轻量对象可以更简单一些。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "上海滩的许先生", 
                    "userLink": "https://www.zhihu.com/people/4e252fe283766c925e749d8d5eddc998", 
                    "content": "封装、继承、多态可以实现吗？", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "赵月半", 
                    "userLink": "https://www.zhihu.com/people/c461a48e4880f4aec98e87a0eb50e70a", 
                    "content": "这个代码有问题 用了全局变量的list指针 这样写只能构造一个链表 应该为每个“成员函数”增加一个this指针参数", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "是在下输了", 
                            "userLink": "https://www.zhihu.com/people/10c592b3ebec17f9537c7ac9f8f49e17", 
                            "content": "list每次调用malloc后都指向一块新的内存了", 
                            "likes": 0, 
                            "replyToAuthor": "赵月半"
                        }, 
                        {
                            "userName": "赵月半", 
                            "userLink": "https://www.zhihu.com/people/c461a48e4880f4aec98e87a0eb50e70a", 
                            "content": "有多个list对象的时候不就把之前的list对象覆盖了？", 
                            "likes": 0, 
                            "replyToAuthor": "是在下输了"
                        }
                    ]
                }, 
                {
                    "userName": "CGD龙哥", 
                    "userLink": "https://www.zhihu.com/people/ee8d86548e66bd43d343eaee9fcdadb4", 
                    "content": "继承，可以参考kobject", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "左江", 
                    "userLink": "https://www.zhihu.com/people/75f451b2dbffbc8592fa7fe255821ed2", 
                    "content": "<p><b>结构体本身还可以嵌套</b></p><p> 需要注意 结构体本身不能嵌套 链表的例子中 成员是结构体指针类型 而不是结构体类型 注意区别</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Certain Y", 
                    "userLink": "https://www.zhihu.com/people/c2027d8e7d2446879899cd113f25ab97", 
                    "content": "我很早就想过，要是用指针调用方法的话，怎么处理那个对象本身的参数。这篇文章里直接用了个全局变量，我就呵呵了", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "maben", 
                    "userLink": "https://www.zhihu.com/people/95fc264dd414c3742cf2f21d1b8eaf23", 
                    "content": "太误导人了", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54282852", 
            "userName": "程序员", 
            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
            "upvote": 3, 
            "title": "C++ 线程安全的单例模式", 
            "content": "<p>废话不多说，常用的代码积淀下来。</p><h2>一、懒汉模式</h2><p>即第一次调用该类实例的时候才产生一个新的该类实例，并在以后仅返回此实例。</p><p>需要用锁，来保证其线程安全性：原因：多个线程可能进入判断是否已经存在实例的if语句，从而non thread safety。</p><p>使用double-check来保证thread safety。但是如果处理大量数据时，该锁才成为严重的性能瓶颈。</p><p>1、静态成员实例的懒汉模式：</p><blockquote>class Singleton<br/>{<br/>private:<br/>static Singleton* m_instance;<br/>Singleton(){}<br/>public:<br/>static Singleton* getInstance();<br/>};<br/><br/>Singleton* Singleton::getInstance()<br/>{<br/>if(NULL == m_instance)<br/>{<br/>Lock();//借用其它类来实现，如boost<br/>if(NULL == m_instance)<br/>{<br/>m_instance = new Singleton;<br/>}<br/>UnLock();<br/>}<br/>return m_instance;<br/>}</blockquote><h2>2、内部静态实例的懒汉模式</h2><p>这里需要注意的是，C++0X以后，要求编译器保证内部静态变量的线程安全性，可以不加锁。但C++ 0X以前，仍需要加锁。</p><blockquote>class SingletonInside<br/>{<br/>private:<br/>SingletonInside(){}<br/>public:<br/>static SingletonInside* getInstance()<br/>{<br/>Lock(); // not needed after C++0x<br/>static SingletonInside instance;<br/>UnLock(); // not needed after C++0x<br/>return instance;<br/>}<br/>};</blockquote><p>二、饿汉模式：即无论是否调用该类的实例，在程序开始时就会产生一个该类的实例，并在以后仅返回此实例。</p><p>由静态初始化实例保证其线程安全性，WHY？因为静态实例初始化在程序开始时进入主函数之前就由主线程以单线程方式完成了初始化，不必担心多线程问题。</p><p>故在性能需求较高时，应使用这种模式，避免频繁的锁争夺。</p><blockquote>class SingletonStatic<br/>{<br/>private:<br/>static const SingletonStatic* m_instance;<br/>SingletonStatic(){}<br/>public:<br/>static const SingletonStatic* getInstance()<br/>{<br/>return m_instance;<br/>}<br/>};<br/><br/>//外部初始化 before invoke main<br/>const SingletonStatic* SingletonStatic::m_instance = new SingletonStatic;</blockquote><p>好了，线程单例模式就讲到这里，还希望对大家有所帮助！</p>", 
            "topic": [
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "编程学习", 
                    "tagLink": "https://api.zhihu.com/topics/19593616"
                }
            ], 
            "comments": [
                {
                    "userName": "何海松", 
                    "userLink": "https://www.zhihu.com/people/31dad42bdcb778cb2738fd3384073faf", 
                    "content": "都已经9012年啦，该学学C++11单例模式的写法了", 
                    "likes": 4, 
                    "childComments": []
                }, 
                {
                    "userName": "夏峥", 
                    "userLink": "https://www.zhihu.com/people/27074de1b47aa42e52204c54c90e61a0", 
                    "content": "double check并不安全，早就不能使用了", 
                    "likes": 3, 
                    "childComments": [
                        {
                            "userName": "WSDAB", 
                            "userLink": "https://www.zhihu.com/people/132369c9dcf0063b73b2443b1c2e4901", 
                            "content": "怎么不安全了，为什么？", 
                            "likes": 0, 
                            "replyToAuthor": "夏峥"
                        }, 
                        {
                            "userName": "zhiqiang", 
                            "userLink": "https://www.zhihu.com/people/82d0de053aedabdd8c2c4a3634b812e4", 
                            "content": "<p>因为编译器和CPU会乱序执行。</p>", 
                            "likes": 4, 
                            "replyToAuthor": "WSDAB"
                        }
                    ]
                }, 
                {
                    "userName": "小纸条", 
                    "userLink": "https://www.zhihu.com/people/38cfdab9d5dd0c2fd95259ab37fd80ad", 
                    "content": "楼上两位说的都对。其实call once就行了。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "「已注销」", 
                    "userLink": "https://www.zhihu.com/people/14aac0cd2e17e129478b1101fe540aa8", 
                    "content": "call_once + forward才是正宗啊", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "sin1080", 
                    "userLink": "https://www.zhihu.com/people/51bea1e489b8383cb7eee1816591f318", 
                    "content": "<p>static才是正宗。。。当然，不用单例才是best practice</p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "左江", 
                    "userLink": "https://www.zhihu.com/people/75f451b2dbffbc8592fa7fe255821ed2", 
                    "content": "<p>基础不牢</p><p>双重if就不谈了</p><p>后面的static实现 return的时候 没有&amp;操作 也是醉了 </p><p>坦白说 这样的疏忽对老手来说有点匪夷所思</p><p></p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54364236", 
            "userName": "程序员", 
            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
            "upvote": 17, 
            "title": "最为全面的C 语言资源大全（下）", 
            "content": "<h2><b>学习，参考和指南</b><br/></h2><p>下面列出了学习 C 编程的资源，或者跟 C 编程相关的有用的东西。</p><p><b>参考</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.securecoding.cert.org/confluence/display/c/SEI%2BCERT%2BC%2BCoding%2BStandard\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SEI CERT C 编码标准</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//c-faq.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C FAQ – comp.lang.c 常见问题</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.etalabs.net/compare_libcs.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU/Linux 下 C/POSIX 标准库实现的比较</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.open-std.org/JTC1/SC22/WG14/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C11 标准草案</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/gnu-c-manual/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU C 参考手册</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//kamalatta.ddnss.de/otherdocs/pikestyle.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Robert Pike 的 C 笔记</a></p><p><b>初级</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//home.netcom.com/~tjensen/ptr/pointers.htm\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">指针教程</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//blog.jobbole.com/25409/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 语言指针 5 分钟教程</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//blog.jobbole.com/44845/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 语言内存地址基础</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//blog.jobbole.com/44639/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 语言函数指针基础</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//blog.jobbole.com/44863/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 语言指针和数组基础</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//nethack4.org/blog/building-c.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">构建 C 项目</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//en.wikibooks.org/wiki/C_Programming\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 编程百科全书</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//gist.github.com/eatonphil/21b3d6569f24ad164365\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">“有趣”的 C 介绍</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.recurse.com/blog/5-learning-c-with-gdb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">用 GDB 学习 C</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//computing.llnl.gov/tutorials/pthreads/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">POSIX 线程编程指南</a> (有点过时，但大部分还是有效和有用的)</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.crasseux.com/books/ctut.pdf\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU C 编程指南</a> (在线 PDF)</p><p><a href=\"https://link.zhihu.com/?target=http%3A//blog.pkh.me/p/20-templating-in-c.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 语言中的模板</a></p><p><b>中级</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//blogs.oracle.com/ksplice/entry/8_gdb_tricks_you_should\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">8 个你应该知道的 GDB 技巧</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//blog.noctua-software.com/c-tricks.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">10 个 C99 技巧</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//jvns.ca/blog/2014/12/14/fun-with-threads/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入并发：尝试互斥锁和原子操作</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.youtube.com/playlist%3Flist%3DPLLX-Q6B8xqZ8n8bwjGdzBJ25X2utwnoEG\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenMP 介绍</a> (视频)</p><p><a href=\"https://link.zhihu.com/?target=https%3A//computing.llnl.gov/tutorials/openMP/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenMP 指南</a> (针对 OpenMP3 标准)</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.tedunangst.com/flak/post/memcpy-vs-memmove\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">memcpy 与 memmove 的比较</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//computing.llnl.gov/tutorials/mpi/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MPI 指南</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//proprogramming.org/some-unknown-features-or-tricks-in-c-language/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 语言中一些未知特性或者技巧</a></p><p><b>f=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//blog.jobbole.com/57822/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">blog.jobbole.com/57822/</span><span class=\"invisible\"></span></a>&#34;&gt;失落的C语言结构体封装艺术</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//marek.vavrusa.com/c/memory/2015/02/20/memory/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 程序员需要了解的内存知识</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">每个 C 程序员需要知道的未定义行为知识</a></p><p><b>高级</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//250bpm.com/blog%3A56\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 中的高级元编程</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//danluu.com/malloc-tutorial/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一个快速教程：如何实现和调试 malloc，free，calloc，和 realloc</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//graphics.stanford.edu/~seander/bithacks.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">位操作技巧</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//kukuruku.co/hub/programming/i-do-not-know-c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">我不懂 C</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//snaipe.me/c/c-smart-pointers/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在 C 语言中实现智能指针</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.greenend.org.uk/rjk/tech/inline.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 中的内联函数</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.chiark.greenend.org.uk/~sgtatham/mp/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 中的自定义控制结构元编程</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.samnip.ps/thought/macro-storage-for-inverse-comma\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">用 C 的宏解决临时内存问题</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.google.com/presentation/d/1h49gY3TSiayLMXYmRMaAEMl05FaJ-Z6jDOWOz3EsqqQ/edit%3Fpli%3D1%23slide%3Did.gaf50702c_0153\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 语言中一些不为人知的角落</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.codeproject.com/Articles/6154/Writing-Efficient-C-and-C-Code-Optimization\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">编写高效的 C 和 C 代码优化</a></p><h2><b>自学教程</b></h2><p><a href=\"https://link.zhihu.com/?target=http%3A//www.cppinstitute.org/%3Fpage_id%3D1487\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 语言认证协会预备课程</a></p><h2><b>实体书</b></h2><p><b>参考资料</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//careferencemanual.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C: A Reference Manual 5E</a> – C99 完全参考手册</p><p><a href=\"https://link.zhihu.com/?target=http%3A//shop.oreilly.com/product/9780596004361.do\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C Pocket Reference</a> – C99 简明参考手册</p><p><a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/The_C_Programming_Language\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The C Programming Language 2E</a> – 第一本 C 语言书籍，由 C 的创造者编写。</p><p><b>初级</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.pearsonhighered.com/educator/product/C-Primer-Plus-6E/9780321928429.page\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C Primer Plus 6E</a> – 一个全面的 C11 编程指南。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//knking.com/books/c2/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C Programming: A Modern Approach</a> – 一本极好的学习 C 基础的书。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//shop.oreilly.com/product/0636920015482.do\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Head First C</a> – 一本“深入浅出”风格的学习 C 的书籍。</p><p><b>中级</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//shop.oreilly.com/product/0636920033677.do\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">21st Century C</a> – 一本非常好的 C 语言书籍，可作为第二选择。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//shop.oreilly.com/product/0636920028000.do\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Understanding and Using C Pointers</a> – 一本深入讨论 C 指针的书。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//shop.oreilly.com/product/0636920026136.do\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ZeroMQ</a> – 一本介绍如何用 C 使用 ZeroMQ 的书。</p><p><b>高级</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//dl.acm.org/citation.cfm%3Fid%3D179241\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expert C Programming: Deep C Secrets</a> – 一本从有趣，深度和娱乐的视角分析 C 内部结构的书籍。</p><p><b>多媒体</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.ffmpeg.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FFMPEG</a> – 一个完整，跨平台的录音，转换和流化视频以及音频的解决方案。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a> 或更高版本，部分是 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//gstreamer.freedesktop.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GStreamer</a> – 一个声音和可视化媒体的框架。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//lodev.org/lodepng/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">lodepng</a> – 一个简单的 PNG 图像解码器和编码器，不需要其他依赖。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>.</p><p><b>网络</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//lionet.info/asn1c/compiler.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">asnlc</a> – 一个把 ASN.1 规范转换为 C 代码的编译器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/zeromq/czmq\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">czmq</a> – 一个 ZeroMQ 的高级绑定。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/adns/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU adns</a> – 一个高级，易用，异步的 DNS 客户端和实用工具。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 及更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/gsasl/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU SASL</a> – 一个简单身份认证和安全层和一些常见 SASL 机制的实现。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 及更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.gnutls.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GnuTLS</a> – 一个安全通信库，实现了 SSL，TLS 和 DTLS。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a> 及更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/google/gumbo-parser\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gumbo-parser</a> – 一个 C99 标准的 HTML5 解析库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/joyent/http-parser\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http-parser</a> – 一个 HTTP 请求回应解析器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.nlnetlabs.nl/projects/ldns/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ldns</a> – 一个简化 DNS 编程的库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//curl.haxx.se/libcurl/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libcurl</a> – 一个客户端的 URL 转换库，支持多种格式。<a href=\"https://link.zhihu.com/?target=http%3A//curl.haxx.se/docs/copyright.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">curl license</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/dinhviethoa/libetpan\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LibEtPan</a> – 一个邮件库，支持 IMAP，SMTP，POP 和 NNTP 网络协议。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//software.schmorp.de/pkg/libev.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libev</a> – 一个事件驱动库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>.</p><p><a href=\"https://link.zhihu.com/?target=http%3A//libevent.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libevent</a> – 一个在网络服务器中事件驱动库的可替代品。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/gss/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libgss</a> – 通用安全服务。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.hughes.com.au/products/libhttpd/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libhttpd</a> – 一个给应用或嵌入式设备添加基本 Web 服务器功能的库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/libidn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libidn</a> – Stringprep，Punycode 和 IDNA 规范的实现。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/libmicrohttpd/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libmicrohttpd</a> – 一个迷你库，可作为其他应用的一部分，让运行 HTTP 服务器变得简单。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//wiki.gnome.org/action/show/Projects/libsoup%3Faction%3Dshow%26redirect%3DLibSoup\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libsoup</a> – 一个 GNOME HTTP 客户端/服务器库，使用了 GObject。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/lpereira/lwan\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">lwan</a> – 一个实验性，可扩展，高性能的 HTTP 服务器。 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/cesanta/mongoose\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mongoose</a> – 基于 C 的嵌入式 Web 服务器。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/nanomsg/nanomsg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">nanomsg</a> – 一个基于 C 的 ZeroMQ 实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/davidmoreno/onion\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">onion</a> – 易于使用的 HTTP 服务器库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.openssl.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenSSL</a> – 一个 SSL 和 TLS 协议的实现，还包括一个加密库。<a href=\"https://link.zhihu.com/?target=https%3A//www.openssl.org/source/license.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Dual Licensed under the OpenSSL License and the SSLeay License</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/osip/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">oSip</a> – 一个基于 C 的 SIO 实现，没有额外的依赖。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPLv2.1</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/awslabs/s2n\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">s2n</a> – 一个 C99 标准的 TLS/SSL 协议的实现，简单，快并且以安全优先。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/silentbicycle/socket99\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">socket99</a> – BSD 套接字 API 的 C99 封装。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AISC\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ISC</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/irungentoo/toxcore\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Tox</a> – 一个通信平台，被设计为 Skype 杀手。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/sinemetu1/twitc\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">twitc</a> – 一个与 Twitter OAuth API 交互的迷你 C 库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><h2><b>网络框架</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/balde/balde\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">balde</a> – 一个基于 GLib 的 C 微框架。 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPLv2.1</a>。</p><h2><b>数值计算</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/b-k/apophenia\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">apophenia</a> – 一个用于统计和科学计算的库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//math-atlas.sourceforge.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ATLAS</a> – 自动调谐线性代数软件。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.netlib.org/blas/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">BLAS</a> – Basic Linear Algebra Subprograms；提供向量和矩阵操作的一系列操作。<a href=\"https://link.zhihu.com/?target=http%3A//www.netlib.org/blas/%23_licensing\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">BLAS license</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.feynarts.de/cuba/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cuba</a> – 一个计算多维的数值积分的库。 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPLv3</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.fftw.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FFTW</a> – The Fastest Fourier Transform in the West；一个高度优化的快速傅立叶变换例程。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//flintlib.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FLINT</a> – Fast Library for Number Theory;一个支持算数，多项式，幂级数和矩阵等。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/glpk/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GLPK</a> – GNU Linear Programming Kit；一个求解大规模线性规划，混合整数规划和其他相关问题。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gmplib.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GMP</a> – GNU Multple Precision Arithmetic Library；一个支持任意精度计算的库。双重许可 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 和 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPLv3</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.multiprecision.org/index.php%3Fprog%3Dmpc%26page%3Dhome\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU MPC</a> – 一个支持复杂数字计算的库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//mpfr.loria.fr/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU MPFR</a> – 一个支持任意精度的浮点数计算库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL3</a> 或更高版本（大多数最近版本），<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a> 或更高版本（2.4.x 之前）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/mpria/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU MPRIA</a> – 一个支持多精度合理区间运算的可扩展数学库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/software/gsl/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GSL</a> – The GNU Scientific Library；一个精确的数值计算库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//sourceforge.net/projects/kissfft/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">KISS FFT</a> – 一个非常快的傅里叶变换库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.netlib.org/lapack/lapacke.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LAPACKE</a> – 一个 <a href=\"https://link.zhihu.com/?target=http%3A//www.netlib.org/lapack/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LAPACK</a> 的 C 接口。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//pari.math.u-bordeaux.fr/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PARI/GP</a> – 一个数论的计算机代数系统，包括 C 编译器。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.mcs.anl.gov/petsc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PETSc</a> – 一系列数据结构和例程，用于计算由偏微分方程建模的应用程序的可扩展并行解。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//slepc.upv.es/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SLEPc</a> – 一个在并行计算机中的解决大型，稀疏特征值问题的软件库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL3</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.yeppp.info/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Yeppp!</a> – 非常快，SIMD 优化的数学库。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><h2><b>并行编程</b></h2><p><a href=\"https://link.zhihu.com/?target=http%3A//repo.hu/projects/cchan/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cchan</a> – 一个线程间通信通道构建的小型库。公共领域。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/concurrencykit/ck\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ck</a> – 并发原语，安全内存回收机制和非阻塞数据结构。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//libmill.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mill</a> – 用 C 写成的 Go 风格并发。<a href=\"https://link.zhihu.com/?target=https%3A//directory.fsf.org/wiki/License%3AX11\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">X11</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.mpich.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MPICH</a> – MPI 的另一种实现。<a href=\"https://link.zhihu.com/?target=http%3A//git.mpich.org/mpich.git/blob_plain/6aab201f58d71fc97f2c044d250389ba86ac1e3c%3A/COPYRIGHT\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MPICH licence</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//openmp.org/wp/about-openmp/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenMP</a> – 一组 C 编译指令，使其易于并行化代码。标准（许可不适用）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/open-mpi/ompi\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenMPI</a> – 一个消息传输接口实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.mcs.anl.gov/petsc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PETSc</a> – 一系列数据结构和例程，用于计算由偏微分方程建模的应用程序的可扩展并行解。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/pth/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pth</a> – 一个非抢占式优先级调度多线程执行的可扩展实现。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或者更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/POSIX_Threads\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pthreads</a> – POSIX 线程库。标准（没有适用的许可）。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//slepc.upv.es/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SLEPc</a> – 一个在并行计算机中的解决大型，稀疏特征值问题的软件库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//tinycthread.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TinyCThread</a> – 一个可扩展，小型的 C11 标准线程 API 实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AZlib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zlib</a>。</p><h2><b>正则表达式</b></h2><p>有些人遇到问题时就会想：“啊，我知道了，我可以使用正则表达式”。于是现在他们有了两个问题。- Jamie Zawinski。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.pcre.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PCRE</a> – 与 Perl 5 正则表达式完全相同的实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/cesanta/slre\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SLRE</a> – Super Light Regular Expression library;一个 Perl 正则表达式语法子集的迷你实现。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/laurikari/tre/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TRE</a> – 一个与 POSIX 一致，充满特色的正则表达式库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><h2><b>序列化</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jmckaskill/c-capnproto\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">c-capnproto</a> – 一个 Cap’n Proto 序列化协议的实现。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/camgunz/cmp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cmp</a> – 一个 <a href=\"https://link.zhihu.com/?target=http%3A//msgpack.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MessagePack</a> 序列化协议的实现。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//avro.apache.org/docs/current/api/c/index.html%23_introduction_to_avro_c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libavro</a> – 一个 Avro 数据序列化系统的 C 实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/ludocode/mpack\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mpack</a> – 另一个 <a href=\"https://link.zhihu.com/?target=http%3A//msgpack.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MessagePack</a> 序列化协议的实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/protobuf-c/protobuf-c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">protobuf-c</a> – 一个 Google Protocol Buffer 的 C 实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/External_Data_Representation\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">xdr</a> – External Data Representation；数据序列化标准。标准（没有可用许可）。</p><h2><b>源码集锦</b></h2><p>下面包含了一些小型源码集合。如果你想要大型且成熟的，看《框架》那一节。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//ccodearchive.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CCAN</a> – 模仿 Perl 的 CPAN，这是一个大的实用 C 代码集合。完整的列表在 <a href=\"https://link.zhihu.com/?target=http%3A//ccodearchive.net/list.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这里</a>。多种许可（所有都是免费软件）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/clibs/clib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">clib</a> – 一个 C 软件包管理器，配备了一堆自己的库。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/gnulib/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gnulib</a> – 通用 GNU 代码的集合。多种许可证，全部免费。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.fefe.de/djb/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libdjb</a> – 做各种事情的库的集合。（显然）公共领域。</p><h2><b>标准库</b></h2><p>下面包括了标准 C 库。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/android/platform_bionic\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Bionic</a> – 谷歌为 Android 开发的 C 标准库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.fefe.de/dietlibc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">dietlibc</a> – 标准 C 库，可能是最小的二进制文件。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/software/libc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">glibc</a> – GNU C 库。一个 C 标准库的实现。 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.musl-libc.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">musl</a> – 标准 C 库，兼容 POSIX 2008 和 C11，为静态链接设计。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><h2><b>字符串处理</b></h2><p><a href=\"https://link.zhihu.com/?target=http%3A//bstring.sourceforge.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bstrlib</a> – 更好的字符串处理库。双重许可，<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a> 或 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//site.icu-project.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ICU</a> – International Components for Unicode；提供 Unicode 支持的库。 <a href=\"https://link.zhihu.com/?target=http%3A//source.icu-project.org/repos/icu/icu/trunk/license.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ICU license</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/libunistring/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libunistring</a> – 处理 Unicode 字符串的 C 库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/libiconv/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libgiconv</a> – 文本转换库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>（库），<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>（编码转换程序）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/antirez/sds\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SDS</a> – Simple Dynamic Strings；一个用简单方式处理 C 字符串的库，而且兼容标准 C 字符串函数。可通过 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/clibs/clib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">clib</a> 使用。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/Ed-von-Schleck/shoco\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">shoco</a> – 一个小型文本压缩器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/Ed-von-Schleck/shoco\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">smaz</a> – 一个高效的字符串压缩库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>.</p><h2><b>测试</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/Tuplanolla/cheat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CHEAT</a> – 一个非常简单的单元测试框架。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//check.sourceforge.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Check</a> – 一个 C 的单元测试框架。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/ThrowTheSwitch/CMock\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CMock</a> – 一个 C 的 mock/stub 生成器。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//cmocka.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cmocka</a> – 一个支持 mock 对象的单元测试框架。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/Snaipe/Criterion\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Criterion</a> – 一个 KISS 风格，非侵入式的 C 测试框架。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//cunit.sourceforge.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CUnit</a> – 另一个 C 的单元测试框架。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/siu/minunit\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">minunit</a> – 极小的 C 单元测试框架。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/ThrowTheSwitch/Unity\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Unity</a> – 一个简单的 C 单元测试框架。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><h2><b>文本编辑器扩展</b></h2><p>在几乎任何像样的程序员文本编辑器支持C之际，有一些扩展，让编辑器更加令人愉快。下面是根据编辑器分目录的。</p><h2><b>Emacs</b></h2><p><a href=\"https://link.zhihu.com/?target=http%3A//cedet.sourceforge.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CEDET</a> – Collection of Emacs Development Environment Tools；给 Emacs 提供一种类似 IDE 的特点，是内建的。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/flycheck/flycheck\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Flycheck</a> – 现代语法检查。对于 C，它可以使用 GCC 或者 Clang 作为后端。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/capitaomorte/yasnippet\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Yasnippet</a> – 一个模板系统，支持 C 的通用代码片段。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><h2><b>Vim</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/scrooloose/syntastic\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Syntastic</a> – 语法检查和语言分析。<a href=\"https://link.zhihu.com/?target=https%3A//github.com/scrooloose/syntastic/blob/master/LICENCE\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Do What The Fuck You Want To license</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//valloric.github.io/YouCompleteMe/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">YouCompleteMe</a> – 一个 Vim 的代码补全引擎。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>。</p><h2><b>工具</b></h2><p>下面是实用的程序列表，包括了帮助你编写和调试 C 代码的库或者编译器，不包括编辑器。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//yanoh.github.io/adlint/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">adlint</a> – 一个静态分析器。支持完全的 C89 标准和部分 C99 标准。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//astyle.sourceforge.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Artistic Style</a> – 一个支持 C 的小而快的自动化代码格式化工具。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/google/sanitizers\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">address-sanitizer</a> – 一个很快的内存错误探测器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//biicode.github.io/biicode/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">biicode</a> – 一个现代的 C 依赖管理器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/ryanmjacobs/c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">c</a> – 在命令行中编译和执行 C 脚本，也支持 shebang。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/RhysU/c99sh\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">c99sh</a> – 用 hash-bang 运行 C 文件。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.cprover.org/cbmc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CBMC</a> – C Bounded Model Checker；一个检查数组边界，指针安全和用户自定义断言的工具。<a href=\"https://link.zhihu.com/?target=https%3A//directory.fsf.org/wiki/License%3ABSD_4Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Original BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/mpv-player/mpv\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cdecl</a> – 一个在线服务，能够把 C 的声明翻译成英文，反向也可以。公共领域。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.flourish.org/cinclude2dot/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cinclude2dot</a> – 在 C 项目中使用 Graphviz 的图像包含依赖。任意的 GNU GPL 版本（根据文件中的要求）</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/complexity/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Complexity</a> – 一个测量 C 代码复杂性的工具。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/ddd/ddd.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DDD</a> – 各种命令行调试器的图形前端。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//fabutil.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">fab</a> – 让每次构建都最优的构建系统。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/software/gdb/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GDB</a> – The GNU Project debugger；一个 C 调试器。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//glade.gnome.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Glade</a> – 一个让 TK+ GUIs 开发更快的 RAD 工具。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//gmsl.sourceforge.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GMSL</a> – GNU Make Standard Library；一个 GNU Make 额外功能的集合。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/global/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU Global</a> – 一个 C 的源码标签工具。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/software/binutils/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gprof</a> – 一个性能分析工具。GNU binutils 的一部分。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.andre-simon.de/index.php\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Highlight</a> – 把源码转化为高亮的格式化文本。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/include-what-you-use/include-what-you-use\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">include-what-you-use</a> – 帮助程序员发现不必要的包含和提供解决他们的建议。基于 LLVM/Clang（只能与它一起工作）。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AIllinoisNCSA\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NCSA</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/indent/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">indent</a> – 自动格式化 C 代码，让它更容易阅读。也能把一种风格的代码转化为另一种。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/make/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Make</a> – 一个控制程序的可执行和其他非代码文件的生成的工具。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本（链接到 GNU 的实现)。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/andlabs/qo\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">qo</a> – 无需分开的配置文件的构建系统。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//rr-project.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">rr</a> – 记录非确定执行来允许可确定调试的调试器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//gittup.org/tup/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">tup</a> – 一个很快，基于文件，跨平台的构建系统。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//dotat.at/prog/unifdef/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">unifdef</a> – 移除 #ifdef 和 #if 指令包含的文本，不会改变文件的其他部分。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a> 和 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.valgrind.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Valgrind</a> – 各种动态分析工具，包括一个内存泄漏检测工具。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><h2><b>实用工具</b></h2><p>下面是包罗万象的目录，主要是那些不适合放在其他目录的东西。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jeremyevans/ape_tag_libs/tree/master/c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ApeTagLibs</a> – APEv2 标签的 C 库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//sourceware.org/binutils/docs/bfd/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bfd</a> – 处理二进制对象文件的库。GNU binutils 的一部分。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/liuliu/ccv\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ccv</a> – C-based/Cached/Core Computer Vision library；现代计算机视觉。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//fakenmc.github.io/cf4ocl/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cf4ocl</a> – The C Framework for OpenCL；一个跨平台面向对象框架，用于开发和用基准问题测试 <a href=\"https://link.zhihu.com/?target=https%3A//www.khronos.org/opencl/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenCL</a> 项目。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL3</a>（库）, <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>（其他代码）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jgm/CommonMark\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CommonMark</a> – CommonMark 规范的 C 实现。<a href=\"https://link.zhihu.com/?target=https%3A//github.com/jgm/CommonMark/blob/master/LICENSE\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Variety of licenses, all free</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/ThrowTheSwitch/CException\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CException</a> – 异常的 C 实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/docopt/docopt.c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">docopt.c</a> – 命令行选项解析器的 C 实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.dyncall.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">dyncall</a> – 另一个外部函数接口库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//leenissen.dk/fann/wp/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FANN</a> – Fast Artifical Neural Network library；一个神经网络的实现。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//pp.ipd.kit.edu/firm/Index\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Firm</a> – 一个 C 库，提供了基于图像中间表示，优化和适合编译器的汇编代码生成。配备了 C 的前端例子，使用相同的许可。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPLv2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//sourceforge.net/projects/gjrand/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gjrand</a> – 随机数字生成的例程库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 或者 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPLv3</a>（用户的选择）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/freeipmi/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU FreeIPMI</a> – 一个带内和带外的 IPMI 实现。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/gperf/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU gperf</a> – 一个完美的哈希函数生成器，提供一系列的字符串。输出 C 代码。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/libffcall/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU Libffcall</a> – 一个构建外部函数接口库的集合。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/gperftools/gperftools\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gperftools</a> – 一系列测量和提高性能的实用工具集合。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/abiggerhammer/hammer\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hammer</a> – 二进制格式的解析器组合。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>.</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.hboehm.info/gc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hans Boehm GC</a> – C 的垃圾收集器？如果我用了不要介意。多种许可证，完全免费。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/adamierymenko/huffandpuff\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">huffandpuff</a> – 一个极小的哈夫曼编码器和解码器。公共领域。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/ndevilla/iniparser\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">iniparser</a> – 一个 .ini 文件的解析器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.canonware.com/jemalloc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">jemalloc</a> – 一个 malloc 实现，着重于段错误的避免和可扩展并发支持。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/watmough/jwHash\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">jwHash</a> – 一个很快的哈希表实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jtsiomb/kdtree\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">kdtree</a> – KD-trees 的简单库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//kitsune-dsu.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Kitsune</a> – 高效，通用的框架，用于软件的动态升级。 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//adtinfo.org/libavl.html/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libavl</a> – 一个包括各种自平衡二叉树的库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/mongodb/libbson\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libbson</a> – BSON 实用库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//libcello.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libCello</a> – 引入高级语言给 C 的库。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//libcox.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libcox</a> – 一个运行跨平台系统调用和跨系统标准工具的库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/atgreen/libffi\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libffi</a> – 轻量级的外部函数接口库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//libgit2.github.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libgit2</a> – Git 的纯 C 实现。<a href=\"https://link.zhihu.com/?target=https%3A//github.com/libgit2/libgit2/blob/master/COPYING\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2 only, with a linking exception</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/libimobiledevice/libimobiledevice\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libimobiledevice</a> – 一个跨平台协议库，用于与 iThings 通信。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPLv2.1</a> 或更高版本（库），<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 或更高版本（工具）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/mpv-player/mpv\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libmpv</a> – 音乐播放库。编译的时候加入 ./waf configure --disable-cplayer --enable-libmpv-shared 来避免生成音乐播放器。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/nfc-tools/libnfc\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libnfc</a> – 一个平台独立的 NFC 库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/lgpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//facebook.github.io/libphenom/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libPhenom</a> – 事件框架，用于构建高扩展和高性能系统。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/andrewrk/libsoundio\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libsoundio</a> – 跨平台，实时音频输入输出的库，有很多种后端。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/vstakhov/libucl\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libucl</a> – 通用配置库解析器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//notabug.org/koz.ross/libudp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libudp</a> – 一个统一设计模式的 C 实现。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/libuv/libuv\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libuv</a> – 跨平台异步 I/O。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.pyyaml.org/wiki/LibYAML\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libYAML</a> – 一个 YAML 1.1 解析器和发射器。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.oberhumer.com/opensource/lzo/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">lzo</a> – 一个很快的数据压缩库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/orangeduck/mpc\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mpc</a> – 解析器组合库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/ncurses/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ncurses</a> – 彩色的终端 UI 库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/riolet/nope.c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">nope.c</a> – 一个基于 C 语言，超级轻量级的软件平台，用于可扩展服务端和网络应用的开发（想想 C 程序员的 nodejs）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/cloudwu/pbc\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pbc</a> – 一个协议缓冲库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/alanxz/rabbitmq-c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">rabbitmq-c</a> – <a href=\"https://link.zhihu.com/?target=http%3A//www.rabbitmq.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">RabbitMQ</a> 的客户端库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.colm.net/open-source/ragel/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Ragel</a> – 为编译C的状态机的DSL。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//troydhanson.github.io/uthash/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">uthash</a> – 哈希表实现，允许已经存在的数据结构很容易地存在哈希表里面。<a href=\"https://link.zhihu.com/?target=http%3A//troydhanson.github.io/uthash/license.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">1-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/eatonphil/Viola\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Viola</a> – libCello 的简化版本。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/madler/zlib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zlib</a> – 一个相当漂亮却精致不张扬的压缩库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><h2><b>XML</b></h2><p>“XML 是垃圾。真的，没有任何借口。XML 对人类不友好的，甚至对于电脑来说也是一场灾难。根本就没有这个可怕的垃圾存在的理由” -Linus Torvalds</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.libexpat.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a> – 面向流的 XML 解析器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//xmlsoft.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libxml2</a> – 一个符合标准，轻量级的 XML 解析器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.msweet.org/projects.php%3FZ3\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mini-xml</a> – 小型 XML 读写库。没有 C 标准库的依赖。<a href=\"https://link.zhihu.com/?target=http%3A//svn.msweet.org/mxml/trunk/COPYING\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1 with static linking exception</a>。</p>", 
            "topic": [
                {
                    "tag": "C 语言入门", 
                    "tagLink": "https://api.zhihu.com/topics/19691553"
                }, 
                {
                    "tag": "编程学习", 
                    "tagLink": "https://api.zhihu.com/topics/19593616"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": [
                {
                    "userName": "阿辉", 
                    "userLink": "https://www.zhihu.com/people/7e9f1d38cd0362d6a0390d749fa0bfe9", 
                    "content": "总结一下，c语言入门到入坟。", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54363710", 
            "userName": "程序员", 
            "userLink": "https://www.zhihu.com/people/615af3deee57d4be80caa75ce00c72ec", 
            "upvote": 14, 
            "title": "最为全面的C 语言资源大全（上）", 
            "content": "<p>koz.ross 维护的一个 C 语言资源列表，包括了：构建系统、编译器、数据库、加密、初中高的教程/指南、书籍、库等等。</p><h2>构建系统</h2><p>下面是一些 C 项目的自动化构建和测试工具。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//nethack4.org/projects/aimake/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">aimake</a> – 一个被设计来避免复杂配置的构建工具。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/autoconf/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Autoconf</a> – 一个可扩展的 M4 宏指令包，提供命令行脚本来自动配置软件源码包，是 Autotools 的一部分。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/automake/automake.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Automake</a> – 一个自动生成符合 GNU 代码标准的 Makefile.in 文件的工具。需要与 Autoconf 配合使用，它也是 Autotools 的一部分。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.perforce.com/resources/documentation/jam\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Jam</a> – 一个构建系统，它被设计的比make更加易用。隐式地理解 C 的构建规则。<a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Perforce_Jam%23License\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Jam License</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/libtool/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Libtool</a> – 一个通用库支持脚本，是 Autotools 的一部分。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//mesonbuild.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Meson</a> – 一个非常快，用户友好的构建系统，基于 Ninja。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>.</p><h2>编译器</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//clang.llvm.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Clang</a> – 一个基于 LLVM 的 C 的编译器，支持 C11 标准。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AIllinoisNCSA\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NCSA</a>.</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/AbsInt/CompCert\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CompCert</a> – 一个经过充分验证的 C 编译器。支持几乎所有的 C89 标准。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gcc.gnu.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GCC</a> – 在它的编译器集合中提供了 C 编译器。支持 C11 和 OpenMP 的标准。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//pcc.ludd.ltu.se/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PCC</a> – 一个值得尊敬的 C 编译器，支持 C99 标准。<a href=\"https://link.zhihu.com/?target=http%3A//pcc.ludd.ltu.se/licenses/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Various licenses</a>，完全免费。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//bellard.org/tcc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TCC</a> – 一个迷你，速度快的 C 编译器，支持 C99（除了复杂的类型）。 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a></p><h2>加密</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//www.gnutls.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GnuTLS</a> – 一个安全通信库，实现了 SSL，TLS 和 DTLS。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/libgcrypt/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libgcrypt</a> – 一个通用的密码库，支持多种加密方法。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>（代码），<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a> 或更高版本（说明书和工具）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.openssl.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenSSL</a> – 一个 SSL 和 TLS 协议的实现，还包括一个加密库。<a href=\"https://link.zhihu.com/?target=https%3A//www.openssl.org/source/license.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Dual Licensed under the OpenSSL License and the SSLeay License</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jedisct1/libsodium\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libsodium</a> – 一个现代，易用的加密库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/libtom/libtomcrypt\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libtomcrypt</a> – 一个相当全面，模块化和可移植的工具集。公开领域。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//tls.mbed.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mbed TLS</a> – 一个 C 实现的加密库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><h2>数据库</h2><p>下面列出了基于 C API 的数据库和数据存储</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.oracle.com/us/products/database/berkeley-db/overview/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">BerkeleyDB</a> – 一个高性能的嵌入式键值对数据库。<a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/licenses/agpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU AGPLv3</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/redis/hiredis\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hiredis</a> – 一个极简的 Redis 客户端。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//symas.com/mdb/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LMDB</a> – 一个极快，极简的嵌入式键值对数据存储系统。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AOpenLDAPv2.7\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">newOpenLDAP</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//mariadb.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MariaDB</a> – 一个强壮，可扩展和可靠的 SQL 服务器，设计来作为 MySQL 的替代品。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/mongodb/mongo-c-driver\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mongo-c-driver</a> – 一个高性能的 MongoDB 客户端。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>.</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.postgresql.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PostgreSQL</a> – 一个强大的对象关系数据库系统。<a href=\"https://link.zhihu.com/?target=http%3A//opensource.org/licenses/postgresql\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PostgreSQL licence</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/software/recutils/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">recutils</a> – 一个工具和 C 库的集合，用于访问可编辑，纯文本的名为 recfiles 的数据库文件。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//redis.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Redis</a> – 一个先进的键值对存储系统。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/pmwkaa/sophia\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sophia</a> – 一个现代，可嵌入的键值对数据库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.sqlite.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SQLite</a> – 一个自包含，无服务器，零配置，支持事务的 SQL 数据库引擎，包括 C 接口。公开领域。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//unqlite.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">UnQLite</a> – 一个自包含，无服务器，零配置，支持事务的 NoSQL 数据库引擎，包括 C 接口。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><h2>文档生成</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//www.gedanken.org.uk/software/cxref/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cxref</a> – 生成 C 程序的文档，支持 LaTeX，HTML， RTF 或者 SGML 的格式。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//hplgit.github.io/doconce/doc/web/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DocOnce</a> – 一种朴素的标签标记语言，可以用来生成多种格式的文档。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>.</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.stack.nl/~dimitri/doxygen/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Doxygen</a> – 一个事实上的标准工具，用于从注释的代码中生成 C 文档。能够生成多种格式的文档。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.gtk.org/gtk-doc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GTK-Doc</a> – 一个从注释的代码中生成 C 文档的工具，支持 Autotools <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>（代码）, <a href=\"https://link.zhihu.com/?target=https%3A//www.gnu.org/licenses/old-licenses/fdl-1.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU FDL1.1</a>。</p><h2>编辑器</h2><p>这些是特别精致，IDE 类型的编辑器。如果你想要一个程序员的文本编辑器，看别的地方。此外，不管你选择哪一款编辑器，它都支持 C。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//anjuta.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Anjuta DevStudio</a> – GNOME IDE。 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.codeblocks.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Code::Blocks</a> – 一个可扩展，可配置的 IDE，支持 C。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.codelite.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CodeLite</a> – 一个跨平台的 IDE。 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.eclipse.org/ide/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Eclipse</a> – 一个用java写成的 IDE。 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AEPLv1.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">EPL</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.geany.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Geany</a> – 一个很小很快的 IDE。 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>及更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.kdevelop.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">KDevelop</a> – KDE IDE. <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><h2>环境</h2><p>下面列出了被设计来引领 Windows 进入支持 C 的 21 世纪的技术。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//cygwin.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cygwin</a> – 被设计用于在 Windows 下模拟 POSIX 兼容环境。<a href=\"https://link.zhihu.com/?target=https%3A//cygwin.com/licensing.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Various licenses, all free</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//mingw-w64.yaxm.org/doku.php/start\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MinGW-w64</a> – 一个 Windows 下极简的 C 开发环境，支持 64 位。<a href=\"https://link.zhihu.com/?target=http%3A//mingw.org/license\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Various licenses, all free</a>。</p><h2>框架</h2><p>这一节包括提供数据结构的大型库和你所期待“现代”的标准库。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//apr.apache.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">APR</a> – Apache Portable Runtime；另一个跨平台的实用函数库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AApache2.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache2.0</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/fragglet/c-algorithms\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C Algorithms</a> – 一个常用算法和数据结构的集合。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.eso.org/sci/software/cpl/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CPL</a> – The Common Pipeline Library；一系列详尽，高效和强壮的软件工具包。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.enlightenment.org/p.php%3Fp%3Dabout/efl\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">EFL</a> – 一个大型实用数据结构和函数的的集合。多种许可证，完全免费。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//wiki.gnome.org/Projects/GLib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GLib</a> – 一个便携，高效和强大的实用函数和数据结构库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//developer.gnome.org/gio/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GIO</a> – 一个现代和易用的 VFS API。[GNU LGPL2.1]。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//developer.gnome.org/gobject/stable/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GObject</a> – 一个 C 的面向对象系统和对象模型。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/keybuk/libnih\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libnih</a> – 一个轻量级的 C 函数和数据结构库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.koanlogic.com/libu/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libU</a> – 一个提供基本实用函数的迷你库，包括内存分配，字符串处理和日志功能。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.mission-base.com/peter/source/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PBL</a> – 一个包括实用函数，特色数据结构等的大型库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>及更高版本（库），<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>及更高版本（测试代码）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/wolkykim/qlibc\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">qlibc</a> – 一个简单且强大的 C 库，当我们想要小且轻的库时，可作为 Glib 的替代品。<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wolkykim/qlibc/blob/master/LICENSE\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">qLib license</a> (类似于 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>).</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/nothings/stb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">stb</a> – 一系列单文件 C 库。公共领域。</p><h2>游戏编程</h2><h2>引擎</h2><p>这些作为 C 游戏编程代码的例子。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/orangeduck/Corange\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Corange</a> – 一个纯 C 的游戏引擎。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//icculus.org/twilight/darkplaces/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Darkplaces</a> – 一个 Quake2 引擎的修改版本。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/ioquake/ioq3\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ioquake3</a> – Quake3 引擎，终于免费啦。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//bitbucket.org/orx/orx\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Orx</a> – 一个便携，轻量级，插件化，数据驱动，面向 2D 的游戏引擎。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AZlib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zlib</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/id-Software/Quake-2\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Quake2</a> – Quake2 引擎。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/zturtleman/spearmint\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Spearmint</a> – 一个为 FPS 游戏设计的引擎。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>及更高版本。</p><h2>资源</h2><p>这些是排序过的对游戏编程有用的库。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//liballeg.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Allegro</a> – 一个跨平台，视频游戏开发和多媒体库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AZlib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zlib</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/slembcke/Chipmunk2D\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Chipmunk2D</a> – 一个快且轻量级的 2D 游戏物理库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.sfml-dev.org/download/csfml/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CSFML</a> – 一个用 C 封装的 <a href=\"https://link.zhihu.com/?target=http%3A//www.sfml-dev.org/index.php\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SFML</a>。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AZlib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zlib</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/dcnieho/FreeGLUT\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeGLUT</a> – 一个替代性的 OpenGL 实用工具包。允许用 OpenGL 上下文创建和管理窗口。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AX11\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">X11</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.glfw.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GLFW</a> – 一个使用 OpenGL 上下文创建窗口的多平台库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AZlib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zlib</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/timonwong/libao\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libao</a> – 一个有多种输出的跨平台音频库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/gpl-2.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL2.1</a>及更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/libretro/RetroArch\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">RetroArch</a> – <a href=\"https://link.zhihu.com/?target=http%3A//www.libretro.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libretro</a> 的参考前端。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.libsdl.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SDL</a> – 一个跨平台库，通过 OpenGL 提供音频，键盘，鼠标，操纵杆和图形硬件的底层访问。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AZlib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zlib</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.libsdl.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SDL2</a>– 一个跨平台库，通过 OpenGL 提供音频，键盘，鼠标，操纵杆和图形硬件的底层访问。这是最新版本。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AZlib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zlib</a>。</p><h2>通用编程</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/attractivechaos/klib\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">klib</a> – 小且轻量级的常用算法和数据结构实现。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><h2>图像</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//cairographics.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cairo</a> – 一个 2D 图像库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a> 或者 <a href=\"https://link.zhihu.com/?target=https%3A//directory.fsf.org/wiki/License%3AMPLv1.1\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MPLv1.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/rib/cogl-web/wiki\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cogl</a> – 一个 GPU 图像和实用 API。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>（依赖使用 <a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a> 许可，库使用 <a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LGPLv2.1</a> 许可）。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//blogs.gnome.org/clutter/get-it/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Clutter</a> – 一个基于 OpenGL 的 UI 库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/prideout/heman\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">heman</a> – 一个迷你图像实用工具库，处理高度图，法线图，距离场等。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/cacalabs/libcaca\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libcaca</a> – 一个基于终端接口的 ASCII 渲染器。<a href=\"https://link.zhihu.com/?target=http%3A//www.wtfpl.net/txt/copying/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">WTFPLv2</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//pngquant.org/lib/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libimagequant</a> – 小且轻量级的库，用于高质量的从 RGBA 图像到 8 位像素图的转换。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki%3Ftitle%3DLicense%3AFreeBSD\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FreeBSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//libjpeg-turbo.virtualgl.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libjpeg-turbo</a> – 一个更快的读写 JPEG 文件库。<a href=\"https://link.zhihu.com/?target=http%3A//www.libjpeg-turbo.org/About/License\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Various licences</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//http//www.libpng.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libpng</a> – 官方 PNG 参考库。<a href=\"https://link.zhihu.com/?target=http%3A//www.libpng.org/pub/png/src/libpng-LICENSE.txt\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libpng license</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//gnu.org/software/libxmi/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libxmi</a> – 一个光栅化 2D 位图的函数库。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/gpl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU GPL3</a> 或更高版本。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/mozilla/mozjpeg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mozjpeg</a> – 一个提升 JPEG 图像质量的编码器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3ABSD_3Clause\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3-clause BSD</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.opengl.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenGL</a> – 一个高性能图像的工业标准，提供了原生 C语言 绑定。<a href=\"https://link.zhihu.com/?target=http%3A//www.sgi.com/tech/opengl/%3F/license.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Various licenses</a>。</p><h2>图像用户接口</h2><p>这些具体来说就是<a href=\"https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Widget_toolkit\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">控件工具包</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.gtk.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GTK+</a> – 一个跨平台的控件工具包。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//webserver2.tecgraf.puc-rio.br/iup/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">IUP</a> – 另一个跨平台的控件工具包。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.tcl.tk/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Tk</a> – 一个基本控件工具包，Tcl/Tk 的一部分。<a href=\"https://link.zhihu.com/?target=http%3A//www.tcl.tk/software/tcltk/license.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Tcl/Tk License</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//xforms-toolkit.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">XForms Toolkit</a> – 一个为 XWindow 设计的控件工具包。<a href=\"https://link.zhihu.com/?target=http%3A//www.gnu.org/licenses/old-licenses/lgpl-2.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GNU LGPL2.1</a>。</p><h2>JSON</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//www.digip.org/jansson/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Jansson</a> – 一个编码，解码和处理 JSON 的 C 库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//zserge.com/jsmn.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">jsmn</a> – 一个极简的 JSON 解析器。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/json-c/json-c/wiki\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">json-c</a> – 一个处理 JSON 的库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AExpat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Expat</a>。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/netmail-open/wjelement/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">WJElement</a> – 高级 JSON 处理库，支持 JSON Schema。任意版本的 LGPL。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//lloyd.github.io/yajl/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">YAJL</a> – 一个很快的 JSON 流解析 C 库。<a href=\"https://link.zhihu.com/?target=http%3A//directory.fsf.org/wiki/License%3AISC\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ISC</a>。</p>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "资源", 
                    "tagLink": "https://api.zhihu.com/topics/19561319"
                }, 
                {
                    "tag": "编程学习", 
                    "tagLink": "https://api.zhihu.com/topics/19593616"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54278100", 
            "userName": "程序员基础知识", 
            "userLink": "https://www.zhihu.com/people/fb378aca097e7e0e88eff8d19e99ab8e", 
            "upvote": 4, 
            "title": "C语言入门教程-(6)运算符", 
            "content": "<h2><b>1.运算符概述</b></h2><p>运算符是一种编译器执行特定的数学或逻辑操作的符号。C语言提供了以下类型的运算符：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>条件运算符</li><li>其他运算符</li></ul><h2><b>2.算术运算符</b></h2><p>算术运算符分为单目运算符和双目运算符，单目运算符表示只需要一个操作数，双目运算符需要两个操作数。</p><h2><b>2.1 双目算术运算符</b></h2><ul><li>1）+ ：加法，把两个操作数相加</li><li>2）- ：减法，从第一个操作数中减去第二个操作数</li><li>3）* ：乘法，把两个操作数相乘</li><li>4）/ ：除法，第一个操作数除以第二个操作数</li><li>5）% ：求模（取余），第一个操作数除以第二个操作数所得余数</li></ul><p>双目运算符中，C语言中的加号、减号与数学中的一样。乘号、除号因为ASCII符号中没有与数学中相对应的符号，所以使用星号表示乘号，使用斜线表示除号。C语言中增加了一个求模运算符，是用来取余的。需要注意的是，求模运算符的两个操作数必须是整型。</p><p>【实例6.1】加减乘除以及取模运算</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">21</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">c</span><span class=\"p\">;</span>\n    <span class=\"kt\">float</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"mf\">2.5</span><span class=\"p\">;</span>\n    <span class=\"kt\">double</span> <span class=\"n\">e</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">21</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">;</span>\n\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a + b = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">-</span> <span class=\"n\">b</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a - b = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">*</span> <span class=\"n\">b</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a * b = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">/</span> <span class=\"n\">b</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a / b = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">/</span> <span class=\"n\">d</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a / d = %lf</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">e</span><span class=\"p\">);</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">%</span> <span class=\"n\">b</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a %% b = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">%</span> <span class=\"n\">g</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a %% g = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">f</span> <span class=\"o\">%</span> <span class=\"n\">b</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; f %% b = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">f</span> <span class=\"o\">%</span> <span class=\"n\">g</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; f %% g = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><p>执行以上程序，输出结果为：<br/> a + b = 31<br/> a - b = 11<br/> a * b = 210<br/> a / b = 2<br/> a / d = 8.400000<br/> a % b = 1<br/> a % g = 1<br/> f % b = -1<br/> f % g = -1</p><p>实例解析：<br/>加、减与数学中的一样，其中需要说明的是除法以及取模运算。C语言中的除法运算，不同类型的除数和被除数会导致不同类型的运算结果。一种情况是，当除数和被除数都是整数时，运算结果也是整数。当不能整除时，就直接舍弃小数部分，只保留整数部分。另一种情况是，一旦除数和被除数中有一个是小数，那么运算结果也是小数，并且是double类型的小数。C语言中的取余运算，就是求相除后的余数。取余运算中%的两边都必须是整数，不能出现小数，否则会报错。余数可以是正数也可以是负数，由%左边的整数决定：如果%左边是正数，那么余数也是正数；如果%左边是负数，那么余数也是负数。</p><h2><b>2.2 单目算术运算符</b></h2><ul><li>1）- ：取负，把操作数乘以-1</li><li>2）++：自增运算符，把操作数增加1</li><li>3）--：自减运算符，把操作数减少1</li></ul><p>单目运算符中，只需要一个操作数。取负操作符将正操作数设置为负数，负操作数设置为正数。自增运算符使得变量的值增加1，自减运算符使得变量的值减少1。比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\n<span class=\"n\">j</span><span class=\"o\">--</span><span class=\"p\">;</span></code></pre></div><p>变量i的值增加1，变量j的值减少1，相当于：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">j</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span></code></pre></div><p>自增运算符和自减运算符的运算对象只能是变量，不能是常量或者表达式，否则将会报错。比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"mi\">1</span><span class=\"o\">++</span><span class=\"p\">;</span><span class=\"c1\">//报错\n</span><span class=\"c1\"></span><span class=\"o\">--</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"o\">//</span><span class=\"err\">报错</span></code></pre></div><p>自增运算符和自减运算符分为两种方式：一种是在变量前面，称为前缀模式；一种是在变量后面，称为后缀模式。下面介绍一下两种方式的区别：</p><ul><li>前缀模式，先执行变量的自增或者自减操作，再将得到的结果参与表达式运算。</li><li>后缀模式，先将变量参与表达式运算，再执行变量的自增或者自减操作。</li></ul><p>前缀模式，也被理解为先运算后赋值，比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">;</span></code></pre></div><p>执行上面语句，i和j的值都是2。先是变量i自增，i的值变为2，再将结果2赋值给j。</p><p>后缀模式，也被理解为先赋值后运算，比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">;</span></code></pre></div><p>执行上面语句，i的值是2，j的值是1。先是变量i赋值给j，这个时候i还没有自增操作，i的值还是1，所以j的值是1。赋值后，i再自增，i的值变为2。</p><p>【实例6.2】前缀模式和后缀模式</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">c</span><span class=\"p\">;</span>\n\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">++</span><span class=\"p\">;</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;先赋值后运算：</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; c 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">);</span>\n\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"c1\">//重新赋值为10\n</span><span class=\"c1\"></span>    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">--</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; c 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">);</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;先运算后赋值：</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"o\">++</span><span class=\"n\">a</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; c 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">);</span>\n\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"o\">--</span><span class=\"n\">a</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; c 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34; a 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">);</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>先赋值后运算：<br/> c 的值是 10<br/> a 的值是 11<br/> c 的值是 10<br/> a 的值是 9<br/>先运算后赋值：<br/> c 的值是 11<br/> a 的值是 11<br/> c 的值是 9<br/> a 的值是 9</p><p>实例解析：<br/>++ 在变量前面和后面是有区别的：++ 在前面叫做前自增。前自增先进行自增运算，再进行其他操作。++ 在后面叫做后自增。后自增先进行其他操作，再进行自增运算。<br/>对于，c = a++; a 的值不会立马加 1，而是先把 a 原来的值（也就是10）交给 c，然后再加 1。a 原来的值为 10，所以 c 的值也就为 10。而 a 经过自增，最终值为 11。<br/>对于，c = a--; a 的值不会立马减 1，而是先把 a 原来的值（也就是10）交给 c，然后再减 1。a 原来的值为 10，所以 c 的值也就为 10。而 a 经过自减，最终值为 9。<br/>对于，c = ++a，先执行 ++a，结果为 11，再将 11 赋值给 c，所以 c 的最终值为11。而 a 经过自增，最终的值也为 11。<br/>对于，c = --a，先执行 --a，结果为 9，再将 9 赋值给 c，所以 c 的最终值为9。而 a 经过自减，最终的值也为 9。</p><h2><b>2.3 算术运算符的优先级</b></h2><p>在数学运算中，运算符是有优先级的，C语言中的运算符也有优先级。算术运算符的优先级：单目算术运算符(-、++、--) &gt; 乘号(*)、除号(/)、求模(%) &gt; 加号(+)、减号(-)。比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"mi\">3</span><span class=\"p\">;</span></code></pre></div><p>根据优先级，将会先计算2 * 3，再将得到的结果6和1相加，得到7，赋值给变量a。</p><p>当表达式中有多个相同优先级的运算符时，按照从左到右的顺序运算。比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"mi\">3</span> <span class=\"o\">/</span> <span class=\"mi\">3</span><span class=\"p\">;</span></code></pre></div><p>乘号(*)、除号(/)优先级相同，按照从左到右的顺序运算，先计算2 * 3，将结果6 / 3，得到结果2和1相加，得到3，赋值给变量a。</p><p>如果需要改变表达式的运算顺序，我们还可以使用圆括号。比如：</p><div class=\"highlight\"><pre><code class=\"language-text\">int a = (1 + 2) * 3 / 3;\n</code></pre></div><p>先计算圆括号内的1 + 2，得到的结果3再去运算，最后得到3，赋值给变量a。</p><h2><b>3.关系运算符</b></h2><ul><li>1）==：检查两个操作数的值是否相等，如果相等则条件为真。    </li><li>2）!=：检查两个操作数的值是否相等，如果不相等则条件为真。    </li><li>3）&gt; ：检查左操作数的值是否大于右操作数的值，如果是则条件为真。</li><li>4）&lt; ：检查左操作数的值是否小于右操作数的值，如果是则条件为真。</li><li>5）&gt;=：检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</li><li>6）&lt;=：检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。    </li></ul><p>关系运算符只有两种结果：true或者false。true代表条件为真，false代表条件为假。C语言中，一般非0值代表true，0代表false。比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"c1\">//条件为假，结果是false。\n</span><span class=\"c1\"></span><span class=\"mi\">1</span> <span class=\"o\">!=</span> <span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"c1\">//条件为真，结果是true。\n</span><span class=\"c1\"></span><span class=\"mi\">1</span> <span class=\"o\">&gt;</span> <span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"c1\">//条件为假，结果是false。\n</span><span class=\"c1\"></span><span class=\"mi\">1</span> <span class=\"o\">&lt;</span> <span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"c1\">//条件为真，结果是true。\n</span><span class=\"c1\"></span><span class=\"mi\">1</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"c1\">//条件为假，结果是false。\n</span><span class=\"c1\"></span><span class=\"mi\">1</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"o\">//</span><span class=\"err\">条件为真，结果是</span><span class=\"nb\">true</span><span class=\"err\">。</span></code></pre></div><h2>4.逻辑运算符</h2><ul><li>1）! ：单目运算符，称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</li><li>2）&amp;&amp;：双目运算符，称为逻辑与运算符。如果两个操作数都非零，则条件为真。</li><li>3）||：双目运算符，称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</li></ul><p>逻辑运算符与数学上有相同之处。逻辑运算符和关系运算符一样，也只有两种结果：true或者false。逻辑运算符可以将多个关系表达式的结果合并起来。我们要判断变量i是否在0和100之间，不能直接表示成：0 =&lt; i =&lt; 100。需要使用逻辑运算符来表示，比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">i</span> <span class=\"o\">=&lt;</span> <span class=\"mi\">100</span></code></pre></div><p>如果变量i在0和100之间，则结果为true，否则为false。</p><p>逻辑运算符也是有优先级的，逻辑非运算符(!)&gt;逻辑与运算符(&amp;&amp;)&gt;逻辑或运算符(||)。</p><p>【实例6.3】逻辑运算符</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;!a = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">!</span><span class=\"n\">a</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;!b = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">!</span><span class=\"n\">b</span><span class=\"p\">);</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;a&amp;&amp;b = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">b</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;a||b = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">||</span> <span class=\"n\">b</span><span class=\"p\">);</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;a&amp;&amp;b||c&amp;&amp;d = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">b</span> <span class=\"o\">||</span> <span class=\"n\">c</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">d</span><span class=\"p\">);</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;a&amp;&amp;!b||c&amp;&amp;d = %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">b</span> <span class=\"o\">||</span> <span class=\"n\">c</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">d</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>!a = 1<br/>!b = 0<br/>a&amp;&amp;b = 0<br/>a||b = 1<br/>a&amp;&amp;b||c&amp;&amp;d = 1<br/>a&amp;&amp;!b||c&amp;&amp;d = 1</p><p>实例解析：<br/>在使用printf()函数以整数形式输出逻辑结果时，1代表true，0代表false。!a代表a取反，0取反结果为true，所以输出1。那么!b取反则输出0。a&amp;&amp;b代表a和b做与运算，0和1做与运算，结果为false，则输出0。a||b 代表a和b做或运算，0和1做或运算，结果为true，则输出1。a&amp;&amp;b || c&amp;&amp;d，根据优先级，我们先运算a&amp;&amp;b和c&amp;&amp;d，得到的结果是false和true，false和true进行或运算，结果还是true，所以输出1。a &amp;&amp; !b || c&amp;&amp;d，根据优先级，我们先运算!b，得到的结果是false，然后运算a和false以及c&amp;&amp;d，得到的结果是，false和true进行或运算，结果是true，所以输出1。</p><h2><b>5.位运算符</b></h2><p>位运算符作用于位，并逐位执行操作，也就是二进制的运算。</p><ul><li>1）~ ：单目运算符，按二进制位进行取反运算。</li><li>2）&amp; ：双目运算符，按二进制位进行与运算。</li><li>3）| ：双目运算符，按二进制位进行或运算。</li><li>4）^ ：双目运算符，按二进制位进行异或运算。</li><li>5）&lt;&lt;：双目运算符，二进制左移运算符。</li><li>6）&gt;&gt;：双目运算符，二进制右移运算符。</li></ul><p>位运算符不能用于float、double等类型，只能用于整数类型。</p><p>【实例6.4】位运算符</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">50</span><span class=\"p\">;</span>    <span class=\"cm\">/* 50 = 0011 0010 */</span>\n    <span class=\"kt\">int</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">19</span><span class=\"p\">;</span>    <span class=\"cm\">/* 19 = 0001 0011 */</span>\n    <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">&amp;</span> <span class=\"n\">b</span><span class=\"p\">;</span>       <span class=\"cm\">/* 18 = 0001 0010 */</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;a &amp; b 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">|</span> <span class=\"n\">b</span><span class=\"p\">;</span>       <span class=\"cm\">/* 51 = 0011 0011 */</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;a | b 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">^</span> <span class=\"n\">b</span><span class=\"p\">;</span>       <span class=\"cm\">/* 33 = 0010 0001 */</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;a ^ b 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"o\">~</span><span class=\"n\">a</span><span class=\"p\">;</span>          <span class=\"cm\">/* -51 = 1100 1100 */</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;~a 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">2</span><span class=\"p\">;</span>     <span class=\"cm\">/* 200 = 1100 1000 */</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;a &lt;&lt; 2 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">2</span><span class=\"p\">;</span>     <span class=\"cm\">/* 12 = 0000 1100 */</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;a &gt;&gt; 2 的值是 %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>a &amp; b 的值是 18<br/>a | b 的值是 51<br/>a ^ b 的值是 33<br/>~a 的值是 -51<br/>a &lt;&lt; 2 的值是 200<br/>a &gt;&gt; 2 的值是 12</p><p>实例解析：<br/>A = 50，B = 19，现在以二进制格式表示，它们如下所示：<br/>A = 0011 0010<br/>B = 0001 0011<br/>然后按照二进制位进行相应运算得到结果值。二进制左移运算符，运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0；二进制右移运算符，运算对象的的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p><h2><b>6.赋值运算符</b></h2><p>C语言中，可以将赋值运算符分为两类：简单赋值运算符和复合赋值运算符。</p><h2><b>2.1 简单赋值运算符</b></h2><p>简单赋值运算符就是&#34;=&#34;，一般语法格式：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"err\">变量</span> <span class=\"o\">=</span> <span class=\"err\">表达式</span><span class=\"p\">;</span></code></pre></div><p>赋值运算符&#34;=&#34;和数学表达式中的等号&#34;=&#34;的意义是不同的。前面我们就多次用到了赋值运算符&#34;=&#34;。&#34;=&#34;的作用是把结果赋值给变量，所以赋值运算符的左边必须是变量，赋值运算符从右向左的顺序计算。比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> </code></pre></div><p>以上语句，先将1赋值给b，再将变量b赋值给变量a。</p><p>赋值也是一种运算，我们可以放在表达式中。比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">);</span></code></pre></div><p>以上语句，先将1赋值给b和将2赋值给c，再将变量b和c的值相加，最后得到的结果3赋值给a。</p><h2><b>2.2 复合赋值运算符</b></h2><ul><li>1）+=：加赋值，a += b等价于a = a + b。</li><li>2）-=：减赋值，a -= b等价于a = a - b。</li><li>3）*=：乘赋值，a *= b等价于a = a * b。</li><li>4）/=：除赋值，a /= b等价于a = a / b。</li><li>5）%=：取余赋值，a %= b等价于a = a % b。</li><li>6）&amp;=：位与赋值，a &amp;= b等价于a = a &amp; b。</li><li>7）|=：位或赋值，a |= b等价于a = a | b。</li><li>8）^=：位异或赋值，a ^= b等价于a = a ^ b。</li><li>9）&lt;&lt;=：位左移赋值，a &lt;&lt;= b等价于a = a &lt;&lt; b。</li><li>10）&gt;&gt;=：位右移赋值，a &gt;&gt;= b等价于a = a &gt;&gt; b。</li></ul><p>赋值运算的规则是将左侧的变量和右侧的操作数进行运算，然后再将得到的结果赋值给左侧的变量。比如：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">a</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span><span class=\"p\">;</span></code></pre></div><p>等价于：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span></code></pre></div><h2><b>7.条件运算符</b></h2><p>条件运算的一般语法格式如下：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"err\">表达式</span><span class=\"mi\">1</span><span class=\"err\">？表达式</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"err\">表达式</span><span class=\"mi\">3</span></code></pre></div><p>从语法格式中，我们可以看出，这是一个三目运算。通过问号和冒号将三个表达式连接起来。整个表达式的运算过程：先计算表达式1的值，如果它的值为true(非0值)，则将表达式2的值返回；如果它的值为false(0值)，则将表达式3的值返回。</p><p>【实例6.5】条件运算符，比较两个数的最大值</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">max</span><span class=\"p\">;</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;Please input a:&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;%d&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">);</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;Please input b:&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;%d&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">b</span><span class=\"p\">);</span>\n\n    <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">&gt;</span> <span class=\"n\">b</span> <span class=\"o\">?</span> <span class=\"nl\">a</span> <span class=\"p\">:</span> <span class=\"n\">b</span><span class=\"p\">;</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;max is:%d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span><span class=\"n\">max</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>Please input a:5<br/>Please input b:10<br/>max is:10</p><p>实例解析：<br/>先计算a &gt; b，值为false，将b的值返回，结果为10。</p><h2><b>8.其他运算符</b></h2><ul><li>1）sizeof：长度运算符</li><li>2）&amp; ：取地址运算符</li><li>3）[]：下标运算符</li><li>4）* ：指针运算符</li><li>5）. ：结构体成员运算符</li><li>6）-&gt;：指向结构体成员运算符</li></ul><p>这里介绍一下sizeof长度运算符，其余的在后面会讲到。sizeof运算符返回一个数据类型、变量、常量所占的字节长度，可以使用printf()函数来输出。</p><p>【实例6.6】sizeof长度运算符</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"p\">;</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;int类型字节长度:%d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">));</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;变量a字节长度:%d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">));</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;常量100字节长度:%d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">));</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>int类型字节长度:4<br/>变量a字节长度:4<br/>常量100字节长度:4</p><p>实例解析：<br/>可以看到结果都是4，这是因为int类型的字节长度是4，变量a的字节长度也就是4，存储的常量100自然也就是4。</p><h2><b>9.总结</b></h2><p>总结一下，本节内容主要介绍了C语言的算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、条件运算符和其他运算符。</p><h2><b>10.练习</b></h2><p>6-1 下面程序的输出结果是什么？</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">--</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"o\">++</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"o\">--</span><span class=\"n\">b</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;c=%d, d=%d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>6-2 判断下面结果是true还是flase:</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"mi\">1</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"mi\">3</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4</span> <span class=\"o\">||</span> <span class=\"mi\">4</span> <span class=\"o\">&gt;</span> <span class=\"mi\">5</span> <span class=\"o\">&amp;&amp;</span> <span class=\"mi\">2</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"mi\">9</span> <span class=\"o\">&gt;</span> <span class=\"mi\">8</span> <span class=\"o\">||</span> <span class=\"mi\">7</span> <span class=\"o\">&lt;</span> <span class=\"mi\">6</span>\n\n<span class=\"o\">!</span> <span class=\"mi\">2</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"n\">and</span> <span class=\"mi\">3</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4</span> <span class=\"n\">or</span> <span class=\"mi\">4</span> <span class=\"o\">&gt;</span> <span class=\"mi\">5</span> <span class=\"n\">and</span> <span class=\"mi\">2</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"n\">and</span> <span class=\"mi\">9</span> <span class=\"o\">&gt;</span> <span class=\"mi\">8</span> <span class=\"n\">or</span> <span class=\"mi\">7</span> <span class=\"o\">&lt;</span> <span class=\"mi\">6</span>\n</code></pre></div><p>6-3 编写一个程序，比较三个数的最大值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以在评论中，写下你们的练习答案。</p><blockquote> 之后的文章会给大家带来更精彩的内容<br/>欢迎关注我的知乎专栏：程序员基础知识<br/>获取练习答案以及更多实战项目<br/>欢迎关注我的公众号：程序员基础知识<br/>交(gao)流(ji)群：493584686</blockquote>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": [
                {
                    "userName": "猫与鼠", 
                    "userLink": "https://www.zhihu.com/people/edc07efcd0fbcd9023232b0efb1dc75e", 
                    "content": "感谢大佬[谢邀]", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54100371", 
            "userName": "程序员基础知识", 
            "userLink": "https://www.zhihu.com/people/fb378aca097e7e0e88eff8d19e99ab8e", 
            "upvote": 10, 
            "title": "C语言入门教程-(5)格式化输入输出", 
            "content": "<h2><b>1.输入和输出</b></h2><p>在程序的使用中，我们经常可以看的这么一个场景：用户需要输入数据，经过程序运算，得到结果后输出。在C语言中，输入数据和输出数据都是由库函数完成的，通过语句来输入/输出。</p><h2><b>2.格式化输出—printf()函数</b></h2><p>C语言程序运算的结果在内存中，我们需要将其输出到指定设备中，我们才可以看到数据。printf是print format的缩写，意思是“格式化打印”。“打印”的意思就是在屏幕上显示内容，所以我们称printf是格式化输出。</p><h2><b>2.1 printf()函数</b></h2><p>在前面我们有简单的使用过printf()函数，printf()函数的一般语法格式如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;&lt;格式化字符串&gt;&#34;</span><span class=\"err\">，</span><span class=\"o\">&lt;</span><span class=\"err\">输出列表</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"err\">；</span>\n</code></pre></div><ul><li>格式化字符串：用双引号括起来的字符串，字符串包含的普通字符，printf()函数将其原样输出到屏幕上；以&#34;%&#34;开头的格式字符，printf()函数将数据转换为指定的格式输出到屏幕上。</li><li>输出列表：需要输出到屏幕的数据，数据可以是常量、变量或者表达式。</li></ul><p>【实例5.1】printf()函数输出“C语言入门教程”。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;关注公众号：程序员基础知识&#34;</span><span class=\"p\">);</span>  \n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>关注公众号：程序员基础知识</p><p>实例解析：<br/>printf()函数用于格式化输出到屏幕，在头文件(标准输入输出头文件)中声明。当编译器调用printf()函数时，如果没有头文件，会发生编译错误。实例中，printf()函数只有“格式化字符串”，省略了“输出列表”。该语句字符串只包含的普通字符，printf()函数将其原样输出到屏幕上。</p><h2><b>2.2 printf()函数的字符格式</b></h2><p>格式化字符串中如果包含以“%”开头的格式字符，printf()函数将数据转换为指定的格式输出到屏幕上。格式化字符串中包含三部分，即原样输出文字、控制字符、转义字符。如果输出列表有两个变量或者多个组成，变量之间需要用逗号隔开，多个变量与格式字符串的控制字符一一对应。</p><p>输出不同的类型需要使用不同的控制符，这里汇总了一些常见的控制符。</p><p>%d：输出十进制整数，一般对应int类型</p><p>%i：输出十进制整数，与%d相同</p><p>%c：输出字符，一般对应char类型</p><p>%f：输出十进制实数，一般对应float类型，也可以是double类型</p><p>%lf：输出十进制实数，一般对应double类型，也可以是float类型</p><p>%%：输出百分号（%）</p><p>C语言中定义了一些字母前加&#34;\\&#34;来表示那些不能直接显示的ASCII字符，称为转义字符。汇总了几个常用的转义字符。</p><p>\\n：换行，将当前位置移到下一行开头</p><p>\\t：水平制表，跳到下一个Tab位置</p><p>\\\\：代表一个反斜线字符&#39;\\&#39;</p><p>【实例5.2】通过格式化输出盖伦属性。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">char</span> <span class=\"n\">garenName</span> <span class=\"o\">=</span> <span class=\"sc\">&#39;G&#39;</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;名字：%c</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">garenName</span><span class=\"p\">);</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">garenHp</span> <span class=\"o\">=</span> <span class=\"mi\">455</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">garenMoveSpeed</span> <span class=\"o\">=</span> <span class=\"mi\">340</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;生命值：%d</span><span class=\"se\">\\t</span><span class=\"s\">移动速度：%d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">garenHp</span><span class=\"p\">,</span> <span class=\"n\">garenMoveSpeed</span><span class=\"p\">);</span>\n\n    <span class=\"kt\">float</span> <span class=\"n\">garenAttackSpeed</span> <span class=\"o\">=</span> <span class=\"mf\">0.625</span><span class=\"p\">;</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;攻击速度：%f</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">garenAttackSpeed</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;攻击速度：%lf</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">garenAttackSpeed</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>名字：G<br/>生命值：455     移动速度：340<br/>攻击速度：0.625000<br/>攻击速度：0.625000</p><p>实例解析：<br/>控制字符%c输出一个字符G，转义字符\\n代表换行。生命值和移动速度之间有一个Tab的间隔，这是因为中间有转义字符\\t。float型的控制字符既可以用%f也可以用%lf。在printf()中，%f或者%lf控制字符既可以输出float型又可以输出double型。但在输入的时候则需要注意，float型对应%f，double型对应%lf，本节后面会讲到。</p><h2><b>3.格式化输入—scanf()函数</b></h2><p>输入的意思是向程序填充一些数据，scanf()函数用于从标准输入（比如键盘）读取并格式化。scanf是scan format的缩写，意思是“扫描格式化”。我们称scanf是格式化输入。</p><h2><b>3.1 scanf()函数</b></h2><p>scanf()函数也是一个标准库函数，在头文件中。scanf()函数的一般语法格式如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;&lt;格式化字符串&gt;&#34;</span><span class=\"err\">，</span><span class=\"o\">&lt;</span><span class=\"err\">地址列表</span><span class=\"o\">&gt;</span><span class=\"p\">);</span>\n</code></pre></div><ul><li>格式化字符串：用双引号括起来的字符串，一般只有&#34;%&#34;开头的格式字符。</li><li>地址列表：各个变量的地址，变量的地址通过取地址符号&#34;&amp;&#34;和变量名得到。比如，&amp;a代表变量a的地址。我们不需要关心具体的地址是什么，只需要在变量名前加上取地址符号&#34;&amp;&#34;即可。我们需要注意，scanf()函数要求给出地址，如果只有变量名则会报错。scanf()函数也可以和printf()函数一样可以接受多个值，变量之间需要用逗号隔开，需要一一对应。</li></ul><p>【实例5.3】通过格式化输入并且输出盖伦属性。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n\n    <span class=\"kt\">char</span> <span class=\"n\">garenName</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;Please input garenName:&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;%c&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">garenName</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;名字：%c</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">garenName</span><span class=\"p\">);</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">garenHp</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">garenMoveSpeed</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;Please input garenHp and garenMoveSpeed:&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;%d%d&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">garenHp</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">garenMoveSpeed</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;生命值：%d</span><span class=\"se\">\\t</span><span class=\"s\">移动速度：%d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">garenHp</span><span class=\"p\">,</span> <span class=\"n\">garenMoveSpeed</span><span class=\"p\">);</span>\n\n    <span class=\"kt\">float</span> <span class=\"n\">garenAttackSpeed</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;Please input garenAttackSpeed:&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;%f&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">garenAttackSpeed</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;攻击速度：%f</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">garenAttackSpeed</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>Please input garenName:G<br/>名字：G<br/>Please input garenHp and garenMoveSpeed:455 340<br/>生命值：455     移动速度：340<br/>Please input garenAttackSpeed:0.625<br/>攻击速度：0.625000</p><p>实例解析：<br/>scanf()函数不能输出提示信息，所以我们一般会在前面使用printf()函数来提示。实例中，Please input garenName:就是提示语句，我们输入一个字符&#39;G&#39;,然后回车键表示输入完成。生命值和移动速度的输入值，需要分别保存到两个变量中，scanf()函数使用空白字符（空格、换行、制表符Tab）来分隔输入的数据。455和340之间使用了空格来分隔也可以使用回车来分隔开，scanf()函数将455保存到变量garenHp中，将340保存到garenMoveSpeed中。使用scanf()函数当输入数据是float类型时用%f,当输入数据是double类型时用%lf。 </p><p><b>注意:如果用VS遇到scanf报错，将报错的宏定义（_CRT_SECURE_NO_WARNINGS）添加到项目属性 -- C/C++ -- 预处理器 -- 预处理器定义。要注意自己使用的调试平台和属性页的配置是一致的。比如用的是Debug的x64调试，在进入项目属性也要配置一致。</b></p><h2><b>3.2 scanf()函数的其他使用情况</b></h2><p>1）宽度<br/>我们可以在scanf()函数中指定输入的宽度，达到宽度后，后面的数据将会赋给下一个变量，如果只有一个变量则会将后面的数据舍弃。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;%2d&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">garenHp</span><span class=\"p\">);</span>\n</code></pre></div><p>当输入&#34;455&#34;时，将只有45保存到变量garenHp中，其余数据被舍弃。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;%2d%d&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">garenHp</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">garenMoveSpeed</span><span class=\"p\">);</span>\n</code></pre></div><p>当输入&#34;455&#34;时，将45保存到变量garenHp中，5保存到变量garenMoveSpeed中。</p><p>2）星号<br/>在格式字符串中使用星号，将会跳过这个输入值。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;%d%*d%d&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">garenHp</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">garenMoveSpeed</span><span class=\"p\">);</span>\n</code></pre></div><p>上面语句中，当输入&#34;1 2 3&#34;时,scanf()将第一个数1保存到变量garenHp，第二个数2将会被跳过，然后将第三个数3保存到变量garenMoveSpeed中。</p><h2><b>4.getchar()函数和putchar()函数</b></h2><p>getchar()函数用于接收键盘输入的下一个字符，并把它返回为一个整数，在同一个时间内只会读取一个字符。当调用getchar()函数时，程序就会等待。我们输入的字符被存放在输入缓冲区中，直到按回车为止。输入的字符会回显在屏幕上，能被我们所看见。getchar()函数从输入缓冲区中读入第一个字符。其函数原型如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">getchar</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">);</span>\n</code></pre></div><p>该函数的参数是void，不需要任何参数。当发生读取错误的时候，返回-1。当读取正确的时候，它会返回从键盘输入的第一个字符的ASCII码。</p><p>putchar()函数把字符输出到显示器上，并返回相同的字符，在同一个时间内只会输出一个字符。其函数原型如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">putchar</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">ch</span><span class=\"p\">);</span>\n</code></pre></div><p>该函数的参数是int类型。然后参数被转换为对应字符的ASCII码，最后输出该ASCII码对应的字符。</p><p>【实例5.4】getchar()函数和putchar()函数</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">char</span> <span class=\"n\">ch</span><span class=\"p\">;</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;Please input a ch:&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">ch</span> <span class=\"o\">=</span> <span class=\"n\">getchar</span><span class=\"p\">();</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;ch is:&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">putchar</span><span class=\"p\">(</span><span class=\"n\">ch</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>Please input a ch:a<br/>ch is:a</p><p>实例解析：<br/>getchar()和putchar()函数也在头文件中。首先定义了一个字符类型的ch变量，然后我们从键盘输入&#34;a&#34;加上回车。这个时候，输入缓冲区中有字符a以及回车符号。getchar()函数从输入缓冲区中读取第一个字符，将a存入到变量ch中，然后putchar()函数将其输出。</p><h2><b>5.getch()函数和putch()函数</b></h2><p>getch()函数和前面讲到的getchar()函数功能基本相同，也是接收输入的一个字符。getch()函数直接从键盘获取值，不等待回车键。只要获取到一个值，便立即返回。getch()函数输入的字符不回显，我们在屏幕上也看不到。因此，getch()函数常用来做调试。我们使用vs调试程序时，如果不使用Ctrl+F5，直接使用F5，控制台输出窗口将会一闪而逝。我们可以在程序中加上getch()函数，让程序暂停，这样就不会一闪而逝了，当从键盘按任意键后程序会继续运行。其函数原型如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">getch</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">);</span>\n</code></pre></div><p>putch()函数在使用上和putchar()函数没什么区别，也是用来向屏幕中输出一个字符。其函数原型如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">putch</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">ch</span><span class=\"p\">);</span>\n</code></pre></div><p>【实例5.5】getch()函数和putch()函数</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;conio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">char</span> <span class=\"n\">ch</span> <span class=\"o\">=</span> <span class=\"sc\">&#39;a&#39;</span><span class=\"p\">;</span>\n\n    <span class=\"n\">_putch</span><span class=\"p\">(</span><span class=\"n\">ch</span><span class=\"p\">);</span>\n\n    <span class=\"n\">_getch</span><span class=\"p\">();</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>执行以上程序，输出结果为：<br/>a</p><p>实例解析：<br/>getch()函数和putch()函数在头文件中。这个程序中，我们使用putch()函数输出变量ch，然后调用getch()函数使程序暂停，从键盘输入任意键，程序成功执行完毕。在VS2012之后，我们直接使用getch()和putch()会报错，我们需要在前面加上下划线变成_getch()和_putch()，像实例中一样。</p><h2><b>6.总结</b></h2><p>总结一下，本节内容主要介绍了C语言程序的格式化输入和输出。介绍了scanf()函数和printf()函数、getchar()函数和putchar()函数、getch()函数和putch()函数。</p><h2><b>7.练习</b></h2><p>5-1 下面一段程序将会输出什么？</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n   <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n\n   <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%d %d&#34;</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">);</span>\n\n   <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>5-2 编写一个程序，要求输出两个百分号&#34;%%&#34;和两个&#34;\\&#34;。</p><p>5-3 编写一个程序，要求输入两个变量，一个变量代表盖伦血量，一个变量代表提莫攻击力。然后模拟提莫攻击盖伦，输出盖伦剩余血量。盖伦剩余血量 = 盖伦血量 - 提莫攻击力。</p><p>5-4 编写一个程序，使得输入字符，可以直接转换为ASCII码值。</p><p>可以在评论中，写下你们的练习答案。</p><blockquote>之后的文章会给大家带来更精彩的内容<br/>欢迎关注我的知乎专栏：程序员基础知识<br/>获取练习答案以及更多实战项目<br/>欢迎关注我的公众号：程序员基础知识<br/>交(gao)流(ji)群：493584686</blockquote>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": [
                {
                    "userName": "Waiter", 
                    "userLink": "https://www.zhihu.com/people/1df686eed7bf05da5f61d8bbd5f15e75", 
                    "content": "怎么又是c语言老师，屏蔽了", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "程序员基础知识", 
                            "userLink": "https://www.zhihu.com/people/fb378aca097e7e0e88eff8d19e99ab8e", 
                            "content": "<p>大数据分析推荐的嘛，系统觉得你最近比较关注C语言</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Waiter"
                        }
                    ]
                }, 
                {
                    "userName": "理科男", 
                    "userLink": "https://www.zhihu.com/people/4fee511b43ae176de604edd8f85421ec", 
                    "content": "真的是适合新手的好东西，666！", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "理科男", 
                    "userLink": "https://www.zhihu.com/people/4fee511b43ae176de604edd8f85421ec", 
                    "content": "我都有种全抄的冲动", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53568364", 
            "userName": "程序员基础知识", 
            "userLink": "https://www.zhihu.com/people/fb378aca097e7e0e88eff8d19e99ab8e", 
            "upvote": 9, 
            "title": "C语言入门教程-(4)常量和变量", 
            "content": "<h2><b>1.常量和变量的概念</b></h2><p>程序执行过程中其值不能发生改变的量叫做常量，其值能发生改变的量叫做变量。常量可以直接使用，而变量则必须先定义后才能使用，否则编译器会报错。</p><h2><b>2.常量和变量的命名规范</b></h2><p>在介绍常量和变量的命名规范之前，我们先了解一下什么是标识符和关键字。</p><h2><b>2.1 标识符</b></h2><p>标识符，用来标识符号常量名、变量名、函数名、数组名、文件名、类名、对象名等。简单的将就是大家取的名字~~有效标识符的构成规则如下：</p><ul><li>1）第一个字符必须是字母（大小写都行）或下划线，不能是数字;</li><li>2）后跟字母（大小写都行）、下划线或数字组成;</li><li>3）标识符中的大小写字母有区别。如，变量sum,Sum,SUM代表三个不同的变量；</li><li>4）不能与编译系统已经预定义的、具有特殊用途的保留标识符（即关键字）同名。比如，不能将标识符命名int,char,float,break,case,for,while,return等等； <br/>下面列出几个有效的标识符：</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">teemo</span>    \n<span class=\"n\">Garen</span>\n<span class=\"n\">move_name</span>\n<span class=\"n\">dj8023</span>  \n<span class=\"n\">_temp</span>  \n<span class=\"n\">i</span>\n<span class=\"n\">the_hero_is_Garen</span></code></pre></div><p>下面列出几个无效的标识符：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"mi\">8</span><span class=\"n\">times</span>    <span class=\"c1\">//第一个字符必须是字母（大小写都行）或下划线，不能是数字。\n</span><span class=\"c1\"></span><span class=\"n\">price</span><span class=\"o\">/</span><span class=\"n\">tea</span>    <span class=\"c1\">//后跟字母（大小写都行）、下划线或数字组成，/不是属于之中。\n</span><span class=\"c1\"></span><span class=\"n\">my</span> <span class=\"n\">name</span>    <span class=\"c1\">//含有空格\n</span><span class=\"c1\"></span><span class=\"n\">x</span><span class=\"o\">+</span><span class=\"n\">y</span>    <span class=\"c1\">//包含了&#39;+&#39;号\n</span><span class=\"c1\"></span><span class=\"kt\">int</span>    <span class=\"o\">//</span><span class=\"n\">C语言程序中的关键字</span></code></pre></div><h2><b>2.2 关键字</b></h2><p>C语言中具有特殊含义的英文单词，通常用于构成语句，存储数据，定义数据类型等。下面列出了C语言中的一些保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p><ul><li>1）基本数据类型<br/>int：声明整数类型<br/>float：声明浮点型<br/>double：声明双精度浮点型<br/>char：声明字符类型<br/>void：空类型，声明函数无返回值或无参数</li><li>2）流程控制<br/>条件判断：if、else、switch、case、default等 <br/>循环：while、do、for、break、continue<br/>返回：return</li></ul><p>在本节中，先了解一下就行，有很多不明白的关键字后面会讲到。</p><h2><b>2.3 命名规范</b></h2><p>首先，必须是有效的标识符。在这个基础上，我们使用的命名最好能做到看名字就明白它表示什么。如果要使用一个变量来表示teemo的血量，我们可以将其命名为teemo_hp或者teemoHp，而不是随便的命名为a或者b之类的。遇到两个或者更多的单词组成的名称，我们通常用下划线字符将它们连接起来，或者从第二单词开始将每一个单词的第一个字母大写。</p><p>还有一些程序员可能会在变量中加入描述变量类型或者内容的前缀。例如，可以将整型变量teemoHp命名为nTeemoHp,其中n表示整数值。这样做的好处是在你遇到这个变量的时候，可以很直接的知道这个变量的类型。常用的几种前缀有：c(表示单个字符)、p(表示指针)等。另外，常量的标识符习惯用大写字母表示，变量的标识符习惯用小写字母表示。单下划线打头的标识符一般代表标准数据库的变量，双下划线打头的标识符一般代表编译器的变量。</p><p>关于命名，想说的是，命名可以根据自己的需要、喜好和个人风格来使用，但起码要保证一个程序里面的风格是一致性的。在团队共同开发中，则需要按照规范进行命名。规范的命名不仅可以让自己以后看的明白，也利于给团队其他人维护代码。</p><h2><b>3.常量</b></h2><h2><b>3.1 直接常量</b></h2><p>直接常量又可以叫做字面常量，通过数据来直接表现。在C语言中，编译器会自动根据字面常量的表示形式确定其类型。例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">y = x + 3;</code></pre></div><p>在上面的程序中，3将会被编译器作为int类型的常量。再例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">y = x + 3.0;</code></pre></div><p>3.0是小数，则会被编译器作为float类型的常量。当然，字符也有常量，不过和整型常量不同，字符常量必须使用单引号来进行表示。字符常量是使用单引号括起来的一个字符，不能是多个字符。例如，下面都是合法的字符常量：</p><div class=\"highlight\"><pre><code class=\"language-text\">&#39;a&#39;、&#39;B&#39;、&#39;#&#39;、&#39;8&#39;</code></pre></div><p>需要强调的是只能是单引号，并且只有一个字符，字符可以是ASCII码中的任意字符。如果数字被定义成字符常量的话，就不能代表数字字面的量了。如果参与运算，它的值将会是对应的ASCII码。比如上面的字符常量&#39;8&#39;，在ASCII码对应的值为56。这个时候参与运算，比如加上1，将得到的整数值是57。</p><h2><b>3.2 符号常量</b></h2><p>在C语言程序中，还可以使用一个符号常量来代替常量。使用符号常量有两个好处，一个是如果需要修改常量的话，只要修改定义符号常量的语句就行；另一个好处，使得程序中常量的含义更加清楚。定义符号常量有两种方法：#define宏定义和const语句定义。在这里我就先不展开讲了，大家过一眼就好了，后面的教程会详细的讲解宏定义和const的应用。</p><h2>4.变量</h2><p>在程序中，我们会使用到各种变量。当我们创建一个变量时，就会在内存中开辟一些空间。一般变量先声明，然后初始化。</p><h2><b>4.1 声明变量</b></h2><p>C语言中使用声明语句，来声明一个变量，指出存储类型并提供位置标签。C语言中，变量要求先声明后定义，这样做的好处在于：</p><ul><li>1.确保后面引用的变量名和声明的一致，减少了输入错误。如声明了变量teemo，在后面引用时，不小心输成了timo，编译器将会报错，指示timo未声明。 </li><li>2.在声明变量时，会指定变量的类型，当进行运算的时候，编译器就可以检查运算是否合法。</li><li>3.编译器根据指定变量的类型分配内存。</li></ul><p>声明变量的一般语法格式：</p><div class=\"highlight\"><pre><code class=\"language-text\">类型 变量名;</code></pre></div><p>其中，类型是数据类型的关键字，比如说int表示整数类型、double表示双精度浮点类型。变量名则需要符合命名规范的标识符。下面我们将会通过简单的程序，来介绍如何声明变量。比如说：我们要声明一个变量表示提莫的血量。在C语言中，就可以表示：</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp;\nfloat teemoAttack;</code></pre></div><p>int 是一种数据类型，表示是整数。<br/>teemoHp 是一个标识符，这里代表整数类型的血量。<br/>; 表示一个语句结束。</p><p>我们从计算机的角度来讲，第一条语句指出程序需要一个存储空间，用这个内存来存储一个整数。那么在C语言中，写上这个声明语句，程序就会将计算机的某一区域内存，命名为teemoHp，并在这个内存中存放整数类型。teemoHp这个标识符就是一个变量，它代表teemo的血量。这条语句创造了一个变量teemoHp，我们把这个过程叫做变量声明。</p><p>同类型的变量还可以在一个语句中同时声明多个变量，各变量之间用逗号分隔开，例如:</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp, garenHp;</code></pre></div><p>上面语句声明了两个整数类型的变量，等同于：</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp;\nint garenHp;</code></pre></div><h2><b>4.2 变量初始化</b></h2><p>在对变量声明时，编译器会给变量分配内存，但分配的这个内存并不会被清空。这个就和你删除电脑中的文件一样，虽然你点了删除这些文件，但实际上这些文件还会存在，只是我们看不到了。只有当你再次存储文件覆盖这些文件时，这些文件才算是删除了。这也是一些删除的文件，也可以通过某些手段来恢复的重要原因。那么就可能出现编译器给我们分配的内存，已经有存储值的情况，而且这个值对我们来说还是不确定的。为了防止程序因为不确定的值而出现不可预料的情况，我们在使用变量的时候就要对其进行赋初值，使得变量的值是确定的，这种方法就是初始化。</p><p>下面再来看一个简单的实例，我们要把提莫的血量作为一个变量，提莫的血量值是586。在C语言中，就可以表示成：</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp;\nteemoHp = 586;</code></pre></div><p>我们先声明了一个变量teemoHp，然后将常量586保存到变量teemoHp中。第二个语句中，“=”也叫赋值操作符，这个过程叫做赋值。赋值是指数据放到内存的过程，我们把这个过程叫做变量的赋值；又因为是第一次赋值，也称变量的初始化。</p><p>在声明变量的同时可以直接对其进行赋值，上面的两个语句，又可以直接表示成：</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp = 586;</code></pre></div><p>如果多个变量具有相同的值，还可以进行连续的赋值。例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp, garenHp;\nteemoHp = garenHp = 586;</code></pre></div><p>但不可以在声明的时候对其进行连续赋值。像下面语句一样：</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp = garenHp = 586;//报错</code></pre></div><p>这样写会导致标识符garenHp没有声明，所以编译器报错。</p><p>如果要在一个语句中这样做，我们应该写成下面语句：</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp = 586, garenHp = 586;</code></pre></div><p>我们还可以写成：</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp, garenHp = 586;\nteemoHp = 586;</code></pre></div><p>我们知道，在实际中，提莫通过等级的提升以及出的装备，血量的值会不断变化，那我们应该怎么办呢？答案是，血量的值是一个变量，我们可以通过再次赋值改变血量的值，例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">int teemoHp = 586;\nteemoHp = 1000;\nteemoHp = 5000;</code></pre></div><p>再次的赋值，会把第一次的数据覆盖掉。也就是说，teemoHp中最后的值是5000（这怕不是一个肉提莫），这也是因为586、1000已经被覆盖掉了。</p><h2><b>5.总结</b></h2><p>总结一下，本节内容主要介绍了C语言程序的常量和变量。介绍了常量和变量的概念以及命名规范，然后讲解了它们的一些基本使用方法。</p><h2><b>6.练习</b></h2><p>4-1 对下面进行判断，哪些是合法标识符，哪些又不是合法标识？</p><div class=\"highlight\"><pre><code class=\"language-text\">su8\n_total\nClass\nStudent_name\nlouts_1_2_3\nBASIC\nM.D.John\n\\#123\n3D45\na&gt;b</code></pre></div><p>4-2 编写一个程序，对盖伦的属性值，找到合适的类型来定义并且为其赋值。<br/>名字：简称为G<br/>生命值：455<br/>移动速度：340<br/>攻击速度：0.625<br/>攻击范围：125<br/>生命回复：8.25<br/>攻击力：59.5</p><p>可以在评论中，写下你们的练习答案。</p><blockquote>之后的文章会给大家带来更精彩的内容<br/>欢迎关注我的知乎专栏：程序员基础知识<br/>获取练习答案以及更多实战项目<br/>欢迎关注我的公众号：程序员基础知识<br/>交(gao)流(ji)群：493584686</blockquote>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": [
                {
                    "userName": "qqangel", 
                    "userLink": "https://www.zhihu.com/people/b6d276618a6d0080c12e05bed772a86e", 
                    "content": "<p>su8                                 //合法<br>_total                             //合法<br>Class                             //合法<br>Student_name              //合法<br>louts_1_2_3                  //合法<br>BASIC                          //合法<br>M.D.John                     //不合法<br>\\#123                           //不合法<br>3D45                             //不合法<br>a&gt;b                               //不合法</p>", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52800353", 
            "userName": "程序员基础知识", 
            "userLink": "https://www.zhihu.com/people/fb378aca097e7e0e88eff8d19e99ab8e", 
            "upvote": 12, 
            "title": "C语言入门教程-(3)基本数据类型", 
            "content": "<h2><b>1.数据类型</b></h2><p>在C语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。C语言数据类型可以分为四种：</p><ul><li>1.基本类型：<br/>它们是算术类型，包括两种类型：整数类型和浮点类型。<br/> </li><li>2.枚举类型：<br/>它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。<br/> </li><li>3.void 类型：<br/>类型说明符 void 表明没有可用的值。<br/> </li><li>4.派生类型：<br/>它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。<br/> </li></ul><p>本节内容主要学习的是基本类型，以及简单的介绍一下void类型。其他的类型在后续的章节中，将会慢慢的接触到，不用太担心。</p><h2>2.整数类型</h2><h2><b>2.1 int型</b></h2><p>int类型，就是没有小数的部分，比如2、500、0、-100。<br/>用法如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"n\">timoHp</span> <span class=\"o\">=</span> <span class=\"mi\">586</span><span class=\"p\">;</span><span class=\"c1\">//timo的血量是586；\n</span></code></pre></div><h2><b>2.2 char型</b></h2><p>char类型用于存放一个字符，值用两个单引号&#39;&#39;来表示 (双引号表示字符串)。编程语言通过使用字母的数值编码来解决字母的存储，因此char类型是另一种整型。字符集的字符用数值编码（ASCII码）表示。例如，字符&#39;A&#39;的编码是65，字符&#39;B&#39;的编码是66。<br/>用法如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">//char 只能存放一个字符，超过一个字符就会产生编译错误\n</span><span class=\"c1\"></span><span class=\"kt\">char</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"sc\">&#39;a&#39;</span><span class=\"p\">;</span> \n<span class=\"kt\">char</span> <span class=\"n\">c1</span> <span class=\"o\">=</span> <span class=\"sc\">&#39;盖&#39;</span><span class=\"p\">;</span>\n<span class=\"kt\">char</span> <span class=\"n\">c2</span> <span class=\"o\">=</span> <span class=\"sc\">&#39;伦&#39;</span><span class=\"p\">;</span> \n</code></pre></div><h2><b>2.3 bool型</b></h2><p>在计算中，bool变量的值可以是true或false。我们经常将非零值解释为true,将零解释为false。举一个简单的例子，我们可以这样编写语句：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">bool</span> <span class=\"n\">timoLive</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n</code></pre></div><p>字面值true和false都可以通过提升类型转换为int类型，true被转换为1，而false被转换为0：</p><div class=\"highlight\"><pre><code class=\"language-text\">int timoLive = true;//stick的值是1\nint timoKill = false;//egg的值是0</code></pre></div><p>另外，任何非零值都可以转换为true，而非零被转换为false:</p><div class=\"highlight\"><pre><code class=\"language-text\">bool timoHp = 586;//timoHp的值是true\nbool timoSpeed = -10;//timoSpeed的值是true\nbool timoAttack = 0;//timoAttack的值是false</code></pre></div><h2>3.浮点类型</h2><p>浮点数能够表示带小数部分的数字，它们的表示范围也更大。浮点数在计算机中的存储分两部分，一部分表示值，另一部分用于对值进行放大或缩小。举个简单的例子来帮助大家理解计算机中的浮点数，比如说过情人节了，我们给女朋友发个红包表示一下心意。我们需要表示的数额分别是13.14和1314，它们除了小数点的位置不同外，其他都是相同的（帮你们找了一个极好的借口）。至少计算机是这样看的，至于女朋友怎么看~~~在计算机中，第一个数可以表示为0.1314（基准数）和100（缩放因子），第二个数可以表示为0.1314（基准数）和10000（缩放因子）。缩放因子的作用就是移动小数点的位置，这其实也是浮点数术语的来源。计算机中的实际表示其实不是这样的十进制，而是基于二进制，这里我们简单的明白这个原理就行了。</p><h2><b>3.1 书写浮点数</b></h2><p>浮点数的书写方法有两种，一种是我们使用的标准小数点表示法：<br/>3.14<br/>5.0<br/>0.52<br/>第二种是E表示法：<br/>3.14E+2<br/>1.26e-4<br/>5E6<br/>-20.18E10<br/>3.14E+2<br/>上面的数字就是E表示法，比如说3.14E+3，这里的意思是3.14的小数点向右移动3位。其中前面的符号位可以是正号(+)或者负号(-)，小数点也是可选的，可以使用E或者e,后面的符号可以是+、-或者省略，后面的数字代表移动的位数。</p><h2><b>3.2 单精度浮点数(float)和双精度浮点数(double)</b></h2><p>浮点数根据范围和精度不同分为两种:单精度浮点数(float)和双精度浮点数(double)。一般来说，处理单精度浮点数的速度比处理双精度浮点数快。</p><ul><li>单精度浮点数一般占4个字节,32位。单精度浮点数1位符号位，8位指数，23位小数。float的小数位只有23位，能表示的最大十进制数为2的23次方，即8  388  608，相当于十进制的7位，严格点说，精度只能百分百的保证十进制的6位。所以我们一般说有效数字是8位。单精度浮点的表示范围：-3.40E+38 ~  +3.40E+38。<br/> </li><li>双精度浮点数一般占8个字节，64位。双精度浮点数1位符号位，11位指数，52位小数。小数位能表示的最大十进制数为2的52次方，即4  503 599 627 370  496。这是一个16位数，所以精度能百分百的保证十进制的15位。所以有效数字为16位。双精度浮点的表示范围：-1.79E+308 ~  +1.79E+308。<br/> </li></ul><p>简单的用法如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">float timoArmor = 150.7; //timo的护甲是150.7,查看VS中armor实际的值可以看到是150.699997\ndouble timoAttackSpeed = 0.865;/*timo的攻击速度是0.865，查看VS中attackSpeed实际的值可以看到是0.86499999999999999*/</code></pre></div><p>与整数相比，浮点数有两大优点。第一个是浮点数可以表示整数之间的值，可以表示小数。第二个是浮点数的表示范围比整数大的多。浮点数也有两个缺点，一个是浮点数运算的速度通常比整数慢，而且精度将降低。下面通过一个简单的程序来说明：</p><div class=\"highlight\"><pre><code class=\"language-text\">float a = 3.14E+22;\nfloat b = a + 1.0;</code></pre></div><p>该程序定义一个float类型a，然后b是a+1，试问运行程序b-a是多少？我们认为结果应该为1，但是在我们程序运行结果中，b-a将会是0。产生这个问题的原因就是3.14E+22是一个小数点左边有23位的数字，加上1，就是在第23位加1，但是float类型只能表示8位数字有效，因此对这个值不会有任何影响。</p><h2>4.void类型</h2><p>void的意思是“无类型”，表示函数没有返回值以及对函数参数做限定。这里如果不理解的话，可以先看看就好了，以后讲到函数就懂了。如果不用void，比如用int或者别的，则函数需要有返回值。void就是不需要结果，否则如int、char等，就必需返回一个与其对应的数据才能编译通过。void不能用来定义变量，让我们试着来定义：</p><div class=\"highlight\"><pre><code class=\"language-text\">void a;</code></pre></div><p>这个语句编译时会出错。不过，即使编译不会出错，它也没有任何实际意义。</p><h2>5.总结</h2><p>总结一下，本节内容主要介绍了C语言程序的基本数据类型。介绍了基本类型的整数类型和浮点类型，以及简单的讲解了void类型。整数类型又包括int型、char型、bool型,浮点类型又包括单精度浮点数(float)和双精度浮点数(double)。</p><h2>6.练习</h2><p>3-1 下面的程序，第一处i的值是什么？第二处i的值是什么？</p><div class=\"highlight\"><pre><code class=\"language-text\">char ch = &#39;A&#39;;\nint i = ch;//第一处i\n\nch = ch + 1;\ni = ch;//第二处i</code></pre></div><p>3-2 编写一个程序，对盖伦的属性值，找到合适的类型来定义。<br/>名字：简称为G<br/>生命值：455<br/>移动速度：340<br/>攻击速度：0.625<br/>攻击范围：125<br/>生命回复：8.25<br/>攻击力：59.5</p><p>可以在评论中，写下你们的练习答案。</p><blockquote>之后的文章会给大家带来更精彩的内容<br/>欢迎关注我的知乎专栏：程序员基础知识<br/>获取练习答案以及更多实战项目<br/>欢迎关注我的公众号：程序员基础知识<br/>交(gao)流(ji)群：493584686</blockquote>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": [
                {
                    "userName": "qqangel", 
                    "userLink": "https://www.zhihu.com/people/b6d276618a6d0080c12e05bed772a86e", 
                    "content": "<p>3-1 ASCII字符A的编码是65，下面的程序中，第一处i的值是什么？第二处i的值是什么？<br><br>char ch = 'A';<br>int i = ch;//第一处i<br><br>ch = ch + 1;<br>i = ch;//第二处i<br><br>第一处i的值是65，这是因为'A'对应的字符编码是65。<br>第二处i的值是66，此时的ch也变成了'B'。<br><br>3-2 编写一个程序，对盖伦的属性值，找到合适的类型来定义。<br>名字：简称为G<br>生命值：455<br>移动速度：340<br>攻击速度：0.625<br>攻击范围：125<br>生命回复：8.25<br>攻击力：59.5<br><br>名字：简称为G    --&gt;char类型<br>生命值：455     --&gt;int类型     <br>移动速度：340    --&gt;int类型    <br>攻击速度：0.625    --&gt;float类型    <br>攻击范围：125    --&gt;float类型<br>生命回复：8.25    --&gt;float类型<br>攻击力：59.5    --&gt;float类型<br>答案不唯一，大家定义合适的就行</p>", 
                    "likes": 2, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52259238", 
            "userName": "程序员基础知识", 
            "userLink": "https://www.zhihu.com/people/fb378aca097e7e0e88eff8d19e99ab8e", 
            "upvote": 3, 
            "title": "C语言入门教程-(2)基本程序结构", 
            "content": "<h2><b>1.简单的C语言程序结构</b></h2><p>要建造房屋，首先需要打地基、搬砖搭建框架（这大概就是为什么叫搬砖的原因）。学习计算机语言的时候也一样，应该从基本的结构开始学起。下面，我们看一段简单的源代码，这段代码希望大家动手对着敲一遍，自己动手完完全全敲一次。我想对于刚学编程的人，即使对着敲，也是极其容易出现错误的。当看到编译器很多的错误时候，也别慌。其中最大的两个原因，一个是使用了中文字符，比如中文的分号以及括号，二是拼写单词错误。我们在编程的时候，需要全部使用英文符号。比如，程序中的分号以及括号。</p><div class=\"highlight\"><pre><code class=\"language-text\">//myfirst.c   -- 显示消息\n#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(&#34;Hello\\n&#34;);\n    printf(&#34;程序员基础知识!&#34;);\n\n    return 0;\n}\n</code></pre></div><p>运行编译程序（快捷键“ctrl+F5”）后得到的输出：<br/>Hello<br/>程序员基础知识!</p><p>下面我们将这段代码分析一下，可以从以下几个部分来看：</p><ul><li>1）注释，代码的注释，是对代码的说明。编译器会忽略注释，毕竟机器也不想看你的注释QAQ。</li><li>2）预处理器编译指令#include，以及包含的头文件。</li><li>3）函数头：int main()。C语言程序由函数构成，一个程序可以有多个函数，但是有且只有一个主函数，也就是main()函数。</li><li>4）函数体，花括号“{}”括起来的部分，包括各种指令组成的语句在内。</li><li>5）结束main()函数的return语句。</li></ul><h2><b>2.注释</b></h2><p>C语言有两种注释方式：</p><ul><li>1）“//” <br/>这个其实是C++风格注释，通常用于注释单行文本或代码，它们放在一起组成多行注释。 <br/>以 // 开始，到行尾结束。单行注释，这种注释可以单独占一行，也可以和代码位于同一行。</li><li>2）“/* */” <br/>这个是C风格注释，通常用于注释大块文本或小片代码，也能用它们注释单行。  <br/>以 /* 开始，到 */ 结束。因此可以跨越多行。</li></ul><p>C 风格注释可出现在 C++ 风格注释内:</p><div class=\"highlight\"><pre><code class=\"language-text\">//  printf(&#34;Hello World!&#34;);   /* 输出Hello World! */\n</code></pre></div><p>C++ 风格注释可出现在 C 风格注释内:</p><div class=\"highlight\"><pre><code class=\"language-text\">/*\n    printf(&#34;Hello\\n&#34;);    //输出Hello，并且换行\n    printf(&#34;程序员基础知识!&#34;);    //输出程序员基础知识!\n*/\n</code></pre></div><p>两者可以同时存在，并不冲突:</p><div class=\"highlight\"><pre><code class=\"language-text\">printf(&#34;Hello World!&#34;);\n/* 与 C 风格注释不冲突 */\n// 与 C++ 风格注释不冲突\n</code></pre></div><p>注释主要是为了更好的读懂代码，使人能明确的看出代码的功能。写注释是一个编程的好习惯，而且在以后的团队开发或者代码维护有相当重要的作用。看别人没用注释甚至不规范的代码，肯定让你头疼。在实际工作中经常遇到自己代码写完，过一段时间测试出了bug或者改了需求之类，你还要再看自己代码，有注释就不会忘记了。</p><h2><b>3.预处理器和头文件</b></h2><ul><li>1）预处理器<br/>预处理器在程序编译之前对源文件进行处理，采用以“#”为行首作为指示，include是预处理指令的一种。<br/>预处理指令包括：include 、define 、undef 、if 、 ifdef 、 ifndef 、 else 、 elif 、 endif 、 line 、 error 、 pragma等。我们现在先了解#include，又叫文件包含预处理指令，每个指令占据一行。</li><li>2）头文件<br/>头文件，包含在文件最开始的地方。头文件使用.h为扩展名，头文件提供通用文件操作支持以及提供输入/输出的函数。在这段代码中，主要是提供printf()函数。如果没有这个头文件，我们使用printf()函数将会报错。</li></ul><h2><b>4.main()函数</b></h2><p>通常，C语言程序中必须包含一个名为main()的函数。main()函数由系统调用执行，main()函数是程序执行的入口函数。运行C语言代码时，从main()函数开始。main()函数由两部分组成，函数头int main()部分和函数体用花括号“{}”括起来的部分。main()函数的定义以函数头int main()开始，函数体的作用是指出计算机做什么指令操作。每条完整的指令称为语句，语句以分号“;”结束，所以在C语言程序中不能省略分号。main()中的最后是返回语句return 0，用来结束该函数，0代表程序正常退出。</p><p>int main()的其它写法，可以省略int就写成main()。这是因为在C语言中，省略返回类型则默认为int（C++中逐步淘汰了这种用法）。所以我们就别偷懒了，还是别用这种写法了。还有写成int main(void)和void main()的，我都不推荐，大家还是用int main()最好了。下面是我手画（字丑请自行忽略）的main()结构图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f991c7fe364eef075263a260b2995b75_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1109\" data-rawheight=\"779\" class=\"origin_image zh-lightbox-thumb\" width=\"1109\" data-original=\"https://pic2.zhimg.com/v2-f991c7fe364eef075263a260b2995b75_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1109&#39; height=&#39;779&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1109\" data-rawheight=\"779\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1109\" data-original=\"https://pic2.zhimg.com/v2-f991c7fe364eef075263a260b2995b75_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f991c7fe364eef075263a260b2995b75_b.jpg\"/></figure><h2><b>5.printf()函数输出字符串</b></h2><p>printf()函数的作用是格式化输出。我们来看这段代码：printf(&#34;Hello\\n&#34;); 双引号括起来的部分是要打印的消息。里面的一系列字符（Hello）叫做字符串。“\\n”是指示换行的，被看成一个字符，所以叫做换行符，作用是取新的一行开始。下面的printf(&#34;程序员基础知识!&#34;); 语句，就会另取一行打印输出了。 </p><h2><b>6.空白</b></h2><p>空格、制表符、回车都可以称为空白。空白可以分隔语句的各个部分，让编译器能识别语句中的某些元素在哪里开始和结束。比如语句：int main()，如果你将其写成intmain()，那么程序将报错。有些字符之间不需要用空白分开，比如括号和逗号。</p><p>只包含空格的行，编译器会忽略它。为了增强代码可读性，可以根据需要适当增加一些空格。</p><h2><b>7.总结</b></h2><p>总结一下，本节内容主要介绍了C语言程序的一般格式，具体包括注释、预处理器和头文件、main()函数、printf()函数输出字符串。</p><h2><b>8.练习</b></h2><p>2-1 假设main()函数包含代码：printf(&#34;程序员基础知识!&#34;); 编译器报错“printf”: 找不到标识符，是什么原因？<br/>2-2 return 0;表示成功结束，那么return -1;表示什么？<br/>2-3 编写一个C语言程序，第一行显示“hero:盖伦”，第二行显示“attack:300”，并对代码做一些简单的注释，比如在旁边注释，英雄：盖伦。</p><p>可以在评论中，写下你们的练习答案。</p><blockquote>之后的文章会给大家带来更精彩的内容 <br/>欢迎关注我的知乎专栏：程序员基础知识 <br/>获取练习答案以及更多实战项目 <br/>欢迎关注我的公众号：程序员基础知识 <br/>交(gao)流(ji)群：493584686</blockquote>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": [
                {
                    "userName": "一笑琅然", 
                    "userLink": "https://www.zhihu.com/people/97d87275d1a702f03a59ab23337f2cfe", 
                    "content": "这个答案在哪", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "程序员基础知识", 
                            "userLink": "https://www.zhihu.com/people/fb378aca097e7e0e88eff8d19e99ab8e", 
                            "content": "我准备上传公众号，或者专栏写一个专门的答案，不知道哪个好点", 
                            "likes": 0, 
                            "replyToAuthor": "一笑琅然"
                        }
                    ]
                }, 
                {
                    "userName": "端端", 
                    "userLink": "https://www.zhihu.com/people/575ede4edd34b9fbc76f0ebcf08263de", 
                    "content": "第一题是不是没标识#include &lt;stdio.h&gt;", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "程序员基础知识", 
                            "userLink": "https://www.zhihu.com/people/fb378aca097e7e0e88eff8d19e99ab8e", 
                            "content": "是的，没有头文件", 
                            "likes": 0, 
                            "replyToAuthor": "端端"
                        }
                    ]
                }, 
                {
                    "userName": "qqangel", 
                    "userLink": "https://www.zhihu.com/people/b6d276618a6d0080c12e05bed772a86e", 
                    "content": "<p>2-1 假设main()函数包含代码：printf(\"程序员基础知识!\"); 编译器报错“printf”: 找不到标识符，是什么原因？</p><p><br></p><p>没有头文件，需要加上#include</p><p>//注释少了#include &lt;stdio.h&gt;</p><p><br>int main()<br>{<br>printf(\"Hello!\\n\");<br>printf(\"这是我的第一个程序!\\n\");<br>return 0;<br>}<br><br>2-2 return 0;表示成功结束，那么return -1;表示什么？</p><p><br>return语句用来结束循环，或返回一个函数的值。</p><p>return 0; 一般用在主函数结束时，按照程序开发的一般惯列，标识成功完成本函数。</p><p>return -1; 表示返回一个代数值，一般用在子函数结尾。按照程序开发的一般惯列，表示该函数失败;</p><p>以上两个是约定俗成，系统提供的函数绝大部分定义为int类型返回值的都是这样的。</p><p><br>2-3 编写一个C语言程序，第一行显示“hero:盖伦”，第二行显示“attack:300”，并对代码做一些简单的注释，比如在旁边注释，英雄：盖伦。</p><p><br>#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>printf(\"hero:盖伦 \\n\"); //英雄：盖伦。<br>printf(\"attack:300 \\n\"); /*攻击力: 300*/<br>return 0;<br>}</p>", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52111695", 
            "userName": "程序员基础知识", 
            "userLink": "https://www.zhihu.com/people/fb378aca097e7e0e88eff8d19e99ab8e", 
            "upvote": 4, 
            "title": "C语言入门教程-(1)简介及搭建环境", 
            "content": "<h2><b>1.谁适合阅读本教程</b></h2><p>本教程可以帮助大家从零开始学习C语言，对于有一定基础的人起到夯实基本功的作用。C语言容易学习，非常适合初学者入门，而且也为以后的编程打下基础。借用一句话：“要进入编程行业高手必学C语言，要挣大钱必学C语言，要做黑客、红客必学C语言。”当然了，这是夸张的话了，但是体现出了C语言的重要性。</p><h2><b>2.简介</b></h2><p>C语言是一种通用的、面向过程式的计算机程序设计语言。它易于学习，是结构化语言，能够产生高效率的程序，可以在多种计算机平台上编译。在学习C语言的路上，它会帮助你成长为优秀的程序员。C语言最大的优点在于，它的代码运行速度与汇编语言编写的代码运行速度几乎一样。</p><h2><b>3.Windows 平台下的集成开发环境(简称 IDE)</b></h2><p>C语言的开发环境，需要有文本编辑器和C语言编译器。文本编辑器的作用是让你写代码的，这个代码是用来给自己或者他人看的，称为源文件，C程序的源文件通常使用扩展名 &#34;.c&#34;。而C语言编译器的作用是将源文件&#34;编译&#34;，转为机器语言，把源代码编译成最终的可执行程序。简单的来说，一个是给人看的，一个是翻译后给机器看的。</p><p>当然，作为刚入门，我们就不要搞得太复杂了，我们直接装一个大礼包就好了，也就是集成开发环境！集成开发环境就是包含了文本编辑器和编译器。IDE可以帮助我们更加方便、快捷的搬砖~哦，不！我的意思是写代码，搬砖是不可能搬砖的。</p><p>下面给大家介绍几个常用的C语言IDE。本系列的教程将会使用VS2015的开发环境，当然一开始直接用VS还是会有一些困难的，但我还是推荐大家用这个，我也会简单的给大家介绍一些基本的使用。VS也是以后C++学习必备的工具，甚至将来工作的实际开发环境。</p><h2><b>3.1 Visual Studio（简称 VS）</b></h2><p>Visual Studio是微软开发一款Windows下的标准IDE。VS在实际开发中被广泛的使用，微软还会对其进行更新和升级，目前最新版本是VS2017。VS具备强大的功能，集成很多开发工具。VS一般有三个版本，分别是：免费的社区版以及收费的专业版和企业版。对于大部分程序开发来说，这三个版本的区别不大。免费的社区版一样可以满足大家的需求，所以我推荐大家使用社区版，既省去了破解的麻烦，也尊重了微软的版权。最大的缺点可能就是体量比较大，安装和卸载麻烦。</p><p>推荐指数：五颗星</p><h2><b>3.2 Code::Blocks</b></h2><p>Code::Blocks 是一款开源、跨平台、免费的C/C++的IDE，主要优点是小巧灵活，易于安装和卸载，缺点是不如VS功能强大，以及实际开发用的不多。</p><p>推荐指数：四颗星</p><h2><b>3.3 Dev C++</b></h2><p>Dev C++是一款免费开源C/C++的IDE，也是一些大型竞赛的指定工具。Dev C++的优点是体量小、安装以及卸载起来都比较的方便，缺点是调试功能弱。</p><p>推荐指数：四颗星</p><h2><b>3.4 Visual C++ 6.0（简称VC 6.0）</b></h2><p>Visual C++ 6.0也是微软开发的IDE，是国内很多高校的教学工具。但VC 6.0是1998年的产品，在Win8或者Win10可能会有各种各样的兼容性问题，所以不推荐使用。很多大学把它作为教学工具，并且选用的教材也以VC 6.0为基础来讲解C语言和 C++，这也说明了中国高校的教学体制落后，课程体系的更新远远跟不上技术的进步。</p><p>推荐指数：两颗星</p><h2><b>3.5 Turbo C</b></h2><p>Turbo C是一款古老的C语言开发工具，程序员只能使用键盘操作，不能使用鼠标，所以非常不方便。Turbo C集成了一套图形库，可以在控制台程序中画图，看起来非常炫酷，所以至今仍然有人在使用。</p><p>推荐指数：两颗星</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>注：开发环境的下载链接，在公众号：程序员基础知识，回复“开发环境”即可获取</blockquote><h2><b>4.VS2015的使用</b></h2><p>下面简单的介绍一下VS的使用，使用VS如何建立一个项目。</p><h2><b>4.1 创建项目</b></h2><p>首先，打开 VS2015，在上方菜单栏中选择“文件 --&gt; 新建 --&gt; 项目”。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a248dcbdfcf748aa272f2ed939fd4e10_b.jpg\" data-rawwidth=\"781\" data-rawheight=\"242\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"781\" data-original=\"https://pic1.zhimg.com/v2-a248dcbdfcf748aa272f2ed939fd4e10_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;781&#39; height=&#39;242&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"781\" data-rawheight=\"242\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"781\" data-original=\"https://pic1.zhimg.com/v2-a248dcbdfcf748aa272f2ed939fd4e10_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a248dcbdfcf748aa272f2ed939fd4e10_b.jpg\"/></figure><p>出现下图，选择“Win32控制台应用程序”，填写项目名称，存储位置，点击“确定”按钮即可。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b2d592e853a6cf8ed3a74f0eccd53b88_b.jpg\" data-rawwidth=\"1178\" data-rawheight=\"816\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"1178\" data-original=\"https://pic1.zhimg.com/v2-b2d592e853a6cf8ed3a74f0eccd53b88_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1178&#39; height=&#39;816&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1178\" data-rawheight=\"816\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1178\" data-original=\"https://pic1.zhimg.com/v2-b2d592e853a6cf8ed3a74f0eccd53b88_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b2d592e853a6cf8ed3a74f0eccd53b88_b.jpg\"/></figure><p>然后弹出下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a63dd0f49b218189c41b742cbc34d651_b.jpg\" data-rawwidth=\"888\" data-rawheight=\"707\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"888\" data-original=\"https://pic2.zhimg.com/v2-a63dd0f49b218189c41b742cbc34d651_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;888&#39; height=&#39;707&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"888\" data-rawheight=\"707\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"888\" data-original=\"https://pic2.zhimg.com/v2-a63dd0f49b218189c41b742cbc34d651_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a63dd0f49b218189c41b742cbc34d651_b.jpg\"/></figure><p>点击“下一步”按钮，弹出下图： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-54a8fd3c2a15ce8a5df7fd213202fa2a_b.jpg\" data-rawwidth=\"888\" data-rawheight=\"707\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"888\" data-original=\"https://pic3.zhimg.com/v2-54a8fd3c2a15ce8a5df7fd213202fa2a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;888&#39; height=&#39;707&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"888\" data-rawheight=\"707\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"888\" data-original=\"https://pic3.zhimg.com/v2-54a8fd3c2a15ce8a5df7fd213202fa2a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-54a8fd3c2a15ce8a5df7fd213202fa2a_b.jpg\"/></figure><p>选择“控制台应用程序”，再勾选“空项目”，然后点击“完成”按钮就创建了一个新的项目。</p><h2><b>4.2 添加源文件</b></h2><p>首先，在“解决方案资源管理器”中，选择“源文件”右击鼠标，选择“添加 -&gt; 新建项”，如下图所示： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d3a9a1d68f3a042276a1505c77b03cf1_b.jpg\" data-rawwidth=\"1023\" data-rawheight=\"579\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"1023\" data-original=\"https://pic2.zhimg.com/v2-d3a9a1d68f3a042276a1505c77b03cf1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1023&#39; height=&#39;579&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1023\" data-rawheight=\"579\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1023\" data-original=\"https://pic2.zhimg.com/v2-d3a9a1d68f3a042276a1505c77b03cf1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d3a9a1d68f3a042276a1505c77b03cf1_b.jpg\"/></figure><p>弹出对话框。如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-87be2cdbbf17a6549aa278f2d04fff29_b.jpg\" data-rawwidth=\"1178\" data-rawheight=\"816\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"1178\" data-original=\"https://pic2.zhimg.com/v2-87be2cdbbf17a6549aa278f2d04fff29_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1178&#39; height=&#39;816&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1178\" data-rawheight=\"816\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1178\" data-original=\"https://pic2.zhimg.com/v2-87be2cdbbf17a6549aa278f2d04fff29_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-87be2cdbbf17a6549aa278f2d04fff29_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>选择“C++文件(.cpp)”，填写源文件名称，点击“添加”按钮即可。</p><h2><b>4.3 编写代码并调试运行</b></h2><p>打开 HelloWorld.cpp，写入代码。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3e193600bcc98db27ee5f19fb584d120_b.jpg\" data-rawwidth=\"1240\" data-rawheight=\"295\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-3e193600bcc98db27ee5f19fb584d120_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1240\" data-rawheight=\"295\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-3e193600bcc98db27ee5f19fb584d120_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3e193600bcc98db27ee5f19fb584d120_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>使用快捷键“ctrl+F5”,进行编译、运行。得到下图结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-91e7582e062a2595a2ca5892565fa6bd_b.jpg\" data-rawwidth=\"1053\" data-rawheight=\"235\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"1053\" data-original=\"https://pic2.zhimg.com/v2-91e7582e062a2595a2ca5892565fa6bd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1053&#39; height=&#39;235&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1053\" data-rawheight=\"235\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1053\" data-original=\"https://pic2.zhimg.com/v2-91e7582e062a2595a2ca5892565fa6bd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-91e7582e062a2595a2ca5892565fa6bd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上图中，我们可以在输出的信息看到运行成功。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-21dee800cbda564ea1c375b5ee20aff8_b.jpg\" data-rawwidth=\"489\" data-rawheight=\"264\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"489\" data-original=\"https://pic1.zhimg.com/v2-21dee800cbda564ea1c375b5ee20aff8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;489&#39; height=&#39;264&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"489\" data-rawheight=\"264\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"489\" data-original=\"https://pic1.zhimg.com/v2-21dee800cbda564ea1c375b5ee20aff8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-21dee800cbda564ea1c375b5ee20aff8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以看到输出结果，控制台输出“HelloWorld!”。</p><h2><b>5.第一个程序</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(&#34;Hello World!\\n&#34;);\n\n    return 0;\n}</code></pre></div><ul><li>1）程序的第一行 #include  是预处理器指令，在编译之前进行的处理，告诉编译器要包含 stdio.h 文件。如果不理解的话，就先简单的记住程序的第一行是这段代码就行。</li><li>2）int main() 是主函数，程序从这里开始执行。所以我们读程序的时候一般先从main()函数开始。</li><li>3）printf(&#34;Hello World!&#34;)，printf()是格式化打印函数。它的作用就是输出语句，在屏幕上显示&#34;Hello World!&#34;。</li><li>4）\\n是换行符，起到换行作用。</li><li>5）return 0; 终止 main() 函数，并返回值 0。简单的理解为程序成功运行结束就好了。</li></ul><h2><b>6.总结</b></h2><p>总结一下，本节内容先对C语言做了简单的介绍，然后介绍了如何使用VS2015编写程序，最后分析了我们接触的第一个程序。希望大家可以自己跑一遍这个程序，也可以试试动手敲一下这个程序。也许能体会到完成第一个代码的成就感。</p><h2><b>7.练习</b></h2><p>1-1 在自己电脑上动手安装一个开发环境。<br/>1-2 在控制台输出&#34;Hello World!&#34;。<br/>1-3 在上述基础上，通过更改代码在控制台输出&#34;Hello Meng!&#34;。</p><p>可以在评论中，写下你们的练习答案。</p><blockquote>之后的文章会给大家带来更精彩的内容<br/>欢迎关注我的知乎专栏：程序员基础知识<br/>获取练习答案以及更多实战项目<br/>欢迎关注我的公众号：程序员基础知识<br/>交(gao)流(ji)群：493584686</blockquote>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": [
                {
                    "userName": "qqangel", 
                    "userLink": "https://www.zhihu.com/people/b6d276618a6d0080c12e05bed772a86e", 
                    "content": "<p>1-2 在控制台输出\"Hello World!\"。</p><p>#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>printf(\"Hello World! \\n\");<br>return 0;<br>}</p><p><br></p><p>1-3 在上述基础上，通过更改代码在控制台输出\"Hello Meng!\"。</p><p>#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>printf(\"Hello Meng! \\n\");<br>return 0;<br>}</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/cxyjczc"
}
