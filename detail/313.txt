{
    "title": "好玩的编程", 
    "description": "java知识，算法知识分享，关注机器学习以及人工智能相关技术", 
    "followers": [
        "https://www.zhihu.com/people/lzw-90-40", 
        "https://www.zhihu.com/people/vincent-shi-62", 
        "https://www.zhihu.com/people/xi-zheng-lightgreen", 
        "https://www.zhihu.com/people/stefmoon", 
        "https://www.zhihu.com/people/ben-ben-27-79-77", 
        "https://www.zhihu.com/people/you-ru-45-73", 
        "https://www.zhihu.com/people/zheng-xin-yu-46-41", 
        "https://www.zhihu.com/people/chen-63-74", 
        "https://www.zhihu.com/people/i.PSD", 
        "https://www.zhihu.com/people/chen-chun-sheng-39-24", 
        "https://www.zhihu.com/people/lu-cheng-lin-25", 
        "https://www.zhihu.com/people/jieyujing", 
        "https://www.zhihu.com/people/piao-piao-22-10", 
        "https://www.zhihu.com/people/chen-dong-46-66-81", 
        "https://www.zhihu.com/people/he-xiao-xue-43", 
        "https://www.zhihu.com/people/1874-49-35", 
        "https://www.zhihu.com/people/lan-lan-lan-lan-96-82", 
        "https://www.zhihu.com/people/yanshiyu1976", 
        "https://www.zhihu.com/people/well188", 
        "https://www.zhihu.com/people/don-18-80", 
        "https://www.zhihu.com/people/Prometheus_Y", 
        "https://www.zhihu.com/people/AI_Technology", 
        "https://www.zhihu.com/people/liang-xian-sheng-93-9", 
        "https://www.zhihu.com/people/qi-bo-yu-81", 
        "https://www.zhihu.com/people/okayan", 
        "https://www.zhihu.com/people/liam-zhang-92", 
        "https://www.zhihu.com/people/an-yong-jin-15", 
        "https://www.zhihu.com/people/zhu-41-38", 
        "https://www.zhihu.com/people/yufei-king", 
        "https://www.zhihu.com/people/wangpuyuan", 
        "https://www.zhihu.com/people/tuo-tuo-5-59", 
        "https://www.zhihu.com/people/ming-tian-52-30-63", 
        "https://www.zhihu.com/people/lian-xiao-peng", 
        "https://www.zhihu.com/people/fei-de-geng-gao-2", 
        "https://www.zhihu.com/people/lang-ke-11-86", 
        "https://www.zhihu.com/people/fang-jin-41-88", 
        "https://www.zhihu.com/people/homer-wong-33", 
        "https://www.zhihu.com/people/xiao-wen-87-2", 
        "https://www.zhihu.com/people/dan-cha-60", 
        "https://www.zhihu.com/people/you-qing-37-12", 
        "https://www.zhihu.com/people/better-girl-93-52", 
        "https://www.zhihu.com/people/programmer_song", 
        "https://www.zhihu.com/people/lixi-28-55", 
        "https://www.zhihu.com/people/xin-ba-33-19", 
        "https://www.zhihu.com/people/wu-dong-cai-95", 
        "https://www.zhihu.com/people/jiu-ye-20-63", 
        "https://www.zhihu.com/people/lu-zhang-37", 
        "https://www.zhihu.com/people/ling-yun-4-56-64", 
        "https://www.zhihu.com/people/ziyoufen", 
        "https://www.zhihu.com/people/bu-ru-gui-qu-22-63", 
        "https://www.zhihu.com/people/xloved", 
        "https://www.zhihu.com/people/liu-chuan-bo-46", 
        "https://www.zhihu.com/people/andykung", 
        "https://www.zhihu.com/people/jiang-cheng-you-33", 
        "https://www.zhihu.com/people/zhou-si-yu-22", 
        "https://www.zhihu.com/people/zai-lu-shang-41-60-14", 
        "https://www.zhihu.com/people/76ren-mo-zhu-shi", 
        "https://www.zhihu.com/people/zhang-ke-nan-67", 
        "https://www.zhihu.com/people/xiao-qi-e-77-51", 
        "https://www.zhihu.com/people/asdzheng", 
        "https://www.zhihu.com/people/zcat1", 
        "https://www.zhihu.com/people/yang-jie", 
        "https://www.zhihu.com/people/liang-yu-cheng-79-58", 
        "https://www.zhihu.com/people/yige-ren-37-33", 
        "https://www.zhihu.com/people/you-yan-jing-32", 
        "https://www.zhihu.com/people/pin-cha-17-85", 
        "https://www.zhihu.com/people/ming-ge-82-61", 
        "https://www.zhihu.com/people/long-36-4", 
        "https://www.zhihu.com/people/yan-jin-yang-mo-xi", 
        "https://www.zhihu.com/people/dominee-dominee", 
        "https://www.zhihu.com/people/polaris-qian-xi", 
        "https://www.zhihu.com/people/yimo-sheng-90", 
        "https://www.zhihu.com/people/icarus-5", 
        "https://www.zhihu.com/people/IsaacFly", 
        "https://www.zhihu.com/people/shi-shu-sheng-", 
        "https://www.zhihu.com/people/null.0", 
        "https://www.zhihu.com/people/jie-jie-18-20", 
        "https://www.zhihu.com/people/enum-40", 
        "https://www.zhihu.com/people/fu-keng-die", 
        "https://www.zhihu.com/people/zhi-lang-bu-man", 
        "https://www.zhihu.com/people/janeben", 
        "https://www.zhihu.com/people/yeyxnone", 
        "https://www.zhihu.com/people/tttt-92-73", 
        "https://www.zhihu.com/people/wu-mi-13-69", 
        "https://www.zhihu.com/people/zhan-mu-si-le-bu-lang-77", 
        "https://www.zhihu.com/people/xiao-shan-94-8", 
        "https://www.zhihu.com/people/CedricChan", 
        "https://www.zhihu.com/people/ffc-3", 
        "https://www.zhihu.com/people/wjiany", 
        "https://www.zhihu.com/people/wang-jian-lin-31-74", 
        "https://www.zhihu.com/people/12811", 
        "https://www.zhihu.com/people/ren-hao-84-60", 
        "https://www.zhihu.com/people/tonywill", 
        "https://www.zhihu.com/people/anderson-yao", 
        "https://www.zhihu.com/people/wj2014-59", 
        "https://www.zhihu.com/people/zuo-an-yue-ya-wan", 
        "https://www.zhihu.com/people/lsyasuka", 
        "https://www.zhihu.com/people/wang-hao-91-41", 
        "https://www.zhihu.com/people/neng-bu-dou-yao-ni-15", 
        "https://www.zhihu.com/people/tang-jing-ge-56", 
        "https://www.zhihu.com/people/wang-er-xiao-72-97", 
        "https://www.zhihu.com/people/gu-wa-seejava", 
        "https://www.zhihu.com/people/li-shu-ting-68-8"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/52106040", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 3, 
            "title": "数据库并发控制 - 锁和 MVCC", 
            "content": "<p>在学习几年编程之后，你会发现所有的问题都没有简单、快捷的解决方案，很多问题都需要权衡和妥协，而本文介绍的就是数据库在并发性能和可串行化之间做的权衡和妥协 - 并发控制机制。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fdf737e307386344224c5f05651a8251_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-fdf737e307386344224c5f05651a8251_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;340&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-fdf737e307386344224c5f05651a8251_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fdf737e307386344224c5f05651a8251_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果数据库中的所有事务都是串行执行的，那么它非常容易成为整个应用的性能瓶颈，虽然说没法水平扩展的节点在最后都会成为瓶颈，但是串行执行事务的数据库会加速这一过程；而并发（Concurrency）使一切事情的发生都有了可能，它能够解决一定的性能问题，但是它会带来更多诡异的错误。</p><p>引入了并发事务之后，如果不对事务的执行进行控制就会出现各种各样的问题，你可能没有享受到并发带来的性能提升就已经被各种奇怪的问题折磨的欲仙欲死了。</p><h2>概述</h2><p>如何控制并发是数据库领域中非常重要的问题之一，不过到今天为止事务并发的控制已经有了很多成熟的解决方案，而这些方案的原理就是这篇文章想要介绍的内容，文章中会介绍最为常见的三种并发控制机制：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c4dcbcd9763b23c36ca07a47b2cc85c5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-c4dcbcd9763b23c36ca07a47b2cc85c5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;340&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-c4dcbcd9763b23c36ca07a47b2cc85c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c4dcbcd9763b23c36ca07a47b2cc85c5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>分别是悲观并发控制、乐观并发控制和多版本并发控制，其中悲观并发控制其实是最常见的并发控制机制，也就是锁；而乐观并发控制其实也有另一个名字：乐观锁，乐观锁其实并不是一种真实存在的锁，我们会在文章后面的部分中具体介绍；最后就是多版本并发控制（MVCC）了，与前两者对立的命名不同，MVCC 可以与前两者中的任意一种机制结合使用，以提高数据库的读性能。</p><p>既然这篇文章介绍了不同的并发控制机制，那么一定会涉及到不同事务的并发，我们会通过示意图的方式分析各种机制是如何工作的。</p><h2>悲观并发控制</h2><p>控制不同的事务对同一份数据的获取是保证数据库的一致性的最根本方法，如果我们能够让事务在同一时间对同一资源有着独占的能力，那么就可以保证操作同一资源的不同事务不会相互影响。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-14995b7f880c821a1665a87144c41908_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-14995b7f880c821a1665a87144c41908_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;340&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-14995b7f880c821a1665a87144c41908_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-14995b7f880c821a1665a87144c41908_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最简单的、应用最广的方法就是使用锁来解决，当事务需要对资源进行操作时需要先获得资源对应的锁，保证其他事务不会访问该资源后，在对资源进行各种操作；在悲观并发控制中，数据库程序对于数据被修改持悲观的态度，在数据处理的过程中都会被锁定，以此来解决竞争的问题。</p><h2>读写锁</h2><p>为了最大化数据库事务的并发能力，数据库中的锁被设计为两种模式，分别是共享锁和互斥锁。当一个事务获得共享锁之后，它只可以进行读操作，所以共享锁也叫读锁；而当一个事务获得一行数据的互斥锁时，就可以对该行数据进行读和写操作，所以互斥锁也叫写锁。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1c23d8c05c7350cb5f6b743e29f68086_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-1c23d8c05c7350cb5f6b743e29f68086_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-1c23d8c05c7350cb5f6b743e29f68086_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1c23d8c05c7350cb5f6b743e29f68086_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>共享锁和互斥锁除了限制事务能够执行的读写操作之外，它们之间还有『共享』和『互斥』的关系，也就是多个事务可以同时获得某一行数据的共享锁，但是互斥锁与共享锁和其他的互斥锁并不兼容，我们可以很自然地理解这么设计的原因：多个事务同时写入同一数据难免会发生各种诡异的问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6ed673255163e76c8bba7fcd622ab3f5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-6ed673255163e76c8bba7fcd622ab3f5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;620&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-6ed673255163e76c8bba7fcd622ab3f5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6ed673255163e76c8bba7fcd622ab3f5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果当前事务没有办法获取该行数据对应的锁时就会陷入等待的状态，直到其他事务将当前数据对应的锁释放才可以获得锁并执行相应的操作。</p><h2>两阶段锁协议</h2><p>两阶段锁协议（2PL）是一种能够保证事务可串行化的协议，它将事务的获取锁和释放锁划分成了增长（Growing）和缩减（Shrinking）两个不同的阶段。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-71520f28679e870addbc00ef6a6c9a32_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-71520f28679e870addbc00ef6a6c9a32_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-71520f28679e870addbc00ef6a6c9a32_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-71520f28679e870addbc00ef6a6c9a32_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在增长阶段，一个事务可以获得锁但是不能释放锁；而在缩减阶段事务只可以释放锁，并不能获得新的锁，如果只看 2PL 的定义，那么到这里就已经介绍完了，但是它还有两个变种：</p><ol><li><b>Strict 2PL</b>：事务持有的<b>互斥</b>锁必须在提交后再释放；</li><li><b>Rigorous 2PL</b>：事务持有的<b>所有</b>锁必须在提交后释放；</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a3678da052f5cc1d4b0e8cdf2cc7eee3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-a3678da052f5cc1d4b0e8cdf2cc7eee3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;620&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-a3678da052f5cc1d4b0e8cdf2cc7eee3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a3678da052f5cc1d4b0e8cdf2cc7eee3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>虽然锁的使用能够为我们解决不同事务之间由于并发执行造成的问题，但是两阶段锁的使用却引入了另一个严重的问题，死锁；不同的事务等待对方已经锁定的资源就会造成死锁，我们在这里举一个简单的例子：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7691f52eaa88f038a340f777ac6fda9a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-7691f52eaa88f038a340f777ac6fda9a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;620&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-7691f52eaa88f038a340f777ac6fda9a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7691f52eaa88f038a340f777ac6fda9a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>两个事务在刚开始时分别获取了 draven 和 beacon 资源上面的锁，然后再请求对方已经获得的锁时就会发生死锁，双方都没有办法等到锁的释放，如果没有死锁的处理机制就会无限等待下去，两个事务都没有办法完成。</p><h2>死锁的处理</h2><p>死锁在多线程编程中是经常遇到的事情，一旦涉及多个线程对资源进行争夺就需要考虑当前的几个线程或者事务是否会造成死锁；解决死锁大体来看有两种办法，一种是从源头杜绝死锁的产生和出现，另一种是允许系统进入死锁的状态，但是在系统出现死锁时能够及时发现并且进行恢复。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-070002e4cebd0e118bd62b6814c33b02_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"390\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-070002e4cebd0e118bd62b6814c33b02_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;390&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"390\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-070002e4cebd0e118bd62b6814c33b02_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-070002e4cebd0e118bd62b6814c33b02_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>预防死锁</h2><p>有两种方式可以帮助我们预防死锁的出现，一种是保证事务之间的等待不会出现环，也就是事务之间的等待图应该是一张<b>有向无环图</b>，没有循环等待的情况或者保证一个事务中想要获得的所有资源都在事务开始时以原子的方式被锁定，所有的资源要么被锁定要么都不被锁定。</p><p>但是这种方式有两个问题，在事务一开始时很难判断哪些资源是需要锁定的，同时因为一些很晚才会用到的数据被提前锁定，数据的利用率与事务的并发率也非常的低。一种解决的办法就是按照一定的顺序为所有的数据行加锁，同时与 2PL 协议结合，在加锁阶段保证所有的数据行都是从小到大依次进行加锁的，不过这种方式依然需要事务提前知道将要加锁的数据集。</p><p>另一种预防死锁的方法就是使用抢占加事务回滚的方式预防死锁，当事务开始执行时会先获得一个时间戳，数据库程序会根据事务的时间戳决定事务应该等待还是回滚，在这时也有两种机制供我们选择，一种是 wait-die 机制：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8bc279a136d770b89950d1132cfaad2c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"1100\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-8bc279a136d770b89950d1132cfaad2c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;1100&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"1100\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-8bc279a136d770b89950d1132cfaad2c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8bc279a136d770b89950d1132cfaad2c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当执行事务的时间戳小于另一事务时，即事务 A 先于 B 开始，那么它就会等待另一个事务释放对应资源的锁，否则就会保持当前的时间戳并回滚。</p><p>另一种机制叫做 wound-wait，这是一种抢占的解决方案，它和 wait-die 机制的结果完全相反，当前事务如果先于另一事务执行并请求了另一事务的资源，那么另一事务会立刻回滚，将资源让给先执行的事务，否则就会等待其他事务释放资源：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b16c970325ed2b3984c74dc9eba245fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"950\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-b16c970325ed2b3984c74dc9eba245fe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;950&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"950\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-b16c970325ed2b3984c74dc9eba245fe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b16c970325ed2b3984c74dc9eba245fe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>两种方法都会造成不必要的事务回滚，由此会带来一定的性能损失，更简单的解决死锁的方式就是使用超时时间，但是超时时间的设定是需要仔细考虑的，否则会造成耗时较长的事务无法正常执行，或者无法及时发现需要解决的死锁，所以它的使用还是有一定的局限性。</p><h2>死锁检测和恢复</h2><p>如果数据库程序无法通过协议从原理上保证死锁不会发生，那么就需要在死锁发生时及时检测到并从死锁状态恢复到正常状态保证数据库程序可以正常工作。在使用检测和恢复的方式解决死锁时，数据库程序需要维护数据和事务之间的引用信息，同时也需要提供一个用于判断当前数据库是否进入死锁状态的算法，最后需要在死锁发生时提供合适的策略及时恢复。</p><p>在上一节中我们其实提到死锁的检测可以通过一个有向的等待图来进行判断，如果一个事务依赖于另一个事务正在处理的数据，那么当前事务就会等待另一个事务的结束，这也就是整个等待图中的一条边：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c32711788eb783aff189c72107626a32_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-c32711788eb783aff189c72107626a32_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-c32711788eb783aff189c72107626a32_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c32711788eb783aff189c72107626a32_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如上图所示，如果在这个有向图中出现了环，就说明当前数据库进入了死锁的状态 <code>TransB -&gt; TransE -&gt; TransF -&gt; TransD -&gt; TransB</code>，在这时就需要死锁恢复机制接入了。</p><p>如何从死锁中恢复其实非常简单，最常见的解决办法就是选择整个环中一个事务进行回滚，以打破整个等待图中的环，在整个恢复的过程中有三个事情需要考虑：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8a5df38cc35f82cf07bbcf2f6478b59b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-8a5df38cc35f82cf07bbcf2f6478b59b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;340&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-8a5df38cc35f82cf07bbcf2f6478b59b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8a5df38cc35f82cf07bbcf2f6478b59b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>每次出现死锁时其实都会有多个事务被波及，而选择其中哪一个任务进行回滚是必须要做的事情，在选择牺牲品（Victim）时的黄金原则就是<b>最小化代价</b>，所以我们需要综合考虑事务已经计算的时间、使用的数据行以及涉及的事务等因素；当我们选择了牺牲品之后就可以开始回滚了，回滚其实有两种选择一种是全部回滚，另一种是部分回滚，部分回滚会回滚到事务之前的一个检查点上，如果没有检查点那自然没有办法进行部分回滚。</p><blockquote><i>在死锁恢复的过程中，其实还可能出现某些任务在多次死锁时都被选择成为牺牲品，一直都不会成功执行，造成饥饿（Starvation），我们需要保证事务会在有穷的时间内执行，所以要在选择牺牲品时将时间戳加入考虑的范围。</i></blockquote><h2>锁的粒度</h2><p>到目前为止我们都没有对不同粒度的锁进行讨论，一直以来我们都讨论的都是数据行锁，但是在有些时候我们希望将多个节点看做一个数据单元，使用锁直接将这个数据单元、表甚至数据库锁定起来。这个目标的实现需要我们在数据库中定义不同粒度的锁：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-88a8cb0a0dda36ace2dee9ccc9aacecd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"559\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-88a8cb0a0dda36ace2dee9ccc9aacecd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;559&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"559\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-88a8cb0a0dda36ace2dee9ccc9aacecd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-88a8cb0a0dda36ace2dee9ccc9aacecd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当我们拥有了不同粒度的锁之后，如果某个事务想要锁定整个数据库或者整张表时只需要简单的锁住对应的节点就会在当前节点加上显示（explicit）锁，在所有的子节点上加隐式（implicit）锁；虽然这种不同粒度的锁能够解决父节点被加锁时，子节点不能被加锁的问题，但是我们没有办法在子节点被加锁时，立刻确定父节点不能被加锁。</p><p>在这时我们就需要引入<i>意向锁</i>来解决这个问题了，当需要给子节点加锁时，先给所有的父节点加对应的意向锁，意向锁之间是完全不会互斥的，只是用来帮助父节点快速判断是否可以对该节点进行加锁：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-dd5f8e854fa07f9944b85c5e9a6ae160_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-dd5f8e854fa07f9944b85c5e9a6ae160_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;700&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-dd5f8e854fa07f9944b85c5e9a6ae160_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-dd5f8e854fa07f9944b85c5e9a6ae160_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里是一张引入了两种意向锁，<i>意向共享锁</i>和<i>意向互斥锁</i>之后所有的锁之间的兼容关系；到这里，我们通过不同粒度的锁和意向锁加快了数据库的吞吐量。</p><h2>乐观并发控制</h2><p>除了悲观并发控制机制 - 锁之外，我们其实还有其他的并发控制机制，<i>乐观并发控制</i>（Optimistic Concurrency Control）。乐观并发控制也叫乐观锁，但是它并不是真正的锁，很多人都会误以为乐观锁是一种真正的锁，然而它只是一种并发控制的思想。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-811b0c26c104258c27b44f2016e2b16c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-811b0c26c104258c27b44f2016e2b16c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-811b0c26c104258c27b44f2016e2b16c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-811b0c26c104258c27b44f2016e2b16c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在这一节中，我们将会先介绍<i>基于时间戳的并发控制机制</i>，然后在这个协议的基础上进行扩展，实现乐观的并发控制机制。</p><h2>基于时间戳的协议</h2><p>锁协议按照不同事务对同一数据项请求的时间依次执行，因为后面执行的事务想要获取的数据已将被前面的事务加锁，只能等待锁的释放，所以基于锁的协议执行事务的顺序与获得锁的顺序有关。在这里想要介绍的基于时间戳的协议能够在事务执行之前先决定事务的执行顺序。</p><p>每一个事务都会具有一个全局唯一的时间戳，它即可以使用系统的时钟时间，也可以使用计数器，只要能够保证所有的时间戳都是唯一并且是随时间递增的就可以。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-57202d3ce8218f8e13c9ac9b59f7eed7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"549\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-57202d3ce8218f8e13c9ac9b59f7eed7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;549&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"549\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-57202d3ce8218f8e13c9ac9b59f7eed7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-57202d3ce8218f8e13c9ac9b59f7eed7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>基于时间戳的协议能够保证事务并行执行的顺序与事务按照时间戳串行执行的效果完全相同；每一个数据项都有两个时间戳，读时间戳和写时间戳，分别代表了当前成功执行对应操作的事务的时间戳。</p><p>该协议能够保证所有冲突的读写操作都能按照时间戳的大小串行执行，在执行对应的操作时不需要关注其他的事务只需要关心数据项对应时间戳的值就可以了：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-65654b50ce40281631ddcf73c8039395_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-65654b50ce40281631ddcf73c8039395_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;330&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic2.zhimg.com/v2-65654b50ce40281631ddcf73c8039395_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-65654b50ce40281631ddcf73c8039395_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>无论是读操作还是写操作都会从左到右依次比较读写时间戳的值，如果小于当前值就会直接被拒绝然后回滚，数据库系统会给回滚的事务添加一个新的时间戳并重新执行这个事务。</p><h2>基于验证的协议</h2><p><i>乐观并发控制</i>其实本质上就是基于验证的协议，因为在多数的应用中只读的事务占了绝大多数，事务之间因为写操作造成冲突的可能非常小，也就是说大多数的事务在不需要并发控制机制也能运行的非常好，也可以保证数据库的一致性；而并发控制机制其实向整个数据库系统添加了很多的开销，我们其实可以通过别的策略降低这部分开销。</p><p>而验证协议就是我们找到的解决办法，它根据事务的只读或者更新将所有事务的执行分为两到三个阶段：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5dba22803ce995b081a1ad9e7436bfdf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"490\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-5dba22803ce995b081a1ad9e7436bfdf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;490&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"490\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-5dba22803ce995b081a1ad9e7436bfdf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5dba22803ce995b081a1ad9e7436bfdf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在读阶段，数据库会执行事务中的<b>全部读操作和写操作</b>，并将所有写后的值存入临时变量中，并不会真正更新数据库中的内容；在这时候会进入下一个阶段，数据库程序会检查当前的改动是否合法，也就是是否有其他事务在 RAED PHASE 期间更新了数据，如果通过测试那么直接就进入 WRITE PHASE 将所有存在临时变量中的改动全部写入数据库，没有通过测试的事务会直接被终止。</p><p>为了保证乐观并发控制能够正常运行，我们需要知道一个事务不同阶段的发生时间，包括事务开始时间、验证阶段的开始时间以及写阶段的结束时间；通过这三个时间戳，我们可以保证任意冲突的事务不会同时写入数据库，一旦由一个事务完成了验证阶段就会立即写入，其他读取了相同数据的事务就会回滚重新执行。</p><p>作为乐观的并发控制机制，它会假定所有的事务在最终都会通过验证阶段并且执行成功，而锁机制和基于时间戳排序的协议是悲观的，因为它们会在发生冲突时强制事务进行等待或者回滚，哪怕有不需要锁也能够保证事务之间不会冲突的可能。</p><h2>多版本并发控制</h2><p>到目前为止我们介绍的并发控制机制其实都是通过延迟或者终止相应的事务来解决事务之间的竞争条件（Race condition）来保证事务的可串行化；虽然前面的两种并发控制机制确实能够从根本上解决并发事务的可串行化的问题，但是在实际环境中数据库的事务大都是只读的，读请求是写请求的很多倍，如果写请求和读请求之前没有并发控制机制，那么最坏的情况也是读请求读到了已经写入的数据，这对很多应用完全是可以接受的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-475e9bc9fb50bcb614ab76044c574b0f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-475e9bc9fb50bcb614ab76044c574b0f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-475e9bc9fb50bcb614ab76044c574b0f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-475e9bc9fb50bcb614ab76044c574b0f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在这种大前提下，数据库系统引入了另一种并发控制机制 - <i>多版本并发控制</i>（Multiversion Concurrency Control），每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回；在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。</p><p>MVCC 并不是一个与乐观和悲观并发控制对立的东西，它能够与两者很好的结合以增加事务的并发量，在目前最流行的 SQL 数据库 MySQL 和 PostgreSQL 中都对 MVCC 进行了实现；但是由于它们分别实现了悲观锁和乐观锁，所以 MVCC 实现的方式也不同。</p><h2>MySQL 与 MVCC</h2><p>MySQL 中实现的多版本两阶段锁协议（Multiversion 2PL）将 MVCC 和 2PL 的优点结合了起来，每一个版本的数据行都具有一个唯一的时间戳，当有读事务请求时，数据库程序会直接从多个版本的数据项中具有最大时间戳的返回。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2a489b36ed600d002888eb588e3ad02e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-2a489b36ed600d002888eb588e3ad02e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic3.zhimg.com/v2-2a489b36ed600d002888eb588e3ad02e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2a489b36ed600d002888eb588e3ad02e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>更新操作就稍微有些复杂了，事务会先读取最新版本的数据计算出数据更新后的结果，然后创建一个新版本的数据，新数据的时间戳是目前数据行的最大版本 <code>＋1</code>：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3834eaa922afe5a90b1ed94bcd5df727_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-3834eaa922afe5a90b1ed94bcd5df727_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-3834eaa922afe5a90b1ed94bcd5df727_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3834eaa922afe5a90b1ed94bcd5df727_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>数据版本的删除也是根据时间戳来选择的，MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容。</p><h2>PostgreSQL 与 MVCC</h2><p>与 MySQL 中使用悲观并发控制不同，PostgreSQL 中都是使用乐观并发控制的，这也就导致了 MVCC 在于乐观锁结合时的实现上有一些不同，最终实现的叫做多版本时间戳排序协议（Multiversion Timestamp Ordering），在这个协议中，所有的的事务在执行之前都会被分配一个唯一的时间戳，每一个数据项都有读写两个时间戳：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b512ce9f9f56ea1280661367a4eb50b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2400\" data-rawheight=\"560\" class=\"origin_image zh-lightbox-thumb\" width=\"2400\" data-original=\"https://pic3.zhimg.com/v2-b512ce9f9f56ea1280661367a4eb50b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2400&#39; height=&#39;560&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2400\" data-rawheight=\"560\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2400\" data-original=\"https://pic3.zhimg.com/v2-b512ce9f9f56ea1280661367a4eb50b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b512ce9f9f56ea1280661367a4eb50b6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当 PostgreSQL 的事务发出了一个读请求，数据库直接将最新版本的数据返回，不会被任何操作阻塞，而写操作在执行时，事务的时间戳一定要大或者等于数据行的读时间戳，否则就会被回滚。</p><p>这种 MVCC 的实现保证了读事务永远都不会失败并且不需要等待锁的释放，对于读请求远远多于写请求的应用程序，乐观锁加 MVCC 对数据库的性能有着非常大的提升；虽然这种协议能够针对一些实际情况做出一些明显的性能提升，但是也会导致两个问题，一个是每一次读操作都会更新读时间戳造成两次的磁盘写入，第二是事务之间的冲突是通过回滚解决的，所以如果冲突的可能性非常高或者回滚代价巨大，数据库的读写性能还不如使用传统的锁等待方式。</p><h2>总结</h2><p>数据库的并发控制机制到今天已经有了非常成熟、完善的解决方案，我们并不需要自己去设计一套新的协议来处理不同事务之间的冲突问题，从数据库的并发控制机制中学习到的相关知识，无论是锁还是乐观并发控制在其他的领域或者应用中都被广泛使用，所以了解、熟悉不同的并发控制机制的原理是很有必要的。</p>", 
            "topic": [
                {
                    "tag": "并发", 
                    "tagLink": "https://api.zhihu.com/topics/19757794"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }, 
                {
                    "tag": "MVCC", 
                    "tagLink": "https://api.zhihu.com/topics/20023383"
                }
            ], 
            "comments": [
                {
                    "userName": "小鱼", 
                    "userLink": "https://www.zhihu.com/people/2bddb45369ba87cadb64ef456b8c1dba", 
                    "content": "<p>写的很用心了，配图也很好</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52098102", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 1, 
            "title": "MySQL事务ACID实现详解", 
            "content": "<p>在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性，而我们不知道的可能就是数据库是如何实现这四个属性的；在这篇文章中，我们将对事务的实现进行分析，尝试理解数据库是如何实现事务的，当然我们也会在文章中简单对 MySQL 中对 ACID 的实现进行简单的介绍。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a334d9c01ce811789625e0ca52c28ab8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-a334d9c01ce811789625e0ca52c28ab8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-a334d9c01ce811789625e0ca52c28ab8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a334d9c01ce811789625e0ca52c28ab8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>事务其实就是<b>并发控制的基本单位</b>；相信我们都知道，事务是一个序列操作，其中的操作要么都执行，要么都不执行，它是一个不可分割的工作单位；数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清除了事务的实现，接下来我们将依次介绍数据库是如何实现这四个特性的。</p><h2>原子性</h2><p>在学习事务时，经常有人会告诉你，事务就是一系列的操作，要么全部都执行，要都不执行，这其实就是对事务原子性的刻画；虽然事务具有原子性，但是原子性并不是只与事务有关系，它的身影在很多地方都会出现。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-937b32d90e5d43336ae83a9a9fd2d457_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-937b32d90e5d43336ae83a9a9fd2d457_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-937b32d90e5d43336ae83a9a9fd2d457_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-937b32d90e5d43336ae83a9a9fd2d457_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>由于操作并不具有原子性，并且可以再分为多个操作，当这些操作出现错误或抛出异常时，整个操作就可能不会继续执行下去，而已经进行的操作造成的副作用就可能造成数据更新的丢失或者错误。</p><p>事务其实和一个操作没有什么太大的区别，它是一系列的数据库操作（可以理解为 SQL）的集合，如果事务不具备原子性，那么就没办法保证同一个事务中的所有操作都被执行或者未被执行了，整个数据库系统就既不可用也不可信。</p><h2>回滚日志</h2><p>想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<b>回滚</b>，而在 MySQL 中，恢复机制是通过<i>回滚日志</i>（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9735506203784679fe98545baa3bee42_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-9735506203784679fe98545baa3bee42_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-9735506203784679fe98545baa3bee42_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9735506203784679fe98545baa3bee42_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这个过程其实非常好理解，为了能够在发生错误时撤销之前的全部操作，肯定是需要将之前的操作都记录下来的，这样在发生错误时才可以回滚。</p><p>回滚日志除了能够在发生错误或者用户执行 <code>ROLLBACK</code> 时提供回滚相关的信息，它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。</p><p>回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志<b>逻辑地</b>将数据库中的修改撤销掉看，可以<b>理解</b>为，我们在事务中使用的每一条 <code>INSERT</code> 都对应了一条 <code>DELETE</code>，每一条 <code>UPDATE</code> 也都对应一条相反的 <code>UPDATE</code> 语句。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-efc3ca59670e02f796e73a870e57f2d2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-efc3ca59670e02f796e73a870e57f2d2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-efc3ca59670e02f796e73a870e57f2d2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-efc3ca59670e02f796e73a870e57f2d2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在这里，我们并不会介绍回滚日志的格式以及它是如何被管理的，本文重点关注在它到底是一个什么样的东西，究竟解决了、如何解决了什么样的问题，如果想要了解具体实现细节的读者，相信网络上关于回滚日志的文章一定不少。</p><h2>事务的状态</h2><p>因为事务具有原子性，所以从远处看的话，事务就是密不可分的一个整体，事务的状态也只有三种：Active、Commited 和 Failed，事务要不就在执行中，要不然就是成功或者失败的状态：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1c73acd26ed3bc235796f987f6ff63a9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-1c73acd26ed3bc235796f987f6ff63a9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;232&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-1c73acd26ed3bc235796f987f6ff63a9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1c73acd26ed3bc235796f987f6ff63a9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>但是如果放大来看，我们会发现事务不再是原子的，其中包括了很多中间状态，比如部分提交，事务的状态图也变得越来越复杂。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b6ef03aa3b1dff48480429f90001e8e1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-b6ef03aa3b1dff48480429f90001e8e1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-b6ef03aa3b1dff48480429f90001e8e1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b6ef03aa3b1dff48480429f90001e8e1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><blockquote><i>事务的状态图以及状态的描述取自</i> <i><a href=\"https://link.zhihu.com/?target=https%3A//www.amazon.com/Database-System-Concepts-Computer-Science/dp/0073523321\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Database System Concepts</a></i> <i>一书中第 14 章的内容。</i></blockquote><ul><li>Active：事务的初始状态，表示事务正在执行；</li><li>Partially Commited：在最后一条语句执行之后；</li><li>Failed：发现事务无法正常执行之后；</li><li>Aborted：事务被回滚并且数据库恢复到了事务进行之前的状态之后；</li><li>Commited：成功执行整个事务；</li></ul><p>虽然在发生错误时，整个数据库的状态可以恢复，但是如果我们在事务中执行了诸如：向标准输出打印日志、向外界发出邮件、没有通过数据库修改了磁盘上的内容甚至在事务执行期间发生了转账汇款，那么这些操作作为可见的外部输出都是没有办法回滚的；这些问题都是由应用开发者解决和负责的，在绝大多数情况下，我们都需要在整个事务提交后，再触发类似的无法回滚的操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f315df5ace2456599af1a4535902a342_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"367\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-f315df5ace2456599af1a4535902a342_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;367&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"367\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-f315df5ace2456599af1a4535902a342_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f315df5ace2456599af1a4535902a342_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>以订票为例，哪怕我们在整个事务结束之后，才向第三方发起请求，由于向第三方请求并获取结果是一个需要较长事件的操作，如果在事务刚刚提交时，数据库或者服务器发生了崩溃，那么我们就非常有可能丢失发起请求这一过程，这就造成了非常严重的问题；而这一点就不是数据库所能保证的，开发者需要在适当的时候查看请求是否被发起、结果是成功还是失败。</p><h2>并行事务的原子性</h2><p>到目前为止，所有的事务都只是串行执行的，一直都没有考虑过并行执行的问题；然而在实际工作中，并行执行的事务才是常态，然而并行任务下，却可能出现非常复杂的问题：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c9d3479536046b27fec2b7a306e823c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"550\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-c9d3479536046b27fec2b7a306e823c2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;550&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"550\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-c9d3479536046b27fec2b7a306e823c2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c9d3479536046b27fec2b7a306e823c2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当 Transaction1 在执行的过程中对 <code>id = 1</code> 的用户进行了读写，但是没有将修改的内容进行提交或者回滚，在这时 Transaction2 对同样的数据进行了读操作并提交了事务；也就是说 Transaction2 是依赖于 Transaction1 的，当 Transaction1 由于一些错误需要回滚时，因为要保证事务的原子性，需要对 Transaction2 进行回滚，但是由于我们已经提交了 Transaction2，所以我们已经没有办法进行回滚操作，在这种问题下我们就发生了问题，<a href=\"https://link.zhihu.com/?target=https%3A//www.amazon.com/Database-System-Concepts-Computer-Science/dp/0073523321\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Database System Concepts</a> 一书中将这种现象称为<i>不可恢复安排</i>（Nonrecoverable Schedule），那什么情况下是可以恢复的呢？</p><blockquote><i>A recoverable schedule is one where, for each pair of transactions Ti and Tj such that Tj reads a data item previously written by Ti , the commit operation of Ti appears before the commit operation of Tj .</i></blockquote><p>简单理解一下，如果 Transaction2 依赖于事务 Transaction1，那么事务 Transaction1 必须在 Transaction2 提交之前完成提交的操作：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6dbbf4b7d37c70eac2bcc9511bff7a34_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"550\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-6dbbf4b7d37c70eac2bcc9511bff7a34_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;550&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"550\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-6dbbf4b7d37c70eac2bcc9511bff7a34_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6dbbf4b7d37c70eac2bcc9511bff7a34_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>然而这样还不算完，当事务的数量逐渐增多时，整个恢复流程也会变得越来越复杂，如果我们想要从事务发生的错误中恢复，也不是一件那么容易的事情。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-778141ef997823c438d522eec76a1cbd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-778141ef997823c438d522eec76a1cbd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;692&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-778141ef997823c438d522eec76a1cbd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-778141ef997823c438d522eec76a1cbd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在上图所示的一次事件中，Transaction2 依赖于 Transaction1，而 Transaction3 又依赖于 Transaction1，当 Transaction1 由于执行出现问题发生回滚时，为了保证事务的原子性，就会将 Transaction2 和 Transaction3 中的工作全部回滚，这种情况也叫做<i>级联回滚</i>（Cascading Rollback），级联回滚的发生会导致大量的工作需要撤回，是我们难以接受的，不过如果想要达到<b>绝对的</b>原子性，这件事情又是不得不去处理的，我们会在文章的后面具体介绍如何处理并行事务的原子性。</p><h2>持久性</h2><p>既然是数据库，那么一定对数据的持久存储有着非常强烈的需求，如果数据被写入到数据库中，那么数据一定能够被安全存储在磁盘上；而事务的持久性就体现在，一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-74c67a100b22f049d398073785b938ec_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-74c67a100b22f049d398073785b938ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;232&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-74c67a100b22f049d398073785b938ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-74c67a100b22f049d398073785b938ec_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当事务已经被提交之后，就无法再次回滚了，唯一能够撤回已经提交的事务的方式就是创建一个相反的事务对原操作进行『补偿』，这也是事务持久性的体现之一。</p><h2>重做日志</h2><p>与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8f97990f900b91d55734652e788022b9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-8f97990f900b91d55734652e788022b9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-8f97990f900b91d55734652e788022b9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8f97990f900b91d55734652e788022b9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上，图中的第 4、5 步就是在事务提交时执行的。</p><p>在 InnoDB 中，重做日志都是以 512 字节的块的形式进行存储的，同时因为块的大小与磁盘扇区大小相同，所以重做日志的写入可以保证原子性，不会由于机器断电导致重做日志仅写入一半并留下脏数据。</p><p>除了所有对数据库的修改会产生重做日志，因为回滚日志也是需要持久存储的，它们也会创建对应的重做日志，在发生错误后，数据库重启时会从重做日志中找出未被更新到数据库磁盘中的日志重新执行以满足事务的持久性。</p><h2>回滚日志和重做日志</h2><p>到现在为止我们了解了 MySQL 中的两种日志，回滚日志（undo log）和重做日志（redo log）；在数据库系统中，事务的原子性和持久性是由事务日志（transaction log）保证的，在实现时也就是上面提到的两种日志，前者用于对事务的影响进行撤销，后者在错误处理时对已经提交的事务进行重做，它们能保证两点：</p><ol><li>发生错误或者需要回滚的事务能够成功回滚（原子性）；</li><li>在事务提交后，数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据（持久性）；</li></ol><p>在数据库中，这两种日志经常都是一起工作的，我们<b>可以</b>将它们整体看做一条事务日志，其中包含了事务的 ID、修改的行元素以及修改前后的值。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5a22a8c8baa996c73fb87beeb0f9e74e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"183\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-5a22a8c8baa996c73fb87beeb0f9e74e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;183&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"183\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-5a22a8c8baa996c73fb87beeb0f9e74e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5a22a8c8baa996c73fb87beeb0f9e74e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>一条事务日志同时包含了修改前后的值，能够非常简单的进行回滚和重做两种操作，在这里我们也不会对重做和回滚日志展开进行介绍，可能会在之后的文章谈一谈数据库系统的恢复机制时提到两种日志的使用。</p><h2>隔离性</h2><p>其实作者在之前的文章 <a href=\"https://link.zhihu.com/?target=http%3A//draveness.me/mysql-innodb.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">『浅入浅出』MySQL 和 InnoDB</a> 就已经介绍过数据库事务的隔离性，不过为了保证文章的独立性和完整性，我们还会对事务的隔离性进行介绍，介绍的内容可能稍微有所不同。</p><p>事务的隔离性是数据库处理数据的几大基础之一，如果没有数据库的事务之间没有隔离性，就会发生在 <a href=\"https://link.zhihu.com/?target=https%3A//draveness.me/mysql-transaction%23%25E5%25B9%25B6%25E8%25A1%258C%25E4%25BA%258B%25E5%258A%25A1%25E7%259A%2584%25E5%258E%259F%25E5%25AD%2590%25E6%2580%25A7\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">并行事务的原子性</a> 一节中提到的级联回滚等问题，造成性能上的巨大损失。如果所有的事务的执行顺序都是线性的，那么对于事务的管理容易得多，但是允许事务的并行执行却能能够提升吞吐量和资源利用率，并且可以减少每个事务的等待时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-03455d3bc37a259b8b3edaa86a2841eb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-03455d3bc37a259b8b3edaa86a2841eb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-03455d3bc37a259b8b3edaa86a2841eb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-03455d3bc37a259b8b3edaa86a2841eb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当多个事务同时并发执行时，事务的隔离性可能就会被违反，虽然单个事务的执行可能没有任何错误，但是从总体来看就会造成数据库的一致性出现问题，而串行虽然能够允许开发者忽略并行造成的影响，能够很好地维护数据库的一致性，但是却会影响事务执行的性能。</p><h2>事务的隔离级别</h2><p>所以说数据库的隔离性和一致性其实是一个需要开发者去权衡的问题，为数据库提供什么样的隔离性层级也就决定了数据库的性能以及可以达到什么样的一致性；在 SQL 标准中定义了四种数据库的事务的隔离级别：<code>READ UNCOMMITED</code>、<code>READ COMMITED</code>、<code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>；每个事务的隔离级别其实都比上一级多解决了一个问题：</p><ul><li><code>RAED UNCOMMITED</code>：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；</li><li><code>READ COMMITED</code>：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；</li><li><code>REPEATABLE READ</code>：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；</li><li><code>SERIALIZABLE</code>：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</li></ul><p>以上的所有的事务隔离级别都不允许脏写入（Dirty Write），也就是当前事务更新了另一个事务已经更新但是还未提交的数据，大部分的数据库中都使用了 READ COMMITED 作为默认的事务隔离级别，但是 MySQL 使用了 REPEATABLE READ 作为默认配置；从 RAED UNCOMMITED 到 SERIALIZABLE，随着事务隔离级别变得越来越严格，数据库对于并发执行事务的性能也逐渐下降。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-94efce3eed684db6cfaf6bd4c1ca7085_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"191\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-94efce3eed684db6cfaf6bd4c1ca7085_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;191&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"191\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-94efce3eed684db6cfaf6bd4c1ca7085_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-94efce3eed684db6cfaf6bd4c1ca7085_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>对于数据库的使用者，从理论上说，并不需要知道事务的隔离级别是如何实现的，我们只需要知道这个隔离级别解决了什么样的问题，但是不同数据库对于不同隔离级别的是实现细节在很多时候都会让我们遇到意料之外的坑。</p><p>如果读者不了解脏读、不可重复读和幻读究竟是什么，可以阅读之前的文章 <a href=\"https://link.zhihu.com/?target=http%3A//draveness.me/mysql-innodb.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">『浅入浅出』MySQL 和 InnoDB</a>，在这里我们仅放一张图来展示各个隔离层级对这几个问题的解决情况。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-77d62bde6ef3aefbdfeb81cb7e98a2b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-77d62bde6ef3aefbdfeb81cb7e98a2b3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;417&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-77d62bde6ef3aefbdfeb81cb7e98a2b3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-77d62bde6ef3aefbdfeb81cb7e98a2b3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>隔离级别的实现</h2><p>数据库对于隔离级别的实现就是使用<b>并发控制机制</b>对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新，而最重要也最常见的并发控制机制，在这里我们将简单介绍三种最重要的并发控制器机制的工作原理。</p><h2>锁</h2><p>锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，而是只会锁住那些需要访问的数据项， MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6864695922c389f1db9fb64042680de3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-6864695922c389f1db9fb64042680de3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;417&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-6864695922c389f1db9fb64042680de3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6864695922c389f1db9fb64042680de3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>读锁保证了读操作可以并发执行，相互不会影响，而写锁保证了在更新数据库数据时不会有其他的事务访问或者更改同一条记录造成不可预知的问题。</p><h2>时间戳</h2><p>除了锁，另一种实现事务的隔离性的方式就是通过时间戳，使用这种方式实现事务的数据库，例如 PostgreSQL 会为每一条记录保留两个字段；<i>读时间戳</i>中报错了所有访问该记录的事务中的最大时间戳，而记录行的<i>写时间戳</i>中保存了将记录改到当前值的事务的时间戳。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c55244b5a046cd6b37c6f76697c6a120_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-c55244b5a046cd6b37c6f76697c6a120_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;167&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-c55244b5a046cd6b37c6f76697c6a120_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c55244b5a046cd6b37c6f76697c6a120_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>使用时间戳实现事务的隔离性时，往往都会使用乐观锁，先对数据进行修改，在写回时再去判断当前值，也就是时间戳是否改变过，如果没有改变过，就写入，否则，生成一个新的时间戳并再次更新数据，乐观锁其实并不是真正的锁机制，它只是一种思想，在这里并不会对它进行展开介绍。</p><h2>多版本和快照隔离</h2><p>通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取，很多数据库都对这一机制进行了实现；因为所有的读操作不再需要等待写锁的释放，所以能够显著地提升读的性能，MySQL 和 PostgreSQL 都对这一机制进行自己的实现，也就是 MVCC，虽然各自实现的方式有所不同，MySQL 就通过文章中提到的回滚日志实现了 MVCC，保证事务并行执行时能够不等待互斥锁的释放直接获取数据。</p><h2>隔离性与原子性</h2><p>在这里就需要简单提一下在在原子性一节中遇到的级联回滚等问题了，如果一个事务对数据进行了写入，这时就会获取一个互斥锁，其他的事务就想要获得改行数据的读锁就必须等待写锁的释放，自然就不会发生级联回滚等问题了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-19649d669e4e35184311330e02817807_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-19649d669e4e35184311330e02817807_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic4.zhimg.com/v2-19649d669e4e35184311330e02817807_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-19649d669e4e35184311330e02817807_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>不过在大多数的数据库，比如 MySQL 中都使用了 MVCC 等特性，也就是正常的读方法是不需要获取锁的，在想要对读取的数据进行更新时需要使用 <code>SELECT ... FOR UPDATE</code> 尝试获取对应行的互斥锁，以保证不同事务可以正常工作。</p><h2>一致性</h2><p>作者认为数据库的一致性是一个非常让人迷惑的概念，原因是数据库领域其实包含两个一致性，一个是 ACID 中的一致性、另一个是 CAP 定义中的一致性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3a851bc65ee4f64affe3f2d103edd2c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-3a851bc65ee4f64affe3f2d103edd2c2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-3a851bc65ee4f64affe3f2d103edd2c2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3a851bc65ee4f64affe3f2d103edd2c2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这两个数据库的一致性说的<b>完全不是</b>一个事情，很多很多人都对这两者的概念有非常深的误解，当我们在讨论数据库的一致性时，一定要清楚上下文的语义是什么，尽量明确的问出我们要讨论的到底是 ACID 中的一致性还是 CAP 中的一致性。</p><h2>ACID</h2><p>数据库对于 ACID 中的一致性的定义是这样的：如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。对于这个概念，它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。</p><blockquote><i>A transaction must preserve database consistency - if a transaction is run atomically in isolation starting from a consistent database, the database must again be consistent at the end of the transaction.</i></blockquote><p>我们可以将事务理解成一个函数，它接受一个外界的 SQL 输入和一个一致的数据库，它一定会返回一个一致的数据库。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-51ff9be097c220df93f312ddab6bdadd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-51ff9be097c220df93f312ddab6bdadd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-51ff9be097c220df93f312ddab6bdadd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-51ff9be097c220df93f312ddab6bdadd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>而第二层意思其实是指逻辑上的对于开发者的要求，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。</p><blockquote><i>Ensuring consistency for an individual transaction is the responsibility of the application programmer who codes the transaction. -</i> <i><a href=\"https://link.zhihu.com/?target=https%3A//www.amazon.com/Database-System-Concepts-Computer-Science/dp/0073523321\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Database System Concepts</a></i></blockquote><p>数据库 ACID 中的一致性对事务的要求不止包含对数据完整性以及合法性的检查，还包含应用层面逻辑的正确。</p><p>CAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值；而 ACID 中的一致性是指数据库的规则，如果 schema 中规定了一个值必须是唯一的，那么一致的系统必须确保在所有的操作中，该值都是唯一的，由此来看 CAP 和 ACID 对于一致性的定义有着根本性的区别。</p><h2>总结</h2><p>事务的 ACID 四大基本特性是保证数据库能够运行的基石，但是完全保证数据库的 ACID，尤其是隔离性会对性能有比较大影响，在实际的使用中我们也会根据业务的需求对隔离性进行调整，除了隔离性，数据库的原子性和持久性相信都是比较好理解的特性，前者保证数据库的事务要么全部执行、要么全部不执行，后者保证了对数据库的写入都是持久存储的、非易失的，而一致性不仅是数据库对本身数据的完整性的要求，同时也对开发者提出了要求 - 写出逻辑正确并且合理的事务。</p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "数据库事务", 
                    "tagLink": "https://api.zhihu.com/topics/20093620"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25773456", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 1, 
            "title": "java基础：Q9. 类的动态加载和静态加载", 
            "content": "<ul><li><b>类静态加载</b><br/></li></ul><br/><p>类的静态加载是指通过new方式创建对象的方式<br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-e1ae17f2269a7ee69e3ed16eb1415439_b.jpg\" data-rawwidth=\"713\" data-rawheight=\"88\" class=\"origin_image zh-lightbox-thumb\" width=\"713\" data-original=\"https://pic2.zhimg.com/v2-e1ae17f2269a7ee69e3ed16eb1415439_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;713&#39; height=&#39;88&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"713\" data-rawheight=\"88\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"713\" data-original=\"https://pic2.zhimg.com/v2-e1ae17f2269a7ee69e3ed16eb1415439_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e1ae17f2269a7ee69e3ed16eb1415439_b.jpg\"/></figure><ul><li><b><b>类动态加载</b><br/></b></li></ul><br/><p>类的动态加载是一种在java运行时动态的引入类加载的机制，它是在代码中可直接引入的。可以通过Class.forName(&#34;XXX&#34;)创建对象。</p><p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-9e18c021aa49d45794866c484797cee6_b.jpg\" data-rawwidth=\"708\" data-rawheight=\"38\" class=\"origin_image zh-lightbox-thumb\" width=\"708\" data-original=\"https://pic3.zhimg.com/v2-9e18c021aa49d45794866c484797cee6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;708&#39; height=&#39;38&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"708\" data-rawheight=\"38\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"708\" data-original=\"https://pic3.zhimg.com/v2-9e18c021aa49d45794866c484797cee6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9e18c021aa49d45794866c484797cee6_b.jpg\"/></figure>上面的静态方法返回类className的类对象，&#34;classname&#34;可以在系统运行的时候动态的引入进来，可以实现在运行过程中，通过传入不同的&#34;className&#34;创建不同的实例，这个过程完全可以在运行时确定。可见，动态加载过程中，加载的类信息可以在系统运行过程中动态添加的。在返回这样一个类对象后，我们可以通过如下方法创建一个实例：</p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-a7319553dcdde048ce6840c32be30c19_b.jpg\" data-rawwidth=\"711\" data-rawheight=\"58\" class=\"origin_image zh-lightbox-thumb\" width=\"711\" data-original=\"https://pic2.zhimg.com/v2-a7319553dcdde048ce6840c32be30c19_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;711&#39; height=&#39;58&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"711\" data-rawheight=\"58\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"711\" data-original=\"https://pic2.zhimg.com/v2-a7319553dcdde048ce6840c32be30c19_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a7319553dcdde048ce6840c32be30c19_b.jpg\"/></figure><ul><li>两者间的本质区别<br/></li></ul><br/><ol><li>静态加载的类的源程序在<b>编译时期加载</b>（必须存在），而动态加载的类在<b>编译时期可以缺席</b>（源程序不必存在）<br/></li><li>当类找不到的时候，静态加载方式会抛出异常&#34;<i>NoClassDefFoundError</i>&#34;，而动态加载方式则抛出&#34;<i>ClassNotFoundException</i>&#34;异常</li></ol>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25777260", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 0, 
            "title": "java基础：Q10. 遭遇了\"Class Not Found\"怎么办", 
            "content": "&#34;<i>ClassNotFoundException</i>&#34;异常发生后，追踪起来是非常麻烦的。一般来说，当该异常发生后，jvm在所有的可加载目录下(classpath)，并未找到对应的可加载类。<br/><ul><li>独立的java应用程序使用&#34;-cp&#34;或者&#34;-classpath&#34;来定义所有的类加载目录(包括jar)。如果有多个，在windows下以&#34;;&#34;区分开，linux下以&#34;:&#34;区分开。<br/></li></ul><br/><figure><noscript><img src=\"https://pic1.zhimg.com/v2-f50fe40eb75277ea2bd72555a88e7ecc_b.jpg\" data-rawwidth=\"833\" data-rawheight=\"29\" class=\"origin_image zh-lightbox-thumb\" width=\"833\" data-original=\"https://pic1.zhimg.com/v2-f50fe40eb75277ea2bd72555a88e7ecc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;833&#39; height=&#39;29&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"833\" data-rawheight=\"29\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"833\" data-original=\"https://pic1.zhimg.com/v2-f50fe40eb75277ea2bd72555a88e7ecc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f50fe40eb75277ea2bd72555a88e7ecc_b.jpg\"/></figure><br/><br/><ul><li>确定在所有的加载目录中(包含war,ear以及应用服务器的lib目录)，是否有jar或者class包含当前未找到的文件。<br/></li></ul><figure><noscript><img src=\"https://pic4.zhimg.com/v2-85936e3eb465fb736aef9467f64d0bd3_b.jpg\" data-rawwidth=\"826\" data-rawheight=\"30\" class=\"origin_image zh-lightbox-thumb\" width=\"826\" data-original=\"https://pic4.zhimg.com/v2-85936e3eb465fb736aef9467f64d0bd3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;826&#39; height=&#39;30&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"826\" data-rawheight=\"30\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"826\" data-original=\"https://pic4.zhimg.com/v2-85936e3eb465fb736aef9467f64d0bd3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-85936e3eb465fb736aef9467f64d0bd3_b.jpg\"/></figure><ul><li>校验jar文件的mainfest文件(MANIFEST.MF)的版本号，以及jar文件的读写权限(比如只读)。并校验是否存在同一个jar存在不同版本的问题。如果是通过动态加载机制加载，可以确定是否类名拼写是否正确(大小写敏感)<br/></li><li>检验所运行的JDK版本是否准确</li></ul><figure><noscript><img src=\"https://pic3.zhimg.com/v2-e5bf91827accdde85aa7cb8d274be966_b.jpg\" data-rawwidth=\"833\" data-rawheight=\"28\" class=\"origin_image zh-lightbox-thumb\" width=\"833\" data-original=\"https://pic3.zhimg.com/v2-e5bf91827accdde85aa7cb8d274be966_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;833&#39; height=&#39;28&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"833\" data-rawheight=\"28\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"833\" data-original=\"https://pic3.zhimg.com/v2-e5bf91827accdde85aa7cb8d274be966_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e5bf91827accdde85aa7cb8d274be966_b.jpg\"/></figure><ul><li>在jvm启动脚本中添加<b>-verbose:class</b>选项。如果在JVM启动参数中添加&#34;-verbose&#34;选项，那么所有的class都是从哪儿加载的，包括jar里面的class文件。当父类被加载或者类的静态块被执行的时候，&#34;class&#34;选项会显示一些额外信息。</li><li>查看java dump并分析dump文件，查找里面的类加载相关信息。dump文件一般在如下情况下产生</li><ul><li>当jvm发生本地错误的时候</li><li>当jvm内存溢出的时候</li><li>当发生一个jvm的指令的时候(如jmap命令，如linux环境下的kill -3 命令等)</li></ul></ul><p>我们有很多工具可以分析dump文件信息，如jstack, jmap, hprof，以及MAT(Eclipse Memory Analyzer)</p><ul><li>在网上查找下是否当前目录下确实相关依赖jar。比如：<a href=\"https://link.zhihu.com/?target=http%3A//www.findjar.com\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JAR Search - findJAR.com</a> 是一个在线搜索jar包的网站，可以通过输入类路径或者名称找到对应的类(当然一般是公有缺失的情况下可以使用这种方式)</li></ul><p>据大部分经验来看，&#34;<i>ClassNotFoundException</i>&#34;一旦发生，一般有两个原因，一个是没有引入相关jar导致的jvm找不到这个jar。第二种情况就是多个jar包中都包含这个class，导致的jar冲突。</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27685060", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 2, 
            "title": "Tensorlow 中文API: 常量(constants) - 5. tf.fill", 
            "content": "<blockquote>Tensors常量值函数<ul><li>tf.zeros(shape, dtype=tf.float32, name=None)</li><li>tf.zeros_like(tensor, dtype=None, name=None)</li><li>tf.ones(shape, dtype=tf.float32, name=None)</li><li>tf.ones_like(tensor, dtype=None, name=None)</li><li>tf.fill(dims, value, name=None)</li><li>tf.constant(value, dtype=None, shape=None, name=&#39;Const&#39;)</li></ul></blockquote><br/><h3><b>tf.fill(dims, value, name=None)</b></h3><p>创建一个维度为dims，值为value的tensor对象．该操作会创建一个维度为dims的tensor对象，并将其值设置为value，该tensor对象中的值类型和value一致</p><ul><ul><li>当value为０时，该方法等同于tf.zeros()</li><li>当value为１时，该方法等同于tf.ones()</li></ul></ul><br/>参数:<ul><li>dims: 类型为int32的tensor对象，用于表示输出的维度(1-D, n-D)，通常为一个int32数组，如：[1], [2,3]等</li><li>value: 常量值(字符串，数字等)，该参数用于设置到最终返回的tensor对象值中</li><li>name: 当前操作别名(可选)</li></ul>返回:<p>tensor对象，类型和value一致</p><br/><p>测试用例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">#coding=utf8\nimport tensorflow as tf\nimport basic.util.prints as p\n\nsess = tf.InteractiveSession()\n\ndim = [2,3]\ndata = tf.fill(dim, 5)\np.printValue(&#34;tf.fill(dim, value)&#34;, data)\ndata = tf.fill(dim, 5.0)\np.printValue(&#34;tf.fill(dim, value)&#34;, data)\ndata = tf.fill(dim, &#34;5.0&#34;)\np.printValue(&#34;tf.fill(dim, value)&#34;, data)\n\nsess.close()</code></pre></div><p>运行返回如下：</p><div class=\"highlight\"><pre><code class=\"language-text\"># tf.fill(dim, value) : Tensor(&#34;Fill:0&#34;, shape=(2, 3), dtype=int32) - \n[[5 5 5]\n [5 5 5]]\n# tf.fill(dim, value) : Tensor(&#34;Fill_1:0&#34;, shape=(2, 3), dtype=float32) - \n[[ 5.  5.  5.]\n [ 5.  5.  5.]]\n# tf.fill(dim, value) : Tensor(&#34;Fill_2:0&#34;, shape=(2, 3), dtype=string) - \n[[&#39;5.0&#39; &#39;5.0&#39; &#39;5.0&#39;]\n [&#39;5.0&#39; &#39;5.0&#39; &#39;5.0&#39;]]</code></pre></div>", 
            "topic": [
                {
                    "tag": "TensorFlow", 
                    "tagLink": "https://api.zhihu.com/topics/20032249"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "API", 
                    "tagLink": "https://api.zhihu.com/topics/19553051"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27673079", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 3, 
            "title": "Tensorlow 中文API: 常量(constants) - 4. tf.ones_like", 
            "content": "<blockquote>Tensors常量值函数<ul><li>tf.zeros(shape, dtype=tf.float32, name=None)</li><li>tf.zeros_like(tensor, dtype=None, name=None)</li><li>tf.ones(shape, dtype=tf.float32, name=None)</li><li>tf.ones_like(tensor, dtype=None, name=None)</li><li>tf.fill(dims, value, name=None)</li><li>tf.constant(value, dtype=None, shape=None, name=&#39;Const&#39;)</li></ul></blockquote><br/><h3>tf.ones_like(tensor, dtype=None, name=None)</h3><p>该方法用于创建一个所有参数均为1的tensor对象</p><p>给定一个tensor(tensor对象)，该方法会返回一个类似当前参数类型以及维度的对象，但是所有参数的值均为1．当参数dtype选定了后，所有返回参数的类型也会变成选定的类型<br/></p><p>该方法实际上为一个拷贝函数：默认情况下，它会拷贝参数tensor的类型，维度等数据，并将其中的值设置为1．当参数dtype设置后，那么拷贝后的tensor对象</p><p>参数:</p><ul><li>tensor: tensor对象</li><li><p>dtype: 返回的tensor对象类型，不设置(为空时)时返回类型同参数tensor一致．该参数必须为如下tensorflow类型： float32, float64, int8, int16, int32, int64, uint8以及complex64.</p></li><li><p>name: 该操作别名 (可选).</p></li></ul><p>返回:<br/></p><p>所有参数为1的tensor对象</p><p>测试用例与结果如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">#coding=utf8\nimport tensorflow as tf\nimport basic.util.prints as p\n\nsess = tf.InteractiveSession()\n\n# create a tensor object\noriginal = [1,2,3,4,5]\n# original = tf.zeros([5], dtype=tf.float16)\np.printRowValue(&#34;Original value&#34;, original)\n\n# 调用ones_like，默认类型为int\ndata = tf.ones_like(original)\np.printValue(&#34;tf.ones_like(original)&#34;, data)\n\n# 调用ones_like，默认类型为double\ndata = tf.ones_like(original, dtype=tf.double)\np.printValue(&#34;tf.ones_like(original, dtype=tf.double)&#34;, data)\n\n# dtype类型为: float, int, double, uint以及complex(复数), 如下类型支持\n\ndata = tf.ones_like(original, dtype=tf.float32)\np.printValue(&#34;tf.ones_like(original, dtype=tf.float32)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.float32_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.float32_ref)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.float64)\np.printValue(&#34;tf.ones_like(original, dtype=tf.float64)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.float64_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.float64_ref)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.int8)\np.printValue(&#34;tf.ones_like(original, dtype=tf.int8)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.int8_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.int8_ref)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.int16)\np.printValue(&#34;tf.ones_like(original, dtype=tf.int16)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.int16_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.int16_ref)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.int32)\np.printValue(&#34;tf.ones_like(original, dtype=tf.int32)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.int32_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.int32_ref)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.int64)\np.printValue(&#34;tf.ones_like(original, dtype=tf.int64)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.int64_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.int64_ref)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.uint8)\np.printValue(&#34;tf.ones_like(original, dtype=tf.uint8)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.uint8_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.uint8_ref)&#34;, data)\n\ndata = tf.ones_like(original, dtype=tf.double)\np.printValue(&#34;tf.ones_like(original, dtype=tf.double)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.double_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.double_ref)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.complex64)\np.printValue(&#34;tf.ones_like(original, dtype=tf.complex64)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.complex64_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.complex64_ref)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.complex128)\np.printValue(&#34;tf.ones_like(original, dtype=tf.complex128)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.complex128_ref)\np.printValue(&#34;tf.ones_like(original, dtype=tf.complex128_ref)&#34;, data)\n\n# 特殊情况\ndata = tf.ones_like(original, dtype=tf.float16)\n# p.printValue(&#34;tf.ones_like(original, dtype=tf.float16)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.float16_ref)\n# p.printValue(&#34;tf.ones_like(original, dtype=tf.float16_ref)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.uint16)\n# p.printValue(&#34;tf.ones_like(original, dtype=tf.uint16)&#34;, data)\ndata = tf.ones_like(original, dtype=tf.uint16_ref)\n# p.printValue(&#34;tf.ones_like(original, dtype=tf.uint16_ref)&#34;, data)\n\n# [ERROR] 不支持类型包括: bfloat, qint, quint\n# data = tf.ones_like(original, dtype=tf.bfloat16)\n# data = tf.ones_like(original, dtype=tf.quint8)\n# data = tf.ones_like(original, dtype=tf.qint16)\n# data = tf.ones_like(original, dtype=tf.qint32)\n\n\nsess.close()\n</code></pre></div><p>运行结果：</p><div class=\"highlight\"><pre><code class=\"language-text\"># Original value : [1, 2, 3, 4, 5]\n# tf.ones_like(original) : Tensor(&#34;ones_like:0&#34;, shape=(5,), dtype=int32) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.double) : Tensor(&#34;ones_like_1:0&#34;, shape=(5,), dtype=float64) - \n[ 1.  1.  1.  1.  1.]\n# tf.ones_like(original, dtype=tf.float32) : Tensor(&#34;ones_like_2:0&#34;, shape=(5,), dtype=float32) - \n[ 1.  1.  1.  1.  1.]\n# tf.ones_like(original, dtype=tf.float32_ref) : Tensor(&#34;ones_like_3:0&#34;, shape=(5,), dtype=float32) - \n[ 1.  1.  1.  1.  1.]\n# tf.ones_like(original, dtype=tf.float64) : Tensor(&#34;ones_like_4:0&#34;, shape=(5,), dtype=float64) - \n[ 1.  1.  1.  1.  1.]\n# tf.ones_like(original, dtype=tf.float64_ref) : Tensor(&#34;ones_like_5:0&#34;, shape=(5,), dtype=float64) - \n[ 1.  1.  1.  1.  1.]\n# tf.ones_like(original, dtype=tf.int8) : Tensor(&#34;ones_like_6:0&#34;, shape=(5,), dtype=int8) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.int8_ref) : Tensor(&#34;ones_like_7:0&#34;, shape=(5,), dtype=int8) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.int16) : Tensor(&#34;ones_like_8:0&#34;, shape=(5,), dtype=int16) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.int16_ref) : Tensor(&#34;ones_like_9:0&#34;, shape=(5,), dtype=int16) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.int32) : Tensor(&#34;ones_like_10:0&#34;, shape=(5,), dtype=int32) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.int32_ref) : Tensor(&#34;ones_like_11:0&#34;, shape=(5,), dtype=int32) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.int64) : Tensor(&#34;ones_like_12:0&#34;, shape=(5,), dtype=int64) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.int64_ref) : Tensor(&#34;ones_like_13:0&#34;, shape=(5,), dtype=int64) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.uint8) : Tensor(&#34;ones_like_14:0&#34;, shape=(5,), dtype=uint8) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.uint8_ref) : Tensor(&#34;ones_like_15:0&#34;, shape=(5,), dtype=uint8) - \n[1 1 1 1 1]\n# tf.ones_like(original, dtype=tf.double) : Tensor(&#34;ones_like_16:0&#34;, shape=(5,), dtype=float64) - \n[ 1.  1.  1.  1.  1.]\n# tf.ones_like(original, dtype=tf.double_ref) : Tensor(&#34;ones_like_17:0&#34;, shape=(5,), dtype=float64) - \n[ 1.  1.  1.  1.  1.]\n# tf.ones_like(original, dtype=tf.complex64) : Tensor(&#34;ones_like_18:0&#34;, shape=(5,), dtype=complex64) - \n[ 1.+0.j  1.+0.j  1.+0.j  1.+0.j  1.+0.j]\n# tf.ones_like(original, dtype=tf.complex64_ref) : Tensor(&#34;ones_like_19:0&#34;, shape=(5,), dtype=complex64) - \n[ 1.+0.j  1.+0.j  1.+0.j  1.+0.j  1.+0.j]\n# tf.ones_like(original, dtype=tf.complex128) : Tensor(&#34;ones_like_20:0&#34;, shape=(5,), dtype=complex128) - \n[ 1.+0.j  1.+0.j  1.+0.j  1.+0.j  1.+0.j]\n# tf.ones_like(original, dtype=tf.complex128_ref) : Tensor(&#34;ones_like_21:0&#34;, shape=(5,), dtype=complex128) - \n[ 1.+0.j  1.+0.j  1.+0.j  1.+0.j  1.+0.j]\n</code></pre></div>", 
            "topic": [
                {
                    "tag": "TensorFlow", 
                    "tagLink": "https://api.zhihu.com/topics/20032249"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "API", 
                    "tagLink": "https://api.zhihu.com/topics/19553051"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27673048", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 0, 
            "title": "Tensorlow 中文API: 常量(constants) - 3. tf.ones", 
            "content": "<blockquote>Tensors常量值函数<ul><li>tf.zeros(shape, dtype=tf.float32, name=None)</li><li>tf.zeros_like(tensor, dtype=None, name=None)</li><li>tf.ones(shape, dtype=tf.float32, name=None)</li><li>tf.ones_like(tensor, dtype=None, name=None)</li><li>tf.fill(dims, value, name=None)</li><li>tf.constant(value, dtype=None, shape=None, name=&#39;Const&#39;)</li></ul></blockquote><br/><h3><b>tf.ones(shape, dtype=tf.float32, name=None)</b></h3><p>创建一个所有的参数为1的tensor对象</p><p>这个操作会返回一个类型为dtype，并且维度为sharp的tensor，并且所有的参数均为０．</p><p><b>参数</b>:</p><ul><li>shape: 用于表示维度，通常为一个int32类型数组，或者一个一维(1-D)的<i>tf.int32</i>数字．注意不能直接使用数字</li><li>dtype: 所要创建的tensor对象的数据类型</li><li>name: 一个该操作的别名(可选的).</li></ul><p><b>返回</b>:</p><p>所有参数都为1的tensor对象</p><br/><p>用例以及结果：</p><div class=\"highlight\"><pre><code class=\"language-text\">#coding=utf8\nimport tensorflow as tf\nimport basic.util.prints as p\n\nsess = tf.InteractiveSession()\n\n# 创建一个维度为１, 类型为int的对象\ndata = tf.ones([1], dtype=tf.int32)\np.printValue(&#34;sess.ones([1], dtype=tf.int32)&#34;, data)\n# 创建一个维度为3, 类型为int的对象\ndata = tf.ones([1,2,1], dtype=tf.int32)\np.printValue(&#34;sess.ones([3,4,5], dtype=tf.int32)&#34;, data)\n# double\ndata = tf.ones([8], dtype=tf.double)\np.printValue(&#34;sess.ones([1], dtype=tf.double)&#34;, data)\n# float\ndata = tf.ones([8], dtype=tf.float16)\np.printValue(&#34;sess.ones([1], dtype=tf.float16)&#34;, data)\n\n# [ERROR] sharp不能为int类型，需要制定为tensor sharp类型\n# data = tf.ones(1, dtype=tf.int32)\n# p.printValue(&#34;tf.ones(1, dtype=tf.int32)&#34;, data)\n\n# 可是使用如下方法替换\ndata = tf.ones([1], dtype=tf.int32)\np.printValue(&#34;tf.ones([1], dtype=tf.int32)&#34;, data)\n\nsess.close()</code></pre></div>执行返回结果<div class=\"highlight\"><pre><code class=\"language-text\"># sess.ones([1], dtype=tf.int32) : Tensor(&#34;ones:0&#34;, shape=(1,), dtype=int32) - \n[1]\n# sess.ones([3,4,5], dtype=tf.int32) : Tensor(&#34;ones_1:0&#34;, shape=(1, 2, 1), dtype=int32) - \n[[[1]\n  [1]]]\n# sess.ones([1], dtype=tf.double) : Tensor(&#34;ones_2:0&#34;, shape=(8,), dtype=float64) - \n[ 1.  1.  1.  1.  1.  1.  1.  1.]\n# sess.ones([1], dtype=tf.float16) : Tensor(&#34;ones_3:0&#34;, shape=(8,), dtype=float16) - \n[ 0.  0.  0.  0.  0.  0.  0.  0.]\n# tf.ones([1], dtype=tf.int32) : Tensor(&#34;ones_4:0&#34;, shape=(1,), dtype=int32) - \n[1]\n\n</code></pre></div>", 
            "topic": [
                {
                    "tag": "TensorFlow", 
                    "tagLink": "https://api.zhihu.com/topics/20032249"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "API", 
                    "tagLink": "https://api.zhihu.com/topics/19553051"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27673001", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 2, 
            "title": "Tensorlow 中文API: 常量(constants) - 2. tf.zeros_like", 
            "content": "<blockquote>Tensors常量值函数<ul><li>tf.zeros(shape, dtype=tf.float32, name=None)</li><li>tf.zeros_like(tensor, dtype=None, name=None)</li><li>tf.ones(shape, dtype=tf.float32, name=None)</li><li>tf.ones_like(tensor, dtype=None, name=None)</li><li>tf.fill(dims, value, name=None)</li><li>tf.constant(value, dtype=None, shape=None, name=&#39;Const&#39;)</li></ul></blockquote><h3><b>tf.zeros_like(tensor, dtype=None, name=None)</b></h3><p>该方法用于创建一个所有参数均为０的tensor对象</p><p>给定一个tensor(tensor对象)，该方法会返回一个类似当前参数类型以及维度的对象，但是所有参数的值均为０．当参数dtype选定了后，所有返回参数的类型也会变成选定的类型<br/></p><p>该方法实际上为一个拷贝函数：默认情况下，它会拷贝参数tensor的类型，维度等数据，并将其中的值设置为０．当参数dtype设置后，那么拷贝后的tensor对象</p><p><b>参数:</b></p><ul><li>tensor: tensor对象</li><li><p>dtype: 返回的tensor对象类型，不设置(为空时)时返回类型同参数tensor一致．该参数必须为如下tensorflow类型： float32, float64, int8, int16, int32, int64, uint8以及complex64.</p></li><li><p>name: 该操作别名 (可选).</p></li></ul><p><b>返回:</b><br/></p><p>所有参数为０的tensor对象</p><p>测试用例与结果如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">#coding=utf8\nimport tensorflow as tf\nimport basic.util.prints as p\n\nsess = tf.InteractiveSession()\n\n# create a tensor object\noriginal = [[1,2,3],[4,5,6]]\np.printRowValue(&#34;Original value&#34;, original)\n\n# 调用zeros_like，默认类型为int\ndata = tf.zeros_like(original)\np.printValue(&#34;tf.zeros_like(original)&#34;, data)\n\n# 调用zeros_like，默认类型为double\ndata = tf.zeros_like(original, dtype=tf.double)\np.printValue(&#34;tf.zeros_like(original, dtype=tf.double)&#34;, data)\n\n# dtype类型为: float, int, double, uint以及complex(复数), 如下类型支持\ndata = tf.zeros_like(original, dtype=tf.float16)\ndata = tf.zeros_like(original, dtype=tf.float16_ref)\ndata = tf.zeros_like(original, dtype=tf.float32)\ndata = tf.zeros_like(original, dtype=tf.float32_ref)\ndata = tf.zeros_like(original, dtype=tf.float64)\ndata = tf.zeros_like(original, dtype=tf.float64_ref)\ndata = tf.zeros_like(original, dtype=tf.int8)\ndata = tf.zeros_like(original, dtype=tf.int8_ref)\ndata = tf.zeros_like(original, dtype=tf.int16)\ndata = tf.zeros_like(original, dtype=tf.int16_ref)\ndata = tf.zeros_like(original, dtype=tf.int32)\ndata = tf.zeros_like(original, dtype=tf.int32_ref)\ndata = tf.zeros_like(original, dtype=tf.int64)\ndata = tf.zeros_like(original, dtype=tf.int64_ref)\ndata = tf.zeros_like(original, dtype=tf.uint8)\ndata = tf.zeros_like(original, dtype=tf.uint8_ref)\ndata = tf.zeros_like(original, dtype=tf.uint16)\ndata = tf.zeros_like(original, dtype=tf.uint16_ref)\ndata = tf.zeros_like(original, dtype=tf.double)\ndata = tf.zeros_like(original, dtype=tf.double_ref)\ndata = tf.zeros_like(original, dtype=tf.complex64)\ndata = tf.zeros_like(original, dtype=tf.complex64_ref)\ndata = tf.zeros_like(original, dtype=tf.complex128)\ndata = tf.zeros_like(original, dtype=tf.complex128_ref)\n\n# [ERROR] 不支持类型包括: bfloat, qint, quint\n# data = tf.zeros_like(original, dtype=tf.bfloat16)\n# data = tf.zeros_like(original, dtype=tf.quint8)\n# data = tf.zeros_like(original, dtype=tf.qint16)\n# data = tf.zeros_like(original, dtype=tf.qint32)\n\n\nsess.close()\n</code></pre></div><div class=\"highlight\"><pre><code class=\"language-text\"># Original value : [[1, 2, 3], [4, 5, 6]]\n# tf.zeros_like(original) : Tensor(&#34;zeros_like:0&#34;, shape=(2, 3), dtype=int32) - \n[[0 0 0]\n [0 0 0]]\n# tf.zeros_like(original, dtype=tf.double) : Tensor(&#34;zeros_like_1:0&#34;, shape=(2, 3), dtype=float64) - \n[[ 0.  0.  0.]\n [ 0.  0.  0.]]</code></pre></div><b>该方法在参数复制并置０的时候非常有用</b>", 
            "topic": [
                {
                    "tag": "TensorFlow", 
                    "tagLink": "https://api.zhihu.com/topics/20032249"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "API", 
                    "tagLink": "https://api.zhihu.com/topics/19553051"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27670869", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 0, 
            "title": "Tensorlow 中文API: 常量(constants) - 1. tf.zeros", 
            "content": "<blockquote>Tensors常量值函数<ul><li>tf.zeros(shape, dtype=tf.float32, name=None)</li><li>tf.zeros_like(tensor, dtype=None, name=None)</li><li>tf.ones(shape, dtype=tf.float32, name=None)</li><li>tf.ones_like(tensor, dtype=None, name=None)</li><li>tf.fill(dims, value, name=None)</li><li>tf.constant(value, dtype=None, shape=None, name=&#39;Const&#39;)</li></ul></blockquote><p>在Tensorflow中，任何参数的运算和操作都需要转换成对应的TensorFlow数据类型，例如现实中的字符串类型是不能直接在TensorFlow中进行运算的，必须转换成对应的TensorFlow类型才行</p><p>故而Tensorflow提供了一些函数用于生成常量值．如上是一些基本的生成常量的方法．</p><h3><b>tf.zeros(shape, dtype=tf.float32, name=None)</b></h3><p>创建一个所有的参数为０的tensor对象</p><p>This operation returns a tensor of type dtype with shape shape and all elements set to zero.</p><p>这个操作会返回一个类型为dtype，并且维度为sharp的tensor，并且所有的参数均为０．</p>参数:<ul><li>shape: 用于表示维度，通常为一个int32类型数组，或者一个一维(1-D)的<i>tf.int32</i>数字．<b>注意不能直接使用数字</b></li><li>dtype: 所要创建的tensor对象的数据类型</li><li>name: 一个该操作的别名(可选的).</li></ul>返回:<p>所有参数都为０的tensor对象</p><p>用例以及结果：</p><div class=\"highlight\"><pre><code class=\"language-text\">#coding=utf8\nimport tensorflow as tf\nimport basic.util.prints as p\n\nsess = tf.InteractiveSession()\n\n# 创建一个维度为１, 类型为int的对象\ndata = tf.zeros([1], dtype=tf.int32)\np.printValue(&#34;sess.zeros([1], dtype=tf.int32)&#34;, data)\n# 创建一个维度为3, 类型为int的对象\ndata = tf.zeros([1,2,1], dtype=tf.int32)\np.printValue(&#34;sess.zeros([3,4,5], dtype=tf.int32)&#34;, data)\n# double\ndata = tf.zeros([8], dtype=tf.double)\np.printValue(&#34;sess.zeros([1], dtype=tf.double)&#34;, data)\n# float\ndata = tf.zeros([8], dtype=tf.float16)\np.printValue(&#34;sess.zeros([1], dtype=tf.float16)&#34;, data)\n\n\nsess.close()\n</code></pre></div><div class=\"highlight\"><pre><code class=\"language-text\"># sess.zeros([1], dtype=tf.int32) : Tensor(&#34;zeros:0&#34;, shape=(1,), dtype=int32) - \n[0]\n# sess.zeros([3,4,5], dtype=tf.int32) : Tensor(&#34;zeros_1:0&#34;, shape=(1, 2, 1), dtype=int32) - \n[[[0]\n  [0]]]\n# sess.zeros([1], dtype=tf.double) : Tensor(&#34;zeros_2:0&#34;, shape=(8,), dtype=float64) - \n[ 0.  0.  0.  0.  0.  0.  0.  0.]\n# sess.zeros([1], dtype=tf.float16) : Tensor(&#34;zeros_3:0&#34;, shape=(8,), dtype=float16) - \n[ 0.  0.  0.  0.  0.  0.  0.  0.]</code></pre></div>另外，需要注意的是不能直接使用数字作为<i>shape</i>的参数，例如下面用例就会报错：<div class=\"highlight\"><pre><code class=\"language-text\">...\n# sharp不能为int类型，需要制定为tensor sharp类型\ndata = tf.zeros(1, dtype=tf.int32)\np.printValue(&#34;tf.zeros(1, dtype=tf.int32)&#34;, data)\n...</code></pre></div><div class=\"highlight\"><pre><code class=\"language-text\">Traceback (most recent call last):\n  File &#34;/services/git/GIthub/ml-example/tensorflow/basic/casting/string_to_number.py&#34;, line 20, in &lt;module&gt;\n    data = tf.zeros(1, dtype=tf.int32)\n  File &#34;/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/array_ops.py&#34;, line 623, in zeros\n    output = fill(shape, constant(0, dtype=dtype), name=name)\n  File &#34;/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/gen_array_ops.py&#34;, line 531, in fill\n    return _op_def_lib.apply_op(&#34;Fill&#34;, dims=dims, value=value, name=name)\n  File &#34;/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/op_def_library.py&#34;, line 655, in apply_op\n    op_def=op_def)\n  File &#34;/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py&#34;, line 2156, in create_op\n    set_shapes_for_outputs(ret)\n  File &#34;/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py&#34;, line 1612, in set_shapes_for_outputs\n    shapes = shape_func(op)\n  File &#34;/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/array_ops.py&#34;, line 1165, in _FillShape\n    dimensions_shape = op.inputs[0].get_shape().with_rank(1)\n  File &#34;/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/tensor_shape.py&#34;, line 625, in with_rank\n    raise ValueError(&#34;Shape %s must have rank %d&#34; % (self, rank))\nValueError: Shape () must have rank 1</code></pre></div>这个时候可以通过如下两个方式解决<div class=\"highlight\"><pre><code class=\"language-text\"># 可是使用如下方法替换\ndata = tf.zeros([1], dtype=tf.int32)\np.printValue(&#34;tf.zeros([1], dtype=tf.int32)&#34;, data)\n</code></pre></div>", 
            "topic": [
                {
                    "tag": "TensorFlow", 
                    "tagLink": "https://api.zhihu.com/topics/20032249"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "API", 
                    "tagLink": "https://api.zhihu.com/topics/19553051"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>import basic.util.prints as p basic是什么库？</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27515373", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 2, 
            "title": "机器学习：梯度下降(Gradient Descent)算法", 
            "content": "<p>线性回归是表示因变量和自变量之间的因果关系，其表现形式为一次特征的线性组合，在二维空间中是一条直线，在三维空间中是一个平面，然后推广到n维空间．简单来理解，可以理解为多元一次方程，其中多元表示的对这个结果的多个影响方面，简称特征．</p><h2>1 问题的引出</h2><p>梯度下降算法是线性回归，先化一个为一个特征θ1，θ0为偏置项，最后列出的误差函数如下图所示：</p><h2>手动求解</h2><p>目标是优化J(θ1)，得到其最小化，下图中的×为y</p><blockquote>(i)</blockquote>，下面给出TrainSet，{(1,1),(2,2),(3,3)}通过手动寻找来找到最优解，由图可见当θ1取1时，与y<blockquote>(i)</blockquote>完全重合，J(θ1) = 0<p>下面是θ1的取值与对应的J(θ1)变化情况</p><p>由此可见，最优解即为0，现在来看通过梯度下降法来自动找到最优解，对于上述待优化问题，下图给出其三维图像，可见要找到最优解，就要不断向下探索，使得J(θ)最小即可。</p><h2>2 梯度下降的几何形式</h2><p>下图为梯度下降的目的，找到J（θ）的最小值。</p><p>其实，J(θ)的真正图形是类似下面这样的，因为其是一个凸函数，只有一个全局最优解，所以不必担心像上图一样找到局部最优解</p><p>直到了要找到图形中的最小值之后，下面介绍自动求解最小值的办法，这就是梯度下降法</p><p>对参数向量θ中的每个分量θj，迭代减去速率因子a* (dJ(θ)/dθj)即可，后边一项为J(θ)关于θj的偏导数</p><h2>3 梯度下降的原理</h2><p>导数的概念</p><p>由公式可见，对点x0的导数反映了函数在点x0处的瞬时变化速率，或者叫在点x0处的斜度。推广到多维函数中，就有了梯度的概念，梯度是一个向量组合，反映了多维图形中变化速率最快的方向。</p><p>下图展示了对单个特征θ1的直观图形，起始时导数为正，θ1减小后并以新的θ1为基点重新求导，一直迭代就会找到最小的θ1，若导数为负时，θ1的就会不断增到，直到找到使损失函数最小的值。</p><p>有一点需要注意的是步长a的大小，如果a太小，则会迭代很多次才找到最优解，若a太大，可能跳过最优，从而找不到最优解。</p><p>另外，在不断迭代的过程中，梯度值会不断变小，所以θ1的变化速度也会越来越慢，所以不需要使速率a的值越来越小</p><p>下图就是寻找过程</p><p>当梯度下降到一定数值后，每次迭代的变化很小，这时可以设定一个阈值，只要变化小鱼该阈值，就停止迭代，而得到的结果也近似于最优解。</p><p>若损失函数的值不断变大，则有可能是步长速率a太大，导致算法不收敛，这时可适当调整a值</p><p>为了选择参数a，就需要不断测试，因为a太大太小都不太好。</p><p>如果想跳过的a与算法复杂的迭代，可以选择 Normal Equation。</p><h2>4 随机梯度下降</h2><p>对于样本数量额非常之多的情况，Batch Gradient Descent算法会非常耗时，因为每次迭代都要便利所有样本，可选用Stochastic Gradient Descent 算法，需要注意外层循环Loop，因为只遍历一次样本，不见得会收敛。</p><p>随机梯度算法就可以用作在线学习了，但是注意随机梯度的结果并非完全收敛，而是在收敛结果处波动的，可能由非线性可分的样本引起来的：</p><p>可以有如下解决办法：（来自MLIA）</p><p>1. 动态更改学习速率a的大小，可以增大或者减小</p><p>2. 随机选样本进行学习 </p><br/><p>文章转自：<a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/ooon/p/4947688.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">（二）深入梯度下降(Gradient Descent)算法</a></p>", 
            "topic": [
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "线性回归", 
                    "tagLink": "https://api.zhihu.com/topics/19650500"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27264111", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 0, 
            "title": "TensorFlow(2). 安装", 
            "content": "<p>TensorFlow提供了二进制包安装, 或者使用源代码安装. 本文仅介绍python的库安装</p><h2><b>Linux下安装</b></h2><p>TensorFlow Python API 依赖 Python 2.7 版本. 默认情况下linux均已安装了python该版本</p><p>在 Linux 和 Mac 下最简单的安装方式, 是使用 <a href=\"https://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pip\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pip</a> 安装.</p><p>1. 首先需要校验下本地python版本</p><div class=\"highlight\"><pre><code class=\"language-text\">~$ python --version\nPython 2.7.6</code></pre></div>如果不是,则通过如下命令安装,(如果为centos等,可以使用其他类似命令如yum安装)<div class=\"highlight\"><pre><code class=\"language-text\">~$ sudo apt-get install libpython2.7\n</code></pre></div><p>2. 校验是否安装了pip</p><div class=\"highlight\"><pre><code class=\"language-text\">~$ pip --version\npip 1.5.4 from /usr/lib/python2.7/dist-packages (python 2.7)</code></pre></div><p>如果没有安装,可通过如下命令安装</p><div class=\"highlight\"><pre><code class=\"language-text\">~$ sudo apt-get install libpipeline1</code></pre></div><p>3. 安装tensorflow, 可以使用cpu和gpu版本</p><p>关于GPU版本,可能会涉及到一些额外软件安装, 可参考官网:</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/tensorflow/tensorflow\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">tensorflow/tensorflow</a><br/><a href=\"https://link.zhihu.com/?target=http%3A//www.tensorfly.cn/tfdoc/get_started/os_setup.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TensorFlow 官方文档中文版</a><br/><div class=\"highlight\"><pre><code class=\"language-text\"># 仅使用 CPU 的版本\n$ pip install https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl\n\n# 开启 GPU 支持的版本 (安装该版本的前提是已经安装了 CUDA sdk)\n$ pip install https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl\n</code></pre></div><h2><b>基于 Docker 的安装</b></h2><p>TensorFLow也支持通过 <a href=\"https://link.zhihu.com/?target=http%3A//docker.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Docker</a> 运行 TensorFlow. 该方式的优点是不用操心软件依赖问题.</p><p>首先, <a href=\"https://link.zhihu.com/?target=http%3A//docs.docker.com/engine/installation/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">安装 Docker</a>. 一旦 Docker 已经启动运行, 可以通过命令启动一个容器:</p><div class=\"highlight\"><pre><code class=\"language-text\">$ docker run -it b.gcr.io/tensorflow/tensorflow</code></pre></div><p>该命令将启动一个已经安装好 TensorFlow 及相关依赖的容器.</p><h2><b>Windows下安装</b></h2><p>windows下安装比较麻烦, 首先要安装python和pip, 然后才安装tensorflow.</p><p>windows下支持的python版本只有两个,分别为python3.5和python3.6. </p><p>1. 首先点开地址:<a href=\"https://link.zhihu.com/?target=https%3A//www.python.org/downloads/windows/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Python Releases for Windows</a> 下载3.5版本python, 包含x86和x64版本, 根据系统选择下载版本</p><br/><figure><noscript><img src=\"https://pic4.zhimg.com/v2-5cee3156d1be2482838cd1dfe4735a77_b.png\" data-rawwidth=\"898\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb\" width=\"898\" data-original=\"https://pic4.zhimg.com/v2-5cee3156d1be2482838cd1dfe4735a77_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;898&#39; height=&#39;557&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"898\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"898\" data-original=\"https://pic4.zhimg.com/v2-5cee3156d1be2482838cd1dfe4735a77_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5cee3156d1be2482838cd1dfe4735a77_b.png\"/></figure>下载完成后,一路next直接安装完毕即可. <p>3. 查看是否环境变量设置好了, 并且测试是否可正常打印, 默认条件下python3会自动将安装目录放到path环境变量中,如果没有放入, 则手动添加即可<br/><figure><noscript><img src=\"https://pic1.zhimg.com/v2-f0b50aa67ed24b10a6742f4fbe8ce108_b.png\" data-rawwidth=\"676\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb\" width=\"676\" data-original=\"https://pic1.zhimg.com/v2-f0b50aa67ed24b10a6742f4fbe8ce108_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;676&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"676\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"676\" data-original=\"https://pic1.zhimg.com/v2-f0b50aa67ed24b10a6742f4fbe8ce108_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f0b50aa67ed24b10a6742f4fbe8ce108_b.png\"/></figure></p><p>这样, python就安装好了. </p><p>4. 下一步去pip官网安装pip, pip可以安装很多python的库,比如numpy, tensorflow等等. 官网地址为: <a href=\"https://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pip%23downloads\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Python Package Index</a></p><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-ac3e22ac231e47248ad2b47dffcb7013_b.png\" data-rawwidth=\"1103\" data-rawheight=\"429\" class=\"origin_image zh-lightbox-thumb\" width=\"1103\" data-original=\"https://pic4.zhimg.com/v2-ac3e22ac231e47248ad2b47dffcb7013_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1103&#39; height=&#39;429&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1103\" data-rawheight=\"429\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1103\" data-original=\"https://pic4.zhimg.com/v2-ac3e22ac231e47248ad2b47dffcb7013_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ac3e22ac231e47248ad2b47dffcb7013_b.png\"/></figure>我们使用源码安装,所以选择如上的source文件,</p><p>将下载下来的gz文件解压到c盘根目录(可选其他目录)</p><p>5. 进入该目录(C:\\pip-9.0.1), 同时执行如下命令:</p><div class=\"highlight\"><pre><code class=\"language-text\">C:\\pip-9.0.1&gt;python setup.py install</code></pre></div><p>然后等待其执行完成即可,这个时候pip安装好了,并会在python的安装目录的scripts目录下有对应的pip.exe文件</p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-14f2f267d014ae6748e537874c9f6f0a_b.png\" data-rawwidth=\"760\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb\" width=\"760\" data-original=\"https://pic3.zhimg.com/v2-14f2f267d014ae6748e537874c9f6f0a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;760&#39; height=&#39;322&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"760\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"760\" data-original=\"https://pic3.zhimg.com/v2-14f2f267d014ae6748e537874c9f6f0a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-14f2f267d014ae6748e537874c9f6f0a_b.png\"/></figure><p>6. 讲该目录(<b>{python_home/Scripts}</b>)添加到pip环境变量中即可</p><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-07b1e2af8acacd061e1f5898c9c42dd7_b.png\" data-rawwidth=\"665\" data-rawheight=\"164\" class=\"origin_image zh-lightbox-thumb\" width=\"665\" data-original=\"https://pic4.zhimg.com/v2-07b1e2af8acacd061e1f5898c9c42dd7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;665&#39; height=&#39;164&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"665\" data-rawheight=\"164\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"665\" data-original=\"https://pic4.zhimg.com/v2-07b1e2af8acacd061e1f5898c9c42dd7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-07b1e2af8acacd061e1f5898c9c42dd7_b.png\"/></figure>这样, windows环境下的python和pip均安装完成.</p><p>7. 继续安装tensorflow</p><div class=\"highlight\"><pre><code class=\"language-text\"># 仅使用 CPU 的版本\n$ pip install https://ci.tensorflow.org/view/Nightly/job/nightly-win/M=windows,PY=35/lastSuccessfulBuild/artifact/cmake_build/tf_python/dist/tensorflow-1.2.0rc1-cp35-cp35m-win_amd64.whl\n\n# 开启 GPU 支持的版本 (安装该版本的前提是已经安装了 CUDA sdk)\n$ pip install https://ci.tensorflow.org/view/Nightly/job/nightly-win/M=windows-gpu,PY=35/lastSuccessfulBuild/artifact/cmake_build/tf_python/dist/tensorflow_gpu-1.2.0rc1-cp35-cp35m-win_amd64.whl</code></pre></div><p>在命令行输入制定命令即可, 它会自动下载依赖, 并安装好tensorflow</p><p>可以执行如下语句测试tensorflow是否安装好了</p><div class=\"highlight\"><pre><code class=\"language-text\">$ python\n\n&gt;&gt;&gt; import tensorflow as tf\n&gt;&gt;&gt; hello = tf.constant(&#39;Hello, TensorFlow!&#39;)\n&gt;&gt;&gt; sess = tf.Session()\n&gt;&gt;&gt; sess.run(hello)\nHello, TensorFlow!\n&gt;&gt;&gt; a = tf.constant(10)\n&gt;&gt;&gt; b = tf.constant(32)\n&gt;&gt;&gt; sess.run(a+b)\n42\n</code></pre></div>", 
            "topic": [
                {
                    "tag": "TensorFlow", 
                    "tagLink": "https://api.zhihu.com/topics/20032249"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "人工智能", 
                    "tagLink": "https://api.zhihu.com/topics/19551275"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27216777", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 0, 
            "title": "Tensorflow(1)：简介", 
            "content": "<h2>关于 TensorFlow</h2><p>TensorFlow是<a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%25E8%25B0%25B7%25E6%25AD%258C\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">谷歌</a>基于DistBelief进行研发的第二代<a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%25E4%25BA%25BA%25E5%25B7%25A5%25E6%2599%25BA%25E8%2583%25BD/9180\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">人工智能</a><a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25B3%25BB%25E7%25BB%259F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">学习系统</a>，其命名来源于本身的运行原理。Tensor（张量）意味着N维数组，Flow（流）意味着基于数据流图的计算，TensorFlow为张量从流图的一端流动到另一端计算过程。TensorFlow是将复杂的数据结构传输至人工智能神经网中进行分析和处理过程的系统。如下是来自官网的描述：<br/></p><blockquote>TensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。<br/></blockquote><p>TensorFlow可被用于<a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%25E8%25AF%25AD%25E9%259F%25B3%25E8%25AF%2586%25E5%2588%25AB\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">语音识别</a>或<a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%25E5%259B%25BE%25E5%2583%258F%25E8%25AF%2586%25E5%2588%25AB\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">图像识别</a>等多项机器深度学习领域，同时支持c和python两种语言。<br/></p><p>其中文网址为：<a href=\"https://link.zhihu.com/?target=http%3A//www.tensorfly.cn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TensorFlow中文社区-首页</a></p><br/><h2>支持算法</h2><br/>TensorFlow 表达了高层次的机器学习计算，大幅简化了第一代系统，并且具备更好的灵活性和可延展性。TensorFlow一大亮点是支持异构设备分布式计算，它能够在各个平台上自动运行模型，从手机、单个CPU / GPU到成百上千GPU卡组成的分布式系统。[1]<br/>从目前的文档看，TensorFlow支持CNN、<a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/RNN\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">RNN</a>和<a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/LSTM\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LSTM</a>算法，这都是目前在Image，Speech和NLP最流行的深度神经网络模型。<br/><h2>什么是数据流图</h2><p>数据流图用“结点”（nodes）和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”（tensor）。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。<br/></p><h2>特征与优势</h2><ul><li>高度的灵活性<br/></li></ul><br/><p>TensorFlow 不是一个严格的“神经网络”库。只要你可以将你的计算表示为一个数据流图，你就可以使用Tensorflow。你来构建图，描写驱动计算的内部循环。我们提供了有用的工具来帮助你组装“子图”（常用于神经网络），当然用户也可以自己在Tensorflow基础上写自己的“上层库”。</p><ul><li><b>真正的可移植性</b><br/></li></ul><br/><p>Tensorflow 在CPU和GPU上运行，比如说可以运行在台式机、服务器、手机移动设备等等。想要在没有特殊硬件的前提下，在你的笔记本上跑一下机器学习的新想法？Tensorflow可以办到这点。准备将你的训练模型在多个CPU上规模化运算，又不想修改代码？Tensorflow可以办到这点。想要将你的训练好的模型作为产品的一部分用到手机app里？Tensorflow可以办到这点。你改变主意了，想要将你的模型作为云端服务运行在自己的服务器上，或者运行在Docker容器里？Tensorfow也能办到。Tensorflow就是这么拽 <br/></p><ul><li><b>自动求微分</b><br/></li></ul><br/><p>基于梯度的机器学习算法会受益于Tensorflow自动求微分的能力。作为Tensorflow用户，你只需要定义预测模型的结构，将这个结构和目标函数（objective function）结合在一起，并添加数据，Tensorflow将自动为你计算相关的微分导数。计算某个变量相对于其他变量的导数仅仅是通过扩展你的图来完成的，所以你能一直清楚看到究竟在发生什么。</p><ul><li><b>多语言支持</b><br/></li></ul><br/><p>Tensorflow 有一个合理的c++使用界面，也有一个易用的python使用界面来构建和执行你的graphs。你可以直接写python/c++程序，也可以用交互式的ipython界面来用Tensorflow尝试些想法，它可以帮你将笔记、代码、可视化等有条理地归置好。<b>目前除开c和python外，不支持其他语言。</b></p><ul><li><b>性能最优化</b><br/></li></ul><br/><p>比如说你又一个32个CPU内核、4个GPU显卡的工作站，想要将你工作站的计算潜能全发挥出来？由于Tensorflow 给予了线程、队列、异步操作等以最佳的支持，Tensorflow 让你可以将你手边硬件的计算潜能全部发挥出来。你可以自由地将Tensorflow图中的计算元素分配到不同设备上，Tensorflow可以帮你管理好这些不同副本。</p><p>开发人员可以根据自己需求通过TensorFlow设计不同的人工智能产品。对于很多创业公司来说，他们大都没有能力理解并开发一个与国际同步的深度学习系统，所以TensorFlow会大大降低深度学习在各个行业中的应用难度。使得很多几遍高等数学不是很好的开发人员也能投入到机器学习中。这对于整个机器学习行业都是很有裨益的。</p>", 
            "topic": [
                {
                    "tag": "TensorFlow", 
                    "tagLink": "https://api.zhihu.com/topics/20032249"
                }, 
                {
                    "tag": "人工智能", 
                    "tagLink": "https://api.zhihu.com/topics/19551275"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/26957666", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 3, 
            "title": "Python库之SciPy教程", 
            "content": "SciPy函数库在NumPy库的基础上增加了众多的数学、科学以及工程计算中常用的库函数。例如线性代数、常微分方程数值求解、信号处理、图像处理、稀疏矩阵等等。由于其涉及的领域众多、本书没有能力对其一一的进行介绍。作为入门介绍，让我们看看如何用SciPy进行插值处理、信号滤波以及用C语言加速计算。<p><b>SciPy是世界上著名的Python开源科学计算库，建立在Numpy之上。它增加的功能包括数值积分、最优化、统计和一些专用函数。</b></p><p>本篇文档包括以下内容：<br/>1、文件的输入/输出；<br/>2、统计；<br/>3、信号处理；</p><h2><b>1. <a href=\"https://link.zhihu.com/?target=http%3A//scipy.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">scipy.io</span><span class=\"invisible\"></span></a>文件的输入和输出</b><br/></h2><p>导入相关依赖包</p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; from scipy import io as spio\n&gt;&gt;&gt; import numpy as np</code></pre></div>创建一个数组并保存到文件中<div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; a = np.ones((3,3))\n&gt;&gt;&gt; a\narray([[ 1.,  1.,  1.],\n       [ 1.,  1.,  1.],\n       [ 1.,  1.,  1.]])\n&gt;&gt;&gt; spio.savemat(&#39;file.mat&#39;,{&#39;a&#39;:a})\n&gt;&gt;&gt; \n&gt;&gt;&gt; data = spio.loadmat(&#39;file.mat&#39;, struct_as_record=True)\n&gt;&gt;&gt; data\n{&#39;a&#39;: array([[ 1.,  1.,  1.],\n       [ 1.,  1.,  1.],\n       [ 1.,  1.,  1.]]), &#39;__version__&#39;: &#39;1.0&#39;, &#39;__header__&#39;: &#39;MATLAB 5.0 MAT-file Platform: posix, Created on: Wed May 17 16:19:49 2017&#39;, &#39;__globals__&#39;: []}\n&gt;&gt;&gt; data[&#39;a&#39;]\narray([[ 1.,  1.,  1.],\n       [ 1.,  1.,  1.],\n       [ 1.,  1.,  1.]])\n</code></pre></div><p>载入txt文件：numpy.loadtxt()/numpy.savetxt()<br/>智能导入文本/csv文件：numpy.genfromtxt()/numpy.recfromcsv()<br/>高速，有效率但numpy特有的二进制格式：numpy.save()/numpy.load()</p><h2><b>2. 统计</b><br/></h2><h3><b>2.1 分析随机数</b></h3><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; import scipy.stats as stats\n&gt;&gt;&gt; generated = stats.norm.rvs(size = 900)\n&gt;&gt;&gt; generated.dtype\ndtype(&#39;float64&#39;)\n&gt;&gt;&gt; Mean, std = stats.norm.fit(generated)\n&gt;&gt;&gt; Mean\n-0.00098392245844106043\n&gt;&gt;&gt; std\n0.96347564118451801\n&gt;&gt;&gt; \n</code></pre></div><p><a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/link%3Furl%3DpYYIZK6nt71PTR3rzRhF-wuOZv0Wwr2hRysRQUMDhGPCivoUYwXqa2zvwbTTDbFlipFDP7-R-J0FnDOS2SImQ6OdFGGBqYvtza5Ot_1Eagq\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">偏度（skewnes）</a>描述的是概率分布的偏斜程度，我们需要做一个偏度检验。该检验有两个返回值，其中第二个返回值是p-value，即观察到的数据服从正态分布的概率，取值为0-1<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; stats.skewtest(generated)\nSkewtestResult(statistic=-0.4167400083108363, pvalue=0.67686858714771658)</code></pre></div><p>我们有67%把握认为其服从正态分布</p><p><a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/link%3Furl%3DTO4FcebhoNG72usc6Ea9rE2Jv4weUpHEqDiLIYN521_Pm04ZhVl1xcbYaMZy26olBDFEp-O_8wJxYXACqVofmNyHn9A1aIkH6iwwb1kzrru\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">峰度（kurtosis）</a>描述的是概率分布的陡峭程度。该检验和偏度检验类似。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; stats.kurtosistest(generated)\nKurtosistestResult(statistic=1.6452313569108934, pvalue=0.099922109358986863)</code></pre></div><p><a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/link%3Furl%3DzxoyO2axAS8j7z2IEL1ASapVZavj9Z2iLUaB0vEHzTfaCsOozm73wq7gbajDPMlZ5BJI3mxhsOPAvLaC8cuCkNhZi2nO8oBIiuYdkQbTkgPlW45GhYgzj9VNQSZlCpTC6vOLt4D9Cvpp5Thb6ulI1q\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">正态性检验（normality test）</a>可以检验数据服从正太分布的程度。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; stats.normaltest(generated)\nNormaltestResult(statistic=2.8804584522897754, pvalue=0.23687345486954675)\n</code></pre></div><p>使用Scipy我们很方便的得到数据所在区域中某一百分比处的数值<br/></p><p>例如获取到95%处的值</p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; stats.scoreatpercentile(generated, 95)\n1.5367563534669961</code></pre></div><p>同样返过来也可以通过某一个数值获取其百分比</p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; stats.percentileofscore(generated, 1)\n85.888888888888886\n</code></pre></div><h2><b>2.2 样本比对（比较股票对数收益率）</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; a1 = np.random.rand(10)\n&gt;&gt;&gt; a2 = np.random.rand(10)\n&gt;&gt;&gt; a1\narray([ 0.19910597,  0.16902027,  0.46305597,  0.29216104,  0.52134258,\n        0.0849457 ,  0.1391109 ,  0.44985439,  0.78996225,  0.06177391])\n&gt;&gt;&gt; a2\narray([ 0.23200311,  0.47033435,  0.05213133,  0.00768839,  0.86955667,\n        0.69786845,  0.04830981,  0.00823025,  0.31119304,  0.19254339])\n&gt;&gt;&gt; stats.ttest_ind(a1,a2)\nTtest_indResult(statistic=0.23215451698313397, pvalue=0.81903697972304368)\n</code></pre></div><p>均值检验可以检验两组不同的样本是否有相同的均值，返回值有两个，其中第二个为p-value,取值范围问为0~1<br/></p><p>Kolmogorov-Smirnov检验可以判断两组样本同分布的可能性<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; stats.ks_2samp(a1,a2)\nKs_2sampResult(statistic=0.40000000000000002, pvalue=0.31285267601695582) </code></pre></div><p>在两组数据对数收益率的差值上运用Jarque-Bera正态性检验<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; stats.jarque_bera(a1-a2)\n(0.70085877257661988, 0.70438557126873813)\n&gt;&gt;&gt; stats.jarque_bera(a1-a2)[-1]\n0.70438557126873813\n</code></pre></div>", 
            "topic": [
                {
                    "tag": "Python 库", 
                    "tagLink": "https://api.zhihu.com/topics/19644560"
                }, 
                {
                    "tag": "scipy", 
                    "tagLink": "https://api.zhihu.com/topics/19891785"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/26955071", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 1, 
            "title": "十分钟入门Matplotlib", 
            "content": "<p>数据的处理、分析和可视化已经成为 Python 近年来最重要的应用之一。这种现象又进一步引出“大数据”分析等类似的话题，而大数据分析在人们所能预见的诸多领域内都有广泛应用，这其中就包含笔者个人感兴趣的机器学习。</p><p>Python 在处理数据、分析数据以及数据可视化方面拥有很多功能强大的工具，这也是 Python 在科学领域中能够迅速发展的一个主要原因。</p><p>在接下来的一系列文章中，我们将介绍 Python 科学计算中涉及的主要的库，并且学习如何使用它们处理数据以满足我们的需求。但是我们并非只是停留在快速写出模板代码来使用这些库的层面上，我们还会了解这些库背后的数学知识，以帮助我们更好地理解库的运行原理。</p><p>首先，我们将从一个功能非常强大的库 Matplotlib 开始介绍，在后面的文章中也会一直用到这个库。</p><h2><b>什么是 Matplotlib?</b></h2><p>简单来说，Matplotlib 是 Python 的一个绘图库。它包含了大量的工具，你可以使用这些工具创建各种图形，包括简单的散点图，正弦曲线，甚至是三维图形。Python 科学计算社区经常使用它完成数据可视化的工作。</p><p>你可以在他们的网站上了解到更多 Matplotlib 背后的设计思想，但是我强烈建议你先浏览一下他们的图库，体会一下这个库的各种神奇功能。</p><h2><b>画一个简单的图形</b></h2><p>首先我们要画一条在 [0, 2pi] 上的正弦曲线。读者应该会注意到我们在这里使用了 Numpy 库，但是即便你没有使用过这个库也不用担心，在后面的文章中我们也会介绍到 Numpy 库。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np</code></pre></div><p>以上这些就是我们将要用到的导入模块。<br/></p><h2>简单的绘图</h2><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 50)\n&gt;&gt;&gt; x\narray([ 0.        ,  0.12822827,  0.25645654,  0.38468481,  0.51291309,\n        0.64114136,  0.76936963,  0.8975979 ,  1.02582617,  1.15405444,\n        1.28228272,  1.41051099,  1.53873926,  1.66696753,  1.7951958 ,\n        1.92342407,  2.05165235,  2.17988062,  2.30810889,  2.43633716,\n        2.56456543,  2.6927937 ,  2.82102197,  2.94925025,  3.07747852,\n        3.20570679,  3.33393506,  3.46216333,  3.5903916 ,  3.71861988,\n        3.84684815,  3.97507642,  4.10330469,  4.23153296,  4.35976123,\n        4.48798951,  4.61621778,  4.74444605,  4.87267432,  5.00090259,\n        5.12913086,  5.25735913,  5.38558741,  5.51381568,  5.64204395,\n        5.77027222,  5.89850049,  6.02672876,  6.15495704,  6.28318531])\n&gt;&gt;&gt; plt.plot(x,np.sin(x))\n[&lt;matplotlib.lines.Line2D object at 0x7f898fbe7590&gt;]\n&gt;&gt;&gt; plt.show()</code></pre></div><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-da45f20ceb554fe1c0d0b17c6ce2c1c8_b.jpg\" data-rawwidth=\"636\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb\" width=\"636\" data-original=\"https://pic1.zhimg.com/v2-da45f20ceb554fe1c0d0b17c6ce2c1c8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;636&#39; height=&#39;477&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"636\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"636\" data-original=\"https://pic1.zhimg.com/v2-da45f20ceb554fe1c0d0b17c6ce2c1c8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-da45f20ceb554fe1c0d0b17c6ce2c1c8_b.jpg\"/></figure>上面的代码将画出一个简单的正弦曲线。np.linspace(0, 2 * np.pi, 50) 这段代码将会生成一个包含 50 个元素的数组，这 50 个元素均匀的分布在 [0, 2pi] 的区间上。</p><p>plot 命令以一种简洁优雅的方式创建了图形。提醒一下，如果没有第一个参数 x，图形的 x 轴坐标将不再是 0 到 2pi，而应该是数组的索引范围。</p><p>最后一行代码 plt.show()将图形显示出来，如果没有这行代码图像就不会显示。</p><h2><b>在一张图上绘制两个数据集</b></h2><p>大多数时候读者可能更想在一张图上绘制多个数据集。用 Matplotlib 也可以轻松实现这一点。</p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; x=np.linspace(0,2*np.pi, 50)\n&gt;&gt;&gt; x\narray([ 0.        ,  0.12822827,  0.25645654,  0.38468481,  0.51291309,\n        0.64114136,  0.76936963,  0.8975979 ,  1.02582617,  1.15405444,\n        1.28228272,  1.41051099,  1.53873926,  1.66696753,  1.7951958 ,\n        1.92342407,  2.05165235,  2.17988062,  2.30810889,  2.43633716,\n        2.56456543,  2.6927937 ,  2.82102197,  2.94925025,  3.07747852,\n        3.20570679,  3.33393506,  3.46216333,  3.5903916 ,  3.71861988,\n        3.84684815,  3.97507642,  4.10330469,  4.23153296,  4.35976123,\n        4.48798951,  4.61621778,  4.74444605,  4.87267432,  5.00090259,\n        5.12913086,  5.25735913,  5.38558741,  5.51381568,  5.64204395,\n        5.77027222,  5.89850049,  6.02672876,  6.15495704,  6.28318531])\n&gt;&gt;&gt; plt.plot(x, np.sin(x),x,np.sin(2*x))\n[&lt;matplotlib.lines.Line2D object at 0x7f9af35ca750&gt;, &lt;matplotlib.lines.Line2D object at 0x7f9af35ca910&gt;]\n&gt;&gt;&gt; plt.show()\n</code></pre></div><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-fb0869acde1e2c5ba209ef750c91384c_b.jpg\" data-rawwidth=\"637\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb\" width=\"637\" data-original=\"https://pic1.zhimg.com/v2-fb0869acde1e2c5ba209ef750c91384c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;637&#39; height=&#39;478&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"637\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"637\" data-original=\"https://pic1.zhimg.com/v2-fb0869acde1e2c5ba209ef750c91384c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fb0869acde1e2c5ba209ef750c91384c_b.jpg\"/></figure>上面的代码同时绘制了表示函数 sin(x) 和 sin(2x) 的图形。这段代码和前面绘制一个数据集的代码几乎完全相同，只有一点例外，这段代码在调用 plt.plot() 的时候多传入了一个数据集，并用逗号与第一个数据集分隔开。<br/></p><h2><b>自定义图形的外观</b></h2><p>当在同一个图形上展示多个数据集时，通过改变线条的外观来区分不同的数据集变得非常必要。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; x = np.linspace(0,2*np.pi, 50)\n&gt;&gt;&gt; plt.plot(x,np.sin(x), &#39;r-o&#39;,x,np.cos(x),&#39;g--&#39;)\n[&lt;matplotlib.lines.Line2D object at 0x7f9af31d1490&gt;, &lt;matplotlib.lines.Line2D object at 0x7f9af31d1590&gt;]\n&gt;&gt;&gt; plt.show()\n</code></pre></div><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-31079cd469488d51dd8ff6ddbc5e93d8_b.jpg\" data-rawwidth=\"640\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-31079cd469488d51dd8ff6ddbc5e93d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;478&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-31079cd469488d51dd8ff6ddbc5e93d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-31079cd469488d51dd8ff6ddbc5e93d8_b.jpg\"/></figure>上述代码展示了两种不同的曲线样式：&#39;r-o&#39; 和 &#39;g--&#39;。字母 &#39;r&#39; 和 &#39;g&#39; 代表线条的颜色，后面的符号代表线和点标记的类型。例如 &#39;-o&#39; 代表包含实心点标记的实线，&#39;--&#39; 代表虚线。其他的参数需要读者自己去尝试，这也是学习 Matplotlib 最好的方式。</p><br/><p>颜色： 蓝色 - &#39;b&#39; 绿色 - &#39;g&#39; 红色 - &#39;r&#39; 青色 - &#39;c&#39; 品红 - &#39;m&#39; 黄色 - &#39;y&#39; 黑色 - &#39;k&#39;（&#39;b&#39;代表蓝色，所以这里用黑色的最后一个字母） 白色 - &#39;w&#39; 线： 直线 - &#39;-&#39; 虚线 - &#39;--&#39; 点线 - &#39;:&#39; 点划线 - &#39;-.&#39; 常用点标记 点 - &#39;.&#39; 像素 - &#39;,&#39; 圆 - &#39;o&#39; 方形 - &#39;s&#39; 三角形 - &#39;^&#39; 更多点标记样式点击:<a href=\"https://link.zhihu.com/?target=http%3A//matplotlib.org/api/markers_api.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">markers - Matplotlib 2.0.2 documentation</a></p><h2><b>使用子图</b></h2><p>使用子图可以在一个窗口绘制多张图。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; x = np.linspace(0,2*np.pi, 50)\n&gt;&gt;&gt; plt.subplot(2,1,1)\n&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7f9af2ba9550&gt;\n&gt;&gt;&gt; plt.plot(x,np.sin(x), &#39;r&#39;)\n[&lt;matplotlib.lines.Line2D object at 0x7f9af29ae090&gt;]\n&gt;&gt;&gt; plt.subplot(2,1,2)\n&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7f9af27e8f10&gt;\n&gt;&gt;&gt; plt.plot(x,np.cos(x),&#39;g&#39;)\n[&lt;matplotlib.lines.Line2D object at 0x7f9af27f8450&gt;]\n&gt;&gt;&gt; plt.show()\n\n</code></pre></div><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-15012e325b0ecbf55b3bef060ab6eecc_b.jpg\" data-rawwidth=\"639\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb\" width=\"639\" data-original=\"https://pic1.zhimg.com/v2-15012e325b0ecbf55b3bef060ab6eecc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;639&#39; height=&#39;484&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"639\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"639\" data-original=\"https://pic1.zhimg.com/v2-15012e325b0ecbf55b3bef060ab6eecc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-15012e325b0ecbf55b3bef060ab6eecc_b.jpg\"/></figure>使用子图只需要一个额外的步骤，就可以像前面的例子一样绘制数据集。即在调用 plot() 函数之前需要先调用 subplot() 函数。该函数的第一个参数代表子图的总行数，第二个参数代表子图的总列数，第三个参数代表活跃区域。</p><p>活跃区域代表当前子图所在绘图区域，绘图区域是按从左至右，从上至下的顺序编号。例如在 4×4 的方格上，活跃区域 6 在方格上的坐标为 (2, 2)。</p><h2><b>简单的散点图</b></h2><p>散点图是一堆离散点的集合。用 Matplotlib 画散点图也同样非常简单。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; y=np.sin(x)\n&gt;&gt;&gt; y\narray([  0.00000000e+00,   1.27877162e-01,   2.53654584e-01,\n         3.75267005e-01,   4.90717552e-01,   5.98110530e-01,\n         6.95682551e-01,   7.81831482e-01,   8.55142763e-01,\n         9.14412623e-01,   9.58667853e-01,   9.87181783e-01,\n         9.99486216e-01,   9.95379113e-01,   9.74927912e-01,\n         9.38468422e-01,   8.86599306e-01,   8.20172255e-01,\n         7.40277997e-01,   6.48228395e-01,   5.45534901e-01,\n         4.33883739e-01,   3.15108218e-01,   1.91158629e-01,\n         6.40702200e-02,  -6.40702200e-02,  -1.91158629e-01,\n        -3.15108218e-01,  -4.33883739e-01,  -5.45534901e-01,\n        -6.48228395e-01,  -7.40277997e-01,  -8.20172255e-01,\n        -8.86599306e-01,  -9.38468422e-01,  -9.74927912e-01,\n        -9.95379113e-01,  -9.99486216e-01,  -9.87181783e-01,\n        -9.58667853e-01,  -9.14412623e-01,  -8.55142763e-01,\n        -7.81831482e-01,  -6.95682551e-01,  -5.98110530e-01,\n        -4.90717552e-01,  -3.75267005e-01,  -2.53654584e-01,\n        -1.27877162e-01,  -2.44929360e-16])\n&gt;&gt;&gt; plt.scatter(x,y)\n&lt;matplotlib.collections.PathCollection object at 0x7f9af2503e90&gt;\n&gt;&gt;&gt; plt.show()\n</code></pre></div><p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-372f574b53614960d236d59e1e970326_b.jpg\" data-rawwidth=\"632\" data-rawheight=\"471\" class=\"origin_image zh-lightbox-thumb\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-372f574b53614960d236d59e1e970326_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;632&#39; height=&#39;471&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"632\" data-rawheight=\"471\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-372f574b53614960d236d59e1e970326_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-372f574b53614960d236d59e1e970326_b.jpg\"/></figure>正如上面代码所示，你只需要调用 scatter() 函数并传入两个分别代表 x 坐标和 y 坐标的数组。注意，我们通过 plot 命令并将线的样式设置为 &#39;bo&#39; 也可以实现同样的效果。</p><h2><b>彩色映射散点图</b></h2><p>另一种你可能用到的图形是彩色映射散点图。这里我们会根据数据的大小给每个点赋予不同的颜色和大小，并在图中添加一个颜色栏。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; x = np.random.rand(1000)\n&gt;&gt;&gt; y = np.random.rand(1000)\n&gt;&gt;&gt; size = np.random.rand(1000)*50\n&gt;&gt;&gt; colour = np.random.rand(1000)*50\n&gt;&gt;&gt; plt.scatter(x,y,size,colour)\n&lt;matplotlib.collections.PathCollection object at 0x7f9af29e0990&gt;\n&gt;&gt;&gt; plt.colorbar()\n&lt;matplotlib.colorbar.Colorbar object at 0x7f9af2dce690&gt;\n&gt;&gt;&gt; plt.show()\n</code></pre></div><p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-260aa211b88961f1d1f6f99aaf3c6b61_b.jpg\" data-rawwidth=\"641\" data-rawheight=\"474\" class=\"origin_image zh-lightbox-thumb\" width=\"641\" data-original=\"https://pic2.zhimg.com/v2-260aa211b88961f1d1f6f99aaf3c6b61_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;641&#39; height=&#39;474&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"641\" data-rawheight=\"474\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"641\" data-original=\"https://pic2.zhimg.com/v2-260aa211b88961f1d1f6f99aaf3c6b61_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-260aa211b88961f1d1f6f99aaf3c6b61_b.jpg\"/></figure>上面的代码大量的用到了 np.random.rand(1000)，原因是我们绘图的数据都是随机产生的。</p><p>同前面一样我们用到了 scatter() 函数，但是这次我们传入了另外的两个参数，分别为所绘点的大小和颜色。通过这种方式使得图上点的大小和颜色根据数据的大小产生变化。</p><p>然后我们用 colorbar() 函数添加了一个颜色栏。</p><h2><b>直方图</b></h2><p>直方图是另一种常见的图形，也可以通过几行代码创建出来。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; x = np.random.rand(1000)\n&gt;&gt;&gt; plt.hist(x, 50)\n&gt;&gt;&gt; plt.show()\n\n</code></pre></div><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-664e654ca9ac8a89acf2b33f8cbcbc48_b.jpg\" data-rawwidth=\"639\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb\" width=\"639\" data-original=\"https://pic1.zhimg.com/v2-664e654ca9ac8a89acf2b33f8cbcbc48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;639&#39; height=&#39;478&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"639\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"639\" data-original=\"https://pic1.zhimg.com/v2-664e654ca9ac8a89acf2b33f8cbcbc48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-664e654ca9ac8a89acf2b33f8cbcbc48_b.jpg\"/></figure>直方图是 Matplotlib 中最简单的图形之一。你只需要给 hist() 函数传入一个包含数据的数组。第二个参数代表数据容器的个数。数据容器代表不同的值的间隔，并用来包含我们的数据。数据容器越多，图形上的数据条就越多。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; x = np.linspace(0,2*np.pi, 50)\n&gt;&gt;&gt; plt.plot(x,np.sin(x), &#39;r-x&#39;, label=&#39;Sin(x)&#39;)\n[&lt;matplotlib.lines.Line2D object at 0x7f9af2db4890&gt;]\n&gt;&gt;&gt; plt.plot(x,np.cos(x), &#39;g-^&#39;, label=&#39;Cos(x)&#39;)\n[&lt;matplotlib.lines.Line2D object at 0x7f9af2db4990&gt;]\n&gt;&gt;&gt; plt.legend\n&lt;function legend at 0x7f9b0dbcfe60&gt;\n&gt;&gt;&gt; plt.legend()\n&lt;matplotlib.legend.Legend object at 0x7f9af2dbb110&gt;\n&gt;&gt;&gt; plt.xlabel(&#39;Rads&#39;)\n&lt;matplotlib.text.Text object at 0x7f9af31d1d50&gt;\n&gt;&gt;&gt; plt.ylabel(&#39;Amplitude&#39;)\n&lt;matplotlib.text.Text object at 0x7f9af3185110&gt;\n&gt;&gt;&gt; plt.title(&#39;Sin and Cos Waves&#39;)\n&lt;matplotlib.text.Text object at 0x7f9af313c710&gt;\n&gt;&gt;&gt; plt.show()\n</code></pre></div><figure><noscript><img src=\"https://pic4.zhimg.com/v2-80767a5563d2819d79b33ac575f14a8b_b.jpg\" data-rawwidth=\"636\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb\" width=\"636\" data-original=\"https://pic4.zhimg.com/v2-80767a5563d2819d79b33ac575f14a8b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;636&#39; height=&#39;478&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"636\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"636\" data-original=\"https://pic4.zhimg.com/v2-80767a5563d2819d79b33ac575f14a8b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-80767a5563d2819d79b33ac575f14a8b_b.jpg\"/></figure><p>为了给图形添加图例，我们需要在 plot() 函数中添加命名参数 &#39;label&#39; 并赋予该参数相应的标签。然后调用 legend() 函数就会在我们的图形中添加图例。</p><p>接下来我们只需要调用函数 title()，xlabel() 和 ylabel() 就可以为图形添加标题和标签。</p><p>以上内容应该足够帮助读者开始使用 Matplotlib 和 Python 实现数据可视化，但是这些内容并不全面。我强烈建议读者亲自尝试使用这个工具，笔者也是通过这种方式掌握了这个工具。画一些图形，改变样式并使用子图功能，然后你就会很快掌握 Matplotlib 的使用方式。</p><p>这是一篇是关于如何使用 Matplotlib 和 Python 完成数据可视化的文章，也是 Python 科学计算系列文章中的第一篇。我希望读者能从中有所收获，并且对 Matplotlib 库更加熟悉。</p><p>本人翻译地址为：<a href=\"https://link.zhihu.com/?target=http%3A//www.datadependence.com/2016/04/scientific-python-matplotlib/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">An Introduction to Scientific Python - Matplotlib - Data Dependence</a></p>", 
            "topic": [
                {
                    "tag": "Python 库", 
                    "tagLink": "https://api.zhihu.com/topics/19644560"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "Matplotlib", 
                    "tagLink": "https://api.zhihu.com/topics/19748855"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/26936110", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 1, 
            "title": "python基础之元组", 
            "content": "<h1><b>元组（tuple）</b></h1><p>tuple是另一种有序的数据类型，与list比较类似。主要不同的一点是tuple被创建后就不能对其进行修改。所以，tuple与list不同，没有append(),pop(),insert()这些方法可以使用。获取元素的方法和list是一样的，可以通过索引来访问（也是从0开始的），只不过不能赋值成为其他的元素。<br/></p><p>因为tuple不可变，所以代码更安全。如果可以的话，我们尽量使用tuple代替list。<br/></p><p>定义一个空的tuple，使用 () ：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; t = ()\n&gt;&gt;&gt; t\n()\n&gt;&gt;&gt;\n</code></pre></div><p>可以使用 + 对元组进行连接，例如：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; t1 = (1,2,3)\n&gt;&gt;&gt; t2 = (4,5,6)\n&gt;&gt;&gt; t3=t1+t2\n&gt;&gt;&gt; t3\n(1, 2, 3, 4, 5, 6)\n&gt;&gt;&gt; \n\n</code></pre></div><p>元组中的元素不能被删除，但是我们可以使用 del 删除整个元组，删除后可以重新定义：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; t4 = (1,2,3,4)\n&gt;&gt;&gt; t4\n(1, 2, 3, 4)\n&gt;&gt;&gt; del t4[1]\nTraceback (most recent call last):\n  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;\nTypeError: &#39;tuple&#39; object doesn&#39;t support item deletion\n&gt;&gt;&gt; \n</code></pre></div><p>事实上，上面所说的元素不变是指每个元素的指向永远不变。即指向1，就不能改成指向2，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的，例如：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt;&gt;&gt; tup = (1,2,3,[4,5,6])\n&gt;&gt;&gt; tup[3][0]=10\n&gt;&gt;&gt; tup[3][1]=10\n&gt;&gt;&gt; tup[3][2]=10\n&gt;&gt;&gt; tup\n(1, 2, 3, [10, 10, 10])\n&gt;&gt;&gt; \n</code></pre></div>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25739306", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 1, 
            "title": "java基础：编译时和运行时的区别", 
            "content": "在java开发设计过程中，了解java运行时和编译时的区别是非常有必要的。如下从几个问题来描述两者的区别<ul><li>Q1: 如下代码片段中，A行和B行的区别是什么</li></ul><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-b35ec121569fe2905b994fb2755589bc_b.png\" data-rawwidth=\"797\" data-rawheight=\"182\" class=\"origin_image zh-lightbox-thumb\" width=\"797\" data-original=\"https://pic1.zhimg.com/v2-b35ec121569fe2905b994fb2755589bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;797&#39; height=&#39;182&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"797\" data-rawheight=\"182\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"797\" data-original=\"https://pic1.zhimg.com/v2-b35ec121569fe2905b994fb2755589bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b35ec121569fe2905b994fb2755589bc_b.png\"/></figure>A行是在编译时计算值，B行是在运行时计算值，当该类编译后，如果使用一些反编译器(如jd-gui)反编译后可以看到，实际代码如下：</p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-8a03fe8f8ed3c6b326c724d6dbb9de2a_b.png\" data-rawwidth=\"662\" data-rawheight=\"198\" class=\"origin_image zh-lightbox-thumb\" width=\"662\" data-original=\"https://pic3.zhimg.com/v2-8a03fe8f8ed3c6b326c724d6dbb9de2a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;662&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"662\" data-rawheight=\"198\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"662\" data-original=\"https://pic3.zhimg.com/v2-8a03fe8f8ed3c6b326c724d6dbb9de2a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8a03fe8f8ed3c6b326c724d6dbb9de2a_b.png\"/></figure><p>java编译时会做一些优化操作，比如替换一些final的不可变更的参数，在这里，由于number1和number2都是final的，那么product1肯定是确定的，这里就会在编译时计算出product1的值。</p><ul><li>除了如上的一些代码优化话，再什么其他的情况下查看编译后的class文件是非常有用的？</li></ul><p>java中的泛型。泛型是编译时会做优化，通过编译文件可以非常方便的看到其对应的实际类型，如下例子：</p><p>实际编码如下：</p><p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-ce1e5a8fedc0e6ea2ac87b6b7ed09f79_b.png\" data-rawwidth=\"530\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb\" width=\"530\" data-original=\"https://pic2.zhimg.com/v2-ce1e5a8fedc0e6ea2ac87b6b7ed09f79_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;530&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"530\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"530\" data-original=\"https://pic2.zhimg.com/v2-ce1e5a8fedc0e6ea2ac87b6b7ed09f79_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ce1e5a8fedc0e6ea2ac87b6b7ed09f79_b.png\"/></figure>反编译后的代码如下：</p><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-e99791e586c66386ff18eff92d2d6e17_b.png\" data-rawwidth=\"760\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb\" width=\"760\" data-original=\"https://pic4.zhimg.com/v2-e99791e586c66386ff18eff92d2d6e17_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;760&#39; height=&#39;446&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"760\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"760\" data-original=\"https://pic4.zhimg.com/v2-e99791e586c66386ff18eff92d2d6e17_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e99791e586c66386ff18eff92d2d6e17_b.png\"/></figure>可以，在编译后的文件中，Parent类会显示的被实际类型取代。</p><ul><li>重写，重载，泛型，分别是在运行时还是编译时执行的</li></ul><br/><br/><p>1. 方法重载是在编译时执行的，因为，在编译的时候，如果调用了一个重载的方法，那么编译时必须确定他调用的方法是哪个。如：</p><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-1f40e87438c4597a2df75a3878364198_b.png\" data-rawwidth=\"714\" data-rawheight=\"60\" class=\"origin_image zh-lightbox-thumb\" width=\"714\" data-original=\"https://pic1.zhimg.com/v2-1f40e87438c4597a2df75a3878364198_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;714&#39; height=&#39;60&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"714\" data-rawheight=\"60\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"714\" data-original=\"https://pic1.zhimg.com/v2-1f40e87438c4597a2df75a3878364198_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1f40e87438c4597a2df75a3878364198_b.png\"/></figure>当调用evaluate(&#34;hello&#34;)时候，我们在编译时就可以确定他调用的method #1.</p><p>2. 方法的重写是在运行时进行的。这个也常被称为运行时多态的体现。编译器是没有办法知道它调用的到底是那个方法，相反的，只有在jvm执行过程中，才知晓到底是父子类中的哪个方法被调用了。如下：</p><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-71acd6ee0c8302ab353715b81215cd5f_b.png\" data-rawwidth=\"710\" data-rawheight=\"188\" class=\"origin_image zh-lightbox-thumb\" width=\"710\" data-original=\"https://pic4.zhimg.com/v2-71acd6ee0c8302ab353715b81215cd5f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;710&#39; height=&#39;188&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"710\" data-rawheight=\"188\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"710\" data-original=\"https://pic4.zhimg.com/v2-71acd6ee0c8302ab353715b81215cd5f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-71acd6ee0c8302ab353715b81215cd5f_b.png\"/></figure>试想，当有如下一个接口的时候，我们是无法确定到底是调用父类还是子类的方法</p><p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-8be17564e45fff54bc94965fc9703492_b.png\" data-rawwidth=\"553\" data-rawheight=\"44\" class=\"origin_image zh-lightbox-thumb\" width=\"553\" data-original=\"https://pic3.zhimg.com/v2-8be17564e45fff54bc94965fc9703492_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;553&#39; height=&#39;44&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"553\" data-rawheight=\"44\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"553\" data-original=\"https://pic3.zhimg.com/v2-8be17564e45fff54bc94965fc9703492_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8be17564e45fff54bc94965fc9703492_b.png\"/></figure>3. 泛型(类型检测)，这个发生在编译时。编译器会在编译时对泛型类型进行检测，并吧他重写成实际的对象类型(非泛型代码)，这样就可以被JVM执行了。这个过程被称为&#34;类型擦除&#34;。</p><p>类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。</p><p>类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。类型擦除的主要过程如下：<br/>1). 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。<br/>2). 移除所有的类型参数。<br/></p><br/><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-5e90eb16237a000cc4ae739b03c25d0b_b.png\" data-rawwidth=\"452\" data-rawheight=\"15\" class=\"origin_image zh-lightbox-thumb\" width=\"452\" data-original=\"https://pic4.zhimg.com/v2-5e90eb16237a000cc4ae739b03c25d0b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;452&#39; height=&#39;15&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"452\" data-rawheight=\"15\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"452\" data-original=\"https://pic4.zhimg.com/v2-5e90eb16237a000cc4ae739b03c25d0b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5e90eb16237a000cc4ae739b03c25d0b_b.png\"/></figure>在编译后变成：</p><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-cfb9f956ddab69e312ce57c6405554db_b.png\" data-rawwidth=\"322\" data-rawheight=\"17\" class=\"content_image\" width=\"322\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;322&#39; height=&#39;17&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"322\" data-rawheight=\"17\" class=\"content_image lazy\" width=\"322\" data-actualsrc=\"https://pic4.zhimg.com/v2-cfb9f956ddab69e312ce57c6405554db_b.png\"/></figure>4. 注解。注解即有可能是运行时也有可能是编译时。</p><p>如java中的@Override注解就是典型的编译时注解，他会在编译时会检查一些简单的如拼写的错误(与父类方法不相同)等<br/></p><p>同样的@Test注解是junit框架的注解，他是一个运行时注解，他可以在运行时动态的配置相关信息如timeout等。</p><p>5. 异常。异常即有可能是运行时异常，也有可能是编译时异常。</p><p>RuntimeException是一个用于指示编译器不需要检查的异常。RuntimeException 是在jvm运行过程中抛出异常的父类。对于运行时异常是不需要再方法中显示的捕获或者处理的，如<i>NullPointerException</i>, <i>ArrayIndexOutOfBoundsException</i></p><p>已检查的异常是被编译器在编译时候已经检查过的异常，这些异常需要在try/catch块中处理的异常。</p><p>6. AOP. Aspects能够在编译时，预编译时以及运行时使用。</p><p>1). 编译时：当你拥有源码的时候，AOP编译器(AspectJ编译器)能够编译源码并生成编织后的class。这些编织进入的额外功能是在编译时放进去的。</p><p>2). 预编译时：织入过程有时候也叫二进制织入，它是用来织入到哪些已经存在的class文件或者jar中的。</p><p>3). 运行时：当被织入的对象已经被加载如jvm中后，可以动态的织入到这些类中一些信息。</p><p>7. 继承：继承是编译时执行的，它是静态的。这个过程编译后就已经确定</p><p>8. 代理(delegate)：也称动态代理，是在运行时执行。</p><ul><li>你如何理解&#34;组合优于继承&#34;这句话</li></ul><p>继承是一个多态的工具，而非重用工具。在没有多态关联关系的对象间，一些程序员倾向于使用继承来保持重用。但事实是，只有当子类和父类的关系为&#34;is a&#34;的关系时候，继承才会使用。</p><p>1. 不要使用继承来实现代码的重用。如果两者之间没有&#34;is a&#34;的关系，那么使用组合来实现重用。当父类的某个方法修改后，子类的相关实现也有可能会被更改。</p><p>2. 不要为了多态而使用继承。如果你只是为了实现多态而采用继承模式，那么实际上组合模式更加适合你，而且更加简洁和灵活。</p><p>这也就是为什么GoF设计模式中常说&#34;组合优于继承&#34;的原因。</p><br/><ul><li>你能区分编译时继承和运行时继承的区别吗？请列举例子说明</li></ul><p>实际上在java中只支持编译时继承。java语言原生是不支持运行时时继承的。一般情况下所谓编译时继承如下：</p><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-97bc8f65801518eda62e5524c789daec_b.png\" data-rawwidth=\"714\" data-rawheight=\"77\" class=\"origin_image zh-lightbox-thumb\" width=\"714\" data-original=\"https://pic1.zhimg.com/v2-97bc8f65801518eda62e5524c789daec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;714&#39; height=&#39;77&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"714\" data-rawheight=\"77\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"714\" data-original=\"https://pic1.zhimg.com/v2-97bc8f65801518eda62e5524c789daec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-97bc8f65801518eda62e5524c789daec_b.png\"/></figure><figure><noscript><img src=\"https://pic4.zhimg.com/v2-27707874cdfc108b77551dfbf1999a9f_b.png\" data-rawwidth=\"715\" data-rawheight=\"103\" class=\"origin_image zh-lightbox-thumb\" width=\"715\" data-original=\"https://pic4.zhimg.com/v2-27707874cdfc108b77551dfbf1999a9f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;715&#39; height=&#39;103&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"715\" data-rawheight=\"103\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"715\" data-original=\"https://pic4.zhimg.com/v2-27707874cdfc108b77551dfbf1999a9f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-27707874cdfc108b77551dfbf1999a9f_b.png\"/></figure>如上有两个类，其中Child为Parent的子类。当我们创建一个Parent实例的时候(无论实际对象为Parent还是Child)，编译器在编译期间会将其替换成实际类型。所以继承实际上在编译时就已经确定了。</p><p>而在java中，可以设计通过组合模式来尝试模拟下所谓的运行时继承。</p><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-44c4e2969d9449a5c32301368503f807_b.png\" data-rawwidth=\"711\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb\" width=\"711\" data-original=\"https://pic4.zhimg.com/v2-44c4e2969d9449a5c32301368503f807_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;711&#39; height=&#39;89&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"711\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"711\" data-original=\"https://pic4.zhimg.com/v2-44c4e2969d9449a5c32301368503f807_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-44c4e2969d9449a5c32301368503f807_b.png\"/></figure><figure><noscript><img src=\"https://pic2.zhimg.com/v2-d8c844f49893ad3629d7b188a6c2c9f5_b.png\" data-rawwidth=\"705\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb\" width=\"705\" data-original=\"https://pic2.zhimg.com/v2-d8c844f49893ad3629d7b188a6c2c9f5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;705&#39; height=&#39;173&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"705\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"705\" data-original=\"https://pic2.zhimg.com/v2-d8c844f49893ad3629d7b188a6c2c9f5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d8c844f49893ad3629d7b188a6c2c9f5_b.png\"/></figure>在Child类中，其中有一个Parent实例。通过这种方式，我们动态的child类中代理了parent的相关功能。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25757679", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 2, 
            "title": "java基础：Q8. 类加载器的相关知识", 
            "content": "<ul><li><b>类的加载</b><br/></li></ul><br/>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。<figure><noscript><img src=\"https://pic1.zhimg.com/v2-c8079493f9c005838bf503762f64df6c_b.png\" data-rawwidth=\"437\" data-rawheight=\"188\" class=\"origin_image zh-lightbox-thumb\" width=\"437\" data-original=\"https://pic1.zhimg.com/v2-c8079493f9c005838bf503762f64df6c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;437&#39; height=&#39;188&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"437\" data-rawheight=\"188\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"437\" data-original=\"https://pic1.zhimg.com/v2-c8079493f9c005838bf503762f64df6c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c8079493f9c005838bf503762f64df6c_b.png\"/></figure><ul><li><b><b>类加载器</b></b></li></ul><p>看如下一个例子：</p><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-d2a62f736b9a550bcba847ce8324a95f_b.png\" data-rawwidth=\"741\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb\" width=\"741\" data-original=\"https://pic4.zhimg.com/v2-d2a62f736b9a550bcba847ce8324a95f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;741&#39; height=&#39;143&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"741\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"741\" data-original=\"https://pic4.zhimg.com/v2-d2a62f736b9a550bcba847ce8324a95f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d2a62f736b9a550bcba847ce8324a95f_b.png\"/></figure>运行结果为：</p><p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-2684015e755658f54ed97330e43e49b9_b.png\" data-rawwidth=\"749\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb\" width=\"749\" data-original=\"https://pic2.zhimg.com/v2-2684015e755658f54ed97330e43e49b9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;749&#39; height=&#39;138&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"749\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"749\" data-original=\"https://pic2.zhimg.com/v2-2684015e755658f54ed97330e43e49b9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2684015e755658f54ed97330e43e49b9_b.png\"/></figure>从如上代码可以看到，我们总共获取到了两个classloader。而实际上并非只有两个（启动类加载器是不可见的）。如下图为类加载的结构图：</p><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-e42803c010c45a028a97208a1eec8808_b.png\" data-rawwidth=\"403\" data-rawheight=\"390\" class=\"content_image\" width=\"403\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;403&#39; height=&#39;390&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"403\" data-rawheight=\"390\" class=\"content_image lazy\" width=\"403\" data-actualsrc=\"https://pic1.zhimg.com/v2-e42803c010c45a028a97208a1eec8808_b.png\"/></figure><b>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</b></p><p>从开发人员的角度来说，一般我们可以区分为4类类加载器，分别为：启动类加载器，扩展类加载器，应用类加载器，自定义类加载器。</p><ol><li><b>启动类加载器</b>：Bootstrap ClassLoader，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。<br/></li><li><b>扩展类加载器</b>：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。<br/></li><li><b>应用程序类加载器</b>：该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<br/></li><li><b>自定义类加载器</b>：用户自定义的类加载器。</li></ol><p>注意：对于JVM来说，它只区分两类类加载器</p><ol><li><b>启动类加载器</b>：它是使用C++编写的(仅限hotspot)，它是java虚拟机的一部分</li><li><b>其他所有的类加载器</b>。它是使用java写的。这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li></ol><ul><li><b>JVM类加载机制</b><br/></li></ul><br/><ol><li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入<br/></li><li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类<br/></li><li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效<br/></li></ol><ul><li><b>双亲委派模型</b><br/></li></ul><br/><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。其加载机制如下：<br/></p><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。<br/></li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。<br/></li><li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；<br/></li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会<b>报出异常ClassNotFoundException</b>。<br/></li></ol><p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-ecf83512dc551a734afc32bb6273ea3a_b.png\" data-rawwidth=\"964\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb\" width=\"964\" data-original=\"https://pic3.zhimg.com/v2-ecf83512dc551a734afc32bb6273ea3a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;964&#39; height=&#39;530&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"964\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"964\" data-original=\"https://pic3.zhimg.com/v2-ecf83512dc551a734afc32bb6273ea3a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ecf83512dc551a734afc32bb6273ea3a_b.png\"/></figure>可见，java类加载器是层级结构的，当需要加载一个类的时候，它实际上使用类似委托的方式委托其父加载器去加载该类，当父类加载器无法找到该类的时候，才使用当前类加载器加载。</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25755956", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 0, 
            "title": "Java基础：Q7. 区分方法重载和重写，解释其发生在运行时还是编译时", 
            "content": "<ul><li><b>方法重载</b><br/></li></ul><p>方法的重载是用来解决<b>同一个类</b>中，同样的方法名，但是拥有不同的参数类型的情况。参数类型不同包括，参数长度不一致或者参数类型不一致。如下：</p><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-5ae396e7b9ad77ce31bbb6b9a573d80b_b.png\" data-rawwidth=\"704\" data-rawheight=\"72\" class=\"origin_image zh-lightbox-thumb\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-5ae396e7b9ad77ce31bbb6b9a573d80b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;704&#39; height=&#39;72&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"704\" data-rawheight=\"72\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-5ae396e7b9ad77ce31bbb6b9a573d80b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5ae396e7b9ad77ce31bbb6b9a573d80b_b.png\"/></figure>方法的重载发生在<b>编译时。</b>在编译过程中，编译器必须根据参数类型以及长度来确定到底是调用的哪个方法，这个也是Java编译时多态的体现。比如如果调用如下方法</p><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-1db20796b322b50e5ecbd74d3c5444ec_b.png\" data-rawwidth=\"704\" data-rawheight=\"25\" class=\"origin_image zh-lightbox-thumb\" width=\"704\" data-original=\"https://pic1.zhimg.com/v2-1db20796b322b50e5ecbd74d3c5444ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;704&#39; height=&#39;25&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"704\" data-rawheight=\"25\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"704\" data-original=\"https://pic1.zhimg.com/v2-1db20796b322b50e5ecbd74d3c5444ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1db20796b322b50e5ecbd74d3c5444ec_b.png\"/></figure>我们可以确定他调用的是String类型的参数方法，参数只有一个，那么在编译时它就确定了调用的是方法一：method #1</p><p><b>方法重载其实是为不同的数据(参数类型)以不同的方式(参数长度)来实现同样的操作</b></p><ul><li><b>方法重写</b><br/></li></ul><br/><p>方法重写是指<b>父子类</b>(两个类)中，拥有同样的方法名和参数(类型和长度)的情况，子类会重写并覆盖父类的实现。如下所示</p><p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-115937969b9a97855f6cf3244db872ea_b.png\" data-rawwidth=\"703\" data-rawheight=\"83\" class=\"origin_image zh-lightbox-thumb\" width=\"703\" data-original=\"https://pic3.zhimg.com/v2-115937969b9a97855f6cf3244db872ea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;703&#39; height=&#39;83&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"703\" data-rawheight=\"83\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"703\" data-original=\"https://pic3.zhimg.com/v2-115937969b9a97855f6cf3244db872ea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-115937969b9a97855f6cf3244db872ea_b.png\"/></figure><figure><noscript><img src=\"https://pic4.zhimg.com/v2-5b2cc83a924010011f8b9277c778d78b_b.png\" data-rawwidth=\"701\" data-rawheight=\"97\" class=\"origin_image zh-lightbox-thumb\" width=\"701\" data-original=\"https://pic4.zhimg.com/v2-5b2cc83a924010011f8b9277c778d78b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;701&#39; height=&#39;97&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"701\" data-rawheight=\"97\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"701\" data-original=\"https://pic4.zhimg.com/v2-5b2cc83a924010011f8b9277c778d78b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5b2cc83a924010011f8b9277c778d78b_b.png\"/></figure>方法重写发生在运行时。因为在编译时，编译器是无法知道我们到底是调用父类的方法还是子类的方法，相反的，只有在实际运行的时候，我们才知道应该调用哪个方法。这个也是java运行时多态的体现。如下用例：</p><p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-63bd68e3e37fc919321875156e07eca6_b.png\" data-rawwidth=\"706\" data-rawheight=\"54\" class=\"origin_image zh-lightbox-thumb\" width=\"706\" data-original=\"https://pic3.zhimg.com/v2-63bd68e3e37fc919321875156e07eca6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;706&#39; height=&#39;54&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"706\" data-rawheight=\"54\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"706\" data-original=\"https://pic3.zhimg.com/v2-63bd68e3e37fc919321875156e07eca6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-63bd68e3e37fc919321875156e07eca6_b.png\"/></figure><figure><noscript><img src=\"https://pic4.zhimg.com/v2-8fe362a424235aabef7d2a5784b82927_b.png\" data-rawwidth=\"715\" data-rawheight=\"71\" class=\"origin_image zh-lightbox-thumb\" width=\"715\" data-original=\"https://pic4.zhimg.com/v2-8fe362a424235aabef7d2a5784b82927_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;715&#39; height=&#39;71&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"715\" data-rawheight=\"71\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"715\" data-original=\"https://pic4.zhimg.com/v2-8fe362a424235aabef7d2a5784b82927_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8fe362a424235aabef7d2a5784b82927_b.png\"/></figure>在创建过程中，只有在运行过程中，我们才知道实际上到底是A还是B去调用，所以方法重写是在运行时才确定的，JVM需要去知晓并做相关处理。</p><p><b>方法重写其实是为不同的对象(父子类)以同样的方式(参数长度)来实现同样的操作</b></p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25731347", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 0, 
            "title": "java基础：Q5.finally例子解析", 
            "content": "<ul><li>如下方法返回什么值？<br/></li></ul><br/><figure><noscript><img src=\"https://pic3.zhimg.com/v2-3766359aa746bb840b4e8d6ccb735a16_b.png\" data-rawwidth=\"604\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb\" width=\"604\" data-original=\"https://pic3.zhimg.com/v2-3766359aa746bb840b4e8d6ccb735a16_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;604&#39; height=&#39;119&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"604\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"604\" data-original=\"https://pic3.zhimg.com/v2-3766359aa746bb840b4e8d6ccb735a16_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3766359aa746bb840b4e8d6ccb735a16_b.png\"/></figure><p>解析：在try块的任何return以及exception块的throw exception之前，finally块均会被执行。故而，return 1会在return 2之前执行。实际上， return 2块永远都不会执行到。</p><p>同样的，如下代码也永远不会抛异常：</p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-562f52ed09474239749d12d216c2a2b2_b.png\" data-rawwidth=\"465\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-562f52ed09474239749d12d216c2a2b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;465&#39; height=&#39;118&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"465\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-562f52ed09474239749d12d216c2a2b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-562f52ed09474239749d12d216c2a2b2_b.png\"/></figure><ul><li>在什么情况下， finally块不会被执行？</li></ul><p>1. 无限循环，除非抛异常，否则永远不会执行finally块</p><p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-0f51e834244af764bccd4d30a00ad999_b.png\" data-rawwidth=\"758\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb\" width=\"758\" data-original=\"https://pic2.zhimg.com/v2-0f51e834244af764bccd4d30a00ad999_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;758&#39; height=&#39;192&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"758\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"758\" data-original=\"https://pic2.zhimg.com/v2-0f51e834244af764bccd4d30a00ad999_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0f51e834244af764bccd4d30a00ad999_b.png\"/></figure>2. 在try/catch块中执行了代码<i>System.exit(1) </i></p><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-c946bfb60f156c9bfddcd99659192d20_b.png\" data-rawwidth=\"721\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb\" width=\"721\" data-original=\"https://pic1.zhimg.com/v2-c946bfb60f156c9bfddcd99659192d20_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;721&#39; height=&#39;194&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"721\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"721\" data-original=\"https://pic1.zhimg.com/v2-c946bfb60f156c9bfddcd99659192d20_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c946bfb60f156c9bfddcd99659192d20_b.png\"/></figure>3. 线程突然死掉(停电等)</p><p>4. finally块中自己抛出了异常</p><ul><li>finally一般用于什么情形</li></ul><p>finally块一般用于关闭非内存型的资源流，如数据库连接，文件流，socket流等。在JDK7之前，这些流是需要手动关闭的，在JDK7后，系统会在try后自动关闭(实现了AutoCloseable接口)</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25730205", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 3, 
            "title": "java面试: Q4. final, finally和finalize区别", 
            "content": "&#34;final&#34;可以定义在参数，方法，类上，意义各不一样<ol><li>当用在参数上时，表示的该参数对应的应用时不可变更(同时意味着，如果该引用为一个对象，该对象中的值时可以修改的)</li><li>当用在方法上时，表示该方法不可被重写</li><li>当用在类上时，表示该类不能被继承</li></ol><p>&#34;finally&#34;常try/catch中，即便在try块中异常抛出，finally块逻辑也会执行，一般用于一些非内存的资源，如文件流，socket流，数据库连接等的关闭处理。注意，这个在jdk7以后其实并不准确了。</p><p>JDK7中定义了一个新接口AutoCloseable用于非显示的在try/catch/finally中关闭资源流问题，该实现也间接的实现了因为未合理的关闭资源导致的内存泄露问题。所以在JDK7后，如果自定义实现了一个资源类，如果实现了该接口，那么可以不用显示的关闭该资源。</p><p>如文件流中，JDK7之前的操作流程为：</p><div class=\"highlight\"><pre><code class=\"language-java\"> <span class=\"n\">BufferedReader</span> <span class=\"n\">br</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n <span class=\"k\">try</span> <span class=\"o\">{</span>\n   <span class=\"n\">File</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">File</span><span class=\"o\">(</span><span class=\"s\">&#34;c://temp/simple.txt&#34;</span><span class=\"o\">);</span>\n   <span class=\"n\">InputStream</span> <span class=\"n\">is</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">);</span>\n   <span class=\"n\">InputStreamReader</span> <span class=\"n\">isr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">InputStreamReader</span><span class=\"o\">(</span><span class=\"n\">is</span><span class=\"o\">);</span>\n   <span class=\"n\">br</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BufferedReader</span><span class=\"o\">(</span><span class=\"n\">isr</span><span class=\"o\">);</span>\n \n   <span class=\"n\">String</span> <span class=\"n\">read</span><span class=\"o\">;</span>\n \n   <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">read</span> <span class=\"o\">=</span> <span class=\"n\">br</span><span class=\"o\">.</span><span class=\"na\">readLine</span><span class=\"o\">())</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">read</span><span class=\"o\">);</span>\n   <span class=\"o\">}</span>\n <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">IOException</span> <span class=\"n\">ioe</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n   <span class=\"n\">ioe</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n   <span class=\"c1\">//Hmmm another try catch. unsightly\n</span><span class=\"c1\"></span>   <span class=\"k\">try</span> <span class=\"o\">{</span>\n     <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">br</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">br</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n\t <span class=\"o\">}</span>\n   <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">IOException</span> <span class=\"n\">ex</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n     <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div><p>JDK7后的操作流程为:</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"k\">try</span> <span class=\"o\">(</span><span class=\"n\">InputStream</span> <span class=\"n\">is</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">File</span><span class=\"o\">(</span><span class=\"s\">&#34;c://temp/simple.txt&#34;</span><span class=\"o\">));</span>\n <span class=\"n\">InputStreamReader</span> <span class=\"n\">isr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">InputStreamReader</span><span class=\"o\">(</span><span class=\"n\">is</span><span class=\"o\">);</span>\n <span class=\"n\">BufferedReader</span> <span class=\"n\">br2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BufferedReader</span><span class=\"o\">(</span><span class=\"n\">isr</span><span class=\"o\">);)</span> <span class=\"o\">{</span>\n   <span class=\"n\">String</span> <span class=\"n\">read</span><span class=\"o\">;</span>\n \n   <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">read</span> <span class=\"o\">=</span> <span class=\"n\">br2</span><span class=\"o\">.</span><span class=\"na\">readLine</span><span class=\"o\">())</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">read</span><span class=\"o\">);</span>\n   <span class=\"o\">}</span>\n <span class=\"o\">}</span>\n \n <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">IOException</span> <span class=\"n\">ioe</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n   <span class=\"n\">ioe</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n <span class=\"o\">}</span>\n</code></pre></div><p><i>AutoClosable</i>接口只有一个接口close()方法，该方法会在try/catch中自动调用，该方法中定义了所有的资源关闭信息，只要一个类实现该方法，那么该资源会自动释放<br/></p><p>&#34;finalize&#34;时当一个对象被垃圾回收期回收的时候调用，一般来说，我们不会直接操作与其相关的东西。我们在设计的时候，不应该在该方法中定义资源流的关闭问题，因为在垃圾回收的时候，我们不知道什么什么时候资源会被回收。</p><p>总之，final和finally在我们的代码会经常使用到，但是finalize我们一般不会使用</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25714231", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 1, 
            "title": "Java面试基础：Q3. 为什么String类是final的", 
            "content": "主要分三方面，分别为性能，线程安全，以及不可预知错误<ul><li>性能<br/></li></ul><br/><p>final类一般是被设计用于哪些不可更改的对象，如数字，枚举值等。如果你需要另外一个新的值，那么创建另外的值就可以了。在java中，Integer, Float, Long, Character, BigInteger, BigDecimel等都是final的。像我们日常经常使用到的基于hashcode的缓存，对象的缓存，以及对象池等优化策略能显著的提升性能。</p><p>如果string对象是可更改的，那么当在修改应用一的string值的时候，同时不修改应用二对应的string值，这种不可能那么容易的达到。因为他们两个引用实际指向的是同一个内存地址。</p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-9e9d8e6251dfd8cf3f19845ff67a1c9d_b.png\" data-rawwidth=\"626\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb\" width=\"626\" data-original=\"https://pic2.zhimg.com/v2-9e9d8e6251dfd8cf3f19845ff67a1c9d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;626&#39; height=&#39;368&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"626\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"626\" data-original=\"https://pic2.zhimg.com/v2-9e9d8e6251dfd8cf3f19845ff67a1c9d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9e9d8e6251dfd8cf3f19845ff67a1c9d_b.png\"/></figure><ul><li>线程安全<br/></li></ul><br/><p>final类天生就是线程安全的，因为他们一旦被创建后就不可能被更改。他只可能是读操作，故而final类可以在多线程很方便的使用，而不会产生线程安全问题</p><ul><li>不可预知的错误<br/></li></ul><br/><p>在现实生活中，很多的信息如文件名，密码，电话号码等等都是字符串类型的。试想一下，如果string类不是final的，那么一个账号或者密码很有可能在不知不觉中被篡改了，这样会导致一些奇怪的，不可预测的问题。</p><p>另外，关于string常量池的存储位置，在1.6和1.7版本的区别</p><p>1. 在JDK1.6中，string常量池是存储在jvm的PermGen中，这个区域是用于存储类的信息以及string常量池的，该区域是有大小限制的。</p><p>2. 在JDK1.7中，string常量池是存储在heap中，该去无限制</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25690526", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 0, 
            "title": "Java面试基础：Q2. 请讲述下String对象在java中如何被管理的", 
            "content": "A: String类在java中被设计成轻量级的，所谓轻量级是指在实际使用过程中，无需在内存中创建各种字符串也能保证字符创重复使用。<p>字符串常量池是为String类所管理的，当intern()方法被调用的时候，实际上&#34;equals(...)&#34;也被调用来去String常量池中查找某一个该值是否存在。如果存在，则直接放回常量池中该值的引用，否则在常量池中创建该值，并返回改值的引用。</p><p>所以，对于任意两个字符串s1,s2。 <i>s1.intern( )</i> == <i>s2.intern( ) </i>返回true的唯一条件是：<i>s1.equals(s2) </i>返回true</p><p><b>所以，intern()方法最终返回的只可能会是常量池内值的引用</b></p><p>样例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">    public static void main(String[] args){\n        String s1 = new String(&#34;A&#34;);\n        String s2 = new String(&#34;A&#34;);\n        System.out.println(s1 + &#34; equals &#34; + s2 + &#34;--&gt; &#34; +  s1.equals(s2)); //true\n        System.out.println(s1+&#34; == &#34;+s2+&#34;: &#34;+(s1 == s2));      // false;\n        System.out.println(s1+&#34;.intern() == &#34;+s2+&#34;.intern(): &#34;+(s1.intern() == s2.intern()));      // true;\n\n        String s3 = &#34;A&#34;;\n        String s4 = new String(&#34;A&#34;).intern();\n        System.out.println(s2+&#34; == &#34;+s3+&#34;: &#34;+(s2 == s3));      // false;\n        System.out.println(s3+&#34; == &#34;+s4+&#34;: &#34;+(s3 == s4));      // true\n    }\n</code></pre></div><p>其对象引用关系大致为：</p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-1e731c500b2d0f16cbe07ab323bb2140_b.png\" data-rawwidth=\"773\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb\" width=\"773\" data-original=\"https://pic1.zhimg.com/v2-1e731c500b2d0f16cbe07ab323bb2140_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;773&#39; height=&#39;259&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"773\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"773\" data-original=\"https://pic1.zhimg.com/v2-1e731c500b2d0f16cbe07ab323bb2140_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1e731c500b2d0f16cbe07ab323bb2140_b.png\"/></figure>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "程序员面试", 
                    "tagLink": "https://api.zhihu.com/topics/19579066"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25688311", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 3, 
            "title": "Java面试基础：Q1. \"==\"和\"equals(...)\"的区别是什么，你一定遗漏了什么。", 
            "content": "<ul><li>当使用&#34;==&#34;的时候，实际上比较的是两个对象的引用是否指向同一个内存地址。<br/></li><li>当使用&#34;equals(...)&#34;时，实际上比较的是真正指向的字符串是否相等(也称为深度比较)<br/></li></ul><p>如下样例：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class StringEquals {\n    public static void main(String[] args) throws Exception{\n        String s1 = &#34;Hello&#34;;\n        String s2 = new String(s1);\n        String s3 = &#34;Hello&#34;;\n        System.out.println(s1 + &#34; equals &#34; + s2 + &#34;--&gt; &#34; +  s1.equals(s2)); //true\n        System.out.println(s1 + &#34; == &#34; + s2 + &#34; --&gt; &#34; + (s1 == s2)); //false\n        System.out.println(s1 + &#34; == &#34; + s3+ &#34; --&gt; &#34; + (s1 == s3)); //true\n    }\n}</code></pre></div><p>解析如下：</p><ul><li>s1在JVM堆中创建了一个对象。一个是java堆的string常量池中的&#34;Hello&#34;值的对象，一个是一个引用对象，其引用的值为string常量池中的&#34;Hello&#34;的内存地址。</li><li>s2在JVM堆中创建了一个对象。它首先会去string常量池中找&#34;Hello&#34;值(如果没有找到，则在常量池中创建这个常量，如果找到，则不需要创建)，然后还要在堆中创建一个对象，其值为string常量池的引用。很明显，这种情况下，&#34;Hello&#34;常量已经存在，故而只需要创建一个对象即可</li><li>s3在jvm堆中没有创建对象。同样的，在s3创建&#34;Hello&#34;之前，需要去常量池中找该值是否存在，如果不存在，则在常量池中创建改值，否则不创建。</li></ul><p><b>【注意】这里所说的创建，仅仅是指java堆中的对象创建。其实s1,s2,s3指向的内存地址都是不一样的，因为s1,s2,s3的创建时在栈中，他们的值时对应的堆中的内存地址(引用)。故而如果说如上代码到底创建了多少对象的话，那么应该是5个，其中2个在堆上，3个在栈上。</b></p><p>按照如上的解释，结果不难得出：</p><p>s1和s3均为指向常量池&#34;Hello&#34;的引用，故而，他们无论是&#34;==&#34;和&#34;equals(...)&#34;是相同的时</p><p>s2则不同，s2为指向堆中的一个对象，该对象指向常量池&#34;Hello&#34;的引用，故而其与s1的&#34;equals(...)&#34;返回true, &#34;==&#34;返回false。</p><p>【注明】：可参考String类中的native()方法</p><p>对象创建的内存属性为：</p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-7f8a09384b03d788dc8842497d7e72a0_b.png\" data-rawwidth=\"595\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb\" width=\"595\" data-original=\"https://pic1.zhimg.com/v2-7f8a09384b03d788dc8842497d7e72a0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;595&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"595\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"595\" data-original=\"https://pic1.zhimg.com/v2-7f8a09384b03d788dc8842497d7e72a0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7f8a09384b03d788dc8842497d7e72a0_b.png\"/></figure><p>该问题可以引申出一个问题：java的引用和值的区别是什么？</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25678755", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 0, 
            "title": "排序算法实现-计数排序(Java版本）", 
            "content": "<p>计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。</p><ul><li><p>计数排序特征</p></li></ul><p>当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1的原因。</p><p>计数排序对输入的数据有附加的限制条件：</p><p>1、输入的线性表的元素属于有限偏序集S；</p><p>2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。</p><p>在这两个条件下，计数排序的复杂性为O(n)。</p><ul><li><p>算法过程</p></li></ul><p>算法的步骤如下：</p><ol><li><p>找出待排序的数组中最大和最小的元素</p></li><li><p>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项</p></li><li><p>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</p></li><li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p></li></ol><ul><li><p>Java实现分析</p></li></ul><p>该实现代码比较简单，如下：</p><p>其思想需要理解下</p><ol><li><p>对于一个数组而言，其序号其实也是排序好的，count[i](其中i等于currentValue-minValue)所以(currentValue-minValue)刚好可以表示为在count数组中的序号为多少的出现的次数</p></li><li><p>获取到的count数组在第一次循环后可以表示为分别在index中出现的数的次数，如果这样来算，我们可以知道count[i]肯定是在count[0]+...count[i-1]位。所以这样就知道位置了</p></li></ol><p>大致的样例模型如下：</p><ul><li><p>算法分析<br/></p></li></ul><p>计数排序是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C。</p><p>计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>其复杂度如下：</p><br/><p>源码如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.hbhs.algorithm.sort</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.ArrayList</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.List</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/*\n</span><span class=\"cm\"> * 计数排序&lt;BR&gt;\n</span><span class=\"cm\"> *  计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。&lt;BR&gt;\n</span><span class=\"cm\"> *  1 找出待排序的数组中最大和最小的元素&lt;BR&gt;\n</span><span class=\"cm\"> *  2 统计数组中每个值为i的元素出现的次数，存入数组C的第i项&lt;BR&gt;\n</span><span class=\"cm\"> *  3 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）&lt;BR&gt;\n</span><span class=\"cm\"> *  4 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1&lt;BR&gt;\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CountSort</span> <span class=\"o\">{</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 计数排序，针对集中数字有较好的排序\n</span><span class=\"cm\">\t * @param sequenceForArray\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">Integer</span><span class=\"o\">[]</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">maxValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">],</span> <span class=\"n\">minValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span>\n\t\t<span class=\"c1\">// 1. 获取最大和最小值， 用于创建临时的计数数组\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">minValue</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">minValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">maxValue</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">maxValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 2. 创建计数数组\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">countArray</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">maxValue</span><span class=\"o\">-</span><span class=\"n\">minValue</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t\t<span class=\"c1\">// 3. 迭代待排序数组，做计数操作，这个时候表示的是每一个距离最小值的数在待排序序列中有几次\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t<span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">value</span><span class=\"o\">-</span> <span class=\"n\">minValue</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 4. 依次迭代，计算每个值应当所在位置\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">Integer</span><span class=\"o\">[]</span> <span class=\"n\">tempArray</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">[</span><span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">tempArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">tempArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 5. 做叠加操作\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">countArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 整理设置\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">tempArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span><span class=\"n\">0</span> <span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">tempArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t<span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">value</span><span class=\"o\">-</span><span class=\"n\">minValue</span><span class=\"o\">]-</span><span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n\t\t\t<span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">value</span><span class=\"o\">-</span><span class=\"n\">minValue</span><span class=\"o\">]</span> <span class=\"o\">-=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 计数排序，针对集中数字有较好的排序\n</span><span class=\"cm\">\t * @param sequenceForArray\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">maxValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">],</span> <span class=\"n\">minValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span>\n\t\t<span class=\"c1\">// 获取最大和最小值\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">minValue</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">minValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">maxValue</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">maxValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">countArray</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">maxValue</span><span class=\"o\">-</span><span class=\"n\">minValue</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t\t<span class=\"c1\">// 计数\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t<span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">value</span><span class=\"o\">-</span> <span class=\"n\">minValue</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 计算每个值所在位置\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">Integer</span><span class=\"o\">[]</span> <span class=\"n\">tempArray</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">[</span><span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">tempArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">tempArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">countArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 整理设置\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">tempArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span><span class=\"n\">0</span> <span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">tempArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t<span class=\"n\">sequenceForArray</span><span class=\"o\">[</span><span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">value</span><span class=\"o\">-</span><span class=\"n\">minValue</span><span class=\"o\">]-</span><span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n\t\t\t<span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">value</span><span class=\"o\">-</span><span class=\"n\">minValue</span><span class=\"o\">]</span> <span class=\"o\">-=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 计数排序，针对集中数字有较好的排序\n</span><span class=\"cm\">\t * @param sequenceForArray\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">maxValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">),</span> <span class=\"n\">minValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n\t\t<span class=\"c1\">// 获取最大和最小值\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">minValue</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">minValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">maxValue</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">maxValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">countArray</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">maxValue</span><span class=\"o\">-</span><span class=\"n\">minValue</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t\t<span class=\"c1\">// 计数\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">value</span><span class=\"o\">-</span> <span class=\"n\">minValue</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 计算每个值所在位置\n</span><span class=\"c1\"></span>\t\t\n\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">countArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">tempArray</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;();</span>\n\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">tempArray</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">tempArray</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">));</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 整理设置\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">tempArray</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span><span class=\"n\">0</span> <span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">tempArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">sequenceForArray</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">value</span><span class=\"o\">-</span><span class=\"n\">minValue</span><span class=\"o\">]-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">countArray</span><span class=\"o\">[</span><span class=\"n\">value</span><span class=\"o\">-</span><span class=\"n\">minValue</span><span class=\"o\">]</span> <span class=\"o\">-=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "排序", 
                    "tagLink": "https://api.zhihu.com/topics/19572852"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25658268", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 1, 
            "title": "排序算法实现-快速排序(Java版本）", 
            "content": "<p>快速排序（Quicksort），又称划分交换排序（partition-exchange sort），一种排序算法。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><ul><li><p>算法描述</p></li></ul><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><ol><li><p>从数列中挑出一个元素，称为&#34;基准&#34;（pivot），</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p>其伪代码如下：</p><p>其大致排序图如下：<br/></p><ul><li><p>相关排序算法比较<br/></p></li></ul><ol><li><p>快速排序是二叉查找树（二叉查找树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分区版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。</p></li><li><p>快速排序的最直接竞争者是堆排序（Heapsort）。堆排序通常比快速排序稍微慢，但是最坏情况的运行时间总是O(n log n)。快速排序是经常比较快，除了introsort变化版本外，仍然有最坏情况性能的机会。如果事先知道堆排序将会是需要使用的，那么直接地使用堆排序比等待introsort再切换到它还要快。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要Θ(log n)的空间。然而，堆排序需要有效率的随机存取才能变成可行。</p></li><li><p>快速排序也与归并排序（Mergesort）竞争，这是另外一种递归排序算法，但有坏情况O(n log n)运行时间的优势。不像快速排序或堆排序，归并排序是一个稳定排序，且可以轻易地被采用在链表（linked list）和存储在慢速访问媒体上像是磁盘存储或网络连接存储的非常巨大数列。尽管快速排序可以被重新改写使用在炼串列上，但是它通常会因为无法随机存取而导致差的基准选择。归并排序的主要缺点，是在最佳情况下需要Ω(n)额外的空间。<br/></p></li></ol><ul><li><p>Java实现与分析<br/></p></li></ul><p>首先创建一个方法，用于快速排序某一个数列</p><p>其中调用了一个其他方法，用于排序指定序号范围内的数列，其实现如下：</p><p>其中的分区算法大致流程为：</p><ol><li><p>设置一个主元(待比较的数)，然后将数列分成左右两部分，并保证该主元左边的数都比该值下，右边的数都比它大</p></li><li><p>循环左右两边的数列，继续执行步骤1</p></li></ol><p>一次区分的样例如下：<br/></p><p>其中最后一个数为主元，空格区分开的为左右两个序列。其实现如下：</p><p>需要注意的是在执行完这个操作后，需要把主元放到合适的位置</p><p>当分别对左右区间做排序后，最终的数列就是排序好的。</p><ul><li><p>其他变种</p></li></ul><ol><li><p>随机化快排：快速排序的最坏情况基于每次划分对主元的选择，而这种随机化，其实就是随机选取主元</p></li><li><p>平衡快排：每次尽可能地选择一个能够代表中值的元素作为关键数据，然后遵循普通快排的原则进行比较、替换和递归。</p></li><li><p>外部快排：与普通快排不同的是，关键数据是一段buffer，详细请查询其他文档。</p></li><li><p>三路基数快排：结合了基数排序（radix sort，如一般的字符串比较排序就是基数排序）和快排的特点，是字符串排序中比较高效的算法。</p></li></ol><ul><li><p>性能分析<br/></p></li></ul><p>快速度排序基本上是外界比较流程的排序算法，基本上比其他的算法有一些优势。</p><p>其复杂度如下：<br/></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "排序", 
                    "tagLink": "https://api.zhihu.com/topics/19572852"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": [
                {
                    "userName": "Clean-91", 
                    "userLink": "https://www.zhihu.com/people/f0670c12bc827bd06aace45962484140", 
                    "content": "代码呢？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25623301", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 3, 
            "title": "排序算法实现-二叉树排序(Java版本）", 
            "content": "<p>二叉查找树（Binary Search Tree），也称二叉搜索树、有序二叉树，是指一棵空树或者具有下列性质的二叉树：</p><ol><li><p>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li><p>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li><p>任意节点的左、右子树也分别为二叉查找树；</p></li><li><p>没有键值相等的节点。</p></li></ol><p>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。</p><p>如果我们能够将一个数列构造成一个二叉树，那么按一定顺序获取到的新数列就是排序好的数列，二叉树排序算法就是依照这个实现的。那么二叉树怎么构建和查找呢？</p><ul><li><p>二叉树的插入</p></li></ul><p>向一个二叉搜索树b中插入一个节点s的算法，过程为：</p><ol><li><p>若b是空树，则将s所指结点作为根节点插入，否则：</p></li><li><p>若s-&gt;data等于b的根节点的数据域之值，则返回，否则：</p></li><li><p>若s-&gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：</p></li><li><p>把s所指节点插入到右子树中。（新插入节点总是叶子节点）</p></li></ol><ul><li><p>二叉树的查找</p></li></ul><p>在二叉搜索树b中查找x的过程为：</p><ol><li><p>若b是空树，则搜索失败，否则：</p></li><li><p>若x等于b的根节点的数据域之值，则查找成功；否则：</p></li><li><p>若x小于b的根节点的数据域之值，则搜索左子树；否则：</p></li><li><p>查找右子树。</p></li></ol><ul><li><p>Java实现以及解析<br/></p></li></ul><p>首先，我们需要创建一个类用于表示二叉树节点，它有左右两个子节点，当左右z节点都为空时候，则表示为叶子节点</p><p>我们再创建排序方法，操作步骤如下：</p><ol><li><p>首先，构造二叉树，并将待排序数组一个个添加到二叉树中</p></li><li><p>然后从二叉树中读取到排序好的数列的原始index列表</p></li><li><p>根据排序好的数列index列表获取到排序好的数列<br/></p></li></ol><p>在执行流程中，最重要的就是插入数据到二叉树中的过程，因为在插入过程中会做排序</p><p>需要注意的是，在插入过程,待插入的数据一定会最终成为叶子节点，所以最终一旦发现找到的节点不为空的时候，一定要迭代子节点</p><p>获取排序好的序列过程，我们采用的是左序搜索算法<br/></p><p>再排序过程其实没有必要了，有冗余，其实从上步中就可以得到排序好的数列，代码还是贴出</p><p>发布</p><ul><li><p>性能分析<br/></p></li></ul><p>每个结点的C(i)为该结点的层次数。</p><ol><li><p>最坏情况下，当先后插入的关键字有序时，构成的二叉查找树蜕变为单支树，树的深度为n. 其平均查找长度为(n+1)/2，和顺序查找相同<br/></p></li><li><p>最好的情况是二叉查找树的形态和折半查找的判定树相同，其平均查找长度和log2(n</p></li></ol><p>源码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.hbhs.algorithm.sort;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport com.hbhs.algorithm.HBHSAssert;\n\n/**\n * 二叉查找树排序\n * @author walter.xu\n *\n */\npublic class BinaryTreeSort {\n\t\n\t/**\n\t * 二叉查找树排序&lt;br&gt;\n\t * @param sequenceArray\n\t */\n\t\n\tpublic static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(T[] sequenceArray){\n\t\t//将数组第一个值作为树的根节点\n\t\tBinaryTree root = new BinaryTree(0);\n\t\t// 将数组其他元素组装到树种\n\t\tfor (int i = 1; i &lt; sequenceArray.length; i++) {\n\t\t\taddNodeIntoTree(sequenceArray, i, root);\n\t\t}\n\t\t// 获取到排序号的Index\n\t\tList&lt;Integer&gt; indexList = new ArrayList&lt;Integer&gt;();\n\t\tgetSortedIndexFromTree(indexList, root);\n\t\t// 按照排序好的序列列表重新生成序列\n\t\tsortSequence(sequenceArray, indexList);\n\t}\n\t/**\n\t * 添加节点到树种\n\t * @param sequenceArray\n\t * @param currentIndex\n\t * @param root\n\t */\n\tprivate static &lt;T extends Comparable&lt;? super T&gt;&gt; void addNodeIntoTree(T[] sequenceArray,\n\t\t\tint currentIndex, BinaryTree root){\n\t\tHBHSAssert.isTrue(currentIndex&gt;0, &#34;Index must more than 0&#34;);\n\t\t// 获取当前的比较Index\n\t\tint compareIndex = root.getCurrentIndex();\n\t\tif(compareIndex&gt;=0){\n\t\t\t// 如果当前节点比待插入的节点小，则指定左树节点，否则指定右树节点\n\t\t\tif (sequenceArray[compareIndex].compareTo(sequenceArray[currentIndex])&gt;0) {\n\t\t\t\tBinaryTree leftNode = root.getLeftNode();\n\t\t\t\t// 左树为空时，将当前节点作为左树，否则迭代左树\n\t\t\t\tif (leftNode==null) {\n\t\t\t\t\troot.setLeftNode(new BinaryTree(currentIndex));\n\t\t\t\t}else{\n\t\t\t\t\taddNodeIntoTree(sequenceArray, currentIndex, root.getLeftNode());\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tBinaryTree rightNode = root.getRightNode();\n\t\t\t\t// 右树为空时，将当前节点作为右树，否则迭代右树\n\t\t\t\tif (rightNode==null) {\n\t\t\t\t\troot.setRightNode(new BinaryTree(currentIndex));\n\t\t\t\t}else{\n\t\t\t\t\taddNodeIntoTree(sequenceArray, currentIndex, root.getRightNode());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * 二叉查找树排序&lt;br&gt;\n\t * @param sequenceArray\n\t */\n\t\n\tpublic static &lt;T&gt; void sort(T[] sequenceArray, Comparator&lt;T&gt; c){\n\t\t//将数组第一个值作为树的根节点\n\t\tBinaryTree root = new BinaryTree(0);\n\t\t// 将数组其他元素组装到树种\n\t\tfor (int i = 1; i &lt; sequenceArray.length; i++) {\n\t\t\taddNodeIntoTree(sequenceArray, i, root, c);\n\t\t}\n\t\t// 获取到排序号的Index\n\t\tList&lt;Integer&gt; indexList = new ArrayList&lt;Integer&gt;();\n\t\tgetSortedIndexFromTree(indexList, root);\n\t\tsortSequence(sequenceArray, indexList);\n\t}\n\t/**\n\t * 添加节点到树种\n\t * @param sequenceArray\n\t * @param currentIndex\n\t * @param root\n\t */\n\tprivate static &lt;T&gt; void addNodeIntoTree(T[] sequenceArray,\n\t\t\tint currentIndex, BinaryTree root, Comparator&lt;T&gt; c){\n\t\tHBHSAssert.isTrue(currentIndex&gt;0, &#34;Index must more than 0&#34;);\n\t\t// 获取当前的比较Index\n\t\tint compareIndex = root.getCurrentIndex();\n\t\tif(compareIndex&gt;=0){\n\t\t\t// 如果当前节点比待插入的节点小，则指定左树节点，否则指定右树节点\n\t\t\tif (c.compare(sequenceArray[compareIndex], sequenceArray[currentIndex])&gt;0) {\n\t\t\t\tBinaryTree leftNode = root.getLeftNode();\n\t\t\t\t// 左树为空时，将当前节点作为左树，否则迭代左树\n\t\t\t\tif (leftNode==null) {\n\t\t\t\t\troot.setLeftNode(new BinaryTree(currentIndex));\n\t\t\t\t}else{\n\t\t\t\t\taddNodeIntoTree(sequenceArray, currentIndex, root.getLeftNode(), c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tBinaryTree rightNode = root.getRightNode();\n\t\t\t\t// 右树为空时，将当前节点作为右树，否则迭代右树\n\t\t\t\tif (rightNode==null) {\n\t\t\t\t\troot.setRightNode(new BinaryTree(currentIndex));\n\t\t\t\t}else{\n\t\t\t\t\taddNodeIntoTree(sequenceArray, currentIndex, root.getRightNode(), c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * 二叉查找树排序&lt;br&gt;\n\t * @param sequenceArray\n\t */\n\t\n\tpublic static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; sequenceArray){\n\t\t//将数组第一个值作为树的根节点\n\t\tBinaryTree root = new BinaryTree(0);\n\t\t// 将数组其他元素组装到树种\n\t\tfor (int i = 1; i &lt; sequenceArray.size(); i++) {\n\t\t\taddNodeIntoTree(sequenceArray, i, root);\n\t\t}\n\t\t// 获取到排序号的Index\n\t\tList&lt;Integer&gt; indexList = new ArrayList&lt;Integer&gt;();\n\t\tgetSortedIndexFromTree(indexList, root);\n\t\tsortSequence(sequenceArray, indexList);\n\t}\n\t/**\n\t * 添加节点到树种\n\t * @param sequenceArray\n\t * @param currentIndex\n\t * @param root\n\t */\n\tprivate static &lt;T extends Comparable&lt;? super T&gt;&gt; void addNodeIntoTree(List&lt;T&gt; sequenceArray,\n\t\t\tint currentIndex, BinaryTree root){\n\t\tHBHSAssert.isTrue(currentIndex&gt;0, &#34;Index must more than 0&#34;);\n\t\t// 获取当前的比较Index\n\t\tint compareIndex = root.getCurrentIndex();\n\t\tif(compareIndex&gt;=0){\n\t\t\t// 如果当前节点比待插入的节点小，则指定左树节点，否则指定右树节点\n\t\t\tif (sequenceArray.get(compareIndex).compareTo(sequenceArray.get(currentIndex))&gt;0) {\n\t\t\t\tBinaryTree leftNode = root.getLeftNode();\n\t\t\t\t// 左树为空时，将当前节点作为左树，否则迭代左树\n\t\t\t\tif (leftNode==null) {\n\t\t\t\t\troot.setLeftNode(new BinaryTree(currentIndex));\n\t\t\t\t}else{\n\t\t\t\t\taddNodeIntoTree(sequenceArray, currentIndex, root.getLeftNode());\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tBinaryTree rightNode = root.getRightNode();\n\t\t\t\t// 右树为空时，将当前节点作为右树，否则迭代右树\n\t\t\t\tif (rightNode==null) {\n\t\t\t\t\troot.setRightNode(new BinaryTree(currentIndex));\n\t\t\t\t}else{\n\t\t\t\t\taddNodeIntoTree(sequenceArray, currentIndex, root.getRightNode());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * 二叉查找树排序&lt;br&gt;\n\t * @param sequenceArray\n\t */\n\t\n\tpublic static &lt;T&gt; void sort(List&lt;T&gt; sequenceArray, Comparator&lt;T&gt; c){\n\t\t//将数组第一个值作为树的根节点\n\t\tBinaryTree root = new BinaryTree(0);\n\t\t// 将数组其他元素组装到树种\n\t\tfor (int i = 1; i &lt; sequenceArray.size(); i++) {\n\t\t\taddNodeIntoTree(sequenceArray, i, root, c);\n\t\t}\n\t\t// 获取到排序号的Index\n\t\tList&lt;Integer&gt; indexList = new ArrayList&lt;Integer&gt;();\n\t\tgetSortedIndexFromTree(indexList, root);\n\t\tsortSequence(sequenceArray, indexList);\n\t}\n\t/**\n\t * 添加节点到树种\n\t * @param sequenceArray\n\t * @param currentIndex\n\t * @param root\n\t */\n\tprivate static &lt;T&gt; void addNodeIntoTree(List&lt;T&gt; sequenceArray,\n\t\t\tint currentIndex, BinaryTree root, Comparator&lt;T&gt; c){\n\t\tHBHSAssert.isTrue(currentIndex&gt;0, &#34;Index must more than 0&#34;);\n\t\t// 获取当前的比较Index\n\t\tint compareIndex = root.getCurrentIndex();\n\t\tif(compareIndex&gt;=0){\n\t\t\t// 如果当前节点比待插入的节点小，则指定左树节点，否则指定右树节点\n\t\t\tif (c.compare(sequenceArray.get(compareIndex), sequenceArray.get(currentIndex))&gt;0) {\n\t\t\t\tBinaryTree leftNode = root.getLeftNode();\n\t\t\t\t// 左树为空时，将当前节点作为左树，否则迭代左树\n\t\t\t\tif (leftNode==null) {\n\t\t\t\t\troot.setLeftNode(new BinaryTree(currentIndex));\n\t\t\t\t}else{\n\t\t\t\t\taddNodeIntoTree(sequenceArray, currentIndex, root.getLeftNode(), c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tBinaryTree rightNode = root.getRightNode();\n\t\t\t\t// 右树为空时，将当前节点作为右树，否则迭代右树\n\t\t\t\tif (rightNode==null) {\n\t\t\t\t\troot.setRightNode(new BinaryTree(currentIndex));\n\t\t\t\t}else{\n\t\t\t\t\taddNodeIntoTree(sequenceArray, currentIndex, root.getRightNode(), c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * \n\t * @param sequenceArray\n\t * @param indexList\n\t */\n\t@SuppressWarnings(&#34;unchecked&#34;)\n\tprivate static &lt;T&gt; void sortSequence(T[] sequenceArray, List&lt;Integer&gt; indexList){\n\t\t// 待优化\n\t\tObject[] sortedSequence = new Object[sequenceArray.length];\n\t\tfor (int i = 0; i &lt; indexList.size(); i++) {\n\t\t\tsortedSequence[i] = sequenceArray[indexList.get(i)];\n\t\t}\n\t\tfor (int i = 0; i &lt; indexList.size(); i++) {\n\t\t\tsequenceArray[i] = (T)sortedSequence[i];\n\t\t}\n\t}\n\t/**\n\t * \n\t * @param sequenceArray\n\t * @param indexList\n\t */\n\t@SuppressWarnings(&#34;unchecked&#34;)\n\tprivate static &lt;T&gt; void sortSequence(List&lt;T&gt; sequenceArray, List&lt;Integer&gt; indexList){\n\t\t// 待优化\n\t\tObject[] sortedSequence = new Object[sequenceArray.size()];\n\t\tfor (int i = 0; i &lt; indexList.size(); i++) {\n\t\t\tsortedSequence[i] = sequenceArray.get(indexList.get(i));\n\t\t}\n\t\tfor (int i = 0; i &lt; indexList.size(); i++) {\n\t\t\tsequenceArray.set(i, (T)sortedSequence[i]);\n\t\t}\n\t}\n\t\n\t/**\n\t * 获取到树结构的所有index组合，排序方式为：前序遍历方式\n\t * @param indexList\n\t * @param root\n\t */\n\tprivate static void getSortedIndexFromTree(List&lt;Integer&gt; indexList, BinaryTree root){\n\t\tif (root!=null) {\n\t\t\tgetSortedIndexFromTree(indexList, root.getLeftNode());\n\t\t\tindexList.add(root.getCurrentIndex());\n\t\t\tgetSortedIndexFromTree(indexList, root.getRightNode());\n\t\t}\n\t}\n\t \n}\n/**\n * 临时树结构\n * @author walter.xu\n *\n */\nclass BinaryTree{\n\t// current index in array for tree node\n\tprivate int currentIndex;\n\t// left node\n\tprivate BinaryTree leftNode = null;\n\t// right node\n\tprivate BinaryTree rightNode = null;\n\t\n\tpublic BinaryTree(int index) {\n\t\tthis.currentIndex = index;\n\t}\n\t\n\tpublic int getCurrentIndex() {\n\t\treturn currentIndex;\n\t}\n\tpublic void setCurrentIndex(int currentIndex) {\n\t\tthis.currentIndex = currentIndex;\n\t}\n\n\tpublic BinaryTree getLeftNode() {\n\t\treturn leftNode;\n\t}\n\n\tpublic void setLeftNode(BinaryTree leftNode) {\n\t\tthis.leftNode = leftNode;\n\t}\n\n\tpublic BinaryTree getRightNode() {\n\t\treturn rightNode;\n\t}\n\n\tpublic void setRightNode(BinaryTree rightNode) {\n\t\tthis.rightNode = rightNode;\n\t}\n\n}\n\n</code></pre></div>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "排序", 
                    "tagLink": "https://api.zhihu.com/topics/19572852"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25571420", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 1, 
            "title": "排序算法实现-归并排序(Java版本）", 
            "content": "<p>归并排序（Merge sort），是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。其主要的操作为归并操作。</p><p>其大致的过程如下：</p><p>归并排序分解和合并图<br/></p><ul><li><p>归并操作</p></li></ul><p>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作，归并后的序列是有序的。归并排序算法依赖归并操作。</p><p>如　设有数列{6，202，100，301，38，8，1}</p><p>初始状态：6,202,100,301,38,8，1</p><ol><li><p>第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；</p></li><li><p>第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；</p></li><li><p>第三次归并后：{1,6,8,38,100,202,301},比较次数：4；</p></li></ol><p>总的比较次数为：3+4+4=11,；</p><p>归并操作分迭代和递归两种方式，原理如下</p><p>迭代法</p><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p></li><li><p>重复步骤3直到某一指针到达序列尾</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p></li></ol><p>递归法（假设序列共有n个元素）：</p><ol><li><p>将序列每相邻两个数字进行归并操作，形成F(n/2)个序列，排序后每个序列包含两个元素</p></li><li><p>将上述序列再次归并，形成F(N/.4)个序列，每个序列包含四个元素</p></li><li><p>重复步骤2，直到所有元素排序完毕</p></li></ol><p>其借鉴使用了分治模式的知识，其关键点为：</p><ul><li><p>算法描述<br/></p></li></ul><p>归并操作的工作原理如下：</p><p>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p><p>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置</p><p>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p><p>重复步骤3直到某一指针超出序列尾</p><p>将另一序列剩下的所有元素直接复制到合并序列尾</p><p>其算法伪代码如下：</p><ul><li><p>Java实现以及分析<br/></p></li></ul><p>首先创建一个方法用于表示使用归并算法排序数列<br/></p><p>该方法中调用其他方法，用于对指定范围内的数列做归并操作，其实现如下：</p><p>该方法中做迭代操作，相关逻辑如下：</p><ol><li><p>当需要merge的序列个数为1时(startIndex&gt;=endIndex)，停止继续迭代。否则继续迭代</p></li><li><p>取startIndex和endIndex中间值，分别对两边的数列继续使用归并排序算法（当前方法，仅仅开始序号和截至序号不一样了），我们定义为左序列和右序列</p></li><li><p>然后对左序列和右序列做归并操作，归并完成后，算法完成，数列也排序号了</p></li></ol><p>归并算法如下：<br/></p><p>当迭代完成时，数列也排序好了</p><ul><li><p>算法分析<br/></p></li></ul><p>归并排序是速度仅次于快速排序的算法，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列，其时间和空间复杂度信息如下：</p><br/><p>代码如下</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.hbhs.algorithm.sort</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.Comparator</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.List</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 分治模式：\n</span><span class=\"cm\"> * 分解(Divide):将原来问题分解成一系列子问题\n</span><span class=\"cm\"> * 解决(Conquer):递归解各子问题，如子问题足够小，直接求解\n</span><span class=\"cm\"> * 合并(Combine):将子问题的结果合并成原来的问题的解\n</span><span class=\"cm\"> * 合并排序(merge sort) 算法完全依照分治模式，直观操作如下：\n</span><span class=\"cm\"> * 分解：将n个元素分成各自含n/2个元素的子序列\n</span><span class=\"cm\"> * 解决：用合并排序法对两个子序列递归的排序\n</span><span class=\"cm\"> * 合并：合并两个以排序的子序列以得到排序结果\n</span><span class=\"cm\"> * \n</span><span class=\"cm\"> * 算法伪代码：\n</span><span class=\"cm\"> * MERGE(A,p,q,r)\n</span><span class=\"cm\"> * n1 &lt;- q-p+1\n</span><span class=\"cm\"> * n2 &lt;- r-q\n</span><span class=\"cm\"> * create arrays L[1...n1+1] and R[1...n2+1]\n</span><span class=\"cm\"> * for i &lt;- 1 to n1\n</span><span class=\"cm\"> *     do L[i] &lt;- A[p+i-1]\n</span><span class=\"cm\"> * for j &lt;-1 to n2\n</span><span class=\"cm\"> *     do R[j] &lt;- A[q+j]\n</span><span class=\"cm\"> * L[n1+1] &lt;- MAX(int)\n</span><span class=\"cm\"> * R[n2+1] &lt;- MAX(int)\n</span><span class=\"cm\"> * i &lt;- 1\n</span><span class=\"cm\"> * j &lt;- 1\n</span><span class=\"cm\"> * for k &lt;- p to r\n</span><span class=\"cm\"> *     do if L[i] &lt;= R[j]\n</span><span class=\"cm\"> *        then A[k] &lt;- L[i]\n</span><span class=\"cm\"> *          i &lt;- i+1\n</span><span class=\"cm\"> *        else A[k] &lt;- R[j]\n</span><span class=\"cm\"> *          j &lt;- j+1\n</span><span class=\"cm\"> * \n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MergeSort</span> <span class=\"o\">{</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 归并排序算法\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 归并算法, 归并待排序数组中从A[start,....,end] 范围内的数据,&lt;br&gt;\n</span><span class=\"cm\">\t * 在该范围内二分后区分为左子数组以及右子数组，并分别对两个子数组做递归归并.\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t * @param start\n</span><span class=\"cm\">\t * @param end\n</span><span class=\"cm\">\t * @return\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">){</span>\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">&lt;</span> <span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">end</span><span class=\"o\">)/</span><span class=\"n\">2</span><span class=\"o\">;</span>\n\t\t\t<span class=\"c1\">// 递归左子数组做归并排序\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">);</span>\n\t\t\t<span class=\"c1\">// 递归右子数组做归并排序\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">end</span><span class=\"o\">);</span>\n\t\t\t<span class=\"c1\">// 归并数组，最终使得A[start,..,q]均小于A[q,end]\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">merge</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">end</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * Merge core method. This method promise the data format as below:&lt;br&gt;\n</span><span class=\"cm\">\t * for A[start,..., end]\n</span><span class=\"cm\">\t *   define int i= (end-start)/2 , split as left part: A[start,...,(end-start+1)], right part: A[(end-start),...,end]\n</span><span class=\"cm\">\t *   merge the two part, and must fit the rules: every element in left part must lower than the ones in right part.\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t * @param start\n</span><span class=\"cm\">\t * @param div\n</span><span class=\"cm\">\t * @param end\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"nd\">@SuppressWarnings</span><span class=\"o\">(</span><span class=\"s\">&#34;unchecked&#34;</span><span class=\"o\">)</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">merge</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">div</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">n1</span> <span class=\"o\">=</span> <span class=\"n\">div</span><span class=\"o\">-</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">//分治的左边\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">n2</span> <span class=\"o\">=</span> <span class=\"n\">end</span><span class=\"o\">-</span><span class=\"n\">div</span><span class=\"o\">;</span> <span class=\"c1\">//分治的右边\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">leftPart</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">n1</span><span class=\"o\">];</span>\n\t\t<span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">rightPart</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">n2</span><span class=\"o\">];</span>\n\t\t<span class=\"c1\">//赋值,初始化左边数组和右边数组\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n1</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n2</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">div</span><span class=\"o\">+</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 对于左半部分和右半部分和原来的数组中元素对比，按照规则set对应值。\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">,</span><span class=\"n\">j</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">start</span><span class=\"o\">;</span><span class=\"n\">k</span><span class=\"o\">&lt;=</span><span class=\"n\">end</span><span class=\"o\">;</span><span class=\"n\">k</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">&gt;=</span> <span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">||</span><span class=\"n\">j</span><span class=\"o\">&gt;=</span><span class=\"n\">rightPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"k\">break</span><span class=\"o\">;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(((</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]).</span><span class=\"na\">compareTo</span><span class=\"o\">((</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])&lt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]=(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t\t<span class=\"n\">i</span><span class=\"o\">++;</span>\n\t\t\t<span class=\"o\">}</span><span class=\"k\">else</span><span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]=(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n\t\t\t\t<span class=\"n\">j</span><span class=\"o\">++;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">//最后leftPart和rightPart有一个未做set值操作，需要将改值设置到原始数组对应的end值中\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">==</span><span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">end</span><span class=\"o\">]=</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">rightPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span> <span class=\"o\">}</span>\n\t\t<span class=\"k\">else</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">end</span><span class=\"o\">]=</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 归并排序算法\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 归并算法, 归并待排序数组中从A[start,....,end] 范围内的数据,&lt;br&gt;\n</span><span class=\"cm\">\t * 在该范围内二分后区分为左子数组以及右子数组，并分别对两个子数组做递归归并.\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t * @param start\n</span><span class=\"cm\">\t * @param end\n</span><span class=\"cm\">\t * @return\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">&lt;</span> <span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">end</span><span class=\"o\">)/</span><span class=\"n\">2</span><span class=\"o\">;</span>\n\t\t\t<span class=\"c1\">// 递归左子数组做归并排序\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t\t<span class=\"c1\">// 递归右子数组做归并排序\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t\t<span class=\"c1\">// 归并数组，最终使得A[start,..,q]均小于A[q,end]\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">merge</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * Merge core method. This method promise the data format as below:&lt;br&gt;\n</span><span class=\"cm\">\t * for A[start,..., end]\n</span><span class=\"cm\">\t *   define int i= (end-start)/2 , split as left part: A[start,...,(end-start+1)], right part: A[(end-start),...,end]\n</span><span class=\"cm\">\t *   merge the two part, and must fit the rules: every element in left part must lower than the ones in right part.\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t * @param start\n</span><span class=\"cm\">\t * @param div\n</span><span class=\"cm\">\t * @param end\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"nd\">@SuppressWarnings</span><span class=\"o\">(</span><span class=\"s\">&#34;unchecked&#34;</span><span class=\"o\">)</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">merge</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">div</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">n1</span> <span class=\"o\">=</span> <span class=\"n\">div</span><span class=\"o\">-</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">//分治的左边\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">n2</span> <span class=\"o\">=</span> <span class=\"n\">end</span><span class=\"o\">-</span><span class=\"n\">div</span><span class=\"o\">;</span> <span class=\"c1\">//分治的右边\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">leftPart</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">n1</span><span class=\"o\">];</span>\n\t\t<span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">rightPart</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">n2</span><span class=\"o\">];</span>\n\t\t<span class=\"c1\">//赋值,初始化左边数组和右边数组\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n1</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n2</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">div</span><span class=\"o\">+</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 对于左半部分和右半部分和原来的数组中元素对比，按照规则set对应值。\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">,</span><span class=\"n\">j</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">start</span><span class=\"o\">;</span><span class=\"n\">k</span><span class=\"o\">&lt;=</span><span class=\"n\">end</span><span class=\"o\">;</span><span class=\"n\">k</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">&gt;=</span> <span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">||</span><span class=\"n\">j</span><span class=\"o\">&gt;=</span><span class=\"n\">rightPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"k\">break</span><span class=\"o\">;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">((</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])&lt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]=(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n\t\t\t\t<span class=\"n\">i</span><span class=\"o\">++;</span>\n\t\t\t<span class=\"o\">}</span><span class=\"k\">else</span><span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]=(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n\t\t\t\t<span class=\"n\">j</span><span class=\"o\">++;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">//最后leftPart和rightPart有一个未做set值操作，需要将改值设置到原始数组对应的end值中\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">==</span><span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">end</span><span class=\"o\">]=</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">rightPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t\t<span class=\"o\">}</span><span class=\"k\">else</span>\n\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">[</span><span class=\"n\">end</span><span class=\"o\">]=</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**#########################\n</span><span class=\"cm\">\t * List\n</span><span class=\"cm\">\t * #########################\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 归并排序算法\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 归并算法, 归并待排序数组中从A[start,....,end] 范围内的数据,&lt;br&gt;\n</span><span class=\"cm\">\t * 在该范围内二分后区分为左子数组以及右子数组，并分别对两个子数组做递归归并.\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t * @param start\n</span><span class=\"cm\">\t * @param end\n</span><span class=\"cm\">\t * @return\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">){</span>\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">&lt;</span> <span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">end</span><span class=\"o\">)/</span><span class=\"n\">2</span><span class=\"o\">;</span>\n\t\t\t<span class=\"c1\">// 递归左子数组做归并排序\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">);</span>\n\t\t\t<span class=\"c1\">// 递归右子数组做归并排序\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">end</span><span class=\"o\">);</span>\n\t\t\t<span class=\"c1\">// 归并数组，最终使得A[start,..,q]均小于A[q,end]\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">merge</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">end</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * Merge core method. This method promise the data format as below:&lt;br&gt;\n</span><span class=\"cm\">\t * for A[start,..., end]\n</span><span class=\"cm\">\t *   define int i= (end-start)/2 , split as left part: A[start,...,(end-start+1)], right part: A[(end-start),...,end]\n</span><span class=\"cm\">\t *   merge the two part, and must fit the rules: every element in left part must lower than the ones in right part.\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t * @param start\n</span><span class=\"cm\">\t * @param div\n</span><span class=\"cm\">\t * @param end\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"nd\">@SuppressWarnings</span><span class=\"o\">(</span><span class=\"s\">&#34;unchecked&#34;</span><span class=\"o\">)</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">merge</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">div</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">n1</span> <span class=\"o\">=</span> <span class=\"n\">div</span><span class=\"o\">-</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">//分治的左边\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">n2</span> <span class=\"o\">=</span> <span class=\"n\">end</span><span class=\"o\">-</span><span class=\"n\">div</span><span class=\"o\">;</span> <span class=\"c1\">//分治的右边\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">leftPart</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">n1</span><span class=\"o\">];</span>\n\t\t<span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">rightPart</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">n2</span><span class=\"o\">];</span>\n\t\t<span class=\"c1\">//赋值,初始化左边数组和右边数组\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n1</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n2</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">div</span><span class=\"o\">+</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 对于左半部分和右半部分和原来的数组中元素对比，按照规则set对应值。\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">,</span><span class=\"n\">j</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">start</span><span class=\"o\">;</span><span class=\"n\">k</span><span class=\"o\">&lt;=</span><span class=\"n\">end</span><span class=\"o\">;</span><span class=\"n\">k</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">&gt;=</span> <span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">||</span><span class=\"n\">j</span><span class=\"o\">&gt;=</span><span class=\"n\">rightPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"k\">break</span><span class=\"o\">;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(((</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]).</span><span class=\"na\">compareTo</span><span class=\"o\">((</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])&lt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n<span class=\"c1\">//\t\t\t\tsequenceForSort[k]=(T)leftPart[i];\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"n\">i</span><span class=\"o\">++;</span>\n\t\t\t<span class=\"o\">}</span><span class=\"k\">else</span><span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]);</span>\n<span class=\"c1\">//\t\t\t\tsequenceForSort[k]=(T)rightPart[j];\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"n\">j</span><span class=\"o\">++;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">//最后leftPart和rightPart有一个未做set值操作，需要将改值设置到原始数组对应的end值中\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">==</span><span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">rightPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">]);</span>\n<span class=\"c1\">//\t\t\tsequenceForSort[end]= (T)rightPart[rightPart.length-1];\n</span><span class=\"c1\"></span>\t\t<span class=\"o\">}</span><span class=\"k\">else</span><span class=\"o\">{</span>\n\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">]);</span>\n<span class=\"c1\">//\t\t\tsequenceForSort[end]= (T)leftPart[leftPart.length-1];\n</span><span class=\"c1\"></span>\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 归并排序算法\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 归并算法, 归并待排序数组中从A[start,....,end] 范围内的数据,&lt;br&gt;\n</span><span class=\"cm\">\t * 在该范围内二分后区分为左子数组以及右子数组，并分别对两个子数组做递归归并.\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t * @param start\n</span><span class=\"cm\">\t * @param end\n</span><span class=\"cm\">\t * @return\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">&lt;</span> <span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">end</span><span class=\"o\">)/</span><span class=\"n\">2</span><span class=\"o\">;</span>\n\t\t\t<span class=\"c1\">// 递归左子数组做归并排序\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t\t<span class=\"c1\">// 递归右子数组做归并排序\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">mergeSortAlgorithm</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t\t<span class=\"c1\">// 归并数组，最终使得A[start,..,q]均小于A[q,end]\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">merge</span><span class=\"o\">(</span><span class=\"n\">sequenceForSort</span><span class=\"o\">,</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * Merge core method. This method promise the data format as below:&lt;br&gt;\n</span><span class=\"cm\">\t * for A[start,..., end]\n</span><span class=\"cm\">\t *   define int i= (end-start)/2 , split as left part: A[start,...,(end-start+1)], right part: A[(end-start),...,end]\n</span><span class=\"cm\">\t *   merge the two part, and must fit the rules: every element in left part must lower than the ones in right part.\n</span><span class=\"cm\">\t * @param sequenceForSort\n</span><span class=\"cm\">\t * @param start\n</span><span class=\"cm\">\t * @param div\n</span><span class=\"cm\">\t * @param end\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"nd\">@SuppressWarnings</span><span class=\"o\">(</span><span class=\"s\">&#34;unchecked&#34;</span><span class=\"o\">)</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">merge</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">div</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">n1</span> <span class=\"o\">=</span> <span class=\"n\">div</span><span class=\"o\">-</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">//分治的左边\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">n2</span> <span class=\"o\">=</span> <span class=\"n\">end</span><span class=\"o\">-</span><span class=\"n\">div</span><span class=\"o\">;</span> <span class=\"c1\">//分治的右边\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">leftPart</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">n1</span><span class=\"o\">];</span>\n\t\t<span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">rightPart</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">n2</span><span class=\"o\">];</span>\n\t\t<span class=\"c1\">//赋值,初始化左边数组和右边数组\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n1</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">+</span><span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n2</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">div</span><span class=\"o\">+</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 对于左半部分和右半部分和原来的数组中元素对比，按照规则set对应值。\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">,</span><span class=\"n\">j</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">start</span><span class=\"o\">;</span><span class=\"n\">k</span><span class=\"o\">&lt;=</span><span class=\"n\">end</span><span class=\"o\">;</span><span class=\"n\">k</span><span class=\"o\">++){</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">&gt;=</span> <span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">||</span><span class=\"n\">j</span><span class=\"o\">&gt;=</span><span class=\"n\">rightPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"k\">break</span><span class=\"o\">;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">((</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])&lt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n<span class=\"c1\">//\t\t\t\tsequenceForSort[k]=(T)leftPart[i];\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"n\">i</span><span class=\"o\">++;</span>\n\t\t\t<span class=\"o\">}</span><span class=\"k\">else</span><span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n<span class=\"c1\">//\t\t\t\tsequenceForSort[k]=(T)rightPart[j];\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"n\">j</span><span class=\"o\">++;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">//最后leftPart和rightPart有一个未做set值操作，需要将改值设置到原始数组对应的end值中\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">==</span><span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">rightPart</span><span class=\"o\">[</span><span class=\"n\">rightPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">]);</span>\n<span class=\"c1\">//\t\t\tsequenceForSort[end]= (T)rightPart[rightPart.length-1];\n</span><span class=\"c1\"></span>\t\t<span class=\"o\">}</span><span class=\"k\">else</span><span class=\"o\">{</span>\n\t\t\t<span class=\"n\">sequenceForSort</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">leftPart</span><span class=\"o\">[</span><span class=\"n\">leftPart</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">]);</span>\n<span class=\"c1\">//\t\t\tsequenceForSort[end]= (T)leftPart[leftPart.length-1];\n</span><span class=\"c1\"></span>\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n</code></pre></div>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "排序", 
                    "tagLink": "https://api.zhihu.com/topics/19572852"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25566353", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 1, 
            "title": "排序算法实现-堆排序(Java版本）", 
            "content": "<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>其大致比较执行图为：</p><ul><li><p>定义</p></li></ul><p>堆排序其实是利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p><p>如：</p><p>n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）：</p><p>(1)ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点</p><p>若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</p><ul><li><p>堆数据结构分析<br/></p></li></ul><ol><li><p>高度：堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。</p></li><li><p>堆节点的访问：通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：父节点i的左子节点在位置(2*i+1);父节点i的右子节点在位置(2*i+2);子节点i的父节点在位置floor((i-1)/2);</p></li><li><p>堆的操作：在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。创建最大堆（Build_Max_Heap）：将堆所有数据重新排序堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p></li></ol><p>堆的基本排序步骤为：</p><ul><li><p>Java实现源码分析</p></li></ul><p>首先创建一个方法表示堆排序，参数为待排序数组</p><ol><li><p>在排序之前，我们首先要对当前数组建立一个最大堆或者最小堆</p></li><li><p>然后迭代一次迭代前（n-1）个数，继续奖励最大堆或者最小堆，依次迭代，直到剩下长度为1</p></li></ol><p>那么如何建立最大堆呢(最小堆相反比较即可)，源码如下：</p><p>因为只需要对非叶子节点做最大堆构建，所以建立最大堆的cao做实际上是[0, n/2]之间的节点。</p><ol><li><p>该方法为对序号为i的节点做最大堆的构建，那么该节点的左子节点为：i*2-1, 右子节点为：i*2</p></li><li><p>需要检验左右子节点是否存在。</p></li><li><p>当发现构造的当前堆的根节点发生变更时，需要再次对其父节点做最大堆的重新构造。<br/></p></li></ol><p>我们可以发现，堆算法巧妙的运用了数组和二叉树数据结构关系以及堆数据结构的性质来实现的。只要你懂得最大堆、最小堆的性质，以及如何构建一个最大堆和最小堆，那么该算法应该很快能实现</p><ul><li><p>算法分析</p></li></ul><ol><li><p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。</p></li><li><p>平均性能：O(N*logN)。</p></li><li><p>其他性能：由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。堆排序是就地排序，辅助空间为O(1）.</p></li><li><p>它是不稳定的排序方法。（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化</p></li></ol><br/><p>源代码为：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.hbhs.algorithm.sort</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.Comparator</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.List</span><span class=\"o\">;</span>\n\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 堆排序是一种数组对象，他可以被看成是一个完全二叉树结构。树的每一层都是填满的，随后一层可能除外。\n</span><span class=\"cm\"> * &lt;p&gt;表示堆的数组A是一个具有两个属性的对象：\n</span><span class=\"cm\"> * lenght[A]是数组中的元素个数，heap-size[A]是存放在A中的堆的元素个数。就是说，虽然A[1..length[A]]\n</span><span class=\"cm\"> * 中都包含有效值，但A[heap-size[A]]之后的元素是不属于相应的堆的，此处heap-size[A]&lt;=lenght[A].\n</span><span class=\"cm\"> * &lt;/p&gt;\n</span><span class=\"cm\"> * &lt;p&gt;\n</span><span class=\"cm\"> * 树根为A[1],给定的某节点小标i，其父节点PARENT(i),左儿子LEFT(i)和右儿子RIGHT(i)的下标可以简单的计算出来:\n</span><span class=\"cm\"> * &lt;p&gt;&lt;code&gt;PARENT(i): return [i/2]&lt;/code&gt;&lt;/p&gt;\n</span><span class=\"cm\"> * &lt;p&gt;&lt;code&gt;LEFT(i): return 2i&lt;/code&gt;&lt;/p&gt;\n</span><span class=\"cm\"> * &lt;p&gt;&lt;code&gt;RIGHT(i): return 2i+1&lt;/code&gt;&lt;/p&gt;\n</span><span class=\"cm\"> * &lt;/p&gt;\n</span><span class=\"cm\"> * &lt;p&gt;LEFT过程可以在一条指令内计算出2i，方法是将i的二进制表示左移1位。类似的RIGHT过程也可以通过将i的二进制左移1位并低位中加1，快速计算出2i+1\n</span><span class=\"cm\"> * .\n</span><span class=\"cm\"> * PARENT过程则可以通过把i右移1位而得到[i/2]。在堆排序算法中，这三个过程功过宏过程或者内联过程实现。\n</span><span class=\"cm\"> * &lt;/p&gt;\n</span><span class=\"cm\"> * \n</span><span class=\"cm\"> * &lt;p&gt;\n</span><span class=\"cm\"> * 二叉堆有两种：最大堆和最小堆。两种堆都需要满足堆特性，其细节则视堆的种类而定。\n</span><span class=\"cm\"> * 在最大堆中，最大堆特性是指除了根意外的每个节点i，有&lt;code&gt;A[PARENT(i)&gt;=A[i]]&lt;/code&gt;&lt;br&gt;\n</span><span class=\"cm\"> * 在最小堆中，最小堆特性是指除了根意外的每个节点i，有&lt;code&gt;A[PARENT(i)&lt;=A[i]]&lt;/code&gt;&lt;br&gt;\n</span><span class=\"cm\"> * &lt;/p&gt;\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">HeapSort</span> <span class=\"o\">{</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * &lt;code&gt;&lt;b&gt;堆排序算法&lt;/b&gt;&lt;/code&gt;\n</span><span class=\"cm\">\t * &lt;p&gt;\n</span><span class=\"cm\">\t * 开始时，堆排序算法先用BUILD-MAX-HEAP将数组A[1..n](此处n=lenght[A])构成一个最大堆，\n</span><span class=\"cm\">\t * 因为数组中最大的元素在A[1]，则可以通过将他与A[n]呼唤来达到最终正确的位置。现在，如果从对中去掉节点n(通过减少heap-size[A]),可以\n</span><span class=\"cm\">\t * 很容易的将A[1..n-1]建成最大堆。原来根的子女仍旧是最大堆，而新的根元素则可能违背了最大堆的性质，这个时候需要调用MAX-HEAPIFY(A,1)就保持了这一性质。\n</span><span class=\"cm\">\t * 在A[1..n-1]中构造出最大堆。堆排序算法需要不断重复该过程，堆的大小由n-1一直降到2.\n</span><span class=\"cm\">\t * &lt;/p&gt;\n</span><span class=\"cm\">\t * &lt;code&gt;&lt;b&gt;HEAPSORT(A)&lt;/b&gt;&lt;/code&gt;\n</span><span class=\"cm\">\t * BUILD-MAX-HEAP(A)\n</span><span class=\"cm\">\t * for i &lt;- lenght[A] downto 2\n</span><span class=\"cm\">\t *   do exchange A[1] &lt;-&gt; A[i]\n</span><span class=\"cm\">\t *     heap-size[A] &lt;- heap-size[A]-1\n</span><span class=\"cm\">\t *     MAX-HEAPIFY[A,1]\n</span><span class=\"cm\">\t *     &lt;br&gt;\n</span><span class=\"cm\">\t * &lt;B&gt;堆排序时间复杂度为：&lt;/B&gt;&lt;code&gt;nlgn&lt;/code&gt;\n</span><span class=\"cm\">\t * @param heapSequence\n</span><span class=\"cm\">\t * @return\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">heapSequence</span><span class=\"o\">){</span>\n\t\t<span class=\"c1\">// 创建最大堆\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">buildMaxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">);</span>\n\t\t\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&gt;</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">--){</span>\n\t\t\t\n\t\t\t<span class=\"c1\">// 此时heapSequence[0]的值应该为最大值，与该堆最后一个值互换\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">T</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">));</span>\n\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">,</span><span class=\"n\">1</span><span class=\"o\">,</span><span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * &lt;code&gt;&lt;b&gt;堆排序算法&lt;/b&gt;&lt;/code&gt;\n</span><span class=\"cm\">\t * &lt;p&gt;\n</span><span class=\"cm\">\t * 开始时，堆排序算法先用BUILD-MAX-HEAP将数组A[1..n](此处n=lenght[A])构成一个最大堆，\n</span><span class=\"cm\">\t * 因为数组中最大的元素在A[1]，则可以通过将他与A[n]呼唤来达到最终正确的位置。现在，如果从对中去掉节点n(通过减少heap-size[A]),可以\n</span><span class=\"cm\">\t * 很容易的将A[1..n-1]建成最大堆。原来根的子女仍旧是最大堆，而新的根元素则可能违背了最大堆的性质，这个时候需要调用MAX-HEAPIFY(A,1)就保持了这一性质。\n</span><span class=\"cm\">\t * 在A[1..n-1]中构造出最大堆。堆排序算法需要不断重复该过程，堆的大小由n-1一直降到2.\n</span><span class=\"cm\">\t * &lt;/p&gt;\n</span><span class=\"cm\">\t * &lt;code&gt;&lt;b&gt;HEAPSORT(A)&lt;/b&gt;&lt;/code&gt;\n</span><span class=\"cm\">\t * BUILD-MAX-HEAP(A)\n</span><span class=\"cm\">\t * for i &lt;- lenght[A] downto 2\n</span><span class=\"cm\">\t *   do exchange A[1] &lt;-&gt; A[i]\n</span><span class=\"cm\">\t *     heap-size[A] &lt;- heap-size[A]-1\n</span><span class=\"cm\">\t *     MAX-HEAPIFY[A,1]\n</span><span class=\"cm\">\t *     &lt;br&gt;\n</span><span class=\"cm\">\t * &lt;B&gt;堆排序时间复杂度为：&lt;/B&gt;&lt;code&gt;nlgn&lt;/code&gt;\n</span><span class=\"cm\">\t * @param heapSequence\n</span><span class=\"cm\">\t * @return\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">heapSequence</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"c1\">// 创建最大堆\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">buildMaxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t\t\t\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&gt;</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">--){</span>\n\t\t\t\t\t\n\t\t\t<span class=\"c1\">// 此时heapSequence[0]的值应该为最大值，与该堆最后一个值互换\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">T</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">));</span>\n\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">,</span><span class=\"n\">1</span><span class=\"o\">,</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * &lt;code&gt;&lt;B&gt;创建堆&lt;/B&gt;&lt;/code&gt;\n</span><span class=\"cm\">\t * 对于创建一个HEAP，需要对每个非子节点调用MAX-HEAPIFY(A,i).\n</span><span class=\"cm\">\t * BUILD-MAX-HEAP(A)\n</span><span class=\"cm\">\t * heap-size[A] &lt;- lenght[A]\n</span><span class=\"cm\">\t * for i &lt;- [lenght[A]/2] downto 1\n</span><span class=\"cm\">\t *   do MAX-HEAPIFY(A,i)\n</span><span class=\"cm\">\t * @param heapSequence\n</span><span class=\"cm\">\t * @return\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">buildMaxHeapify</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">heapSequence</span><span class=\"o\">){</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()/</span><span class=\"n\">2</span> <span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&gt;</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">--){</span>\n\t\t\t<span class=\"n\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * &lt;code&gt;&lt;B&gt;创建堆&lt;/B&gt;&lt;/code&gt;\n</span><span class=\"cm\">\t * 对于创建一个HEAP，需要对每个非子节点调用MAX-HEAPIFY(A,i).\n</span><span class=\"cm\">\t * BUILD-MAX-HEAP(A)\n</span><span class=\"cm\">\t * heap-size[A] &lt;- lenght[A]\n</span><span class=\"cm\">\t * for i &lt;- [lenght[A]/2] downto 1\n</span><span class=\"cm\">\t *   do MAX-HEAPIFY(A,i)\n</span><span class=\"cm\">\t * @param heapSequence\n</span><span class=\"cm\">\t * @param c\n</span><span class=\"cm\">\t * @return\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">buildMaxHeapify</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">heapSequence</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()/</span><span class=\"n\">2</span> <span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&gt;</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">--){</span>\n\t\t\t<span class=\"n\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 最大堆 MAX-HEAPIFY(A,i)\n</span><span class=\"cm\">\t * MAX-HEAPIFY(A,i)\n</span><span class=\"cm\">\t *   l &lt;- LEFT(i)\n</span><span class=\"cm\">\t *   r &lt;- RIGHT(i)\n</span><span class=\"cm\">\t *   if l &lt;= heap-size[A] and A[l] &gt; A[i]\n</span><span class=\"cm\">\t *     then largest &lt;- l\n</span><span class=\"cm\">\t *     else largest &lt;- i\n</span><span class=\"cm\">\t *   if r &lt;= heap-size[A] and A[r] &gt; A[largest]\n</span><span class=\"cm\">\t *     then largest &lt;- r\n</span><span class=\"cm\">\t *   if largest != i\n</span><span class=\"cm\">\t *     then exchange A[i] &lt;-&gt; A[largest]\n</span><span class=\"cm\">\t *        MAX-HEAPIFY(A,largest)\n</span><span class=\"cm\">\t * @param heapSequence\n</span><span class=\"cm\">\t * @param i\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">heapSequence</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">leftNode</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">rightNode</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">;</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">leftNode</span><span class=\"o\">&lt;</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()&amp;&amp;</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">leftNode</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">).</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">))</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">leftNode</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span><span class=\"k\">else</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n\t\t\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">rightNode</span><span class=\"o\">&lt;</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()&amp;&amp;</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">rightNode</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">).</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">))&gt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">rightNode</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t\t\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">largest</span> <span class=\"o\">!=</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">T</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">));</span>\n\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">,</span> <span class=\"n\">largest</span><span class=\"o\">);</span>\n\t\t\t\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 最大堆 MAX-HEAPIFY(A,i)\n</span><span class=\"cm\">\t * MAX-HEAPIFY(A,i)\n</span><span class=\"cm\">\t *   l &lt;- LEFT(i)\n</span><span class=\"cm\">\t *   r &lt;- RIGHT(i)\n</span><span class=\"cm\">\t *   if l &lt;= heap-size[A] and A[l] &gt; A[i]\n</span><span class=\"cm\">\t *     then largest &lt;- l\n</span><span class=\"cm\">\t *     else largest &lt;- i\n</span><span class=\"cm\">\t *   if r &lt;= heap-size[A] and A[r] &gt; A[largest]\n</span><span class=\"cm\">\t *     then largest &lt;- r\n</span><span class=\"cm\">\t *   if largest != i\n</span><span class=\"cm\">\t *     then exchange A[i] &lt;-&gt; A[largest]\n</span><span class=\"cm\">\t *        MAX-HEAPIFY(A,largest)\n</span><span class=\"cm\">\t * @param heapSequence\n</span><span class=\"cm\">\t * @param i\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">heapSequence</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">leftNode</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">rightNode</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">;</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">leftNode</span><span class=\"o\">&lt;</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()&amp;&amp;</span>\n\t\t\t\t<span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">leftNode</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">),</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">))</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">leftNode</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span><span class=\"k\">else</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n\t\t\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">rightNode</span><span class=\"o\">&lt;</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()&amp;&amp;</span>\n\t\t\t\t<span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">rightNode</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">),</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">))&gt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">rightNode</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\n\t\t\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">largest</span> <span class=\"o\">!=</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">T</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">));</span>\n<span class=\"c1\">//\t\t\theapSequence[i-1] = heapSequence[largest-1];\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">);</span>\n<span class=\"c1\">//\t\t\theapSequence[largest-1] = key;\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">,</span> <span class=\"n\">largest</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t\t\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 重新堆化节点I，使得该节点下为最大/小堆\n</span><span class=\"cm\">\t * @param heapSequence\n</span><span class=\"cm\">\t * @param i\n</span><span class=\"cm\">\t * @param heapLenght\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">heapSequence</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">heapLenght</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">leftNode</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">;</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">rightNode</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\t\t<span class=\"c1\">// Check if the leftNode is larger currentNode, if yes, mark leftNode as the largestNode.\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">leftNode</span><span class=\"o\">&lt;=</span><span class=\"n\">heapLenght</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">leftNode</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">).</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">))&gt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">leftNode</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span><span class=\"k\">else</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n\t\t<span class=\"c1\">// Check if the rightNode is larger current largestNode, if yes, mark rightNode as the largestNode.\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">rightNode</span><span class=\"o\">&lt;=</span><span class=\"n\">heapLenght</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">rightNode</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">).</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">))&gt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">rightNode</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// Check if the largestNode is currentNode, if not, swap it. And in the same time, heapify the subNode again.\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">largest</span> <span class=\"o\">!=</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">T</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">));</span>\n<span class=\"c1\">//\t\t\theapSequence[i-1] = heapSequence[largest-1];\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">);</span>\n<span class=\"c1\">//\t\t\theapSequence[largest-1] = key;\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// Heapify the swaped subNode.\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">,</span> <span class=\"n\">largest</span><span class=\"o\">,</span><span class=\"n\">heapLenght</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 重新堆化节点I，使得该节点下为最大/小堆\n</span><span class=\"cm\">\t * @param heapSequence\n</span><span class=\"cm\">\t * @param i\n</span><span class=\"cm\">\t * @param heapLenght\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">heapSequence</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">heapLenght</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">leftNode</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">;</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">rightNode</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">leftNode</span><span class=\"o\">&lt;=</span><span class=\"n\">heapLenght</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">leftNode</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">),</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">))&gt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">leftNode</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span><span class=\"k\">else</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n\t\t\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">rightNode</span><span class=\"o\">&lt;=</span><span class=\"n\">heapLenght</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">rightNode</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">),</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">))&gt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">largest</span> <span class=\"o\">=</span> <span class=\"n\">rightNode</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\n\t\t\n\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">largest</span> <span class=\"o\">!=</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"n\">T</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">));</span>\n<span class=\"c1\">//\t\t\theapSequence[i-1] = heapSequence[largest-1];\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">heapSequence</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">largest</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">);</span>\n<span class=\"c1\">//\t\t\theapSequence[largest-1] = key;\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">maxHeapify</span><span class=\"o\">(</span><span class=\"n\">heapSequence</span><span class=\"o\">,</span> <span class=\"n\">largest</span><span class=\"o\">,</span><span class=\"n\">heapLenght</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t\t\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t\n<span class=\"o\">}</span>\n\n</code></pre></div>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "排序", 
                    "tagLink": "https://api.zhihu.com/topics/19572852"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/25547274", 
            "userName": "徐工", 
            "userLink": "https://www.zhihu.com/people/578161486f8bbb3d9b42560a26045c23", 
            "upvote": 2, 
            "title": "排序算法实现-希尔排序(Java版本）", 
            "content": "<p>希尔排序（Shell排序），也称递减增量排序算法，是<a href=\"https://link.zhihu.com/?target=http%3A//m.toutiao.com/i6392853670240715265/%3Fgroup_id%3D6393081352874393857%26group_flags%3D0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">插入排序</a>的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于<a href=\"https://link.zhihu.com/?target=http%3A//m.toutiao.com/i6392853670240715265/%3Fgroup_id%3D6393081352874393857%26group_flags%3D0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">插入排序</a>的以下两点性质而提出改进方法的：</p><ul><li><p>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</p></li><br/><li><p>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p></li></ul><p>其执行大致步骤如下：<br/></p><ul><li><p>基本思想<br/></p></li></ul><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量d(t)=1{d(t)&lt;d(t-1)&lt;...&lt;d(2)&lt;d(1)}</p><p>该方法实质上是一种分组插入方法</p><p>比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。</p><p>一般的初次取序列的一半为增量，以后每次减半，直到增量为1。</p><p>其算法伪代码为：</p><ul><li><p>算法实现</p></li></ul><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p><p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序</p><p>假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><p>我们进行排序后得到</p><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：<br/></p><p>排序后得到</p><p>一直到步长为1时，那么数列就排序好了。</p><ul><li><p>步长序列</p></li></ul><p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p><p>一般来说，步长选择为：n/2</p><ul><li><p>Java实现源码分析</p></li></ul><p>首先我们创建一个方法，参数为待排序的数组</p><p>其中获取步长的方法中选取Kunth的(3*gap+1)公式计算<br/></p><p>获取步长后，我们按照步长的最大到最小值，循环使用简单插入排序即可，简单插入排序的算法实现为：<br/></p><p>循环调用，知道步长为1时，数组就排序好了。</p><ul><li><p>算法分析</p></li></ul><ol><li><p>不需要大量的辅助空间，和归并排序一样容易实现。希尔排序是基于插入排序的一种算法， 在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间复杂度与增量序列的选取有关</p></li><li><p>希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。</p></li><li><p>希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法</p></li><li><p>Shell排序的时间性能优于直接插入排序，希尔排序在效率上较直接插入排序有较大的改进。</p></li></ol><p>源代码如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.hbhs.algorithm.sort</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.ArrayList</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.Comparator</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.List</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）\n</span><span class=\"cm\"> * input: an array a of length n with array elements numbered 0 to n − 1\n</span><span class=\"cm\"> * inc ← round(n/2)\n</span><span class=\"cm\"> * while inc &gt; 0 do:    \n</span><span class=\"cm\"> *     for i = inc .. n − 1 do:        \n</span><span class=\"cm\"> *        temp ← a[i]\n</span><span class=\"cm\"> *        j ← i\n</span><span class=\"cm\"> *        while j ≥ inc and a[j − inc] &gt; temp do:\n</span><span class=\"cm\"> *          a[j] ← a[j − inc] \n</span><span class=\"cm\"> *          j ← j − inc   \n</span><span class=\"cm\"> *        a[j] ← temp  \n</span><span class=\"cm\"> *     inc ← round(inc / 2)\n</span><span class=\"cm\"> * \n</span><span class=\"cm\"> * STEP 1:\n</span><span class=\"cm\"> * 13 14 94 33 82\n</span><span class=\"cm\"> * 25 59 94 65 23\n</span><span class=\"cm\"> * 45 27 73 25 39\n</span><span class=\"cm\"> * 10\n</span><span class=\"cm\"> * \n</span><span class=\"cm\"> * STEP 2:\n</span><span class=\"cm\"> * 10 14 73 25 23\n</span><span class=\"cm\"> * 13 27 94 33 39\n</span><span class=\"cm\"> * 25 59 94 65 82\n</span><span class=\"cm\"> * 45\n</span><span class=\"cm\"> * \n</span><span class=\"cm\"> * STEP 3\n</span><span class=\"cm\"> * 10 14 73\n</span><span class=\"cm\"> * 25 23 13\n</span><span class=\"cm\"> * 27 94 33\n</span><span class=\"cm\"> * 39 25 59\n</span><span class=\"cm\"> * 94 65 82\n</span><span class=\"cm\"> * 45\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * STEP 4 ...\n</span><span class=\"cm\"> * 10 14 13\n</span><span class=\"cm\"> * 25 23 33\n</span><span class=\"cm\"> * 27 25 59\n</span><span class=\"cm\"> * 39 65 73\n</span><span class=\"cm\"> * 45 94 82\n</span><span class=\"cm\"> * 94\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * @author walter.xu\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ShellSort</span> <span class=\"o\">{</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * Shell sort\n</span><span class=\"cm\">\t * @param sequenceArray\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceArray</span><span class=\"o\">){</span>\n\t\t<span class=\"c1\">// 步长列表\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">gapList</span> <span class=\"o\">=</span> <span class=\"n\">getGapArray</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span>\n\t\t<span class=\"c1\">// 循环步长\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">step</span> <span class=\"o\">=</span> <span class=\"n\">gapList</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">step</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">step</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">stepSize</span> <span class=\"o\">=</span> <span class=\"n\">gapList</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">step</span><span class=\"o\">);</span>\n\t\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">stepSize</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"c1\">// 做简单插入排序操作\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"n\">simpleInsertSort</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"n\">stepSize</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 简单插入排序，排序的序列为：\n</span><span class=\"cm\">\t * A[currentIndex],A[currentIndex-stepSize],A[currentIndex-2*stepSize],A[currentIndex-3*stepSize]...\n</span><span class=\"cm\">\t * @param sequenceArray\n</span><span class=\"cm\">\t * @param stepSize\n</span><span class=\"cm\">\t * @param currentIndex\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">simpleInsertSort</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">stepSize</span><span class=\"o\">,</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">currentIndex</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">T</span> <span class=\"n\">currentValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">];</span>\n\t\t<span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">currentIndex</span> <span class=\"o\">&gt;=</span> <span class=\"n\">stepSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"c1\">// 如果上个节点比当前节点达\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">-</span><span class=\"n\">stepSize</span><span class=\"o\">].</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">])&lt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"c1\">// 如果找到一个节点比当前节点小，则表示该节点为当前值待插入的节点\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"k\">break</span><span class=\"o\">;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"c1\">// 如果上一个值比当前值要大，则后移上一个值到当前值，同时将指针继续往前移一位\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">-</span><span class=\"n\">stepSize</span><span class=\"o\">];</span>\n\t\t\t<span class=\"n\">currentIndex</span> <span class=\"o\">-=</span> <span class=\"n\">stepSize</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 设置当前参照节点值\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">currentValue</span><span class=\"o\">;</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * Shell sort\n</span><span class=\"cm\">\t * @param sequenceArray\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"c1\">// 步长列表\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">gapList</span> <span class=\"o\">=</span> <span class=\"n\">getGapArray</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span>\n\t\t<span class=\"c1\">// 循环步长\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">step</span> <span class=\"o\">=</span> <span class=\"n\">gapList</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">step</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">step</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">stepSize</span> <span class=\"o\">=</span> <span class=\"n\">gapList</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">step</span><span class=\"o\">);</span>\n\t\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">stepSize</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"c1\">// 做简单插入排序操作\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"n\">simpleInsertSort</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"n\">stepSize</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 简单插入排序，排序的序列为：\n</span><span class=\"cm\">\t * A[currentIndex],A[currentIndex-stepSize],A[currentIndex-2*stepSize],A[currentIndex-3*stepSize]...\n</span><span class=\"cm\">\t * @param sequenceArray\n</span><span class=\"cm\">\t * @param stepSize\n</span><span class=\"cm\">\t * @param currentIndex\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">simpleInsertSort</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">[]</span> <span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">stepSize</span><span class=\"o\">,</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">currentIndex</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">T</span> <span class=\"n\">currentValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">];</span>\n\t\t<span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">currentIndex</span> <span class=\"o\">&gt;=</span> <span class=\"n\">stepSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"c1\">// 如果上个节点比当前节点达\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">-</span><span class=\"n\">stepSize</span><span class=\"o\">],</span> <span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">])&lt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"c1\">// 如果找到一个节点比当前节点小，则表示该节点为当前值待插入的节点\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"k\">break</span><span class=\"o\">;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"c1\">// 如果上一个值比当前值要大，则后移上一个值到当前值，同时将指针继续往前移一位\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">-</span><span class=\"n\">stepSize</span><span class=\"o\">];</span>\n\t\t\t<span class=\"n\">currentIndex</span> <span class=\"o\">-=</span> <span class=\"n\">stepSize</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 设置当前参照节点值\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">sequenceArray</span><span class=\"o\">[</span><span class=\"n\">currentIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">currentValue</span><span class=\"o\">;</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * Shell sort\n</span><span class=\"cm\">\t * @param sequenceArray\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceArray</span><span class=\"o\">){</span>\n\t\t<span class=\"c1\">// 步长列表\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">gapList</span> <span class=\"o\">=</span> <span class=\"n\">getGapArray</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">());</span>\n\t\t<span class=\"c1\">// 循环步长\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">step</span> <span class=\"o\">=</span> <span class=\"n\">gapList</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">step</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">step</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">stepSize</span> <span class=\"o\">=</span> <span class=\"n\">gapList</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">step</span><span class=\"o\">);</span>\n\t\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">stepSize</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"c1\">// 做简单插入排序操作\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"n\">simpleInsertSort</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"n\">stepSize</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 简单插入排序，排序的序列为：\n</span><span class=\"cm\">\t * A[currentIndex],A[currentIndex-stepSize],A[currentIndex-2*stepSize],A[currentIndex-3*stepSize]...\n</span><span class=\"cm\">\t * @param sequenceArray\n</span><span class=\"cm\">\t * @param stepSize\n</span><span class=\"cm\">\t * @param currentIndex\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"kd\">extends</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;?</span> <span class=\"kd\">super</span> <span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">simpleInsertSort</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">stepSize</span><span class=\"o\">,</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">currentIndex</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">T</span> <span class=\"n\">currentValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">);</span>\n\t\t<span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">currentIndex</span> <span class=\"o\">&gt;=</span> <span class=\"n\">stepSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"c1\">// 如果上个节点比当前节点达\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">-</span><span class=\"n\">stepSize</span><span class=\"o\">).</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">))&lt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"c1\">// 如果找到一个节点比当前节点小，则表示该节点为当前值待插入的节点\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"k\">break</span><span class=\"o\">;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"c1\">// 如果上一个值比当前值要大，则后移上一个值到当前值，同时将指针继续往前移一位\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">,</span> <span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">-</span><span class=\"n\">stepSize</span><span class=\"o\">));</span>\n<span class=\"c1\">//\t\t\tsequenceArray[currentIndex] = sequenceArray[currentIndex-stepSize];\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">currentIndex</span> <span class=\"o\">-=</span> <span class=\"n\">stepSize</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 设置当前参照节点值\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">,</span> <span class=\"n\">currentValue</span><span class=\"o\">);</span>\n<span class=\"c1\">//\t\tsequenceArray[currentIndex] = currentValue;\n</span><span class=\"c1\"></span>\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * Shell sort\n</span><span class=\"cm\">\t * @param sequenceArray\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"c1\">// 步长列表\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">gapList</span> <span class=\"o\">=</span> <span class=\"n\">getGapArray</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">());</span>\n\t\t<span class=\"c1\">// 循环步长\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">step</span> <span class=\"o\">=</span> <span class=\"n\">gapList</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">step</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">step</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">stepSize</span> <span class=\"o\">=</span> <span class=\"n\">gapList</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">step</span><span class=\"o\">);</span>\n\t\t\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">stepSize</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"c1\">// 做简单插入排序操作\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"n\">simpleInsertSort</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"n\">stepSize</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 简单插入排序，排序的序列为：\n</span><span class=\"cm\">\t * A[currentIndex],A[currentIndex-stepSize],A[currentIndex-2*stepSize],A[currentIndex-3*stepSize]...\n</span><span class=\"cm\">\t * @param sequenceArray\n</span><span class=\"cm\">\t * @param stepSize\n</span><span class=\"cm\">\t * @param currentIndex\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"kt\">void</span> <span class=\"nf\">simpleInsertSort</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">sequenceArray</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">stepSize</span><span class=\"o\">,</span>\n\t\t\t<span class=\"kt\">int</span> <span class=\"n\">currentIndex</span><span class=\"o\">,</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">T</span> <span class=\"n\">currentValue</span> <span class=\"o\">=</span> <span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">);</span>\n\t\t<span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">currentIndex</span> <span class=\"o\">&gt;=</span> <span class=\"n\">stepSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"c1\">// 如果上个节点比当前节点达\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">compare</span><span class=\"o\">(</span><span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">-</span><span class=\"n\">stepSize</span><span class=\"o\">),</span> <span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">))&lt;</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"c1\">// 如果找到一个节点比当前节点小，则表示该节点为当前值待插入的节点\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"k\">break</span><span class=\"o\">;</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t<span class=\"c1\">// 如果上一个值比当前值要大，则后移上一个值到当前值，同时将指针继续往前移一位\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">,</span> <span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">-</span><span class=\"n\">stepSize</span><span class=\"o\">));</span>\n<span class=\"c1\">//\t\t\tsequenceArray[currentIndex] = sequenceArray[currentIndex-stepSize];\n</span><span class=\"c1\"></span>\t\t\t<span class=\"n\">currentIndex</span> <span class=\"o\">-=</span> <span class=\"n\">stepSize</span><span class=\"o\">;</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"c1\">// 设置当前参照节点值\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">sequenceArray</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">currentIndex</span><span class=\"o\">,</span> <span class=\"n\">currentValue</span><span class=\"o\">);</span>\n<span class=\"c1\">//\t\tsequenceArray[currentIndex] = currentValue;\n</span><span class=\"c1\"></span>\t<span class=\"o\">}</span>\n\t\n\t<span class=\"cm\">/**\n</span><span class=\"cm\">\t * 获取所有步长的数组,可以选择普通的n/2方式.\n</span><span class=\"cm\">\t * 经查询后发现最好步长串行是由Sedgewick提出的 (1, 5, 19, 41, 109,...)\n</span><span class=\"cm\">\t * 该串行的项来自 9 * 4^i - 9 * 2^i + 1 和 4^i - 3 * 2^i + 1 .\n</span><span class=\"cm\">\t * 本例中采用步长公式为：gap*3+1: by Knuth,1973&gt;: 1, 4, 13, 40, 121\n</span><span class=\"cm\">\t * @param sequenceSize\n</span><span class=\"cm\">\t * @return\n</span><span class=\"cm\">\t */</span>\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">getGapArray</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">sequenceSize</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">gapList</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;();</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">gapSize</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\t\t<span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">gapSize</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceSize</span><span class=\"o\">){</span>\n\t\t\t<span class=\"n\">gapSize</span> <span class=\"o\">=</span> <span class=\"n\">3</span><span class=\"o\">*</span><span class=\"n\">gapSize</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">gapSize</span> <span class=\"o\">&lt;</span> <span class=\"n\">sequenceSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t\t\t<span class=\"n\">gapList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">gapSize</span><span class=\"o\">);</span>\n\t\t\t<span class=\"o\">}</span>\n\t\t\t\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">gapList</span><span class=\"o\">;</span>\n\t<span class=\"o\">}</span>\n\t\n<span class=\"o\">}</span>\n\n</code></pre></div><p>rt</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "排序", 
                    "tagLink": "https://api.zhihu.com/topics/19572852"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/ml123"
}
