{
    "title": "风中饮酒的程序员", 
    "description": "记录当下这一刻的灵感与喜悦", 
    "followers": [
        "https://www.zhihu.com/people/peng-jun-qin-28", 
        "https://www.zhihu.com/people/zui-ai-ping-guo-cu", 
        "https://www.zhihu.com/people/mu-yi-56-20", 
        "https://www.zhihu.com/people/haha-49-41-44", 
        "https://www.zhihu.com/people/ai-chi-yu-fa-tang", 
        "https://www.zhihu.com/people/zhou-ming-64-31", 
        "https://www.zhihu.com/people/shou-ye-ren-zzz", 
        "https://www.zhihu.com/people/man-zhe-ye-95", 
        "https://www.zhihu.com/people/pch-45-70", 
        "https://www.zhihu.com/people/xd-huo", 
        "https://www.zhihu.com/people/wei-jian-wei-60", 
        "https://www.zhihu.com/people/FutureWL", 
        "https://www.zhihu.com/people/chu-meng-ying-45", 
        "https://www.zhihu.com/people/zhu-bu-zhi-32", 
        "https://www.zhihu.com/people/zou-yi-54-36", 
        "https://www.zhihu.com/people/da-pang-zi-8-95", 
        "https://www.zhihu.com/people/efd0", 
        "https://www.zhihu.com/people/liu-guang-zhong-28", 
        "https://www.zhihu.com/people/nurenok-91", 
        "https://www.zhihu.com/people/jasmine-26-31", 
        "https://www.zhihu.com/people/wang5990302", 
        "https://www.zhihu.com/people/xi-feng-22-11", 
        "https://www.zhihu.com/people/bind-27", 
        "https://www.zhihu.com/people/chen-tao-64-74", 
        "https://www.zhihu.com/people/wang-xue-19-52", 
        "https://www.zhihu.com/people/lishuang", 
        "https://www.zhihu.com/people/xia-tian-63-78-54", 
        "https://www.zhihu.com/people/yao-liao-yao-tou-29-11", 
        "https://www.zhihu.com/people/congx", 
        "https://www.zhihu.com/people/asdbaihu-41", 
        "https://www.zhihu.com/people/liuhui-wh", 
        "https://www.zhihu.com/people/yang-hong-hong-18-63", 
        "https://www.zhihu.com/people/havanese.com", 
        "https://www.zhihu.com/people/ding-felix", 
        "https://www.zhihu.com/people/du-hao-ming", 
        "https://www.zhihu.com/people/xie-wen-60", 
        "https://www.zhihu.com/people/lisa-negi", 
        "https://www.zhihu.com/people/lan-ling-xiao-xiao-sheng-39-41", 
        "https://www.zhihu.com/people/xin-ba-33-19", 
        "https://www.zhihu.com/people/lin-zi-27-39", 
        "https://www.zhihu.com/people/ler0ever", 
        "https://www.zhihu.com/people/ke-zi-13-63", 
        "https://www.zhihu.com/people/bo-luo-chui-xue-0534", 
        "https://www.zhihu.com/people/meng-xuan-10-1", 
        "https://www.zhihu.com/people/jayleee", 
        "https://www.zhihu.com/people/mod-ty", 
        "https://www.zhihu.com/people/dang-nian-ming-yue-zai-11", 
        "https://www.zhihu.com/people/liu-xiao-sheng-27", 
        "https://www.zhihu.com/people/viggoxia", 
        "https://www.zhihu.com/people/lin-sheng-piao-yang", 
        "https://www.zhihu.com/people/tan-yan-16-73", 
        "https://www.zhihu.com/people/zhuqyuan", 
        "https://www.zhihu.com/people/astella-li", 
        "https://www.zhihu.com/people/ai-chi-rou-rou-de-guo-bao", 
        "https://www.zhihu.com/people/wlz-14", 
        "https://www.zhihu.com/people/zhang-zi-cheng-81", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/yong-hu-6375007497", 
        "https://www.zhihu.com/people/liucen", 
        "https://www.zhihu.com/people/wen-jie-16-47", 
        "https://www.zhihu.com/people/wyq-6-60", 
        "https://www.zhihu.com/people/qin-jy-6", 
        "https://www.zhihu.com/people/halomaster", 
        "https://www.zhihu.com/people/han-lin-12-93", 
        "https://www.zhihu.com/people/yuan-kun-82-85", 
        "https://www.zhihu.com/people/li-wei-ran-43", 
        "https://www.zhihu.com/people/storm-java", 
        "https://www.zhihu.com/people/cao-yue-82-71", 
        "https://www.zhihu.com/people/tao-jian-37-93", 
        "https://www.zhihu.com/people/ming-yu-69-3", 
        "https://www.zhihu.com/people/xuan-che", 
        "https://www.zhihu.com/people/pan-chen-liang-74", 
        "https://www.zhihu.com/people/ruan-dao", 
        "https://www.zhihu.com/people/tnlj", 
        "https://www.zhihu.com/people/org.println", 
        "https://www.zhihu.com/people/xiao-xiao-feng-che", 
        "https://www.zhihu.com/people/jeysin", 
        "https://www.zhihu.com/people/chao-ru-98", 
        "https://www.zhihu.com/people/taciturn-knight-52-35", 
        "https://www.zhihu.com/people/soaa", 
        "https://www.zhihu.com/people/jesse-8-81", 
        "https://www.zhihu.com/people/tian-tian-xiang-shang-96-2-19", 
        "https://www.zhihu.com/people/li-li-41-95-90", 
        "https://www.zhihu.com/people/wang-chuan-gui-33", 
        "https://www.zhihu.com/people/luo-shen-49-41", 
        "https://www.zhihu.com/people/ding-da-lei-58", 
        "https://www.zhihu.com/people/dwq-54-62", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/straydragon", 
        "https://www.zhihu.com/people/a-xu-50-22", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/zhangjiyang", 
        "https://www.zhihu.com/people/zhang-fei-chi-58", 
        "https://www.zhihu.com/people/meng-wen-19", 
        "https://www.zhihu.com/people/li-yang-32-77-91", 
        "https://www.zhihu.com/people/zagnix", 
        "https://www.zhihu.com/people/you-ming-chen-76", 
        "https://www.zhihu.com/people/da-xiong-mao-1-93", 
        "https://www.zhihu.com/people/cpm-81", 
        "https://www.zhihu.com/people/yu-ming-63-67", 
        "https://www.zhihu.com/people/zhangsan-97-39", 
        "https://www.zhihu.com/people/windroid-24", 
        "https://www.zhihu.com/people/peng-jin-yi", 
        "https://www.zhihu.com/people/shi-yi-69-52", 
        "https://www.zhihu.com/people/chen-yi-liang-64-71", 
        "https://www.zhihu.com/people/guo-zhen-38", 
        "https://www.zhihu.com/people/jia-wen-quan-53", 
        "https://www.zhihu.com/people/lei-zi-hai", 
        "https://www.zhihu.com/people/er-jin-zhi-43", 
        "https://www.zhihu.com/people/advstock", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/zhuang-___-hang", 
        "https://www.zhihu.com/people/xiaoxx_5", 
        "https://www.zhihu.com/people/fseraph", 
        "https://www.zhihu.com/people/ming-shi-46", 
        "https://www.zhihu.com/people/wu-yin-25", 
        "https://www.zhihu.com/people/rockcheung", 
        "https://www.zhihu.com/people/kilia-xixi", 
        "https://www.zhihu.com/people/liu-zheng-71-3", 
        "https://www.zhihu.com/people/jiahut", 
        "https://www.zhihu.com/people/syaka", 
        "https://www.zhihu.com/people/chenai001", 
        "https://www.zhihu.com/people/wei-juan-ran", 
        "https://www.zhihu.com/people/zcode", 
        "https://www.zhihu.com/people/shi-zhong-71-24", 
        "https://www.zhihu.com/people/likelxl", 
        "https://www.zhihu.com/people/yorkj", 
        "https://www.zhihu.com/people/liu-sha-22-64", 
        "https://www.zhihu.com/people/he-he-he-45-57", 
        "https://www.zhihu.com/people/pangPython", 
        "https://www.zhihu.com/people/yuanjch-35", 
        "https://www.zhihu.com/people/cashplk", 
        "https://www.zhihu.com/people/liu-qi-10-14-98", 
        "https://www.zhihu.com/people/ta-xue-wu-hen-21-78", 
        "https://www.zhihu.com/people/lemon-94-10", 
        "https://www.zhihu.com/people/spartacus", 
        "https://www.zhihu.com/people/yun-yin-81-1", 
        "https://www.zhihu.com/people/lu-dai-ma-de-sheng-ge", 
        "https://www.zhihu.com/people/wlovey", 
        "https://www.zhihu.com/people/cheng-zheng-7-24", 
        "https://www.zhihu.com/people/shaco.zhu", 
        "https://www.zhihu.com/people/wei-xu-hong", 
        "https://www.zhihu.com/people/ye-lane-38", 
        "https://www.zhihu.com/people/xiao-liu-3-81", 
        "https://www.zhihu.com/people/silencedzhu-h", 
        "https://www.zhihu.com/people/zhao-xiao-pang-38-68", 
        "https://www.zhihu.com/people/xu-bo-11-5", 
        "https://www.zhihu.com/people/qipais", 
        "https://www.zhihu.com/people/fang-yu-83-9", 
        "https://www.zhihu.com/people/jianglei131", 
        "https://www.zhihu.com/people/a-a-a-98", 
        "https://www.zhihu.com/people/man-mu-huang-tang", 
        "https://www.zhihu.com/people/long-xiang-ling-53", 
        "https://www.zhihu.com/people/xu-wan-jin-6", 
        "https://www.zhihu.com/people/liu-liu-98-32", 
        "https://www.zhihu.com/people/li-yong-chuan", 
        "https://www.zhihu.com/people/pein-81", 
        "https://www.zhihu.com/people/miss-lee-17", 
        "https://www.zhihu.com/people/wang-chang-fu-32", 
        "https://www.zhihu.com/people/eukire", 
        "https://www.zhihu.com/people/eta-100a", 
        "https://www.zhihu.com/people/she-wo-qi-shui-1573", 
        "https://www.zhihu.com/people/du-fei-yang-10", 
        "https://www.zhihu.com/people/zhipengliu", 
        "https://www.zhihu.com/people/si-mi-da-12-34", 
        "https://www.zhihu.com/people/kevin-hill", 
        "https://www.zhihu.com/people/starzhu-meng-meng", 
        "https://www.zhihu.com/people/fang-qing-li-26", 
        "https://www.zhihu.com/people/dang-chu-xiang", 
        "https://www.zhihu.com/people/PengKing", 
        "https://www.zhihu.com/people/she-liang", 
        "https://www.zhihu.com/people/tmhoney-71", 
        "https://www.zhihu.com/people/hijackjave", 
        "https://www.zhihu.com/people/cheou", 
        "https://www.zhihu.com/people/wen-zhi-hong", 
        "https://www.zhihu.com/people/rsysw", 
        "https://www.zhihu.com/people/qu-ni-tui", 
        "https://www.zhihu.com/people/sky-15"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/82876123", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 1, 
            "title": "如果你也缺个对象池", 
            "content": "<h2>0 引言</h2><p>如果你也缺个对象池，可能会看到这篇文章；如果你看到这篇文章，那就没必要解释为什么使用对象池和它的作用了。</p><p>对象池的设计与实现常见有两种思路，一是利用现成的第三方<b>对象池</b>二次包装，站在巨人的肩膀晒太阳，二是池子底层的容器也自己造，造伦子一时爽，一直造一直爽。而这两者刚好典型代表可参照Jedis与durid 的连接池设计。</p><h2>1. 二次封装：参考redis connnetion pool</h2><p>jedis pool 底层采用apache的对象池<b>GenericObjectPool</b>实现, <b>GenericObjectPool</b> 提供了后进先出(LIFO)与先进先出(FIFO)两种行为模式的池。默认为true，即当池中有空闲可用的对象时，调用borrowObject方法会返回最近（后进）的实例。</p><p>GenericObjectPool实现了ObjectPool&lt;T&gt;接口，而ObjectPool&lt;T&gt;中有以下方法：</p><blockquote>Object borrowObject() // 从池中获得一个对象 <br/>void returnObject(Object obj) // 返回一个对象给池 <br/>void invalidateObject(Object obj) // 使对象实效，不再受池管辖（必须是已经从池中获得的对象） <br/>void addObject() // 生成一个对象（通过工程或其他实现方式），并将其放入空闲队列中 <br/>int getNumIdle() // 获得空闲对象的数量 <br/>int getNumActive() // 获得活动对象的数量 <br/>void clear() // 清空池中空闲对象<b>，</b>释放相关资源 <br/>void close() // 关闭池，释放所有与它相关资源 <br/>void setFactory(PoolableObjectFactory factory) // 设置池对象工厂</blockquote><p>稍微深挖下，GenericObjectPool 底层采用map装载所有链接，利用<b>LinkedBlockingDeque</b>装载所有空闲链接，LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</p><div class=\"highlight\"><pre><code class=\"language-text\">//所有的链接容器：\nprivate final Map&lt;IdentityWrapper&lt;T&gt;, PooledObject&lt;T&gt;&gt; allObjects;\n//空闲的链接容器：\nprivate final LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt; idleObjects;</code></pre></div><p>jedis pool设计方案 初始化，取链接，归还链接:</p><div class=\"highlight\"><pre><code class=\"language-text\">public void initPool(final GenericObjectPoolConfig poolConfig, PooledObjectFactory&lt;T&gt; factory) {\n  if (this.internalPool != null) {\n    try {\n      closeInternalPool();\n    } catch (Exception e) {\n    }\n  }\n  this.internalPool = new GenericObjectPool&lt;T&gt;(factory, poolConfig);\n}</code></pre></div><div class=\"highlight\"><pre><code class=\"language-text\">public T getResource() {\n  try {\n    return internalPool.borrowObject();\n  } catch (NoSuchElementException nse) {\n    throw new JedisException(&#34;Could not get a resource from the pool&#34;, nse);\n  } catch (Exception e) {\n    throw new JedisConnectionException(&#34;Could not get a resource from the pool&#34;, e);\n  }\n}</code></pre></div><div class=\"highlight\"><pre><code class=\"language-text\">@Deprecated\npublic void returnResourceObject(final T resource) {\n  if (resource == null) {\n    return;\n  }\n  try {\n    internalPool.returnObject(resource);\n  } catch (Exception e) {\n    throw new JedisException(&#34;Could not return the resource to the pool&#34;, e);\n  }\n}</code></pre></div><h2><b>2. 造轮子：参考druid connnetion pool</b></h2><p>drurd连接池主要用到的是ReentrantLock锁，还有 notEmpty empty两个条件(condition)，生产连接与消费连接的线程在两个条件上等待与唤醒。连接池是由数据源确定的，所以具体要看pool包里的DruidAbstractDataSource与DruidDataSource两个类了。</p><p>这两个类庞大得一米，首先看了一下属性，主要有很多count，time，还有一些default值，留意集合字段，比如Map&lt;DruidPooledConnection, Object&gt; activeConnections，利用一个数组 private volatile DruidConnectionHolder[] connections标识对象池。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e11cf452ce4c62a0acdce7e397f53955_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1255\" data-rawheight=\"383\" class=\"origin_image zh-lightbox-thumb\" width=\"1255\" data-original=\"https://pic2.zhimg.com/v2-e11cf452ce4c62a0acdce7e397f53955_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1255&#39; height=&#39;383&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1255\" data-rawheight=\"383\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1255\" data-original=\"https://pic2.zhimg.com/v2-e11cf452ce4c62a0acdce7e397f53955_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e11cf452ce4c62a0acdce7e397f53955_b.jpg\"/></figure><p><b>2.1创建连接</b></p><p>先看看DruidDataSource里的CreateConnectionThread都干什么，连接太多了的时候，在empty条件上等待，就是等空了再运行，现在别急着创建连接，等着吧！</p><div class=\"highlight\"><pre><code class=\"language-text\">// 防止创建超过maxActive数量的连接\n  if (activeCount + poolingCount &gt;= maxActive) {  \n             empty.await();  \n  continue;  \n         }  \n try {  \n     connection = createPhysicalConnection();  \n     setFailContinuous(false);  \n boolean result = put(connection);  \n </code></pre></div><p><b>2.2使用连接</b></p><p>那么谁在notEmpty条件上等待呢？我们查一下，发现是方法  DruidConnectionHolder takeLast()之中，当poolingCount中数量为0时等待。正好说明使用连接的线程，当连接没有时，就等待着呗。如果池中有连接呢？就执行下面的语句了：</p><div class=\"highlight\"><pre><code class=\"language-text\">decrementPoolingCount();//减少池中连接的计数，当然拿走一个少一个了。\nDruidConnectionHolder last = connections[poolingCount];//正好拿走的是池中最后一个。\nconnections[poolingCount] = null;//最后一个就成null了。</code></pre></div><p><b>2.3减少连接</b></p><p>在创建连接线程附近还有一个DestroyConnectionThread()，跟踪里面，有destroyTask.run();-----&gt;shrink(true);看名字是收缩嘛，可能连接空闲的太多了，就缩小呗。<br/>在shrink()方法中，重点有下面的语句，分析放在后面：<br/>final int checkCount = poolingCount - minIdle;//池中的数量-最小空闲数量，感觉是收缩的条件之一</p><div class=\"highlight\"><pre><code class=\"language-text\"> for (DruidConnectionHolder item : evictList) {//可回收的都放在这里了 \n     Connection connection = item.getConnection();  \n     JdbcUtils.close(connection);//关闭这些连接了。 \n     destroyCount.incrementAndGet();  \n }  </code></pre></div><p><b>2.4 初始化方法init()</b></p><p>都是谁在用这两个线程呢？查找一下，发现<b>创建线程与收缩线程</b>是由void init()来调用的，看名字就知道这是系统启动的主方法了。</p><div class=\"highlight\"><pre><code class=\"language-text\">void init(){\n     initFromSPIServiceLoader();//load filters from SPI ServiceLoader，\n connections = new DruidConnectionHolder[maxActive];//新建连接池，个数是最大活动连接数maxActive。 \n   for (int i = 0, size = getInitialSize(); i &lt; size; ++i) {//放入连接池中连接 \n                     PhysicalConnectionInfo pyConnectInfo = createPhysicalConnection();  \n                     DruidConnectionHolder holder = new DruidConnectionHolder(this, pyConnectInfo);  \n                     connections[poolingCount] = holder;  \n                   incrementPoolingCount();  \n               }  \n            createAndLogThread();//看名字是日志，就不看了 \n           createAndStartCreatorThread();//创建连接的线程，一直在工作，池子满了就是等待状态。 \n           createAndStartDestroyThread();//收缩池子的线程，一直在工作。 \n \n             initedLatch.await();//主线程在计数器为0前一直等待。 \n      init = true;  \n}  </code></pre></div><p>创建线程与收缩线程两步采用CountDownLatch实现控制：</p><div class=\"highlight\"><pre><code class=\"language-text\">CountDownLatch             initedLatch             = new CountDownLatch(2);</code></pre></div><p><br/>当前同步数为2，在变成0后，主线程才能运行，否则一直等待中。在<b>创建连接</b>与<b>收缩池子</b>的线程中都有initedLatch.countDown();，一共正好两个，那么主线程就是等待上面两个线程都运行了才运行吧，才置init状态标识为true。</p><h2>3 自定义对象池案例</h2><p>参考了以上两种方式，我们再设计自己的对象池就有据可循了，总结下一个<b>连接池基本特性</b>：</p><ul><li>创建并不是真的创建，而是从池子中选出空闲连接。</li><li>销毁并不是真的销毁，而是将使用中的连接放回池中。</li><li>真正的创建和销毁由线程池的特性机制来决定。</li><li>保存连接的容器是必不可少的，另外，该容器也要支持连接的添加和移除功能，并保证线程安全。</li><li>我们需要因为要对连接的销毁做逻辑调整，我们需要重写它的close以及isClosed方法。</li><li>我们需要有个入口对连接池做管理，例如回收空闲连接，连接池不仅仅只是对Connection生命周期的控制，还应该加入一些特色，例如初始连接数，最大连接数，最小连接数、最大空闲时长以及获取连接的等待时长，这些我们也简单支持一下。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-50bedb208e3884c49204148a5e6df882_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb\" width=\"469\" data-original=\"https://pic3.zhimg.com/v2-50bedb208e3884c49204148a5e6df882_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;469&#39; height=&#39;294&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"469\" data-original=\"https://pic3.zhimg.com/v2-50bedb208e3884c49204148a5e6df882_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-50bedb208e3884c49204148a5e6df882_b.jpg\"/></figure><p><b> 3.1 对象可复用的条件（condition）</b></p><p>由于对象池对象的可复用性，故设计对象池前很必要的一步就是调研对象可复用的条件，以便在归还对象时释放资源。</p><p><b> 3.2 对象池任务调度流程</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7fb6949e2bb9519b9295893de4dafac4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1833\" data-rawheight=\"778\" class=\"origin_image zh-lightbox-thumb\" width=\"1833\" data-original=\"https://pic1.zhimg.com/v2-7fb6949e2bb9519b9295893de4dafac4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1833&#39; height=&#39;778&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1833\" data-rawheight=\"778\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1833\" data-original=\"https://pic1.zhimg.com/v2-7fb6949e2bb9519b9295893de4dafac4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7fb6949e2bb9519b9295893de4dafac4_b.jpg\"/></figure><p><b>3.3 对象池设计与实现</b></p><p>不带案例的talk都是刷流氓，以socketclient 连接池为例，底层采用apache 的对象池，设计<b>socket-connection-pool：</b></p><p><b>架构 </b>：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0ef69800ef6938deedd9ef856ea791b1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"211\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-0ef69800ef6938deedd9ef856ea791b1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;211&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"211\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-0ef69800ef6938deedd9ef856ea791b1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0ef69800ef6938deedd9ef856ea791b1_b.jpg\"/></figure><p><b>参数配置：</b></p><p>创建物理链接参数：</p><div class=\"highlight\"><pre><code class=\"language-text\">address:\nali-address: 主机 [端口, 端口, 端口]\nbaidu-address: 主机 [端口, 端口, 端口, 端口]</code></pre></div><p>pool配置参数:</p><div class=\"highlight\"><pre><code class=\"language-text\">maxTotal //连接池中创建的最大连接数\nmaxIdle //指定连接池中最大空闲连接数\nminIdle //指定连接池中最小空闲连接数\nmaxWaitMillis // 获取链接的超时时间\ntestOnBorrow //获得一个链接实例的时候是否检查连接可用性（ping()）；如果为true，则得到的实例均是可用的；\ntestOnReturn //return 一个jedis实例给pool时，是否检查连接可用性（ping()）；\nlifo //borrowObject返回对象时，是采用DEFAULT_LIFO（last in first out，即类似cache的最频繁使用队列），如果为False，则表示FIFO队列；改为默认false\n\n//如果为true，表示有一个idle object evitor线程对idle object进行扫描，如果validate失败，\n//此object会被从pool中drop掉；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；\ntestWhileIdle\n//清理无用连接的时间间隔，idle object evitor两次扫描之间要sleep的毫秒数\ntimeBetweenEvictionRunsMillis\n//表示idle object evitor每次扫描的最多的对象数；\nnumTestsPerEvictionRun\n//表示一个对象至少停留在idle状态的最短时间，然后才能被idle object evitor扫描并驱逐；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；\nminEvictableIdleTimeMillis：\n//在minEvictableIdleTimeMillis基础上，加入了至少minIdle个对象已经在pool里面了。如果为-1，evicted不会根据idle time驱逐任何对象。\n//如果minEvictableIdleTimeMillis&gt;0，则此项设置无意义，且只有在timeBetweenEvictionRunsMillis大于0时才有意义；\nsoftMinEvictableIdleTimeMillis</code></pre></div><p>后面几项如不知怎么配置，可借鉴redis设置：</p><div class=\"highlight\"><pre><code class=\"language-text\">public JedisPoolConfig() {\n // defaults to make your life with connection pool easier :)\n setTestWhileIdle(true);\n setMinEvictableIdleTimeMillis(60000);\n setTimeBetweenEvictionRunsMillis(30000);\n setNumTestsPerEvictionRun(-1);\n}</code></pre></div><p><b>链接connnetion对象：</b></p><p>原始对象：org.freeswitch.esl.client.outbound.SocketClient</p><div class=\"highlight\"><pre><code class=\"language-text\">socketClient = new SocketClient(port, new AIOutboundAliFactory(redisSocketService,callRecordMapper, localRecordPath, localRecordPrefix,systemConfigService));</code></pre></div><p>装饰对象：SocketClientConnetionHolder</p><p>推荐将原始物理链接封装一层用holder表示（思路来源于druid pool），可添加额外职责:</p><ul><li>连接类别</li><li>标识链接是否有效</li><li>添加上一次执行任务的ID</li><li>监控统计</li></ul><p><b>pool 初始化、取、还链接操作：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public FsSocketPool(final GenericObjectPoolConfig poolConfig, final FsSocketAddrConfig fsSocketAddrConfig) {\n    super(poolConfig, new FsSocketFactory(fsSocketAddrConfig));\n}\n\n@Override\npublic FsSocketClientHolder getResource() {\n    FsSocketClientHolder fsSocketClientHolder = super.getResource();\n    fsSocketClientHolder.setDataSource(this);\n    fsSocketClientHolder.setBorrowDate(new Date());\n    return fsSocketClientHolder;\n}\n\n@Override\npublic void returnBrokenResource(final FsSocketClientHolder resource) {\n    if (resource != null) {\n        returnBrokenResourceObject(resource);\n    }\n}\n\n@Override\npublic void returnResource(final FsSocketClientHolder resource) {\n    if (resource != null) {\n        try {\n            returnResourceObject(resource);\n        } catch (Exception e) {\n            returnBrokenResource(resource);\n            throw new FsSocketException(&#34;Could not return the resource to the pool&#34;, e);\n        }\n    }\n}\n\npublic void printState() {\n    StringBuffer stringBuffer = new StringBuffer();\n    stringBuffer.append(&#34;FsSocketPool printState:\\n&#34;);\n    stringBuffer.append(&#34;============================================================\\r\\n&#34;);\n    stringBuffer.append(&#34;当前活动连接数:&#34;).append(super.getNumActive()).append(&#34;\\r\\n&#34;);\n    stringBuffer.append(&#34;当前等待连接数:&#34;).append(super.getNumWaiters()).append(&#34;\\r\\n&#34;);\n    stringBuffer.append(&#34;当前空闲连接数:&#34;).append(super.getNumIdle()).append(&#34;\\r\\n&#34;);\n    stringBuffer.append(&#34;============================================================\\r\\n&#34;);\n    logger.info(stringBuffer.toString());\n}</code></pre></div><p><b>实际创建物理连接的工厂FsSocketFactory：</b></p><p>FsSocketFactory需要实现PooledObjectFactory接口， 理解这个FsSocketFactory这个4个方法很重要，一图以壁纸：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2cdfbb3def261006c7fe578aabb037c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"626\" data-original=\"https://pic1.zhimg.com/v2-2cdfbb3def261006c7fe578aabb037c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;626&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"626\" data-original=\"https://pic1.zhimg.com/v2-2cdfbb3def261006c7fe578aabb037c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2cdfbb3def261006c7fe578aabb037c0_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">@Override\npublic PooledObject&lt;FsSocketClienxtHolder&gt; makeObject() throws Exception {\n    logger.info(&#34;fs socket pool makeObject start&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#34;);\n    //select an unused address to create the obj\n    RecognitionServerType type = null;\n    HostAndPort hostAndPort = null;\n    for (HostAndPort hp : addr) {\n        if (!usedAddr.contains(hp)) {\n            hostAndPort = hp;\n            type = RecognitionServerType.getTypeByName(hp.getTag());\n            break;\n        }\n    }\n    if (type == null || hostAndPort == null) {\n        throw new FsSocketException(&#34;makeObject: address is used fully&#34;);\n    }\n\n    //record the used port\n    usedAddr.add(hostAndPort);\n\n    final FsSocketClientHolder fsSocketClientHolder = new FsSocketClientHolder(type, hostAndPort, localRecordPath, localRecordPrefix,\n            redisSocketService, heartbeatService, callRecordMapper, systemConfigService);\n    try {\n        fsSocketClientHolder.start();\n    } catch (Exception ex) {\n        fsSocketClientHolder.close();\n        throw new FsSocketException(&#34;makeObject: create new fs socket client error&#34;, ex);\n    }\n    logger.info(&#34;fs socket pool makeObject success end&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#34;);\n    return new DefaultPooledObject&lt;FsSocketClientHolder&gt;(fsSocketClientHolder);\n}\n\n@Override\npublic void destroyObject(PooledObject&lt;FsSocketClientHolder&gt; pooledObject) throws Exception {\n    final FsSocketClientHolder fsSocketClientHolder = pooledObject.getObject();\n    logger.info(&#34;fs socket pool destroyObject start&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#34;);\n    HostAndPort hostAndPort = fsSocketClientHolder.getHostAndPort();\n    try {\n        fsSocketClientHolder.destroy();\n    } catch (Exception ex) {\n        throw new FsSocketException(&#34;destroy an old fs socket client error&#34;, ex);\n    }\n    //return the addr\n    if (fsSocketClientHolder.getDestroyed() &amp;&amp; usedAddr.contains(hostAndPort)) {\n        usedAddr.remove(hostAndPort);\n    }\n    logger.info(&#34;fs socket pool destroyObject end&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#34;);\n}\n\n@Override\npublic boolean validateObject(PooledObject&lt;FsSocketClientHolder&gt; pooledObject) {\n    final FsSocketClientHolder fsSocketClientHolder = pooledObject.getObject();\n    boolean res = true;\n    if (fsSocketClientHolder.getDestroyed()) {\n        res = false;\n    } else {\n        res = FsSocketPoolServer.validateSocket(fsSocketClientHolder);\n    }\n    logger.info(&#34;fs socket pool validateObject|RES:{},Holder:{}&#34;, res, fsSocketClientHolder);\n    return res;\n}\n\n\n@Override\npublic void activateObject(PooledObject&lt;FsSocketClientHolder&gt; pooledObject) throws Exception {\n    //default is ok\n}\n\n@Override\npublic void passivateObject(PooledObject&lt;FsSocketClientHolder&gt; pooledObject) throws Exception {\n    //default is ok\n}</code></pre></div><p>注意几点：</p><ul><li>validateObject对应testOnBorrow、testOnReturn以及设置了空闲连接检测的属性后，都会用到；</li><li>调用destroyObject后，方法内部只需将该链接的物理链接关闭即可，在池子中该对象会自动从队列移除（<b>无需代码再次invalidObject</b>）;</li><li>设置了空闲检测属性setTestWhileIdle后，池子会自动对空闲链接回收，调用destroyObject；</li></ul>", 
            "topic": [
                {
                    "tag": "对象池", 
                    "tagLink": "https://api.zhihu.com/topics/20097830"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "连接池", 
                    "tagLink": "https://api.zhihu.com/topics/19619291"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80618999", 
            "userName": "Tnlj", 
            "userLink": "https://www.zhihu.com/people/2b4ccac031e1115aaafb2322596a7288", 
            "upvote": 4, 
            "title": "线程池详解，确定不进来看看？", 
            "content": "<h2>零：相关类UML图</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cbc94200c5d4d66071970a7f7730a08d_b.jpg\" data-size=\"normal\" data-rawwidth=\"1163\" data-rawheight=\"823\" class=\"origin_image zh-lightbox-thumb\" width=\"1163\" data-original=\"https://pic2.zhimg.com/v2-cbc94200c5d4d66071970a7f7730a08d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1163&#39; height=&#39;823&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1163\" data-rawheight=\"823\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1163\" data-original=\"https://pic2.zhimg.com/v2-cbc94200c5d4d66071970a7f7730a08d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cbc94200c5d4d66071970a7f7730a08d_b.jpg\"/><figcaption>Executor框架相关类类图</figcaption></figure><h2>一： Executor框架</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">Executor</span><span class=\"o\">{</span>\n   <span class=\"kt\">void</span> <span class=\"nf\">execute</span><span class=\"o\">(</span><span class=\"n\">Runable</span> <span class=\"n\">command</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>Executor 是个简单的接口，它为灵活且强大的异步任务执行框架提供了基础，该框架能够支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用 Runable 表示任务。</p><p>Executor 基于生产者 - 消费者模式，提交任务的模式相当于生产者（生成待完成的任务单元），执行任务的线程相当于消费者（执行完这些任务单元）。</p><h3>1.1 Executor 的生命周期</h3><p>Executor 的实现通常会创建线程来执行任务，但 JVM 只有在所有非守护线程全部终结后才会退出，因此，如果无法正确的关闭 Executor，那么 JVM 将无法结束。</p><p>由于 Executor 以异步的方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的，有的任务可能已经完成，有的可能正在运行，而其他的任务甚至可能在队列中等待执行。当关闭应用程序时，可能采用最平缓的关闭形式（完成所有已经启动的任务，并且不再接受新的任务），也可能采用最粗暴的关闭形式（直接关掉机房的电源），以及其他可能的形式。既然 Executor 是为应用程序提供服务的，不管是采用平缓或者粗暴的方式，他们也应该都是可关闭的，并将在关闭过程中受影响的任务的状态反馈给应用程序。</p><p>为了解决执行服务的生命周期的问题， 有了 Executor 的扩展接口 ExecutorService 接口， <b>ExecutorService 接口添加了一些用于生命周期的方法，以及一些用于任务提交的便利方法。</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">ExecutorService</span> <span class=\"kd\">extends</span> <span class=\"n\">Executor</span><span class=\"o\">{</span>\n   <span class=\"c1\">//平缓的关闭过程\n</span><span class=\"c1\"></span>   <span class=\"kt\">void</span> <span class=\"nf\">shutdown</span><span class=\"o\">();</span>\n   <span class=\"c1\">//粗暴的关闭过程\n</span><span class=\"c1\"></span>   <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;</span> <span class=\"nf\">shutdownNow</span><span class=\"o\">();</span>\n   <span class=\"kt\">boolean</span> <span class=\"nf\">isShutdown</span><span class=\"o\">();</span>\n   <span class=\"kt\">boolean</span> <span class=\"nf\">isTerminated</span><span class=\"o\">();</span>\n   <span class=\"kt\">boolean</span> <span class=\"nf\">awaitTermination</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">timeout</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span> <span class=\"n\">unit</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span><span class=\"o\">;</span>\n   <span class=\"c1\">//用于任务提交的一些便利方法，未列全\n</span><span class=\"c1\"></span>   <span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"nf\">submit</span><span class=\"o\">(</span><span class=\"n\">Callable</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">task</span><span class=\"o\">);</span>\n   <span class=\"n\">Future</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">submit</span><span class=\"o\">(</span><span class=\"n\">Runnable</span> <span class=\"n\">task</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>ExecutorService 的生命周期有3中状态：<b>运行、关闭和已终止</b>。ExecutorService 在创建初期处于运行状态。shutdown 方法将执行平缓的关闭过程：不再接受 新的任务提交，同时等待已提交的任务执行完成，包含那些还未开始执行的任务。 shutdownNow 方法将执行粗暴的关闭过程：他将尝试取消所有运行中的任务，并将不再启动队列中尚未开始执行的任务。</p><p>在 ExecutorService 关闭后提交的任务将由“拒绝执行处理器（Rejected Exception Handler）”来处理（详见3.3节），他会抛弃任务，或者使得 execute 方法抛出一个未检查的 RejectedExecutionException。等所有任务都完成后， ExecutorService 将进入终止状态。</p><p><b>ExecutorService 接口与 Executor 相比，提供了返回 Future 对象，终止、关闭线程池的方法。Executor 接口定义的 execute() 方法只能接收 Runable 接口的对象，而 ExecutorService 接口中的 submit() 方法则可以接受 Runable 和 Callable 接口的对象。</b></p><h3>1.2 Callable 和 Future  </h3><p>Executor 框架使用 Runable 作为其基本的任务表达形式。Runable 是一种有很大局限的抽象，虽然 run() 方法能够将相应的信息写入日志或者放入共享的数据结构，但他不能返回值或者抛出一个受检查的异常。</p><p>许多任务实际上都是存在延迟的计算 -- 执行数据库查询、从网络上获取资源。对于这些任务，Callable 是一种更好的抽象：它认为 call() 方法将返回一个值或者抛出一个异常。</p><p><b>ExecutorService 中的所有submit 方法都将返回一个Future，从而将一个Runable或者Callable提交给Executor，并得到一个Future用来获取任务的执行结果或者取消任务。Future 代表了一个异步运算的结果，它提供了判断运算是否完成、等待运算的进行以及获得运算结果</b>等，该接口包含的方法如下所示：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">Future</span><span class=\"o\">{</span>\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 试图取消对此任务的执行\n</span><span class=\"cm\">     * 如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。\n</span><span class=\"cm\">     * 当调用 cancel 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。\n</span><span class=\"cm\">     * 如果任务已经启动，则 mayInterruptIfRunning 参数确定是否应该以试图停止任务的方式来中断执行此任务的线程\n</span><span class=\"cm\">     */</span>\n    <span class=\"kt\">boolean</span> <span class=\"nf\">cancel</span><span class=\"o\">(</span><span class=\"kt\">boolean</span> <span class=\"n\">mayInterruptIfRunning</span><span class=\"o\">);</span>\n    <span class=\"kt\">boolean</span> <span class=\"nf\">isCancelled</span><span class=\"o\">();</span>\n    <span class=\"kt\">boolean</span> <span class=\"nf\">isDone</span><span class=\"o\">();</span>\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     *   如有必要，等待计算完成，然后获取其结果\n</span><span class=\"cm\">     */</span>\n    <span class=\"n\">V</span> <span class=\"nf\">get</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span><span class=\"o\">,</span> <span class=\"n\">ExecutionException</span><span class=\"o\">;</span>\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）\n</span><span class=\"cm\">     */</span>\n    <span class=\"n\">V</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">timeout</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span> <span class=\"n\">unit</span><span class=\"o\">)</span>\n            <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span><span class=\"o\">,</span> <span class=\"n\">ExecutionException</span><span class=\"o\">,</span> <span class=\"n\">TimeoutException</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>其中，get 方法的行为取决于任务的状态（尚未开始、正在运行、已完成）。如果任务已完成，那么get会立即返回结果或者抛出一个 Exception ，如果任务没有完成，那么get会阻塞直到任务完成。如果任务抛出了异常，那么get会将异常封装为 ExecutionException 并重新抛出。如果任务被取消，那么get将抛出 CancellationException</p><h2>二：Executors</h2><p>从 JDK 1.5 开始，类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用 Executors 中的静态工厂方法来创建线程池：</p><ul><li><b>newFixedThreadPool</b>。newFixedThreadPool将创建一个固定长度的线程池，每提交一个任务时就创建一个线程池，直到达到线程池的最大数量，这时线程池中线程的数量将不再变化（如果某个线程由于发生了未预期的 Exception 而结束，那么线程池将补充一个新的线程）。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6137a97c3d56db3d7e01ba7f69f1c874_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1295\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb\" width=\"1295\" data-original=\"https://pic1.zhimg.com/v2-6137a97c3d56db3d7e01ba7f69f1c874_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1295&#39; height=&#39;212&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1295\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1295\" data-original=\"https://pic1.zhimg.com/v2-6137a97c3d56db3d7e01ba7f69f1c874_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6137a97c3d56db3d7e01ba7f69f1c874_b.png\"/></figure><ul><li><b>newCachedThreadPool</b>。newCachedThreadPool 将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，当需求增加时，可添加新的线程，线程池的规模不存在任何的限制。注意！！！！这里使用的阻塞队列为 SynchronousQueue，关于这点在 3.2 任务队列模块中详细提到。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4584e2302f452029dd9d6ac743f011d1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1225\" data-rawheight=\"223\" class=\"origin_image zh-lightbox-thumb\" width=\"1225\" data-original=\"https://pic2.zhimg.com/v2-4584e2302f452029dd9d6ac743f011d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1225&#39; height=&#39;223&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1225\" data-rawheight=\"223\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1225\" data-original=\"https://pic2.zhimg.com/v2-4584e2302f452029dd9d6ac743f011d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4584e2302f452029dd9d6ac743f011d1_b.jpg\"/></figure><ul><li><b>newSingleThreadExecutor</b>。newSingleThreadExecutor 是一个单线程的 Executor，它创建单个工作线程来执行任务，如果已有的这个线程因异常结束，将创建一个新的线程来代替。newSingleThreadExecutor 能保证依照任务在队列中的顺序来串行执行。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-07d33892e4f36475ce6422da7bd1536e_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"73\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-07d33892e4f36475ce6422da7bd1536e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;73&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"73\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-07d33892e4f36475ce6422da7bd1536e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-07d33892e4f36475ce6422da7bd1536e_b.png\"/></figure><ul><li><b>newScheduledThreadPool</b>。newScheduledThreadPool创建一个固定长度的线程池，而且以延迟或者定时的方式来执行任务。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-abefd3a87bc7e014445f0d7e202dea42_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"921\" data-rawheight=\"159\" class=\"origin_image zh-lightbox-thumb\" width=\"921\" data-original=\"https://pic3.zhimg.com/v2-abefd3a87bc7e014445f0d7e202dea42_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;921&#39; height=&#39;159&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"921\" data-rawheight=\"159\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"921\" data-original=\"https://pic3.zhimg.com/v2-abefd3a87bc7e014445f0d7e202dea42_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-abefd3a87bc7e014445f0d7e202dea42_b.jpg\"/></figure><p>newFixedThreadPool 和 newCachedThreadPool 这两个工厂方法返回的都是 ThreadPoolExecutor 实例， newSingleThreadExecutor 和 newScheduledThreadPool 返回的则是 ScheduleExecutorService。</p><h3>2.1 Callable 与 Runable 转换</h3><div class=\"highlight\"><pre><code class=\"language-text\">/**\n     * Returns a {@link Callable} object that, when\n     * called, runs the given task and returns the given result.  This\n     * can be useful when applying methods requiring a\n     * {@code Callable} to an otherwise resultless action.\n     * @param task the task to run\n     * @param result the result to return\n     * @param &lt;T&gt; the type of the result\n     * @return a callable object\n     * @throws NullPointerException if task null\n     */\n    public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {\n        if (task == null)\n            throw new NullPointerException();\n        return new RunnableAdapter&lt;T&gt;(task, result);\n    }</code></pre></div><p>以上源码是 Executors 提供的把一个 Runable 转变成 Callable 的接口，当我们把由 Runable 转换而成的 Callable 提交到 ThreadPoolExecutor 执行时，submit 方法将会返回一个 Future 对象，我们可以通过 Future 的get 方法获取到 result 值，代码示例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public static void main(String[] args) {\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(&#34;it&#39;s runable interface&#34;);\n                return;\n            }\n        };\n        //Runable 转 Callable， 并给转换后的 Callable 设置返回值。\n        Callable&lt;Object&gt; change = Executors.callable(runnable, &#34;changed callable&#39;s result&#34;);\n        //确定大小的线程池\n        ExecutorService service = Executors.newFixedThreadPool(3);\n        Future changeFuture = service.submit(change);\n        try {\n            System.out.println(changeFuture.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n//output: it&#39;s runable interface\nchanged callable&#39;s result</code></pre></div><h2>三：ThreadPoolExecutor</h2><h3>3.1 线程的创建于销毁</h3><p>线程池的基本大小（CorePoolSize，也作核心线程数）、最大大小（MaximumPoolSize）以及存活时间等因素共同负责线程的创建和销毁。基本大小也就是线程池的目标大小，即在没有任务执行时线程池的大小，只有在工作队列满了才会创建超出这个数量的线程。线程池的最大大小表示可同时进行活动的线程数量的上限。<b>如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收，并且当线程池的当前大小超过了基本大小时，这个线程将被终止</b>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1d26cc02b5a5fcc15d5ccd77a9300135_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"850\" data-rawheight=\"716\" class=\"origin_image zh-lightbox-thumb\" width=\"850\" data-original=\"https://pic2.zhimg.com/v2-1d26cc02b5a5fcc15d5ccd77a9300135_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;850&#39; height=&#39;716&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"850\" data-rawheight=\"716\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"850\" data-original=\"https://pic2.zhimg.com/v2-1d26cc02b5a5fcc15d5ccd77a9300135_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1d26cc02b5a5fcc15d5ccd77a9300135_b.jpg\"/></figure><p>通过调节线程池的基本大小和存活时间，可以帮助线程池回收空闲线程占用的资源，从而使得这些资源可以用于执行其他的工作。（显然，这是一种折衷：回收空闲线程池会产生额外的延迟，因为当需求增加时，必须创建新的线程来满足需求。）</p><p>newFixedThreadPool 工厂方法将线程池的基本大小和最大大小设置为参数中指定的值由用户指定，而且创建的线程池不会超时。newCachedThreadPool 工厂方法将线程池的最大大小设置为 Integer.MAX_VALUE，而将基本大小设置为0，并将超时时间设置为 60s，这种方法创建的线程池可以被无线扩展，需求降低时也能够自动收缩。</p><h3>3.2 任务队列</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f601b343101705c32cd669288e4ae853_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1054\" data-rawheight=\"625\" class=\"origin_image zh-lightbox-thumb\" width=\"1054\" data-original=\"https://pic4.zhimg.com/v2-f601b343101705c32cd669288e4ae853_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1054&#39; height=&#39;625&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1054\" data-rawheight=\"625\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1054\" data-original=\"https://pic4.zhimg.com/v2-f601b343101705c32cd669288e4ae853_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f601b343101705c32cd669288e4ae853_b.jpg\"/></figure><p>ThreadPoolExecutor 允许提供一个 BlockingQueue 来保存等待执行的任务。任务的排队方式有三种：<b>无界队列、有界队列和同步移交</b>。队列的选择与其他的配置参数有关，例如线程池的大小等。</p><p>newFixedThreadPool 和 newSingleThreadExecutor 在默认情况下将使用一个无界的 LinkedBlockingQueue 。如果所有现存的工作线程都处于忙碌状态，那么任务将在等待队列中等候。如果任务持续不断的到达，并且超过了线程池的处理速度，那么任务队列将无限制的增加。</p><p>一种更稳妥的资源管理策略是使用有界队列，例如 ArrayBlockingQueu、有界的LinkedBlockingQueue、PriorityBlockingQueue。有界队列有助于避免资源耗尽的情况发生，但他又带来了新的问题：当队列填满，新的任务怎么办？在使用有界队列时，队列的大小与线程池的大小必须一起调节。如果线程池较小而队列较大，那么有助于减少内存的使用量，降低CPU的使用率，同时还可以减少上下文切换，但付出的代价就是可能会限制吞吐量。</p><p><b>对于非常大或者无界的线程池，可以使用SynchronousQueue 来避免任务排队，以及直接将任务从生产者移交给工作者线程。SynchronousQueue 不是一个真正的队列，而是一种在线程间的移交机制。要将一个任务放入 SynchronousQueue 中，必须有另外一个空闲线程正在等待接受这个任务。如果没有此时空闲线程且线程数量小于线程池的最大线程数量，那么将创建一个新的线程来执行这个任务，否则将根据饱和策略拒绝执行这个任务。使用直接移交将更高效，因为任务会直接移交给执行它的线程，而不是放入队列中等待。只有当线程池是无界的或者可以拒绝执行任务时 SynchronousQueue 才有实际价值。在 newCachedThreadPool 中使用的就是 SynchronousQueue。</b></p><p>LinkedBlockingQueue 和 ArrayBlockingQueue 都具备队列的基本属性 -- 先进先出（FIFO），任务的执行顺序与到达顺序一致。如果想进一步控制任务的执行顺序，可以使用 PriorityBlockingQueue，这个队列将根据优先级来安排任务的执行。</p><p>只有在任务间相互独立时，为线程池或者阻塞队列设置界限才是合理的，如果任务之间存在依赖性，那么有界的线程池或者阻塞队列将导致线程“饥饿”死锁问题，此时应该使用无界的线程池，比如 newCachedThreadPool。</p><h3>3.3 饱和策略</h3><p><b>在 ThreadPoolExecutor 的源码解释中，在线程池处于被关闭（shutdown）的状态或者此时线程池中线程数已达最大值且等待队列也已饱和，这两种情况下有新的任务过来时，线程池将执行饱和策略（也作拒绝策略）</b>。 ThreadPoolExecutor 的饱和策略可以通过调用 setRejectedExecutionHandler 来修改。JDK 提供了几种不同的 RejectedExecutionHandler 实现，每种实现都包含有不同的饱和策略：<b>AbortPolicy、CallerRunsPolicy、DiscardPolicy 和 DiscardOldestPolicy</b>。</p><p><b>“终止（Abort）”策略是默认的饱和策略</b>，该策略抛出未检查的 RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。当新提交的任务无法保存到等待队列中时，“抛弃（Discard）”策略会抛弃该任务。“抛弃最旧的（DiscardOldest）”策略则会抛弃下一个将要被执行的任务，然后尝试重新提交新的任务（如果等待队列采用的是优先队列，那么抛弃最旧的策略将会导致抛弃优先级最高的任务，因此最高不要将“抛弃最旧的”饱和策略和优先级队列一起使用）。</p><p><b>“调用者运行（Caller-Runs）”策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将这些任务退回给调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了 executor 的线程中执行该任务。当线程池中所有线程被占用，并且等待队列被填满，下一个任务会在调用了 executor 的线程中执行。由于执行任务需要一定的时间，因此主线程至少在一个时间段内不能提交任务，从而使得工作线程能够有时间处理任务。</b></p><p>创建一个固定大小、采用有界队列以及“调用者执行”策略的线程池代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">ThreadPoolExecutor</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">CORE_THREADS</span><span class=\"o\">,</span> <span class=\"n\">MAX_THREADS</span><span class=\"o\">,</span> \n                <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MILLISECONDS</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">LinkedBlockingQueue</span><span class=\"o\">&lt;&gt;());</span>\n        <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">setRejectedExecutionHandler</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">.</span><span class=\"na\">CallerRunsPolicy</span><span class=\"o\">());</span></code></pre></div><h3>3.4 线程工厂</h3><p>每当线程池创建一个线程时，都是通过线程工厂方法来完成，默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息。通过指定一个线程工厂方法，可以定制线程池的配置信息。 ThreadFactory 中只定义了一个 newThread 方法，每当创建一个线程时都会调用到这个方法。</p><p>在许多情况下都需要使用定制的线程工厂方法。例如，你希望为线程池的线程指定一个 UncaughtExceptionHandler ，或者实例化一个定制的 Thread 类用于执行调试信息的记录。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">ThreadFactory</span> <span class=\"o\">{</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * Constructs a new {@code Thread}.  Implementations may also initialize\n</span><span class=\"cm\">     * priority, name, daemon status, {@code ThreadGroup}, etc.\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param r a runnable to be executed by new thread instance\n</span><span class=\"cm\">     * @return constructed thread, or {@code null} if the request to\n</span><span class=\"cm\">     *         create a thread is rejected\n</span><span class=\"cm\">     */</span>\n    <span class=\"n\">Thread</span> <span class=\"nf\">newThread</span><span class=\"o\">(</span><span class=\"n\">Runnable</span> <span class=\"n\">r</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>以下代码就是一个很好的创建线程池，并设置新建线程名称的例子：</p><div class=\"highlight\"><pre><code class=\"language-text\">//配置线程池信息\nExecutorService exportBuyerPool = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,\n\t\t\tnew LinkedBlockingQueue&lt;&gt;(1024), new ThreadFactoryBuilder().setNameFormat(&#34;export_buyer_list-pool-%d&#34;).build(), new ThreadPoolExecutor.AbortPolicy());</code></pre></div><p>ThreadFactoryBuilder 位于com.google.common.util.concurrent，利用建造者模式去设置线程池的相关信息。具体代码如下，当然，也可以根据自己的需要通过实现 ThreadFactory 接口来设置线程池新建线程时的配置。</p><div class=\"highlight\"><pre><code class=\"language-text\">public final class ThreadFactoryBuilder {\n    private String nameFormat = null;\n    private Boolean daemon = null;\n    private Integer priority = null;\n    private UncaughtExceptionHandler uncaughtExceptionHandler = null;\n    private ThreadFactory backingThreadFactory = null;\n\n    public ThreadFactoryBuilder() {\n    }\n\n    public ThreadFactoryBuilder setNameFormat(String nameFormat) {\n        String.format(nameFormat, 0);\n        this.nameFormat = nameFormat;\n        return this;\n    }\n\n    public ThreadFactoryBuilder setDaemon(boolean daemon) {\n        this.daemon = daemon;\n        return this;\n    }\n\n    public ThreadFactoryBuilder setPriority(int priority) {\n        Preconditions.checkArgument(priority &gt;= 1, &#34;Thread priority (%s) must be &gt;= %s&#34;, new Object[]{priority, 1});\n        Preconditions.checkArgument(priority &lt;= 10, &#34;Thread priority (%s) must be &lt;= %s&#34;, new Object[]{priority, 10});\n        this.priority = priority;\n        return this;\n    }\n\n    public ThreadFactoryBuilder setUncaughtExceptionHandler(UncaughtExceptionHandler uncaughtExceptionHandler) {\n        this.uncaughtExceptionHandler = (UncaughtExceptionHandler)Preconditions.checkNotNull(uncaughtExceptionHandler);\n        return this;\n    }\n\n    public ThreadFactoryBuilder setThreadFactory(ThreadFactory backingThreadFactory) {\n        this.backingThreadFactory = (ThreadFactory)Preconditions.checkNotNull(backingThreadFactory);\n        return this;\n    }\n\n    public ThreadFactory build() {\n        return build(this);\n    }\n\n    private static ThreadFactory build(ThreadFactoryBuilder builder) {\n        final String nameFormat = builder.nameFormat;\n        final Boolean daemon = builder.daemon;\n        final Integer priority = builder.priority;\n        final UncaughtExceptionHandler uncaughtExceptionHandler = builder.uncaughtExceptionHandler;\n        final ThreadFactory backingThreadFactory = builder.backingThreadFactory != null ? builder.backingThreadFactory : Executors.defaultThreadFactory();\n        final AtomicLong count = nameFormat != null ? new AtomicLong(0L) : null;\n        return new ThreadFactory() {\n            public Thread newThread(Runnable runnable) {\n                Thread thread = backingThreadFactory.newThread(runnable);\n                if (nameFormat != null) {\n                    //设置新建线程名称\n                    thread.setName(String.format(nameFormat, count.getAndIncrement()));\n                }\n                \n                if (daemon != null) {\n                    //设置新建线程是否为守护线程\n                    thread.setDaemon(daemon);\n                }\n\n                if (priority != null) {\n                    //设置新建线程优先级\n                    thread.setPriority(priority);\n                }\n\n                if (uncaughtExceptionHandler != null) {\n                    //设置异常信息\n                    thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);\n                }\n\n                return thread;\n            }\n        };\n    }\n}</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "线程池", 
                    "tagLink": "https://api.zhihu.com/topics/19721742"
                }
            ], 
            "comments": [
                {
                    "userName": "蒋霍尔", 
                    "userLink": "https://www.zhihu.com/people/60d852f6b87734c20d238772051e841a", 
                    "content": "太强了吧，大佬求带", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/77404755", 
            "userName": "znerl", 
            "userLink": "https://www.zhihu.com/people/08d71d22cf2658349ed7f8e245477973", 
            "upvote": 7, 
            "title": "redis 延时队列", 
            "content": "<p>闲来无事，用redis做了一个延时队列，仅供学习与参考。欢迎拍砖！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e7f2d482e06bcc972e0c1e859fc2d950_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"953\" data-rawheight=\"971\" class=\"origin_image zh-lightbox-thumb\" width=\"953\" data-original=\"https://pic1.zhimg.com/v2-e7f2d482e06bcc972e0c1e859fc2d950_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;953&#39; height=&#39;971&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"953\" data-rawheight=\"971\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"953\" data-original=\"https://pic1.zhimg.com/v2-e7f2d482e06bcc972e0c1e859fc2d950_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e7f2d482e06bcc972e0c1e859fc2d950_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@Slf4j</span>\n<span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">RedisDelayQueue</span> <span class=\"o\">{</span>\n\n    <span class=\"nd\">@Resource</span>\n    <span class=\"kd\">private</span> <span class=\"n\">StringRedisTemplate</span> <span class=\"n\">stringRedisTemplate</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">ScheduledExecutorService</span> <span class=\"n\">timer</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newScheduledThreadPool</span><span class=\"o\">(</span><span class=\"n\">16</span><span class=\"o\">);</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">consumeTopics</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">64</span><span class=\"o\">);</span>\n\n\n    <span class=\"nd\">@PostConstruct</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">init</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">topicList</span> <span class=\"o\">=</span> <span class=\"n\">stringRedisTemplate</span><span class=\"o\">.</span><span class=\"na\">opsForSet</span><span class=\"o\">().</span><span class=\"na\">members</span><span class=\"o\">(</span><span class=\"s\">&#34;topicList&#34;</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">topicList</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">topicList</span><span class=\"o\">.</span><span class=\"na\">forEach</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">::</span><span class=\"n\">registTopic</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">registTopic</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">topic</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">&#34;注册监听topic消息:{}&#34;</span><span class=\"o\">,</span> <span class=\"n\">topic</span><span class=\"o\">);</span>\n        <span class=\"n\">timer</span><span class=\"o\">.</span><span class=\"na\">scheduleAtFixedRate</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">msgs</span> <span class=\"o\">=</span> <span class=\"n\">stringRedisTemplate</span><span class=\"o\">.</span><span class=\"na\">opsForZSet</span><span class=\"o\">().</span><span class=\"na\">rangeByScore</span><span class=\"o\">(</span><span class=\"n\">topic</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">(),</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">1000</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">msgs</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">msgs</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">Long</span> <span class=\"n\">remove</span> <span class=\"o\">=</span> <span class=\"n\">stringRedisTemplate</span><span class=\"o\">.</span><span class=\"na\">opsForZSet</span><span class=\"o\">().</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">topic</span><span class=\"o\">,</span> <span class=\"n\">msgs</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">());</span>\n                <span class=\"c1\">//删除结果大于0代表 抢到了\n</span><span class=\"c1\"></span>                <span class=\"k\">if</span><span class=\"o\">(</span> <span class=\"n\">remove</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">remove</span><span class=\"o\">&gt;</span> <span class=\"n\">0</span> <span class=\"o\">){</span>\n                    <span class=\"n\">stringRedisTemplate</span><span class=\"o\">.</span><span class=\"na\">opsForList</span><span class=\"o\">().</span><span class=\"na\">leftPushAll</span><span class=\"o\">(</span><span class=\"n\">topic</span> <span class=\"o\">+</span> <span class=\"s\">&#34;queue&#34;</span><span class=\"o\">,</span> <span class=\"n\">msgs</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span>\n\n            <span class=\"o\">}</span>\n        <span class=\"o\">},</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">produce</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">topic</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">msg</span><span class=\"o\">,</span> <span class=\"n\">Date</span> <span class=\"n\">date</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">&#34;topic:{} 生产消息：{},于{}消费&#34;</span><span class=\"o\">,</span> <span class=\"n\">topic</span><span class=\"o\">,</span> <span class=\"n\">msg</span><span class=\"o\">,</span> <span class=\"n\">date</span><span class=\"o\">);</span>\n        <span class=\"n\">Long</span> <span class=\"n\">addSuccess</span> <span class=\"o\">=</span> <span class=\"n\">stringRedisTemplate</span><span class=\"o\">.</span><span class=\"na\">opsForSet</span><span class=\"o\">().</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"s\">&#34;topicList&#34;</span><span class=\"o\">,</span> <span class=\"n\">topic</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">addSuccess</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">addSuccess</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">registTopic</span><span class=\"o\">(</span><span class=\"n\">topic</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">stringRedisTemplate</span><span class=\"o\">.</span><span class=\"na\">opsForZSet</span><span class=\"o\">().</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">topic</span><span class=\"o\">,</span> <span class=\"n\">msg</span><span class=\"o\">,</span> <span class=\"n\">date</span><span class=\"o\">.</span><span class=\"na\">getTime</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">consumer</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">topic</span><span class=\"o\">,</span> <span class=\"n\">Function</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Boolean</span><span class=\"o\">&gt;</span> <span class=\"n\">consumer</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">consumeTopics</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">topic</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">RuntimeException</span><span class=\"o\">(</span><span class=\"s\">&#34;请勿重复监听消费&#34;</span> <span class=\"o\">+</span> <span class=\"n\">topic</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">consumeTopics</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">topic</span><span class=\"o\">);</span>\n        <span class=\"kt\">int</span> <span class=\"n\">consumerPoolSize</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n        <span class=\"n\">ExecutorService</span> <span class=\"n\">consumerPool</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"n\">consumerPoolSize</span><span class=\"o\">);</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">consumerPoolSize</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">consumerPool</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">do</span> <span class=\"o\">{</span>\n                    <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">&#34;循环取消息：{}&#34;</span><span class=\"o\">,</span> <span class=\"n\">topic</span><span class=\"o\">);</span>\n                    <span class=\"n\">String</span> <span class=\"n\">msg</span><span class=\"o\">;</span>\n                    <span class=\"k\">try</span> <span class=\"o\">{</span>\n                        <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"n\">stringRedisTemplate</span><span class=\"o\">.</span><span class=\"na\">opsForList</span><span class=\"o\">().</span><span class=\"na\">rightPop</span><span class=\"o\">(</span><span class=\"n\">topic</span> <span class=\"o\">+</span> <span class=\"s\">&#34;queue&#34;</span><span class=\"o\">,</span> <span class=\"n\">1000</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MINUTES</span><span class=\"o\">);</span>\n                    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">QueryTimeoutException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">debug</span><span class=\"o\">(</span><span class=\"s\">&#34;监听超时，重试中！&#34;</span><span class=\"o\">);</span>\n                        <span class=\"k\">continue</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                    <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">&#34;{}监听到消息：{}&#34;</span><span class=\"o\">,</span> <span class=\"n\">topic</span><span class=\"o\">,</span> <span class=\"n\">msg</span><span class=\"o\">);</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">msg</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">Boolean</span> <span class=\"n\">consumerSuccess</span><span class=\"o\">;</span>\n                        <span class=\"k\">try</span> <span class=\"o\">{</span>\n                            <span class=\"n\">consumerSuccess</span> <span class=\"o\">=</span> <span class=\"n\">consumer</span><span class=\"o\">.</span><span class=\"na\">apply</span><span class=\"o\">(</span><span class=\"n\">msg</span><span class=\"o\">);</span>\n                        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                            <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">&#34;消费失败！&#34;</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">);</span>\n                            <span class=\"n\">consumerSuccess</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n                        <span class=\"o\">}</span>\n                        <span class=\"c1\">//消费失败，1分钟后再重试\n</span><span class=\"c1\"></span>                        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">consumerSuccess</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"n\">consumerSuccess</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                            <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">(</span><span class=\"s\">&#34;消费失败，重新放回队列。msg:{},topic:{}&#34;</span><span class=\"o\">,</span> <span class=\"n\">msg</span><span class=\"o\">,</span> <span class=\"n\">topic</span><span class=\"o\">);</span>\n                            <span class=\"n\">produce</span><span class=\"o\">(</span><span class=\"n\">topic</span><span class=\"o\">,</span> <span class=\"n\">msg</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">Date</span><span class=\"o\">(</span><span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"n\">60000</span><span class=\"o\">));</span>\n                        <span class=\"o\">}</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span> <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">);</span>\n            <span class=\"o\">});</span>\n        <span class=\"o\">}</span>\n\n    <span class=\"o\">}</span>\n\n\n<span class=\"o\">}</span></code></pre></div><p>单元测试</p><div class=\"highlight\"><pre><code class=\"language-text\">@Slf4j\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class RedisDelayQueueTest {\n\n    @Resource\n    private RedisDelayQueue redisDelayQueue;\n\n    @Test\n    public void produce() {\n        for (int i = 0; i &lt; 30; i++) {\n            redisDelayQueue.produce(&#34;topic&#34;+i%3 , &#34;hello message&#34;+i , new Date(System.currentTimeMillis()+i*1000));\n        }\n    }\n\n    @Test\n    public void consumer() throws InterruptedException {\n\n        redisDelayQueue.consumer(&#34;topic0&#34;, (msg)-&gt;{\n            log.info(&#34;topic【{}】收到消息：{}&#34;,&#34;topic0&#34;,msg);\n            return true;\n        }); redisDelayQueue.consumer(&#34;topic1&#34;, (msg)-&gt;{\n            log.info(&#34;topic【{}】收到消息：{}&#34;,&#34;topic1&#34;,msg);\n            return true;\n        });\n        redisDelayQueue.consumer(&#34;topic2&#34;, (msg) -&gt; {\n            log.info(&#34;topic【{}】收到消息：{}&#34;, &#34;topic2&#34;, msg);\n            return true;\n        });\n\n\n        TimeUnit.MINUTES.sleep(10);\n    }\n}</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "消息队列", 
                    "tagLink": "https://api.zhihu.com/topics/19708788"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }
            ], 
            "comments": [
                {
                    "userName": "愤怒的小吹球", 
                    "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
                    "content": "<p>学习到了^666,短小精悍，开箱即用！</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "znerl", 
                            "userLink": "https://www.zhihu.com/people/08d71d22cf2658349ed7f8e245477973", 
                            "content": "<p>哈哈，你们的吹捧是我继续改进的动力</p><a class=\"comment_sticker\" href=\"https://pic3.zhimg.com/v2-cb8443f07a41298e45191cef11b90fd2.gif\" data-width=\"\" data-height=\"\">[干杯]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "愤怒的小吹球"
                        }
                    ]
                }, 
                {
                    "userName": "oberon", 
                    "userLink": "https://www.zhihu.com/people/ab391081d76e72e35e909899f078b0c7", 
                    "content": "好办法，建议从zset中取数据删数据和丢到list中的过程放到lua中避免出现意外", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "znerl", 
                            "userLink": "https://www.zhihu.com/people/08d71d22cf2658349ed7f8e245477973", 
                            "content": "<p>这个建议不错</p>", 
                            "likes": 0, 
                            "replyToAuthor": "oberon"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76219083", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 4, 
            "title": "2019年，阿里最新的java程序员面试题目", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-39058e119433be1ae72540917c7d77f4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-39058e119433be1ae72540917c7d77f4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;395&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-39058e119433be1ae72540917c7d77f4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-39058e119433be1ae72540917c7d77f4_b.jpg\"/></figure><p>目录</p><ol><li>技术一面（23问）</li><li>技术二面（3大块）</li><li>性能优化（21点）</li><li>项目实战（34块）</li><li>JAVA方向技术考察点（15点）</li><li>JAVA开发技术面试中可能问到的问题（17问）</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ae8eae1cccb02ddfad0837271075040c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"451\" data-rawheight=\"216\" class=\"origin_image zh-lightbox-thumb\" width=\"451\" data-original=\"https://pic1.zhimg.com/v2-ae8eae1cccb02ddfad0837271075040c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;451&#39; height=&#39;216&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"451\" data-rawheight=\"216\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"451\" data-original=\"https://pic1.zhimg.com/v2-ae8eae1cccb02ddfad0837271075040c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ae8eae1cccb02ddfad0837271075040c_b.jpg\"/></figure><h2>阿里技术面试1</h2><p>1.Java IO流的层次结构?</p><p>2.请说出常用的异常类型?</p><p>3.SKU的全称是什么，SKU与SPU的区别及关系？</p><p>4.FileInputStream 在使用完以后，不关闭流，想二次使用可以怎么操作？</p><p>5.设计一个分步式登录系统？</p><p>6.Spring加载过程？</p><p>7.自己有没有写过类似Spring这样的AOP事务？</p><p>8.Java中 try..catch 关闭流的语法糖?</p><p>9.如何设计一个秒杀系统？要考虑什么？</p><p>10.有没有遇到进线上GC，出现的症状是什么样的，怎么解决的？</p><p>11spring的加载过程？</p><p>12.atomic 与 volatile的区别？</p><p>13.Thread的 notify()给notifyAll()的区别?</p><p>14.notifiy()是唤醒的那一个线程?</p><p>15.Thread.sleep()唤醒以后是否需要重新竞争？</p><p>16.单例有多少种写法? 有什么区别? 你常用哪一种单例，为什么用这种？</p><p>17.问一个Thread.join()相关的问题?</p><p>18.商品相关模块系统怎么设计数据模型？</p><p>19.写一个JAVA死锁的列子?</p><p>20.如何解决死锁?</p><p>21.GC回收算法,及实现原理?</p><p>22.HashMap数据存储结构? key重复了怎么办? 是如何解决的?</p><p>23.Spring AOP的实现原理，底层用什么实现的？</p><h2>阿里技术面试2</h2><p>电话面试主要考察3块内容：</p><ol><li>Java的相关基础知识，开源框架的原理，JVM，多线程，高并发，中间件等；</li><li>之前项目经历，运用的技术，遇到的问题，如何解决，个人有什么收获和成长；</li><li>对于技术的热情（平时是否看些技术书籍，逛论坛，写博客，写源代码或程序等）；</li></ol><h2>JAVA开发技术面试可能问到的问题？</h2><ol><li>我们主要考核的是网络nio 分布式数据库高并发大数据</li><li>自定义表格的实现?</li><li>动态表单设计?</li><li>in-jvm（必考）以及jmm缓存模型如何调优?</li><li>常用的RPC框架</li><li>nio和io</li><li>并发编程，设计模式</li><li>地图组件?</li><li>hashmap有什么漏洞会导致他变慢？</li><li>如何给hashmap的key对象设计他的hashcode？</li><li>泛型通配符?在什么情况下使用？</li><li>后端方面：redis?分布式框架dubbo(阿里巴巴开源框架)?设计模式?</li><li>场景式的问题:秒杀,能列出常见的排队、验证码、库存扣减方式对系统高并发的影响?</li><li>能根据实际的需要构建缓存结构提高提高网站的访问速度，熟练使用ehcache、oscache，了解memcache。</li><li>了解基于dns轮询的负载均衡，熟练配置web服务器实现负载均衡，程序级能综合使用基于hash或取模等手段实现软负载。</li><li>熟悉分布式数据库设计和优化技术，熟练使用mysql、oracle、SqlServer等主流数据库，熟悉hadoop hbase mangodb redis ehcache、oscache memcache。对于大数据量的数据库处理采用分表分库、数据库读写分离、建立缓存等手段优化性能。</li><li>熟练掌握lucene，能基于lucene开发大型的搜索引擎，并能用lucene来改善和优化数据库的like查询。</li></ol><p>JAVA方向技术考察点(补充)：</p><ul><li>掌握Java编程语言，包含io/nio/socket/multi threads/collection/concurrency等功能的使用；</li><li>熟练掌握jvm（sun hotspot和ibm j9）内存模型、gc垃圾回收调优等技能；</li><li>精通JVM,JMM,MVC架构，熟练使用struts2。</li><li>熟练使用spring、struts、ibatis构建应用系统。</li><li>熟练使用Servlet，jsp，freemark等前端技术。</li><li>熟练使用axis搭建基于SOAP协议的WebService服务接口。</li><li>熟练使用MAVEN构建项目工程。</li><li>熟练使用tomcat等web服务。</li><li>熟练使用mysql等关系型数据库，熟悉mysql集群搭建。</li><li>熟练使用redis等NOSQL技术。</li><li>熟悉tcp、http协议。</li><li>熟悉nginx、haproxy等配置。</li><li>熟悉javascript、ajax等技术。</li><li>熟悉主流分布式文件系统FastDFS等。</li><li>熟悉JMS，可熟练使用ActiveMQ。</li></ul><p>Java技术Leader要求能够对于项目本身知其然知其所以然,不仅技术功力深还要业务能力强有很好的idea和业务sense，并且对技术充满兴趣和渴望，千万不要面试官问一个问题答一个，呆板的表情完全看不出任何自己的想法。</p><p>面试中描述你做的每一个项目：你做了什么工作？这些工作你解决了什么问题？还有什么困难没有解决？这些困难在后续如何优化？优化后可以实现什么功能？这些功能如何和中间件和分布式并行系统联系在一起？？Java中间件方向消息的传输方式mq长连接短连接</p><h2>Java 虚拟机有什么优化？</h2><ul><li>底层计算机理解内存管理/数据挖掘系统</li><li>可靠性和可用性如何理解~</li><li>jsp 和sever lap对比</li><li>数据库到界面，字符集转化</li><li>基栈</li><li>jvm优化cup高的时候如果分析和监控</li><li>java curb突出细节问题</li><li>分布式缓存文档如何分流</li><li>迁移数据库垂直分割</li><li>高并发如何处理前端高并发应用层</li><li>LB设计load balance</li><li>负载均衡</li><li>防网络攻击</li><li>数据日志事件监控后通知</li><li>数据库事务实现的底层机制</li><li>字符串空格输入的网络攻击</li><li>Quartz框架的底层原理</li><li>数据库同步中不通过数据库引擎直接读日志等方式同步数据</li></ul><p>如果你想学好JAVA这门技术，也想在IT行业拿高薪，可以进来看看 ，群里有：Java工程化、高性能及分布式、高性能、深入浅出。高架构。性能调优、Spring，MyBatis，Netty源码分析和大数据等多个知识点。</p><h2>阿里面试题</h2><ol><li>二叉树的遍历方式，前序、中序、后序和层序</li><li>volatile关键字</li><li>synchronized</li><li>concurrentHashMap</li><li>锁的优化策略</li><li>操作系统</li></ol><h2>项目部分</h2><ul><li>缓存的使用，如果现在需要实现一个简单的缓存，供搜索框中的ajax异步请求调用，使用什么结构？</li><li>内存中的缓存不能一直存在，用什么算法定期将搜索权重较低的entry去掉？</li><li>TCP如何保证安全性</li><li>红黑树的问题，B+数</li><li>JDK1.8中对HashMap的增强，如果一个桶上的节点数量过多，链表+数组的结构就会转换为红黑树。</li><li>项目中使用的单机服务器，如果将它部署成分布式服务器？</li><li>MySQL的常见优化方式、定为慢查询</li><li>手写一个线程安全的单例模式</li><li>进阿里必会知识：</li><li>算法和数据结构数组、链表、二叉树、队列、栈的各种操作（性能，场景）</li><li>二分查找和各种变种的二分查找</li><li>各类排序算法以及复杂度分析（快排、归并、堆）</li><li>各类算法题（手写）</li><li>理解并可以分析时间和空间复杂度。</li><li>动态规划（笔试回回有。。）、贪心。</li><li>红黑树、AVL树、Hash树、Tire树、B树、B+树。</li><li>图算法（比较少，也就两个最短路径算法理解吧）</li><li>计算机网络OSI7层模型（TCP4层）每层的协议</li><li>url到页面的过程</li><li>HTTPhttp/https 1.0、1.1、2.0</li><li>get/post 以及幂等性</li><li>http 协议头相关</li><li>网络攻击（CSRF、XSS）</li><li>TCP/IP三次握手、四次挥手</li><li>拥塞控制（过程、阈值）</li><li>流量控制与滑动窗口</li><li>TCP与UDP比较</li><li>子网划分（一般只有笔试有）</li><li>DDos攻击</li><li>(B)IO/NIO/AIO三者原理，各个语言是怎么实现的</li><li>Netty</li><li>Linux内核select poll epoll</li><li>数据库（最多的还是mysql，Nosql有redis）索引（包括分类及优化方式，失效条件，底层结构）</li><li>sql语法（join，union，子查询，having，group by）</li><li>引擎对比（InnoDB，MyISAM）</li><li>数据库的锁（行锁，表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁，以及加锁的select sql方式）</li><li>隔离级别，依次解决的问题（脏读、不可重复读、幻读）</li><li>事务的ACID</li><li>B树、B+树</li><li>优化（explain，慢查询，show profile）</li><li>数据库的范式。</li><li>分库分表，主从复制，读写分离。</li><li>Nosql相关（redis和memcached区别之类的，如果你熟悉redis，redis还有一堆要问的）</li><li>操作系统：进程通信IPC（几种方式），与线程区别</li><li>OS的几种策略（页面置换，进程调度等，每个里面有几种算法）</li><li>互斥与死锁相关的</li><li>linux常用命令（问的时候都会给具体某一个场景）</li><li>Linux内核相关（select、poll、epoll）</li><li>编程语言（这里只说Java）：把我之后的面经过一遍，Java感觉覆盖的就差不多了，不过下面还是分个类。</li><li>Java基础（面向对象、四个特性、重载重写、static和final等等很多东西）</li><li>集合（HashMap、ConcurrentHashMap、各种List，最好结合源码看）</li><li>并发和多线程（线程池、SYNC和Lock锁机制、线程通信、volatile、ThreadLocal、CyclicBarrier、Atom包、CountDownLatch、AQS、CAS原理等等）</li><li>JVM（内存模型、GC垃圾回收，包括分代，GC算法，收集器、类加载和双亲委派、JVM调优，内存泄漏和内存溢出）</li><li>IO/NIO相关</li><li>反射和代理、异常、Java8相关、序列化</li><li>设计模式（常用的，jdk中有的）</li><li>Web相关（servlet、cookie/session、Spring</li></ul>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70391048", 
            "userName": "Tnlj", 
            "userLink": "https://www.zhihu.com/people/2b4ccac031e1115aaafb2322596a7288", 
            "upvote": 3, 
            "title": "强引用、弱引用", 
            "content": "<p>Java中除了基本数据类型之外，其他的都是引用类型。根据其生命周期的长短又分为强引用、软引用、弱引用、虚引用，正常情况下我们使用到的都是强引用。</p><h2>1、强引用</h2><p>强引用是指类似 Object obj = new Object()； 这类的引用，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象.</p><h3>疑问：</h3><p>在周志明写的《深入理解Java虚拟机》第二版中以及网上很多资料对于强引用的说法都是：<b>只要对象还存在，垃圾收集器就不会回收被引用的对象。</b>刚看到这点的时候，其实也还是很疑惑的： <b>在实际的编码中， Object obj = new Object() 这类的代码是非常常见的，而且我们也一般也不会再写 obj = null ，也就是说 obj 这个强引用将一直存在，进而创建的对象也会一直存在与堆内存中，如果这样的话 JVM 不就是会分分钟内存溢出了么。</b></p><p>对于这个疑问，在进一步了解 JVM 的内存模型以及询问一些前辈后，发现故事并没有这么简单。。。对于 Object obj = new Object() 这行代码，JVM 所做的操作是在 堆内存中分配一块内存空间给 Object 对象，随后在<b>虚拟机栈（线程私有，生命周期与线程相同）</b>中会有一个强引用 obj 指向刚刚在堆中分配的内存空间。但当该线程结束（方法也退出）时，虚拟机栈中的内容也会随着线程的死亡而消失，指向堆内存中的 obj 引用也就会消失，这时候分配给 Object 的内存空间就不存在引用指向这块内存空间（假设只有这么一个引用指向这块内存空间），根据 JVM 的可达性分析算法，这块堆内存空间已经变为不可达的了，所以也就会被回收掉。</p><p>所以，对于这段描述是没有问题的。虽然我们没有显示的 obj = null 去除该引用，但虚拟机会执行这个操作，对象进而会被回收。</p><h2>2、软引用（SoftReference）</h2><p>软引用用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><h2>3、弱引用(WeakReference)</h2><p>弱引用也是用来描述非必需对象的，但是他的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前。在垃圾收集器工作时，无论当前内存是否足够，被弱引用关联的对象都会被回收掉。</p><h2>4、虚引用(PhantomReference)</h2><p>虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时能收到一个系统通知。</p><p>以上是四个引用类型的基本概述，以下讲重点讲解弱引用在 java 中的一些应用。</p><h3>A、代码</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">testWeakReference</span><span class=\"o\">(){</span>\n        <span class=\"k\">try</span><span class=\"o\">{</span>\n            <span class=\"n\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">weakReference</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">WeakReference</span><span class=\"o\">&lt;&gt;(</span><span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"s\">&#34;test reference&#34;</span><span class=\"o\">));</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">weakReference</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n            <span class=\"c1\">//JVM虚拟机开启回收对象\n</span><span class=\"c1\"></span>            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">gc</span><span class=\"o\">();</span>\n            <span class=\"c1\">//主线程休眠300ms，确保回收工作已完成\n</span><span class=\"c1\"></span>            <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">300</span><span class=\"o\">);</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">weakReference</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n        <span class=\"o\">}</span><span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Throwable</span> <span class=\"n\">e</span><span class=\"o\">){</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">//Output:\n</span><span class=\"c1\"></span>    <span class=\"n\">test</span> <span class=\"n\">reference</span>\n    <span class=\"kc\">null</span></code></pre></div><p>在上述代码中，JVM 堆中新开辟了一块内存给 String 对象，内容为 “test reference”，并且栈中有一个弱引用 weakReference 指向这块内存空间，此时该弱引用指向的内存空间有值且值为 ‘test reference’。随后 JVM 进行一次内存回收操作，由上面对弱引用的定义可知，被弱引用关联的对象只能存活到下一次内存回收之前。<b>也就是说，当 JVM 进行内存回收后，所有被弱引用关联的对象都将被回收。</b>所以在 System.gc() 之后再次获取该弱引用指向的内存空间时，值就为空。</p><h3>B、WeakHashMap</h3><p>在我们平常使用到的 HashMap 中存在这这么一个问题，如何 map 中的 key 已经不存在（为 null ）了，但是该 key 对应的 value 对象却一直存在，而且我们无法使用到该值，这也就造成了内存泄漏的问题，而 WeakHashMap 就很好的解决了这个问题。</p><p>WeakHashMap 与 HashMap 结构相似，都是由一个个的 Entey 组成，在 WeakHashMap 源码中， Entry 定义如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">extends</span> <span class=\"n\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;</span> <span class=\"kd\">implements</span> <span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n        <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n        <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">;</span>\n        <span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n\n        <span class=\"cm\">/**\n</span><span class=\"cm\">         * Creates new entry.\n</span><span class=\"cm\">         */</span>\n        <span class=\"n\">Entry</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">,</span>\n              <span class=\"n\">ReferenceQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">queue</span><span class=\"o\">,</span>\n              <span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">next</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">//WeakHashMap 的key为弱引用\n</span><span class=\"c1\"></span>            <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">queue</span><span class=\"o\">);</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">hash</span>  <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"o\">;</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">next</span>  <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p>初始化 Entry 的时候调用了父类 WeakReference 传入 ReferenceQueue 参数的的构造方法，这也就是 WeakHashMap 能够很好的解决内存泄漏问题的关键所在。这个队列的意义在于增加一种判断机制，可以在外部通过监控来判断对象是否被回收。如果一个对象即将被回收，那么引用这个对象的 reference 对象将会被放到这个队列中。一下是测试 ReferenceQueue 的代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class TestQueue {\n    private static ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();\n    private static int _1M = 1024* 1024;\n\n    public static void main(String[] args) {\n        Object value = new Object();\n        Map&lt;WeakReference&lt;byte[]&gt;, Object&gt; map = new HashMap&lt;&gt;();\n        Thread thread = new Thread(TestQueue::run);\n        thread.setDaemon(true);\n        thread.start();\n        for (int i = 0; i &lt; 100; i++) {\n            byte[] bytes = new byte[_1M];\n            WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(bytes, queue);\n            map.put(weakReference, value);\n        }\n        System.out.println(&#34;map&#39;s size: &#34;+ map.size());\n        int aliveNum = 0;\n        for (Map.Entry&lt;WeakReference&lt;byte[]&gt;, Object&gt; entry : map.entrySet()){\n            if (entry != null){\n                if (entry.getKey().get() != null){\n                    aliveNum++;\n                }\n            }\n        }\n        System.out.println(&#34;100个对象中存活的对象数量：&#34; + aliveNum);\n    }\n    private static void run(){\n        try {\n            int n = 0;\n            WeakReference k;\n            while ((k = (WeakReference)queue.remove()) != null){\n                System.out.println((++n)+ &#34;回收了：&#34;+ k);\n            }\n        }catch (Throwable e){\n            System.out.println(&#34;exception occured&#34;);\n        }\n    }\n}</code></pre></div><p>WeahHashMap 在执行 get()、getEntry()、put()、resize()、remove()、removeMapping()、containsValue() 等方法时，都会执行  getTable() 方法，源码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">    /**\n     * 清除无用的 entry 并返回 Entry 数组\n     * Returns the table after first expunging stale entries.\n     */\n    private Entry&lt;K,V&gt;[] getTable() {\n        expungeStaleEntries();\n        return table;\n    }\n\n     /**\n     * 清除已被 GC 的 key 对应的 value 值\n     * Expunges stale entries from the table.\n     */\n    private void expungeStaleEntries() {\n        //不断从引用队列（ReferenceQueue）中获取已被 GC 的 key 对应的 Entry\n        for (Object x; (x = queue.poll()) != null; ) {\n            synchronized (queue) {\n                @SuppressWarnings(&#34;unchecked&#34;)\n                    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;\n                //计算出该 Entry 对应数组的脚标\n                int i = indexFor(e.hash, table.length);\n\n                Entry&lt;K,V&gt; prev = table[i];\n                Entry&lt;K,V&gt; p = prev;\n                //连表结构，找到该 Entry，并将 value 置为null便于回收\n                while (p != null) {\n                    Entry&lt;K,V&gt; next = p.next;\n                    if (p == e) {\n                        if (prev == e)\n                            table[i] = next;\n                        else\n                            prev.next = next;\n                        // Must not null out e.next;\n                        // stale entries may be in use by a HashIterator\n                        e.value = null; // Help GC\n                        size--;\n                        break;\n                    }\n                    prev = p;\n                    p = next;\n                }\n            }\n        }\n    }</code></pre></div><p>以上代码主要是处理已被 GC 回收的 key 对应的 value 值，确保 map 中的 key 被 GC 回收后，其对应的 value 值也能及时的被回收。引用队列（ReferenceQueue）作为 WeakHashMap的成员变量保存着所有已被回收的key对应的Entry。每当WeakHashMap中有key被回收，那么其所在的Entry就会进入到引用队列中，在下一次执行put、get都会将队列中的Entry的value值设置为空，便于进行垃圾回收。</p><h3>C、ThreadLocal</h3><p>ThreadLocal 是弱引用的又一最佳实践，ThreadLocal 与 WeakHashMap 相似，都是以弱引用对象为 key ，便于进行垃圾回收。</p><p>在 ThreadLocal 源码中，其包含一个静态内部类 ThreadLocalMap ，虽然类名中包含有 Map 字样，但 ThreadLocalMap 的实现却跟 Map 没有任何关系， 内部静态类 ThreadLocalMap 中还有一个静态内部类 Entry ，ThreadLocal 的数据也都是保存在 Entry 中。</p><h3>a、Entry</h3><p>ThreadLocal 源码中对 Entry 的定义如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal&lt;?&gt; k, Object v) {\n                super(k);\n                value = v;\n            }\n        }</code></pre></div><p>如源码， Entry 继承了 WeakReference，key 为 当前ThreadLocal 对象，且为弱引用，细心的你也许能发现，ThreadLocal 在定义弱引用 key 的时候，使用的是不带引用队列参数的构造函数，而 WeakHashMap 使用的则是带引用队列的构造参数，如图一所示，这也导致了两者在清理 key 为 null 的Entry 时采取的不同方法（<b>WeakHashMap通过不断的从引用队列中获取Entry去清理key为null的Entry，而ThreadLocal却因为没有使用引用队列而只能遍历整个Entry数组</b>）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-08b4c2e2c6c7ea9d56213e8ca94341fc_b.jpg\" data-size=\"normal\" data-rawwidth=\"797\" data-rawheight=\"614\" class=\"origin_image zh-lightbox-thumb\" width=\"797\" data-original=\"https://pic1.zhimg.com/v2-08b4c2e2c6c7ea9d56213e8ca94341fc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;797&#39; height=&#39;614&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"797\" data-rawheight=\"614\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"797\" data-original=\"https://pic1.zhimg.com/v2-08b4c2e2c6c7ea9d56213e8ca94341fc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-08b4c2e2c6c7ea9d56213e8ca94341fc_b.jpg\"/><figcaption>图一、 WeakReference类</figcaption></figure><h3>b、ThreadLocalMap</h3><div class=\"highlight\"><pre><code class=\"language-text\">static class ThreadLocalMap{\n   static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal&lt;?&gt; k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n   private static final int INITIAL_CAPACITY = 16;\n   private Entry[] table;\n   private int size = 0;\n   private int threshold; \n}</code></pre></div><p>ThreadLocalMap 在 ThreadLocal 是以静态内部类的方式定义的，所以它就不需要对外部类对象的引用。每个 Thread 线程对象都拥有一个 ThreadLocalMap 对象（见 Thread 源码），在学习到这块的时候，曾经有过一个疑问，Thread 源码中有 ThreadLocalMap， ThreadLocalMap 是ThreadLocal 的静态内部类，ThreadLocalMap 类中还有一个Entry数组， Entry 的key 又是当前的 ThreadLocal 对象，为什么需要一个 Entry 数组？</p><p>以下是我自己的一些想法：每一个线程都有 ThreadLocalMap 实例（虽然 ThreadLocalMap是ThreadLocal 的内部类，但因为他是静态内部类，它不属于我们在当前线程中创建的任何的 ThreadLocal 实例），在当前线程中我们可以通过 new ThreadLocal() 创建很多的 ThreadLocal 实例，当我们对 ThreadLocal set值得时候会获取 Thread 的 ThreadLocalMap 对象（为空则初始化一个），而set值的过程也很简单，如下代码所示， 获取当前ThreadLocal的哈希值与数组长度取与，之后将ThreadLocal作为key，需要保存的值作为value保存在Entry数组中，因为一个线程允许创建多个 ThreadLocal，而这些 ThreadLocal 所保存的值与 ThreadLocal 对象本时的映射关系是保存在 ThreadLocalMap中（其实就是 那个 Entry 数组），这也就是为什么 ThreadLocalMap 中需要有一个 Entry 数组的原因。</p><div class=\"highlight\"><pre><code class=\"language-text\">/**\n* ThreadLocal 的 set 方法\n**/\npublic void set(T value) {\n        //获取当前线程\n        Thread t = Thread.currentThread();\n        //通过 t.threadLocals 获取当前线程的 ThreadLocalMap 对象\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n           //this 为当前执行该方法的 ThreadLocal\n            map.set(this, value);\n        else\n           //当前线程没有 ThreadLocalMap 对象则初始化一个\n            createMap(t, value);\n    }</code></pre></div><p>因为 Entry 的key为弱引用，所以在JVM发生GC时会被回收，这也将导致ThreadLocalMap中存在着key为null，value不为null的Entry，造成内存泄漏。ThreadLocal对这个也进行了处理，在我们执行 get()、set()方法时，在有些情况下会清理key为null的Entry（详见expungeStaleEntry方法），但执行这两个方法并不能 100% 的保证会清理Entry数组，为了避免出现内存泄漏的情况，我们可以手动的执行 remove（） 进行清理。</p><p><b>在我们使用 ThreadLocal 进行get、set操作时，其实跟 ThreadLocal 关系并不大，真正关系大的是 Thread 的 ThreadLocalMap ，而我们创建的 ThreadLocal 实例只是获取他的 hash 值然后作为 Entry 数组的下标。</b></p>", 
            "topic": [
                {
                    "tag": "引用", 
                    "tagLink": "https://api.zhihu.com/topics/19571032"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73427930", 
            "userName": "Tnlj", 
            "userLink": "https://www.zhihu.com/people/2b4ccac031e1115aaafb2322596a7288", 
            "upvote": 4, 
            "title": "跨域请求403", 
            "content": "<h2>0、环境说明</h2><p>1、下文中跨域实现为服务器域名  <a href=\"https://link.zhihu.com/?target=http%3A//yaogy.jd.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">yaogy.jd.com</span><span class=\"invisible\"></span></a>  向本地项目 <a href=\"https://link.zhihu.com/?target=http%3A//leo.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">leo.com</a> 发起跨域请求，本地进行debug。</p><p>2、本地项目 Spring 版本为 4.3.0。</p><p>跨域的实现方式有很多种，注解、过滤器、拦截器都能很好的实现跨域的功能，但在实际应用中却发现在同一个跨域实现、同一个 controller 类下，有的跨域请求成功，有的跨域请求返回 403，如图1 所示。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a6db3b048400ac538c3169103d589b7d_b.jpg\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"590\" class=\"origin_image zh-lightbox-thumb\" width=\"534\" data-original=\"https://pic2.zhimg.com/v2-a6db3b048400ac538c3169103d589b7d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;534&#39; height=&#39;590&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"590\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"534\" data-original=\"https://pic2.zhimg.com/v2-a6db3b048400ac538c3169103d589b7d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a6db3b048400ac538c3169103d589b7d_b.jpg\"/><figcaption>图1.跨域403返回示例</figcaption></figure><h2>1、基于拦截器的跨域403响应</h2><p>图1所示请求中，采取的是通过过滤器的方式实现跨域，ajax 请求方式为 GET请求，content-type 为 application/json，是一个复杂请求。初始过滤器代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class CorsFilter extends OncePerRequestFilter {\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n\n        String originUrl = request.getHeader(&#34;origin&#34;);\n        \n        if(!StringUtils.isEmpty(originUrl)){\n            //自定义跨域域名检查\n            boolean isAllow = checkAllow(originUrl);\n\n            if (isAllow) {\n                response.setHeader(&#34;Access-Control-Allow-Origin&#34;, originUrl);\n            }\n            response.setHeader(&#34;Access-Control-Allow-Credentials&#34;, &#34;true&#34;);\n            response.setHeader(&#34;Access-Control-Allow-Methods&#34;, &#34;POST, GET, OPTIONS&#34;);\n            response.setHeader(&#34;Access-Control-Max-Age&#34;, &#34;1800&#34;);//30分钟\n            response.setHeader(&#34;Access-Control-Allow-Headers&#34;, &#34;x-requested-with, content-type&#34;);\n        }\n        filterChain.doFilter(request, response);\n    }\n}</code></pre></div><p>上述拦截器在拦截普通跨域请求时能够正常跨域，但遇到复杂跨域请求时，在发起预请求的时候预请求阶段就返回 403 ，跨域失败，结果如图1所示。</p><figure data-size=\"small\"><noscript><img src=\"https://pic4.zhimg.com/v2-654e3d8e86bfaafc819b195a0f462843_b.jpg\" data-size=\"small\" data-rawwidth=\"1338\" data-rawheight=\"690\" class=\"origin_image zh-lightbox-thumb\" width=\"1338\" data-original=\"https://pic4.zhimg.com/v2-654e3d8e86bfaafc819b195a0f462843_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1338&#39; height=&#39;690&#39;&gt;&lt;/svg&gt;\" data-size=\"small\" data-rawwidth=\"1338\" data-rawheight=\"690\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1338\" data-original=\"https://pic4.zhimg.com/v2-654e3d8e86bfaafc819b195a0f462843_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-654e3d8e86bfaafc819b195a0f462843_b.jpg\"/><figcaption>图2、对跨域请求的判断</figcaption></figure><p>如图2所示，该方法的全限定名为 org.springframework.web.cors.DefaultCorsProcessor#processRequest，对于CorsConfiguration对象为空的预请求，将直接返回403，至于CorsConfiguration，可以参考另一篇文章 </p><a href=\"https://zhuanlan.zhihu.com/p/66789473\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-fd3a6d48acb43097bced06aa48540b9c_180x120.jpg\" data-image-width=\"4032\" data-image-height=\"3024\" class=\"internal\">Tnlj：CORS与@CrossOrigin详解</a><p><b>大致流程为：Spring 容器在启动的时候会扫描每一个添加了 @Controller 注解的类、@RequestMapping注解的方法，之后判断类或者方法上是否有 @CrossOrigin 注解，并将 @CrossOrigin 注解中的内容转换成 CorsConfiguration 对象</b>，具体转换逻辑如图3所示：</p><figure data-size=\"small\"><noscript><img src=\"https://pic4.zhimg.com/v2-df2cb86100d5a0f9b798de36f85c6e13_b.jpg\" data-size=\"small\" data-rawwidth=\"1373\" data-rawheight=\"770\" class=\"origin_image zh-lightbox-thumb\" width=\"1373\" data-original=\"https://pic4.zhimg.com/v2-df2cb86100d5a0f9b798de36f85c6e13_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1373&#39; height=&#39;770&#39;&gt;&lt;/svg&gt;\" data-size=\"small\" data-rawwidth=\"1373\" data-rawheight=\"770\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1373\" data-original=\"https://pic4.zhimg.com/v2-df2cb86100d5a0f9b798de36f85c6e13_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-df2cb86100d5a0f9b798de36f85c6e13_b.jpg\"/><figcaption>图3、注解到类的转换逻辑</figcaption></figure><p>而对于基于过滤器实现的跨域，没有 @CrossOrigin 注解的加持，CorsConfiguration 对象自然为空，而在Spring对跨域请求的处理逻辑中，对于CorsConfiguration 对象为空的预请求是会执行 rejectRequest 方法，也就是返回状态码 403。既然 Spring 对跨域请求的处理逻辑我们无法改变，所以<b>我们可以在过滤器中添加对 预请求的单独处理或者采用注解的方式解决复杂请求的跨域403响应</b>。修改后的过滤器如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class CorsFilter extends OncePerRequestFilter {\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n\n        String originUrl = request.getHeader(&#34;origin&#34;);//请求的地址\n\n        if(!StringUtils.isEmpty(originUrl)){\n            //自定义跨域域名检查\n            boolean isAllow = checkAllow(originUrl);\n\n            if (isAllow) {\n                response.setHeader(&#34;Access-Control-Allow-Origin&#34;, originUrl);\n            }\n            response.setHeader(&#34;Access-Control-Allow-Credentials&#34;, &#34;true&#34;);\n            response.setHeader(&#34;Access-Control-Allow-Methods&#34;, &#34;POST, GET, OPTIONS&#34;);\n            response.setHeader(&#34;Access-Control-Max-Age&#34;, &#34;1800&#34;);//30分钟\n            response.setHeader(&#34;Access-Control-Allow-Headers&#34;, &#34;x-requested-with, content-type&#34;);\n            \n            //对预请求单独处理\n            String method = request.getMethod();\n            if (method.equalsIgnoreCase(&#34;OPTIONS&#34;)){\n                response.setStatus(HttpServletResponse.SC_OK);\n                return;\n            }\n        }\n        filterChain.doFilter(request, response);\n    }\n}</code></pre></div><h2>说明：在对预请求返回200时，除了状态码是一定要设置的之外，还有就是 Response Head 头中的 Access-Control-Allow-Origin 也一定要返回值，该值可以为请求的 origin 字段或者 *。</h2><h2>2、基于注解的跨域403响应</h2><p>基于注解的跨域实现能够解决 CorsConfiguration 对象为空的问题，进而解决了在拦截器的实现方式中预请求403的问题。但注解并不能解决所有问题，注解使用不当的时候仍然可能返回403响应。</p><p><b>问题产生场景：</b></p><p>1、方法上的注解未设置 methods 属性</p><p>2、ajax请求方法为 POST（或其他非HEAD、GET）方法。</p><p><b>问题产生原因：</b></p><figure data-size=\"small\"><noscript><img src=\"https://pic2.zhimg.com/v2-7dad4a64cab78b984160be0835daf9a1_b.jpg\" data-size=\"small\" data-rawwidth=\"1431\" data-rawheight=\"678\" class=\"origin_image zh-lightbox-thumb\" width=\"1431\" data-original=\"https://pic2.zhimg.com/v2-7dad4a64cab78b984160be0835daf9a1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1431&#39; height=&#39;678&#39;&gt;&lt;/svg&gt;\" data-size=\"small\" data-rawwidth=\"1431\" data-rawheight=\"678\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1431\" data-original=\"https://pic2.zhimg.com/v2-7dad4a64cab78b984160be0835daf9a1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7dad4a64cab78b984160be0835daf9a1_b.jpg\"/><figcaption>图4、注解情况下403原因</figcaption></figure><p>如图4所示，当方法上的 @CrossOrigin 注解未进行任何配置时，获得的 allowMethods 对象为空导致返回 403 响应。checkMethods方法代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">protected List&lt;HttpMethod&gt; checkMethods(CorsConfiguration config, HttpMethod requestMethod) {\n        //方法的具体逻辑见图5\n        return config.checkHttpMethod(requestMethod);\n    }</code></pre></div><figure data-size=\"small\"><noscript><img src=\"https://pic2.zhimg.com/v2-fb2dbf9cf743e7d8552f556319ae992d_b.jpg\" data-size=\"small\" data-rawwidth=\"1213\" data-rawheight=\"675\" class=\"origin_image zh-lightbox-thumb\" width=\"1213\" data-original=\"https://pic2.zhimg.com/v2-fb2dbf9cf743e7d8552f556319ae992d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1213&#39; height=&#39;675&#39;&gt;&lt;/svg&gt;\" data-size=\"small\" data-rawwidth=\"1213\" data-rawheight=\"675\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1213\" data-original=\"https://pic2.zhimg.com/v2-fb2dbf9cf743e7d8552f556319ae992d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fb2dbf9cf743e7d8552f556319ae992d_b.jpg\"/><figcaption>图5、检查allowMethods</figcaption></figure><p>由图5可知，当@CrossOrigin 注解未配置  methods 属性时，默认只允许 GET、HEAD 方法的访问，对于其他的请求方法都将返回403响应。</p><p><b>解决办法：</b></p><p>给方法添加跨域注解时增加需要支持的方法，比如：@CrossOrigin<i>(</i>methods = <i>{</i>RequestMethod.<i>GET</i>, RequestMethod.<i>POST})</i></p><h2>3、总结</h2><p><b>a、使用过滤器、拦截器等的配置方式无法解决复杂请求的预请求的问题，但对于POST方法的简单请求不会出现问题。</b></p><p><b>b、使用注解的方式在不设置跨域方法的情况下对非 GET、HEAD 方法的请求会出现403的响应，但对于复杂请求无需做额外的逻辑处理。</b></p>", 
            "topic": [
                {
                    "tag": "跨域", 
                    "tagLink": "https://api.zhihu.com/topics/19612046"
                }, 
                {
                    "tag": "过滤器", 
                    "tagLink": "https://api.zhihu.com/topics/19726305"
                }
            ], 
            "comments": [
                {
                    "userName": "蒋霍尔", 
                    "userLink": "https://www.zhihu.com/people/60d852f6b87734c20d238772051e841a", 
                    "content": "<a class=\"comment_sticker\" href=\"https://pic4.zhimg.com/v2-ba306425d0a7aee2c7260381f1bf7b97.gif\" data-sticker-id=\"990581350222589952\"> [欢呼]</a>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "蓝领小小生", 
                    "userLink": "https://www.zhihu.com/people/2ff36cfefc23c32dc29cbd43cb1e70f5", 
                    "content": "<p>棒棒哒</p><a class=\"comment_sticker\" href=\"https://pic3.zhimg.com/v2-cfc14c7293afd962ecbd1dc31dafd002.gif\" data-width=\"\" data-height=\"\">[赞同]</a>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72849952", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 1, 
            "title": "Freeswitch脚本大全", 
            "content": "<ol><li> 后台启动 （日志在log/freeswitch.log）：</li></ol><div class=\"highlight\"><pre><code class=\"language-text\"># freeswitch –nc</code></pre></div><p>2 . 后台启动，并关闭使用upup协议检测路由：</p><div class=\"highlight\"><pre><code class=\"language-text\"># freeswitch –nc –nonat</code></pre></div><p>3 . 判断是否运行：</p><div class=\"highlight\"><pre><code class=\"language-text\"># ps aux |grep freeswitch</code></pre></div><p>4 . 看相关端口是否被占用:</p><div class=\"highlight\"><pre><code class=\"language-text\"># netstat –an |grep 5060\n# netstat –anp |grep 5060</code></pre></div><p>5. 使用命令发起呼叫：              </p><div class=\"highlight\"><pre><code class=\"language-text\"> # originate user/1001 &amp;echo\n # originate sofia/gateway/callcenter-gw/1880117xxxx &amp;echo</code></pre></div><p>6. 查看网关注册状态 </p><div class=\"highlight\"><pre><code class=\"language-text\"> # sofia status</code></pre></div><p>7. 安装声音文件（window自带，linux需要装），在源代码src目录:</p><div class=\"highlight\"><pre><code class=\"language-text\"># make sounds-install\n# make moh-install</code></pre></div><p> 或者使用超清：</p><div class=\"highlight\"><pre><code class=\"language-text\"># make cd-sounds-install\n# make cd-moh-install</code></pre></div><p>8. 播放一个特定的文件：</p><div class=\"highlight\"><pre><code class=\"language-text\"># originate user/1001 &amp;playback(/root/wecome.wav)</code></pre></div><p>9. 重新加载xml:</p><div class=\"highlight\"><pre><code class=\"language-text\"># reloadxml</code></pre></div><p>持续跟进，待续补充.......</p>", 
            "topic": [
                {
                    "tag": "FreeSWITCH", 
                    "tagLink": "https://api.zhihu.com/topics/19892529"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "SIP", 
                    "tagLink": "https://api.zhihu.com/topics/19617345"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72321893", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 1, 
            "title": "Linux 下 Freeswitch 部署手册", 
            "content": "<p>Freeswitch部署一般推荐采用<b>源代码</b>编译部署，这样最大的好处就是可以很方便能使用最新的版本，如果部署出现问题也能够方便回退到先前的版本。</p><p><b>1. 下载源代码（最新版本1.8.7）： </b></p><div class=\"highlight\"><pre><code class=\"language-text\">cd /usr/local/src\ngit clone -b v1.6 https://freeswitch.org/stash/scm/fs/freeswitch.git freeswitch</code></pre></div><p><b>2. 开始编译 </b></p><div class=\"highlight\"><pre><code class=\"language-text\">cd/ freeswitch \n./bootstrap.sh </code></pre></div><p>如果会出现类似autoconf not found错误提示，是因为没有下载第三方依赖库，先执行第3步。freeswitch依赖的第三方库有：</p><p>gcc-c++ ，wget alsa-lib-devel， autoconf ，automake ，bison ，broadvoice-devel ，bzip2 ，curl-devel， db-devel ，e2fsprogs-devel， flite-devel ，g722_1-devel， gdbm-devel， gnutls-devel ，ilbc2-devel ，ldns-devel ，libcodec2-devel ，libcurl-devel ，libedit-devel ，libidn-devel ，libjpeg-devel， libmemcached-devel， libogg-devel ，libsilk-devel，libsndfile-devel ，libtiff-devel ，libtheora-devel， libtool， libvorbis-devel ，libxml2-devel ，lua-devel ，lzo-devel ，mongo-c-driver-devel， ncurses-devel， net-snmp-devel ，openssl-devel ，opus-devel ，pcre-devel ，perl perl-ExtUtils-Embed pkgconfig portaudio-devel ，postgresql-devel， python26-devel ，python-devel ，soundtouch-devel，speex-devel， sqlite-devel ，unbound-devel， unixODBC-devel ，libuuid-devel ，which yasm zlib-devel。</p><p><b>3. 安装依赖库： </b></p><p>A）可以一个个安装，如下： </p><div class=\"highlight\"><pre><code class=\"language-text\">1. yum install autoconf \n2. yum install automake \n3. yum install libtool \n....</code></pre></div><p>B）也可以全部一起安装： </p><div class=\"highlight\"><pre><code class=\"language-text\">yum install -y http://files.freeswitch.org/freeswitch-release-1-6.noarch.rpm epel-release</code></pre></div><p><b>4. 再一次编译 </b></p><div class=\"highlight\"><pre><code class=\"language-text\">./bootstrap.sh \n./configure</code></pre></div><p>如果出现以下界面，就是默认配置成功. </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-887b6d0c06499064ff6597af0c491521_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"203\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-887b6d0c06499064ff6597af0c491521_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;203&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"203\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-887b6d0c06499064ff6597af0c491521_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-887b6d0c06499064ff6597af0c491521_b.jpg\"/></figure><p><b>5.运行 make 命令 </b></p><p>如果出现以下界面，则编译成功。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6da6fbca6571bdfb13ef44b61cc2d089_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"196\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-6da6fbca6571bdfb13ef44b61cc2d089_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;196&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"196\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-6da6fbca6571bdfb13ef44b61cc2d089_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6da6fbca6571bdfb13ef44b61cc2d089_b.jpg\"/></figure><p><b>6. 运行make install命令 </b></p><p>如果出现以下界面，则安装成功。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1649e78872d20d3f83b558ac64b93cd4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"175\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-1649e78872d20d3f83b558ac64b93cd4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;175&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"175\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-1649e78872d20d3f83b558ac64b93cd4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1649e78872d20d3f83b558ac64b93cd4_b.jpg\"/></figure><p><b>7.启动freeswitch</b></p><div class=\"highlight\"><pre><code class=\"language-text\">cd /usr/local/freeswitch/bin/\n./freeswitch </code></pre></div><p>如果出现以下界面，则运行成功。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-98343d459990c03ceb103dceafb4eab3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"243\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-98343d459990c03ceb103dceafb4eab3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;243&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"243\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-98343d459990c03ceb103dceafb4eab3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-98343d459990c03ceb103dceafb4eab3_b.jpg\"/></figure><h2>8.配置Freeswitch在任何一个路径都可以运行（可选）</h2><div class=\"highlight\"><pre><code class=\"language-text\">ln -sf /usr/local/freeswitch/bin/freeswitch /usr/bin/ \nln -sf /usr/local/freeswitch/bin/fs_cli /usr/bin/</code></pre></div><h2>9 安装声音文件（可选，推荐安装）</h2><p>安装声音文件，window部署自带无需安装，linux需要安装：</p><div class=\"highlight\"><pre><code class=\"language-text\">make sounds-install\nmake moh-install</code></pre></div><p>或者选用超清音质：</p><div class=\"highlight\"><pre><code class=\"language-text\">make cd-sounds-install\nmake cd-moh-install</code></pre></div><p><b>10 测试</b></p><p>使用一个软电话以用户1000，密码1234的身份注册上线freeswitch客户端用命令拨号：</p><div class=\"highlight\"><pre><code class=\"language-text\">originate user/1000 &amp;echo；</code></pre></div><p>接通应答，即可听到自己的回音。</p><p><b>11.问题</b></p><blockquote>A）如果运行freeswitch出现以下错误，是因为端口被占用了？</blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-aec31249680088223adbb8b203ba6c23_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"41\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-aec31249680088223adbb8b203ba6c23_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;41&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"41\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-aec31249680088223adbb8b203ba6c23_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-aec31249680088223adbb8b203ba6c23_b.png\"/></figure><p>解决办法：可以重启Linux或者关闭占用端口的进程。</p><blockquote>B）如果freeswitch启动成功，但是linphone注册不上？</blockquote><p>解决办法：systemctl stop firewalld.service （关闭防火墙）</p><blockquote>C）fs_cli客户端连接不上</blockquote><p>解决办法：检查:</p><div class=\"highlight\"><pre><code class=\"language-text\">/usr/local/freeswitch/conf/autoload_configs/ event_socket.conf.xml </code></pre></div><p>将listen-ip改为0.0.0.0；</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f76c531969d83720660d1af529d263ef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"112\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-f76c531969d83720660d1af529d263ef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;112&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"112\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-f76c531969d83720660d1af529d263ef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f76c531969d83720660d1af529d263ef_b.jpg\"/></figure><p><b>参考：</b></p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/0d9c4391baaf\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">jianshu.com/p/0d9c4391b</span><span class=\"invisible\">aaf</span><span class=\"ellipsis\"></span></a></li><li><u><a href=\"https://link.zhihu.com/?target=https%3A//www.httproot.com/article/133\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">httproot.com/article/13</span><span class=\"invisible\">3</span><span class=\"ellipsis\"></span></a></u></li><li><u><a href=\"https://link.zhihu.com/?target=https%3A//gitee.com/nwaycn/freeswitch\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">gitee.com/nwaycn/freesw</span><span class=\"invisible\">itch</span><span class=\"ellipsis\"></span></a></u></li><li><u><a href=\"https://link.zhihu.com/?target=https%3A//files.freeswitch.org/freeswitch-releases/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">files.freeswitch.org/fr</span><span class=\"invisible\">eeswitch-releases/</span><span class=\"ellipsis\"></span></a></u></li></ul>", 
            "topic": [
                {
                    "tag": "FreeSWITCH", 
                    "tagLink": "https://api.zhihu.com/topics/19892529"
                }, 
                {
                    "tag": "呼叫中心", 
                    "tagLink": "https://api.zhihu.com/topics/19575587"
                }, 
                {
                    "tag": "SIP", 
                    "tagLink": "https://api.zhihu.com/topics/19617345"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72065578", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 6, 
            "title": "「JVM系列」一步步解析java执行内幕", 
            "content": "<p>对于任何一门语言，要想达到精通的水平，研究它的执行原理(或者叫底层机制)不失为一种良好的方式。在本篇文章中，将重点研究java源代码的执行原理，即从程<br/>序员编写JAVA源代码，到最终形成产品，在整个过程中，都经历了什么？每一步又是怎么执行的？执行原理又是什么？.....<br/>当然，本篇文章的粒度可能稍微侧重于宏观方面，更细粒度的技术分析，需要在接下来的该系列文章中与大家分享....<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c2d04e3ae8a4036eea28a831e72cb761_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"691\" class=\"origin_image zh-lightbox-thumb\" width=\"637\" data-original=\"https://pic2.zhimg.com/v2-c2d04e3ae8a4036eea28a831e72cb761_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;637&#39; height=&#39;691&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"691\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"637\" data-original=\"https://pic2.zhimg.com/v2-c2d04e3ae8a4036eea28a831e72cb761_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c2d04e3ae8a4036eea28a831e72cb761_b.jpg\"/></figure><p><br/>一 编写java源程序<br/></p><hr/><p>java源文件:指存储java源码的文件；<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d923b26432e3fba4917d2ce57b1fd067_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"47\" data-rawheight=\"47\" class=\"content_image\" width=\"47\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;47&#39; height=&#39;47&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"47\" data-rawheight=\"47\" class=\"content_image lazy\" width=\"47\" data-actualsrc=\"https://pic4.zhimg.com/v2-d923b26432e3fba4917d2ce57b1fd067_b.jpg\"/></figure><p><br/>当前比较主流的JAVA IDE?<br/>（1）Intellij IDEA（首推荐）<br/>（2）Eclipse<br/>先来看看如下代码：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-51e409b11aa51c150090697429a953ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"20\" data-rawheight=\"20\" class=\"content_image\" width=\"20\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;20&#39; height=&#39;20&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"20\" data-rawheight=\"20\" class=\"content_image lazy\" width=\"20\" data-actualsrc=\"https://pic2.zhimg.com/v2-51e409b11aa51c150090697429a953ed_b.jpg\"/></figure><p><br/>//MyTest被public修饰，故存储该java源码的文件名为MyTest<br/>public class MyTest {<br/>public static void main(String[] args){<br/>System.out.println(&#34;Test Java execute process.&#34;);<br/>}<br/>}<br/>//由于MyTest被public修饰了，故Class A不能用public修饰<br/>class A{}<br/>//由于MyTest被public修饰了，故Class B不能用public修饰<br/>class B{}<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-51e409b11aa51c150090697429a953ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"20\" data-rawheight=\"20\" class=\"content_image\" width=\"20\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;20&#39; height=&#39;20&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"20\" data-rawheight=\"20\" class=\"content_image lazy\" width=\"20\" data-actualsrc=\"https://pic2.zhimg.com/v2-51e409b11aa51c150090697429a953ed_b.jpg\"/></figure><p><br/>（1）java源文件名就是该源文件中public类的名称<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-85be5fbb33b44367c0409dfc9da69b25_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"818\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb\" width=\"818\" data-original=\"https://pic2.zhimg.com/v2-85be5fbb33b44367c0409dfc9da69b25_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;818&#39; height=&#39;224&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"818\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"818\" data-original=\"https://pic2.zhimg.com/v2-85be5fbb33b44367c0409dfc9da69b25_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-85be5fbb33b44367c0409dfc9da69b25_b.jpg\"/></figure><p><br/>（2）一个java源文件可以包含多个类，但只允许一个类为public<br/>二 编译java源代码<br/></p><hr/><p>当java源程序编码结束后，就需要编译器编译，安装好jdk后，我们打开jdk目录，有两个.exe文件，<br/>即javac.exe(编译源代码，即.java文件)和java.exe(执行字节码，即.class文件)<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5c6448b193f6ed47fd192d333e4ffeda_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-5c6448b193f6ed47fd192d333e4ffeda_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-5c6448b193f6ed47fd192d333e4ffeda_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5c6448b193f6ed47fd192d333e4ffeda_b.jpg\"/></figure><p><br/>1.切换到MyTest.java文件夹<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-148388cc8b83d4a25804258290ed9088_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"202\" data-rawheight=\"50\" class=\"content_image\" width=\"202\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;202&#39; height=&#39;50&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"202\" data-rawheight=\"50\" class=\"content_image lazy\" width=\"202\" data-actualsrc=\"https://pic1.zhimg.com/v2-148388cc8b83d4a25804258290ed9088_b.jpg\"/></figure><p><br/>2.javac.exe编译MyTest.java<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7f13e551cd07281751ed55c79e342f1e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"247\" data-rawheight=\"25\" class=\"content_image\" width=\"247\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;247&#39; height=&#39;25&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"247\" data-rawheight=\"25\" class=\"content_image lazy\" width=\"247\" data-actualsrc=\"https://pic3.zhimg.com/v2-7f13e551cd07281751ed55c79e342f1e_b.jpg\"/></figure><p><br/>编译后，发现e:\\Blogs 目录多了以class为后缀的文件：A.class,B.class和MyTest.class<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e7c60f6507575a6823ede6e6f4e16c56_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"401\" data-rawheight=\"242\" class=\"content_image\" width=\"401\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;401&#39; height=&#39;242&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"401\" data-rawheight=\"242\" class=\"content_image lazy\" width=\"401\" data-actualsrc=\"https://pic3.zhimg.com/v2-e7c60f6507575a6823ede6e6f4e16c56_b.jpg\"/></figure><p><br/>Tip:当javac.exe编译java源代码时，java源代码有几个类，就会编译成一个对应的字节码文件(.class文件)，<br/>其中，字节码文件的文件名就是每个类的类名。需要注意的是，类即使不在源文件中定义，但被源文件引用，<br/>编译后，也会编程相应的字节码文件，如类A引用类C，但类C不定义在类A的源文件中，编译后，类C也被编<br/>译成对应的字节码文件C.class<br/>三 执行java源文件<br/></p><hr/><p>执行java源文件，用java.exe执行即可<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5e666635764204d9a004ab821059a39e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"213\" data-rawheight=\"44\" class=\"content_image\" width=\"213\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;213&#39; height=&#39;44&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"213\" data-rawheight=\"44\" class=\"content_image lazy\" width=\"213\" data-actualsrc=\"https://pic3.zhimg.com/v2-5e666635764204d9a004ab821059a39e_b.jpg\"/></figure><p><br/>到现在，java源程序基本执行结果，并正确打印我们期望的结果，那么，如上的步骤，我们可以总结如下：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8a88709358fd2011ca0687eac99c6385_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"869\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb\" width=\"869\" data-original=\"https://pic2.zhimg.com/v2-8a88709358fd2011ca0687eac99c6385_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;869&#39; height=&#39;126&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"869\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"869\" data-original=\"https://pic2.zhimg.com/v2-8a88709358fd2011ca0687eac99c6385_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8a88709358fd2011ca0687eac99c6385_b.jpg\"/></figure><p><br/>如上总结，已经抽象化了在JVM中的执行，接下来，我们将分析，字节码文件（.calss文件）如何在虚拟机中一步一执行的。<br/>四 JVM如何执行字节码文件<br/></p><hr/><p><b>（一） 装载字节码文件</b><br/>当.java源码被javac.exe编译器编译成.class字节码文件后，接下来的工作就交给JVM处理，JVM首先通过类加载器(ClassLoader)<br/>将class文件和相关Java API加载装入JVM，以供JVM后续处理。<br/>在该阶段中，涉及到如下一些基本概念和知识。<br/>1.JDK,JRE和JVM关系<br/>（1）JDK（Java Development Kit），Java开发工具包，主要用于开发，在JDK7前，JDK包括JRE<br/>（2）JRE（Java Runtime Environment），Java程序运行的核心环境，包括JVM和一些核心库<br/>（3）JVM（Java Virtual Machine），VM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟<br/>各种计算机功能来实现的，是JRE核心模块。<br/>2.JVM<br/>JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机<br/>虚拟机的主要任务是装载class文件并执行其中的字节码，不同的Java虚拟机中，执行引擎可能由不同的实现，大致有如下几种引擎：<br/></p><ul><li>一次性解释字节码引擎</li><li>即时编译引擎</li><li>自适应优化器</li></ul><p>关于虚拟机的实现方式，采用软件方式、硬件方式和软件硬件结合方式，这个要根据具体厂商而定。<br/>3.什么是ClassLoader<br/>虚拟机的主要任务是装载class文件并执行其中的字节码，而class文件是由虚拟机的类加载器(ClassLoader)完成的，在一个Java虚拟机，<br/>有可能存在多个类加载器。<br/>任何java运用程序，可能会使用两种类加载器，即启动类加载器(bootstrap)和用户自定义类加载器。<br/>启动类加载器是Java虚拟机唯一实现的一部分，它又可分为原始类装载器，系统类装载器或默认类装载器，它的主要作用是从操作系统的<br/>磁盘装载相应的类，如Java API类等。<br/>用户自定义装载类，按照用户自定义的方式来装载类。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-65a679c2025447143cf7d25bda58274c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-65a679c2025447143cf7d25bda58274c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;437&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-65a679c2025447143cf7d25bda58274c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-65a679c2025447143cf7d25bda58274c_b.jpg\"/></figure><p><br/><b>（二）将字节码文件存储在JVM内存区</b><br/>当JAVA虚拟机运行一个程序时，它需要内存来存储许多东西，如字节码，从已装载的class文件中得到的其他信息，程序创建的对象，传递给<br/>方法的参数，返回值，局部变量以及运算的中间结果等，这些相关信息被组织到“运行时数据区”。<br/>根据厂商的不同，在Java虚拟机中，运行时数据区也有所不同，有些运行时数据区由线程共享，有些只能由某个特定线程共享。运行时数据区<br/>大致可分几个区：方法区，堆区，栈区，PC寄存器区和本地方法栈区。<br/>在该阶段中，涉及到如下基本概念和知识。<br/>1.方法区<br/>方法区用来存储解析被加载的class文件的相关信息。当虚拟装载一个class文件后，它会从这个class文件包含的二进制数据中解析类型信息，然后将<br/>该相关信息存储到方法区中。<br/>2.堆<br/>堆是用来存储相关引用类型的，如new对象。当程序运行时，虚拟机会把所有该程序在运行时创建的对象都放到堆中。<br/>3.PC寄存器<br/>PC寄存器主要用来存储线程。当新创建一个线程时，该线程都将得到一个自己的PC寄存器(程序计数器)以及一个java栈。<br/>Java虚拟机没有寄存器，其指令集使用Java栈来存储中间数据。<br/>4.栈区<br/>栈区主要用来存储值类型的，如基本数据类型，需要注意的时，String为引用类型，是存在堆中的。Java栈是由许多栈<br/>帧组成的，一个栈帧包含一个Java方法调用的状态，当线程调用一个方法时，虚拟机压入一个新的栈帧到该线程的Java栈中<br/>，当该方法返回时，这个栈帧从Java栈中弹出。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e582e9027d0a45064be9390faf223f93_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"633\" data-original=\"https://pic4.zhimg.com/v2-e582e9027d0a45064be9390faf223f93_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;633&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"633\" data-original=\"https://pic4.zhimg.com/v2-e582e9027d0a45064be9390faf223f93_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e582e9027d0a45064be9390faf223f93_b.jpg\"/></figure><p><br/><b>（三）执行引擎与运行时数据区交互</b><br/>运行时数据区为执行引擎提供了执行环境和相关数据，执行引擎通过与运行时数据区交互，从而获取<br/>执行时需要的相关信息，存储执行的中间结果等<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-51fc2a2f3e4fcdcc9060ed71d778187b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb\" width=\"633\" data-original=\"https://pic4.zhimg.com/v2-51fc2a2f3e4fcdcc9060ed71d778187b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;633&#39; height=&#39;553&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"633\" data-original=\"https://pic4.zhimg.com/v2-51fc2a2f3e4fcdcc9060ed71d778187b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-51fc2a2f3e4fcdcc9060ed71d778187b_b.jpg\"/></figure><p><br/><b>（四）执行引擎与本地方法接口</b><br/>当要执行本地方法时，执行引擎将调用本地方法接口来获取相关OS本地方法，需要注意的是，本地方法与操作系统强耦合的。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fed06de558568cb868917adaa53195ac_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"634\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb\" width=\"634\" data-original=\"https://pic1.zhimg.com/v2-fed06de558568cb868917adaa53195ac_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;634&#39; height=&#39;554&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"634\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"634\" data-original=\"https://pic1.zhimg.com/v2-fed06de558568cb868917adaa53195ac_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fed06de558568cb868917adaa53195ac_b.jpg\"/></figure><p><br/><b>（五）JVM在具体操作系统上执行</b><br/>JVM通过调用本地接口来获取本地方法，从而实现在具体的平台上执行，如在Linux系统上执行，在Window系统上<br/>执行和在Unix系统上执行。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-311beda9d3426c951d85f40341874788_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb\" width=\"637\" data-original=\"https://pic1.zhimg.com/v2-311beda9d3426c951d85f40341874788_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;637&#39; height=&#39;692&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"637\" data-original=\"https://pic1.zhimg.com/v2-311beda9d3426c951d85f40341874788_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-311beda9d3426c951d85f40341874788_b.jpg\"/></figure><p><br/>五 参考文献<br/></p><hr/><p>【01】深入Java虚拟机（原书第2版）(美)Bill Venners 著<br/>【02】Core Java Volume I - Fundamententals(10th Edition) (美) Cay S.Horstmann<br/>【03】Core Java Volume I - Advanced Features(10th Edition) (美) Cay S.Horstmann<br/>写在最后：<br/>码字不易看到最后了，那就点个关注呗，只收藏不点关注的都是在耍流氓！<br/>关注并私信我“架构”，免费送一些Java架构资料，先到先得！</p><p><br/> </p>", 
            "topic": [
                {
                    "tag": "Java 虚拟机（JVM）", 
                    "tagLink": "https://api.zhihu.com/topics/19566470"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "橘子和秋天", 
                    "userLink": "https://www.zhihu.com/people/34796c8a80b2a7c8e16a81358fdf4c24", 
                    "content": "舒服", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72087221", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 2, 
            "title": "听听京东架构师浅谈，MySQL binlog 主从同步", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cb671239a825344dafedca3651de4a53_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"351\" data-rawheight=\"288\" class=\"content_image\" width=\"351\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;351&#39; height=&#39;288&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"351\" data-rawheight=\"288\" class=\"content_image lazy\" width=\"351\" data-actualsrc=\"https://pic4.zhimg.com/v2-cb671239a825344dafedca3651de4a53_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>一、binlog 的基础知识</h2><p>1，binlog 的概念</p><p>Server 层的日志系统（归档日志），binlog 中跟踪对其数据库的所有更改操作。是逻辑日志，以追加日志的形式记录。</p><p>2，binLog 的三种格式</p><p><b>1）statement</b></p><p>记录 SQL 语句的原文。风险点：如果主/从用到的索引不同，操作语句带 limit 时，处理的可能是不同行的记录数据。</p><p><b>2）row</b></p><p>仅记录某条记录的数据修改细节，不关系上下文。缺点：占用空间，同时写 binlog 很耗费 I/O 资源，影响执行速度。</p><p><b>3）mixed</b></p><p>一般语句使用 statement 格式保存，如果使用了一些函数，statement 格式无法完成主从复制的操作，采用 row 格式。MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能就用 row 格式，否则就用 statement 格式。</p><h2>二、主从同步的基础流程</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-df53841ecf547064764d98794366dffa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"348\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-df53841ecf547064764d98794366dffa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;348&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"348\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-df53841ecf547064764d98794366dffa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-df53841ecf547064764d98794366dffa_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>1、主库接收到更新命令，执行更新操作，生成 binlog</li><li>2、从库在主从之间建立长连接</li><li>3、主库 dump_thread 从本地读取 binlog 传送刚给从库</li><li>4、从库从主库获取到 binlog 后存储到本地，成为 relay log（中继日志）</li><li>5、sql_thread 线程读取 relay log 解析、执行命令更新数据</li></ul><p>每个主/从连接都有三个线程，具有多个从库的主库会为每个连接创建一个 dump thread，每个从库都有自己的 I/O thread 和 sql thread。从库使用两个线程将读取主库 binlog 日志和执行更新操作分离开，通过 relay log 机制，使 binlog 的读取和执行互不影响。如果从库某段时间没有运行，重启后从库可以快速读取主库的 binlog 日志；如果从库在 sql thread 执行完 binlog 日志前停止，在重启后也可以在本地的 relay log 中读取到命令继续执行。</p><ul><li>dump thread：在从库与主库创建连接后，主库创建 dump thread 日志将 binlog 发送到从库，如果该线程追上了主控，它将进入休眠状态知道主库发送信号通知其有新的事件产生时才会被唤醒</li><li>I/O thread：在从库执行 start slave 语句时，创建 I/O thread，该线程连接到主库，将 binlog 日志记录到中继日志</li><li>sql thread：读取 relay log 执行命令实现从库数据的更新</li></ul><h2>三、主从延迟问题</h2><p><b>1，什么是主从延迟</b></p><p>主从延迟指的是同一个事务在从库执行完成的时间和主库执行完成的时间直接的差值。</p><p>延迟时间 = 主库执行完事务写入 binlog 的时刻 - 从库执行完事务的时刻</p><p><b>2，主从延迟的来源</b></p><p>1）在一些部署条件下，备库所在机器的性能比主库的机器差</p><p>2）备库读压力大</p><p>3）大事务场景</p><p>4）从库的并行复制能力</p><p>3，从库并行复制策略</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a57fc5e6daade3c4a74d24d9a0f2e752_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-a57fc5e6daade3c4a74d24d9a0f2e752_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;267&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-a57fc5e6daade3c4a74d24d9a0f2e752_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a57fc5e6daade3c4a74d24d9a0f2e752_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>核心思想：</b></p><p>由 sql_thread 作为分配者（coordinator）的角色，负责读取中转日志（relay log）和分发事务，由 worker 线程来执行命令更新数据。</p><p><b>原则：</b></p><ul><li>不能造成更新覆盖，要求更新同一行的两个事务必须分发到同一个 worker 中</li><li>同一个事务不能被拆开，必须放到同一个 worker 中</li></ul><p><b>现有的一些并行复制策略：</b></p><p>1）5.6 按库并行复制</p><p>coordinator 将 relay log 按照 DB 的维度分发给不同的 worker。</p><ul><li>优点：构造映射关系快，只需要库名；不要求 binlog 格式</li><li>缺点：如果主库上只有一个 DB，那这个策略就没有效果了，或者存在热点 DB，也起不到并行的效果</li></ul><p>2）MariaDB 组提交优化</p><p>组提交（group commit）主要有以下特性：</p><ul><li>一组提交的事务有一个相同的 commit_id 直接写到 bin log 里；能够在同一组里提交的事务一定不会修改同一行；主库上可以并行执行的事务备库上也一定可以并行执行。MariaDB 利用组提交的特性对并行复制进行优化，将相同 commit_id 的事务分发到多个 worker 执行，一组全部执行完毕后再执行下一批。</li><li>缺点：在从库上执行时，要等一组事务执行完成后再开始执行下一批事务，这样系统的吞吐量就不够，此外，如果出现大事务，那么这段时间就只用一个 worker 线程在工作，造成资源的浪费。</li></ul><p>3）5.7.22 增加 binlog-transaction-dependency-tracking 参数控制并行复制策略</p><p>commit_order ，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</p><p>原则：</p><ul><li>同时出入 prepare 状态的事务在从库执行时是可以并行的；</li><li>处于 prepare 状态的事务与处于 commit 状态的事务之间在备库执行时也是可以并行的。</li></ul><p>可以通过 binlog_group_commit_sync_delay 和 bin_log_group_commit_sync_no_delay_count 拉长 binlog write 和 fsync 之间的时间，制造更多同时处于 prepare 阶段的事务。</p><p>writeset，对于事务涉及更新的每一行计算出这行的 hash 值组成集合 writeset，如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</p><p>wrtieset_session，是在 writeset 的基础上多了个约束，在主库上同一个线程先后执行的两个事务，在备库执行的时候要保证先后顺序。</p><h2>四、延伸</h2><p><b>1，从库连接到主库请求 binlog 日志</b></p><p>从库主动从主库请求 binlog 的副本，而不是主库主动将数据推送到从库。也就是说每个从库都是独立独立地与主库进行连接，每个从库只能通过向主库请求来接收 binlog 的副本，因此从库能够以自己的速度读取和更新数据库的副本，并且可以随意启动和停止赋值过程，而不会影响到主库或者其他从库的状态。</p><p><b>2，relay log（中继日志）</b></p><p>中继日志与 binlog 相同，由一组包含描述数据库更改的文件和一个包含所有已使用的中继日志文件名称的索引文件组成。在5.6以前，日志是存在 relay <a href=\"https://link.zhihu.com/?target=http%3A//log.info\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">log.info</span><span class=\"invisible\"></span></a> 文件中的，在5.6以后可以使用 --relay log info repository=table 启动 slave，将此日志写入 mysql.slave_relay_log_info 表，而不是文件。</p><p><b>3，复制通道概念</b></p><p>MySQL5.7.6 引入了复制通道的概念，表示事务从主库流到从库的路径。MySQL 服务器会在启动时自动创建一个默认通道，其名称为空字符串（””）。此通道始终存在；用户无法创建或销毁它。如果没有创建其他通道（具有非空名称），则复制语句仅作用于默认通道，以便所有来自旧从属服务器的复制语句都按预期工作。应用于复制通道的语句只能在至少有一个命名通道时使用。</p><p>在多源复制中，从库打开多个通道，每个主通道一个，每个通道都有自己的中继日志和 sql thread，一旦复制通道的接收器（I/O 线程）接收到事务，他们将被添加到通道的中继日志文件中并传递到 sql thread，使通道能够独立工作。</p><p><b>4，主库和从库用不同引擎</b></p><p>对于复制过程来说，主库表和从库表是否使用不同的引擎类型并不重要，实际上，在复制过程中不会复制存储引擎系统变量，用户可以针对不同的复制方案为从库设置不同的存储引擎。</p>", 
            "topic": [
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72231742", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 0, 
            "title": "「面试」如果把线程当作一个人来对待，问题都瞬间明白了你懂的", 
            "content": "<p><i>多线程的问题都曾经困扰过每个开发人员，今天将从全新视角来解说，希望读者都能明白。</i></p><p>强烈建议去运行下文章中的示例代码，自己体会下。</p><p>要是喜欢的点点关注，点点赞。</p><p>对Java技术，架构技术感兴趣的朋友，欢迎加QQ群728821520，一起学习，相互讨论。</p><p><b>问题究竟出在哪里？</b></p><p>一个线程执行，固然是安全的，但是有时太慢了，怎么办？</p><p>老祖宗告诉我们，“一方有难，八方支援”，那不就是多叫几个线程来帮忙嘛，好办呀，多new几个不就行了，又不要钱。这样能管用吗？继续往下看。</p><p>俗话说，“在家靠父母，出门靠朋友”。有了朋友的帮助，就会事半功倍。是这样的吗？</p><p>不一定，如果朋友“不靠谱”，结果竟是在“添乱”。于是就演变为，“不怕神一样的对手，就怕猪一样的队友”。可见“人多力量大”纵然是对的，但也要配合好才能成事。</p><p>人和人是朋友，那线程和线程也是“朋友”，如果多线程之间不能配合好的话，最终也会变为“猪一样的队友”。事实证明，这也不是一件易事。且容我慢慢道来。</p><p>开发是一门技术，管理是一门艺术。也许你正想带着兄弟们大干一场，可偏偏就有人要辞职。或者你付出了这么多，但别人从来没有感动过。为什么会这样呢？</p><p>因为你面对的是人。每个人都是独立的个体，有思想，有灵魂，有情感，有三观。能够接受外界的“输入”，经过“处理”后，能够产生“输出”。</p><p>说白了就是会自主的分析问题，并做出决定。这叫什么呢？答案就是，主观能动性。</p><p>拥有主观能动性的物体（比如人），你需要和它协商着或配合着来共同完成一件事情，而不能“强迫”它去做什么，因为这样往往不会有好的结果。</p><p>费了这么多口舌，就是希望把问题尽量的简单化。终于可以回到程序了，那线程的情况是不是类似的呢？答案是肯定的。</p><p>一个线程准备好后，经过CPU的调度，就可以自主的运行了。此时它俨然成了一个独立的个体，且具有主观能动性。</p><p>这本是一件好事，但却也有不好的一面，那就是你对它的“掌控”能力变弱了，颇有一种“将在外，君命有所不受”的感觉。</p><p>可能你不同意这种看法，说我可以“强迫”它停止运行，调用Thread类的stop()方法来直接把它“掐死”，不好意思，该方法已废弃。</p><p>因为线程可能在运行一些“关键”代码（比如转账），此刻不能被终止。Thread类还有一些其它的方法也都废弃了，大抵原因其实都差不多。</p><p>讲了这么多，相信你已经明白了，简单总结一下：</p><p><b>事情起因</b>：线程可以独立自主的运行，可以认为它具有主观能动性。</p><p><b>造成结果</b>：对它的掌控能力变弱了，而且又不能直接把它“干掉”。</p><p><b>解决方案</b>：凡事商量着来，互相配合着把事情完成。</p><p><b>作者观点</b>：其实就是把线程当作人来对待。</p><p><b>小试牛刀一下</b></p><p>一旦把线程当成人，就来到了人类的世界，这我们太熟悉了，所以很多问题都会变得非常简单明了。一起来看看吧。</p><p>场景一，<b>停止</b></p><p>“大胖，大胖，12点了，该去吃饭了，别写了”</p><p>“好的，好的，稍等片刻，把这几行代码写完就走”</p><p>要点：把停止的信号传达给别人，别人处理完手头的事情就自己主动停止了。</p><blockquote>static void stopByFlag() {<br/>ARunnable ar = new ARunnable();<br/>new Thread(ar).start();<br/>ar.tellToStop();<br/>}<br/>static class ARunnable implements Runnable {<br/>volatile boolean stop;<br/>void tellToStop() {<br/>stop = true;<br/>}<br/>@Override<br/>public void run() {<br/>println(&#34;进入不可停止区域 1。。。&#34;);<br/>doingLongTime(5);<br/>println(&#34;退出不可停止区域 1。。。&#34;);<br/>println(&#34;检测标志stop = %s&#34;, String.valueOf(stop));<br/>if (stop) {<br/>println(&#34;停止执行&#34;);<br/>return;<br/>}<br/>println(&#34;进入不可停止区域 2。。。&#34;);<br/>doingLongTime(5);<br/>println(&#34;退出不可停止区域 2。。。&#34;);<br/>}<br/>}</blockquote><p>解说：线程在预设的地点检测flag，来决定是否停止。</p><p>场景二，<b>暂停/恢复</b></p><p>“大胖，大胖，先别发请求了，对方服务器快挂了”</p><p>“好的，好的，等这个执行完就不发了”</p><p>过了一会</p><p>“大胖，大胖，可以重新发请求了”</p><p>“好的，好的”</p><p>要点：把暂停的信号传达给别人，别人处理完手头的事情就自己主动暂停了。但是恢复是无法自主进行的，只能由操作系统来恢复线程的执行。</p><blockquote>static void pauseByFlag() {<br/>BRunnable br = new BRunnable();<br/>new Thread(br).start();<br/>br.tellToPause();<br/>sleep(8);<br/>br.tellToResume();<br/>}<br/>static class BRunnable implements Runnable {<br/>volatile boolean pause;<br/>void tellToPause() {<br/>pause = true;<br/>}<br/>void tellToResume() {<br/>synchronized (this) {<br/>this.notify();<br/>}<br/>}<br/>@Override<br/>public void run() {<br/>println(&#34;进入不可暂停区域 1。。。&#34;);<br/>doingLongTime(5);<br/>println(&#34;退出不可暂停区域 1。。。&#34;);<br/>println(&#34;检测标志pause = %s&#34;, String.valueOf(pause));<br/>if (pause) {<br/>println(&#34;暂停执行&#34;);<br/>try {<br/>synchronized (this) {<br/>this.wait();<br/>}<br/>} catch (InterruptedException e) {<br/>e.printStackTrace();<br/>}<br/>println(&#34;恢复执行&#34;);<br/>}<br/>println(&#34;进入不可暂停区域 2。。。&#34;);<br/>doingLongTime(5);<br/>println(&#34;退出不可暂停区域 2。。。&#34;);<br/>}<br/>}</blockquote><p>解说：还是在预设的地点检测flag。然后就是wait/notify配合使用。</p><p>场景三，<b>插队</b></p><p>“大胖，大胖，让我站到你前面，不想排队了”</p><p>“好吧”</p><p>要点：别人插队到你前面，必须等他完事后才轮到你。</p><blockquote>static void jqByJoin() {<br/>CRunnable cr = new CRunnable();<br/>Thread t = new Thread(cr);<br/>t.start();<br/>sleep(1);<br/>try {<br/>t.join();<br/>} catch (InterruptedException e) {<br/>e.printStackTrace();<br/>}<br/>println(&#34;终于轮到我了&#34;);<br/>}<br/>static class CRunnable implements Runnable {<br/>@Override<br/>public void run() {<br/>println(&#34;进入不可暂停区域 1。。。&#34;);<br/>doingLongTime(5);<br/>println(&#34;退出不可暂停区域 1。。。&#34;);<br/>}<br/>}</blockquote><p>解说：join方法可以让某个线程插到自己前面，等它执行完，自己才会继续执行。</p><p>场景四，<b>叫醒</b></p><p>“大胖，大胖，醒醒，醒醒，看谁来了”</p><p>“谁啊，我去”</p><p>要点：要把别人从睡梦中叫醒，一定要采取稍微暴力一点的手段。</p><blockquote>static void stopByInterrupt() {<br/>DRunnable dr = new DRunnable();<br/>Thread t = new Thread(dr);<br/>t.start();<br/>sleep(2);<br/>t.interrupt();<br/>}<br/>static class DRunnable implements Runnable {<br/>@Override<br/>public void run() {<br/>println(&#34;进入暂停。。。&#34;);<br/>try {<br/>sleep2(5);<br/>} catch (InterruptedException e) {<br/>println(&#34;收到中断异常。。。&#34;);<br/>println(&#34;做一些相关处理。。。&#34;);<br/>}<br/>println(&#34;继续执行或选择退出。。。&#34;);<br/>}<br/>}</blockquote><p>解说：线程在sleep或wait时，是处于无法交互的状态的，此时只能使用interrupt方法中断它，线程会被激活并收到中断异常。</p><p><b>常见的协作配合</b></p><p>上面那些场景，其实都是对一个线程的操作，下面来看多线程间的一些配合。</p><p>事件一，<b>考试</b></p><p>假设今天考试，20个学生，1个监考老师。规定学生可以提前交卷，即把卷子留下，直接走人就行了。</p><p>但老师必须等到所有的学生都走后，才可以收卷子，然后装订打包。</p><p>如果把学生和老师都看作线程，就是1个线程和20个线程的配合问题，即等20个线程都结束了，这1个线程才开始。</p><p>比如20个线程分别在计算数据，等它们都结束后得到20个中间结果，最后这1个线程再进行后续汇总、处理等。</p><blockquote>static final int COUNT = 20;<br/>static CountDownLatch cdl = new CountDownLatch(COUNT);<br/>public static void main(String[] args) throws Exception {<br/>new Thread(new Teacher(cdl)).start();<br/>sleep(1);<br/>for (int i = 0; i &lt; COUNT; i++) {<br/>new Thread(new Student(i, cdl)).start();<br/>}<br/>synchronized (ThreadCo1.class) {<br/>ThreadCo1.class.wait();<br/>}<br/>}<br/>static class Teacher implements Runnable {<br/>CountDownLatch cdl;<br/>Teacher(CountDownLatch cdl) {<br/>this.cdl = cdl;<br/>}<br/>@Override<br/>public void run() {<br/>println(&#34;老师发卷子。。。&#34;);<br/>try {<br/>cdl.await();<br/>} catch (InterruptedException e) {<br/>e.printStackTrace();<br/>}<br/>println(&#34;老师收卷子。。。&#34;);<br/>}<br/>}<br/>static class Student implements Runnable {<br/>CountDownLatch cdl;<br/>int num;<br/>Student(int num, CountDownLatch cdl) {<br/>this.num = num;<br/>this.cdl = cdl;<br/>}<br/>@Override<br/>public void run() {<br/>println(&#34;学生(%d)写卷子。。。&#34;, num);<br/>doingLongTime();<br/>println(&#34;学生(%d)交卷子。。。&#34;, num);<br/>cdl.countDown();<br/>}<br/>}</blockquote><p>解说：每完成一个线程，计数器减1，当减到0时，被阻塞的线程自动执行。</p><p>事件二，<b>旅游</b></p><p>最近景色宜人，公司组织去登山，大伙都来到了山脚下，登山过程自由进行。</p><p>但为了在特定的地点拍集体照，规定1个小时后在半山腰集合，谁最后到的，要给大家表演一个节目。</p><p>然后继续登山，在2个小时后，在山顶集合拍照，还是谁最后到的表演节目。</p><p>接着开始下山了，在2个小时后在山脚下集合，点名回家，最后到的照例表演节目。</p><blockquote>static final int COUNT = 5;<br/>static CyclicBarrier cb = new CyclicBarrier(COUNT, new Singer());<br/>public static void main(String[] args) throws Exception {<br/>for (int i = 0; i &lt; COUNT; i++) {<br/>new Thread(new Staff(i, cb)).start();<br/>}<br/>synchronized (ThreadCo2.class) {<br/>ThreadCo2.class.wait();<br/>}<br/>}<br/>static class Singer implements Runnable {<br/>@Override<br/>public void run() {<br/>println(&#34;为大家唱歌。。。&#34;);<br/>}<br/>}<br/>static class Staff implements Runnable {<br/>CyclicBarrier cb;<br/>int num；<br/>Staff(int num, CyclicBarrier cb) {<br/>this.num = num;<br/>this.cb = cb;<br/>}<br/>@Override<br/>public void run() {<br/>println(&#34;员工(%d)出发。。。&#34;, num);<br/>doingLongTime();<br/>println(&#34;员工(%d)到达地点一。。。&#34;, num);<br/>try {<br/>cb.await();<br/>} catch (Exception e) {<br/>e.printStackTrace();<br/>}<br/>println(&#34;员工(%d)再出发。。。&#34;, num);<br/>doingLongTime();<br/>println(&#34;员工(%d)到达地点二。。。&#34;, num);<br/>try {<br/>cb.await();<br/>} catch (Exception e) {<br/>e.printStackTrace();<br/>}<br/>println(&#34;员工(%d)再出发。。。&#34;, num);<br/>doingLongTime();<br/>println(&#34;员工(%d)到达地点三。。。&#34;, num);<br/>try {<br/>cb.await();<br/>} catch (Exception e) {<br/>e.printStackTrace();<br/>}<br/>println(&#34;员工(%d)结束。。。&#34;, num);<br/>}<br/>}</blockquote><p>解说：某个线程到达预设点时就在此等待，等所有的线程都到达时，大家再一起向下个预设点出发。如此循环反复下去。</p><p>事件三，<b>劳动</b></p><p>大胖和小白去了创业公司，公司为了节约开支，没有请专门的保洁人员。让员工自己扫地和擦桌。</p><p>大胖觉得擦桌轻松，就让小白去扫地。可小白觉得扫地太累，也想擦桌。</p><p>为了公平起见，于是决定，每人先干一半，然后交换工具，再接着干对方剩下的那一个半。</p><blockquote>static Exchanger&lt;Tool&gt; ex = new Exchanger&lt;&gt;();<br/>public static void main(String[] args) throws Exception {<br/>new Thread(new Staff(&#34;大胖&#34;, new Tool(&#34;笤帚&#34;, &#34;扫地&#34;), ex)).start();<br/>new Thread(new Staff(&#34;小白&#34;, new Tool(&#34;抹布&#34;, &#34;擦桌&#34;), ex)).start();<br/>synchronized (ThreadCo3.class) {<br/>ThreadCo3.class.wait();<br/>}<br/>}<br/>static class Staff implements Runnable {<br/>String name;<br/>Tool tool;<br/>Exchanger&lt;Tool&gt; ex;<br/>Staff(String name, Tool tool, Exchanger&lt;Tool&gt; ex) {<br/>this.name = name;<br/>this.tool = tool;<br/>this.ex = ex;<br/>}<br/>@Override<br/>public void run() {<br/>println(&#34;%s拿的工具是[%s]，他开始[%s]。。。&#34;, name, tool.name, tool.work);<br/>doingLongTime();<br/>println(&#34;%s开始交换工具。。。&#34;, name);<br/>try {<br/>tool = ex.exchange(tool);<br/>} catch (Exception e) {<br/>e.printStackTrace();<br/>}<br/>println(&#34;%s的工具变为[%s]，他开始[%s]。。。&#34;, name, tool.name, tool.work);<br/>}<br/>}<br/>static class Tool {<br/>String name;<br/>String work;<br/>Tool(String name, String work) {<br/>this.name = name;<br/>this.work = work;<br/>}<br/>}</blockquote><p>解说：两个线程在预设点交换变量，先到达的等待对方。</p><p>事件四，<b>魔性游戏</b></p><p>这是一个充满魔性的小游戏，由一个团队一起参加。所有人每隔5秒钟抽一次签，每个人有50%的概率留下来或被淘汰。</p><p>留下来的人下次抽签时同样有50%的概率被淘汰。被淘汰的人下次抽签时同样有50%的概率复活。</p><p>团队所有成员都被淘汰完，为挑战失败，团队所有成员都回到游戏中（除刚开始外），为挑战成功。</p><p>比如一开始10人参与游戏，第一轮抽签后，6人留下，4人淘汰。</p><p>第二轮抽签后，留下的6人中4人被淘汰，淘汰的4人中2人复活，那么目前是4人在游戏中，6人被淘汰。</p><p>一直如此继续下去，直到10人全部被淘汰，或全部回到游戏中。</p><p>可见，人数越多，全部被淘汰的概率越小，但全部回到游戏中的概率也越小。</p><p>反之，人数越少，全部回到游戏中的概率越大，但全部被淘汰的概率也越大。</p><p>是不是很有魔性啊。哈哈。</p><blockquote>static final int COUNT = 6;<br/>static Phaser ph = new Phaser() {<br/>protected boolean onAdvance(int phase, int registeredParties) {<br/>println2(&#34;第(%d)局，剩余[%d]人&#34;, phase, registeredParties);<br/>return registeredParties == 0 ||<br/>(phase != 0 &amp;&amp; registeredParties == COUNT);<br/>};<br/>};<br/>public static void main(String[] args) throws Exception {<br/>new Thread(new Challenger(&#34;张三&#34;)).start();<br/>new Thread(new Challenger(&#34;李四&#34;)).start();<br/>new Thread(new Challenger(&#34;王五&#34;)).start();<br/>new Thread(new Challenger(&#34;赵六&#34;)).start();<br/>new Thread(new Challenger(&#34;大胖&#34;)).start();<br/>new Thread(new Challenger(&#34;小白&#34;)).start();<br/>synchronized (ThreadCo4.class) {<br/>ThreadCo4.class.wait();<br/>}<br/>}<br/>static class Challenger implements Runnable {<br/>String name;<br/>int state;<br/>Challenger(String name) {<br/>this.name = name;<br/>this.state = 0;<br/>}<br/>@Override<br/>public void run() {<br/>println(&#34;[%s]开始挑战。。。&#34;, name);<br/>ph.register();<br/>int phase = 0;<br/>int h;<br/>while (!ph.isTerminated() &amp;&amp; phase &lt; 100) {<br/>doingLongTime(5);<br/>if (state == 0) {<br/>if (Decide.goon()) {<br/>h = ph.arriveAndAwaitAdvance();<br/>if (h &lt; 0)<br/>println(&#34;No%d.[%s]继续，但已胜利。。。&#34;, phase, name);<br/>else<br/>println(&#34;No%d.[%s]继续at(%d)。。。&#34;, phase, name, h);<br/>} else {<br/>state = -1;<br/>h = ph.arriveAndDeregister();<br/>println(&#34;No%d.[%s]退出at(%d)。。。&#34;, phase, name, h);<br/>}<br/>} else {<br/>if (Decide.revive()) {<br/>state = 0;<br/>h = ph.register();<br/>if (h &lt; 0)<br/>println(&#34;No%d.[%s]复活，但已失败。。。&#34;, phase, name);<br/>else<br/>println(&#34;No%d.[%s]复活at(%d)。。。&#34;, phase, name, h);<br/>} else {<br/>println(&#34;No%d.[%s]没有复活。。。&#34;, phase, name);<br/>}<br/>}<br/>phase++;<br/>}<br/>if (state == 0) {<br/>ph.arriveAndDeregister();<br/>}<br/>println(&#34;[%s]结束。。。&#34;, name);<br/>}<br/>}<br/>static class Decide {<br/>static boolean goon() {<br/>return random(9) &gt; 4;<br/>}<br/>static boolean revive() {<br/>return random(9) &lt; 5;<br/>}<br/>}</blockquote><p>解说：某个线程到达预设点后，可以选择等待同伴或自己退出，等大家都到达后，再一起向下一个预设点出发，随时都可以有新的线程加入，退出的也可以再次加入。</p><p><b>生产与销售的问题</b></p><p>在现实中，工厂生产出来的产品会先放到仓库存储，销售人员签了单子后，会从仓库把产品发给客户。</p><p>如果生产的过快，仓库里产品越堆越多，直到把仓库堆满，那就必须停止生产，因为没地方放了。</p><p>此时只能让销售人员赶紧出去签单子，把产品发出去，仓库就有了空间，可以恢复生产了。</p><p>如果销售的过快，仓库里产品越来越少，直到把仓库清空，那就必须停止销售，因为没产品了。</p><p>此时只能让生产人员赶紧生产产品，把产品放到仓库里，仓库里就有了产品，可以恢复销售了。</p><p>可能会有人问，为什么不让生产和销售直接挂钩呢，把仓库这个环节去掉？</p><p>这样会造成两种不好的情况：</p><p>一是突然来了很多单子，生产人员累成死Dog也生产不出来。</p><p>二是很长时间没有单子，生产人员闲成废Dog也无事可做。</p><p>用稍微“专业”点的术语就是此时的生产和销售是一种强耦合的关系，销售的波动对生产影响太大。</p><p>仓库就是一个缓冲区，能有效的吸收波动，很大程度上减少波动的传递，起到一种解耦作用，由强耦合变成一种松散耦合。</p><p>这其实就对应计算机里经典的生产者和消费者问题。</p><p><b>经典的生产者和消费者</b></p><p>一到多个线程充当生产者，生产元素。一到多个线程充当消费者，消费元素。</p><p>在两者之间插入一个队列（Queue）充当缓冲区，建立起生产者和消费者的松散耦合。</p><p>正常情况下，即生产元素的速度和消费元素的速度差不多时，生产者和消费者其实是不需要去关注对方的。</p><p>生产者可以一直生产，因为队列里总是有空间。消费者可以一直消费，因为队列里总是有元素。即达到一个动态的平衡。</p><p>但在特殊情况下，比如生产元素的速度很快，队列里没有了空间，此时生产者必须自我“ba工”，开始“睡大觉”。</p><p>一旦消费者消费了元素之后，队列里才会有空间，生产者才可以重启生产，所以，消费者在消费完元素后有义务去叫醒生产者复工。</p><p>更准确的说法应该是，只有在生产者“睡大觉”时，消费者消费完元素后才需要去叫醒生产者。否则，其实可以不用叫醒，因为人家本来就没睡。</p><p>反之，如果消费元素的速度很快，队列里没有了元素，只需把上述情况颠倒过来即可。</p><p>但这样的话就会引入一个新的问题，就是要能够准备的判断出对方有没有在睡大觉，为此就必须定义一个状态变量，在自己即将开始睡大觉时，自己设置下这个变量。</p><p>对方通过检测这个变量，来决定是否进行叫醒操作。当自己被叫醒后，首先要做的就是清除一下这个变量，表明我已经醒来复工了。</p><p>这样就需要多维护一个变量和多了一部分判断逻辑。可能有些人会觉得可以通过判断队列的“空”或“满”（即队列中的元素数目）来决定是否进行叫醒操作。</p><p>在高并发下，可能刚刚判断队列不为空，瞬间之后队列可能已经变为空的了，这样会导致逻辑出错。线程可能永远无法被叫醒。</p><p>因此，综合所有，生产者每生产一个元素后，都会通知消费者，“现在有元素的，你可以消费”。</p><p>同样，消费者每消费一个元素后，也会通知生产者，“现在有空间的，你可以生产”。</p><p>很明显，这些通知很多时候（即对方没有睡大觉时）是没有真正意义的，不过无所谓，只要忽略它们就行了。</p><p>就是“宁可错杀一千，也不放过一个”。首先要保证是正确的，然后才有资格去BB别的。</p><blockquote>public static void main(String[] args) {<br/>Queue queue = new Queue();<br/>new Thread(new Producer(queue)).start();<br/>new Thread(new Producer(queue)).start();<br/>new Thread(new Consumer(queue)).start();<br/>}<br/>static class Producer implements Runnable {<br/>Queue queue;<br/>Producer(Queue queue) {<br/>this.queue = queue;<br/>}<br/>@Override<br/>public void run() {<br/>try {<br/>for (int i = 0; i &lt; 10000; i++) {<br/>doingLongTime();<br/>queue.putEle(random(10000));<br/>}<br/>} catch (Exception e) {<br/>e.printStackTrace();<br/>}<br/>}<br/>}<br/>static class Consumer implements Runnable {<br/>Queue queue;<br/>Consumer(Queue queue) {<br/>this.queue = queue;<br/>}<br/>@Override<br/>public void run() {<br/>try {<br/>for (int i = 0; i &lt; 10000; i++) {<br/>doingLongTime();<br/>queue.takeEle();<br/>}<br/>} catch (Exception e) {<br/>e.printStackTrace();<br/>}<br/>}<br/>}<br/>static class Queue {<br/>Lock lock = new ReentrantLock();<br/>Condition prodCond = lock.newCondition();<br/>Condition consCond = lock.newCondition();<br/>final int CAPACITY = 10;<br/>Object[] container = new Object[CAPACITY];<br/>int count = 0;<br/>int putIndex = 0;<br/>int takeIndex = 0;<br/>public void putEle(Object ele) throws InterruptedException {<br/>try {<br/>lock.lock();<br/>while (count == CAPACITY) {<br/>println(&#34;队列已满：%d，生产者开始睡大觉。。。&#34;, count);<br/>prodCond.await();<br/>}<br/>container[putIndex] = ele;<br/>println(&#34;生产元素：%d&#34;, ele);<br/>putIndex++;<br/>if (putIndex &gt;= CAPACITY) {<br/>putIndex = 0;<br/>}<br/>count++;<br/>println(&#34;通知消费者去消费。。。&#34;);<br/>consCond.signalAll();<br/>} finally {<br/>lock.unlock();<br/>}<br/>}<br/>public Object takeEle() throws InterruptedException {<br/>try {<br/>lock.lock();<br/>while (count == 0) {<br/>println(&#34;队列已空：%d，消费者开始睡大觉。。。&#34;, count);<br/>consCond.await();<br/>}<br/>Object ele = container[takeIndex];<br/>println(&#34;消费元素：%d&#34;, ele);<br/>takeIndex++;<br/>if (takeIndex &gt;= CAPACITY) {<br/>takeIndex = 0;<br/>}<br/>count--;<br/>println(&#34;通知生产者去生产。。。&#34;);<br/>prodCond.signalAll();<br/>return ele;<br/>} finally {<br/>lock.unlock();<br/>}<br/>}<br/>}</blockquote><p>解说：其实就是对await/signalAll的应用，几乎面试必问。</p>", 
            "topic": [
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71892251", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 1, 
            "title": "Java 程序员必备的 10 个开源工具！你有几个？", 
            "content": "<ul><li>1. JIRA</li><li>2. Git</li><li>3. Jenkins</li><li>4. Selenium</li><li>5. Groovy</li><li>6. Spock</li><li>7. Maven</li><li>8. Gradle</li><li>9. Docker</li><li>10. Linux</li></ul><hr/><p>本文主要介绍Java程序员应该在2018年学习的一些基本和高级工具。如果你是一位经验丰富的Java开发人员，拥有5到10年的经验，你可能对这些工具很熟悉，但如果不是，现在就是是开始学习这些工具的好时机。</p><p>Java世界中存在许多工具，从Eclipse，NetBeans和IntelliJ IDEA等著名的IDE开始到Java开发人员应该知道的JVM分析和监视工具，如JConsole，VisualVM，Eclipse Memory Analyzer等。</p><p>尽管如此，在本文中，我将重点介绍适用于各种Java开发人员的通用工具，例如核心Java 开发人员和Web开发人员。</p><h2><b>1. JIRA</b></h2><p>Atlassian的JIRA是当前敏捷开发领域最重要的工具之一。它用于错误跟踪，问题跟踪和项目管理。如果你遵循敏捷开发方法，例如Sprint和Scrum，那么你必须了解JIRA。它允许您创建Spring循环并跟踪软件开发的进度。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-30a2dbcbc777af491a724e31c175eec7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"366\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-30a2dbcbc777af491a724e31c175eec7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;366&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"366\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-30a2dbcbc777af491a724e31c175eec7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-30a2dbcbc777af491a724e31c175eec7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>JIRA 是目前比较流行的基于Java架构的管理系统，由于Atlassian公 司对很多开源项目实行免费提供缺陷跟踪服务，因此在开源领域，其认知度比其他的产品要高得多，而且易用性也好一些。</p><h2><b>2. Git</b></h2><p>Git是Java程序员的另一个必备工具，它是一个免费的开源分布式版本控制系统，旨在快速高效地处理从很小到非常大的项目版本管理。Git易于学习，占用空间小，具有超强的性能。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-882a5ea687b14664456d7c0a4a82f98c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"280\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-882a5ea687b14664456d7c0a4a82f98c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;280&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"280\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-882a5ea687b14664456d7c0a4a82f98c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-882a5ea687b14664456d7c0a4a82f98c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是发现已经在很多其他自由软件项目中也使用了 Git。</p><h2><b>3. Jenkins</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3f3e25c90498ff6dd295ac5f3384cc4a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"292\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;292&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"292\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic3.zhimg.com/v2-3f3e25c90498ff6dd295ac5f3384cc4a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Jenkins是一个用Java编写的开源自动化服务器。它有助于自动化软件开发，例如编译项目，运行单元测试，集成测试，生成文档以及在本地和远程存储库上载工件。主要用于：</p><p>● 持续、自动地构建/测试软件项目，如CruiseControl与DamageControl。</p><p>● 监控一些定时执行的任务。</p><p>它是在项目中持续集成中最流行的工具之一。如果你还没有开始使用Jenkins，那就从现在开始吧。</p><h2><b>4. Selenium</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-85610b4ab4f0a627eec0f601c6e5a7e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"362\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-85610b4ab4f0a627eec0f601c6e5a7e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;362&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"362\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-85610b4ab4f0a627eec0f601c6e5a7e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-85610b4ab4f0a627eec0f601c6e5a7e4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Selenium是Web应用程序最好的软件测试框架之一。它提供了一种用于创作测试的回放工具，而无需学习测试脚本语言。Java开发人员可以使用Selenium来测试他们的HTML和JSP文件。</p><p>它还为Web浏览器自动化提供了各种工具和库。Selenium 现在存在2个版本，一个叫 selenium-core, 一个叫selenium-rc 。</p><h2><b>5. Groovy</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7d91f6c647ae4d6b20a2cc281b4b1739_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-7d91f6c647ae4d6b20a2cc281b4b1739_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-7d91f6c647ae4d6b20a2cc281b4b1739_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7d91f6c647ae4d6b20a2cc281b4b1739_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Groovy 是一种基于 JVM 的敏捷开发语言，它结合了 Python、Ruby 和 Smalltalk 的许多强大的特性。你可以使用它编写构建脚本，测试脚本，甚至可以使用像Gradle和Spock这样的流行框架。</p><h2><b>6. Spock</b></h2><p>Spock 是适合 Java 和 Groovy 应用程序的一个测试框架。由于其JUnit运行程序，Spock与大多数IDE，构建工具和持续集成服务器兼容。如果你想提高你的单元测试技能，那么多花点时间在学习Spock上总是没错的。</p><h2><b>7. Maven</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e9e719d9168fb7f56d226cc3a99a8459_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"364\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-e9e719d9168fb7f56d226cc3a99a8459_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;364&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"364\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-e9e719d9168fb7f56d226cc3a99a8459_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e9e719d9168fb7f56d226cc3a99a8459_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果你是一位经验丰富的Java开发人员，那么你一定非常了解Maven了，Apache Maven是一个构建和项目管理工具，基于项目对象模型（POM）的概念，Maven可用于管理项目的生成、报告和文档记录。</p><p>Maven的另一个有用特性是依赖关系管理，由于我们在Java项目中使用了大量第三方库，因此手动管理每个JAR及其依赖项可能非常麻烦，Maven通过自动为你下载正确的JAR来帮助你解决问题</p><h2><b>8. Gradle</b></h2><p>Gradle 是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化构建工具。它也是Android的默认构建工具。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-06af0af910e65c9a3d72be25516e762c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-06af0af910e65c9a3d72be25516e762c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;384&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-06af0af910e65c9a3d72be25516e762c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-06af0af910e65c9a3d72be25516e762c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>它引入了基于Groovy的特定于域的语言（DSL），而不是Apache Maven用于声明项目配置的XML，这样有利于配置项目依赖关系以及用户的项目自定义</p><p>为什么选择Gradle在Ant或Maven？因为它结合了其他构建工具的最佳特性，例如它具有Ant的灵活性和控制，Ivy的依赖管理，Maven的配置和插件的约定，以及可以在Ant上使用Groovy DSL。这使它成为Java项目的最佳构建工具。</p><h2><b>9. Docker</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cb351a2adaf8fc7e0163944787a01171_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-cb351a2adaf8fc7e0163944787a01171_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;355&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-cb351a2adaf8fc7e0163944787a01171_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cb351a2adaf8fc7e0163944787a01171_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销，可以很容易地在机器和数据中心中运行。最重要的是，他们不依赖于任何语言、框架或包装系统。</p><h2><b>10. Linux</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1303272ab0cdf3fb7290bd82d7bac3bb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"253\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;253&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"253\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic4.zhimg.com/v2-1303272ab0cdf3fb7290bd82d7bac3bb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>初学Linux最好从Linux命令行基础知识开始，Linux是一种自由和开放源码的类Unix操作系统，在你的职业生涯中起到重要的作用，每一个Java开发者都应该学Linux。</p><p>写在最后：</p><p>码字不易看到最后了，那就点个关注呗，只收藏不点关注的都是在耍流氓！</p><p>关注并私信我“架构”，免费送一些Java架构资料，先到先得！</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71776087", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 8, 
            "title": "资深架构师带你详细了解，Spring之IoC容器", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-eebe92aa2f1c3cf56267a2451c36ee94_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"252\" data-rawheight=\"150\" class=\"content_image\" width=\"252\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;252&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"252\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"252\" data-actualsrc=\"https://pic1.zhimg.com/v2-eebe92aa2f1c3cf56267a2451c36ee94_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>一、 IoC概述</b></h2><p>IoC（Inverse of Control，控制反转）是Spring容器的内核，AOP、声明式事务等功能在此基础上开花结构。不过IoC确实包括很多内涵，涉及代码解耦、设计模式、代码优化等问题的考量。</p><p>先来讲下如下场景：</p><p>《墨攻》中有个场景，刘德华饰演的墨者革离来到梁国城下，梁国守卫问道：“来者何人？”刘德华回答：“墨者革离”。</p><p>有如下几种代码实现方式：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-893d4aabcb20a46bdc8607510ee1767a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"814\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb\" width=\"814\" data-original=\"https://pic3.zhimg.com/v2-893d4aabcb20a46bdc8607510ee1767a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;814&#39; height=&#39;212&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"814\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"814\" data-original=\"https://pic3.zhimg.com/v2-893d4aabcb20a46bdc8607510ee1767a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-893d4aabcb20a46bdc8607510ee1767a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8125f27a5540edda9fa4b645f54fcbca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"823\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"823\" data-original=\"https://pic3.zhimg.com/v2-8125f27a5540edda9fa4b645f54fcbca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;823&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"823\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"823\" data-original=\"https://pic3.zhimg.com/v2-8125f27a5540edda9fa4b645f54fcbca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8125f27a5540edda9fa4b645f54fcbca_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>其实可以这么理解：饰演革离人物角色的，有多种选择，不一定是刘德华，这个控制权掌握在导演手里，所以最终的图示关系就是如下图：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-eb937487674e265be5166f994fe20b73_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb\" width=\"582\" data-original=\"https://pic4.zhimg.com/v2-eb937487674e265be5166f994fe20b73_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;582&#39; height=&#39;363&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"582\" data-original=\"https://pic4.zhimg.com/v2-eb937487674e265be5166f994fe20b73_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-eb937487674e265be5166f994fe20b73_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>那到底是什么东西的“控制”被“反转”了呢？对应到前面的例子，“控制”是指选择GeLi角色扮演者的控制权；“反转”是指这种控制权从《墨攻》剧本中移除，转交到导演受众。对于软件来说，即某一接口具体实现类的选择控制权从调用类中移除，转交到第三方决定，即由Spring容器借由Bean配置来进行控制。</p><p>控制反转还是比较晦涩难懂，那么软件界的泰斗级人物Martin Fowler提出了DI(Dependency Injection，依赖注入)的概念来代替IoC。</p><p><b>1.1 IoC的类型</b></p><p>1. 构造函数注入</p><p>2. 属性注入</p><p>3. 接口注入</p><p><b>1.2 通过容器完成依赖关系的注入</b></p><p>所谓媒体“海选”和第三方代理机构，在程序领域就是一个第三方的容器，他帮助完成类的初始化与装配工作，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出来，专注于更有意义的业务逻辑开发工作。这无疑是一件令人向往的事情。Spring就是这样的一个容器，它通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入工作。</p><h2><b>二、 相关Java基础知识</b></h2><p>Java语言允许通过程序化的方式间接对Class进行操作。Class文件由类装载器装载后，在JVM中奖形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息，如构造函数、属性和方法等。Java允许用户借由这个与Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。</p><p><b>2.1 类装载器 ClassLoader</b></p><p>1. 类装载器的工作机制</p><p>类装载器把一个类装入JVM中，需要经过一下步骤：</p><p>（1）装载：查找和导入Class文件</p><p>（2）链接：执行校验、准备和解析步骤，其中解析步骤是可以选择的。</p><p>1. 校验：检查载入Class文件数据的正确性。</p><p>2. 准备：给类的静态变量分配存储空间。</p><p>3. 解析：将符号引用转换成直接引用。</p><p>（3）初始化：对类的静态变量、静态代码块执行初始化工作。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5d1ba433081480cc8e332e71e4b50074_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-5d1ba433081480cc8e332e71e4b50074_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-5d1ba433081480cc8e332e71e4b50074_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5d1ba433081480cc8e332e71e4b50074_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2.2 Java反射机制</b></p><p>Java的反射体系保证了可以通过程序化的方式访问目标类中的所有的元素，对于private或protexted成员变量和方法，只要JVM的安全机制允许，也可以通过反射进行调用。</p><h2><b>三、 资源抽象接口</b></h2><p>JDK所提供的访问资源的类（如 java.net.URL、FIle等）并不能很好的满足各种底层资源的访问需求，比如缺少从类路径或者Web容器上下文获取资源的操作类，鉴于此，Spring设计了一个Resource接口，它为应用提供了更强的底层资源访问能力。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9ece7482af9f1504b6afc6990df6fce2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"230\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-9ece7482af9f1504b6afc6990df6fce2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;230&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"230\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-9ece7482af9f1504b6afc6990df6fce2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9ece7482af9f1504b6afc6990df6fce2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-94f63af03865b6355b6c5f4809acb325_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"715\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb\" width=\"715\" data-original=\"https://pic2.zhimg.com/v2-94f63af03865b6355b6c5f4809acb325_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;715&#39; height=&#39;134&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"715\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"715\" data-original=\"https://pic2.zhimg.com/v2-94f63af03865b6355b6c5f4809acb325_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-94f63af03865b6355b6c5f4809acb325_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>四、 BeanFactory 和 ApplicationContext</b></h2><p>Spring 通过一个配置文件描述Bean及Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。Spirng的IoC容器在完成这些底层工作的基础上，还提供了Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务。</p><p>我们一般称BeanFactory为IoC容器，而称ApplicationContext为应用上下文。但有时为了行文方便，我们也将ApplicationContext称为Spring容器。</p><p>BeanFactory是Spring框架的基础设施，面向Spring本身；ApplicaitonContext面向使用Spring框架的开发者，几乎所有的应用场合都可以使用ApplicationContext而非底层的BeanFactory。</p><p><b>4.1</b>. 初始化BeanFactory</p><p>1) 对于单实例的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean()获取Bean时，将直接从IoC容器的缓存中获取Bean实例。</p><p>2) 在Spring中，DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例Bean的缓存器，它是一个用HashMap实现的缓存器，单实例的Bean以beanName为键保存在这个HashMap中。</p><p>3) 在初始化BeanFactory时，必须提供一种日志框架</p><p><b>4.2 ApplicationContext介绍</b></p><p>如果说BeanFactory是Spring的“心脏”，那么ApplicationContext就是完整的“身躯”了。</p><p>1. ApplicationContext类体系结构，它是一个接口，代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\"> public interface ApplicationContext extends ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver {\nString getId();\nString getDisplayName();\nlong getStartupDate();\nApplicationContext getParent();\nAutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>1）ApplicationEventPublisher: 让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件。</p><p>2）MessageSource: 为应用提供i18n国际化消息访问的功能</p><p>3）ResourcePatternResolver： 所有ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能，可以通过带前缀的Ant风格的资源文件路径装载Spring的配置文件。</p><p>4）LifeCycle： 该接口提供了start()和stop()两个方法，主要用于控制异步处理过程。</p><p><b>初始化ApplicationContext的几种方式：</b></p><p>1）如果配置文件放置在类路径下，则可以优先考虑使用ClassPathXmlApplicationContext实现类</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e4a54732a24c9bd1a279b5b3176ca4a3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"685\" data-rawheight=\"43\" class=\"origin_image zh-lightbox-thumb\" width=\"685\" data-original=\"https://pic4.zhimg.com/v2-e4a54732a24c9bd1a279b5b3176ca4a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;685&#39; height=&#39;43&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"685\" data-rawheight=\"43\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"685\" data-original=\"https://pic4.zhimg.com/v2-e4a54732a24c9bd1a279b5b3176ca4a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e4a54732a24c9bd1a279b5b3176ca4a3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>2）如果配置文件放置在文件系统的路径下，则可以优先考虑使用FileSystemXml</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-329392419f7ad86dd6c51af6c3c83132_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"689\" data-rawheight=\"45\" class=\"origin_image zh-lightbox-thumb\" width=\"689\" data-original=\"https://pic3.zhimg.com/v2-329392419f7ad86dd6c51af6c3c83132_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;689&#39; height=&#39;45&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"689\" data-rawheight=\"45\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"689\" data-original=\"https://pic3.zhimg.com/v2-329392419f7ad86dd6c51af6c3c83132_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-329392419f7ad86dd6c51af6c3c83132_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>3）基于注解的配置方式如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f44578ba07036f854103f04ff9c88b19_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"326\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f44578ba07036f854103f04ff9c88b19_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;326&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"326\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f44578ba07036f854103f04ff9c88b19_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f44578ba07036f854103f04ff9c88b19_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3807b983c986829e8d889f84bc4497e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-3807b983c986829e8d889f84bc4497e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;322&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-3807b983c986829e8d889f84bc4497e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3807b983c986829e8d889f84bc4497e4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>4）基于Groovy DSL来配置Bean</p><p><b>2. WebApplicationContext类体系结构</b></p><p>在非Web应用的环境下，Bean只有singletom和prototype两种作用域。WebApplicationContext为Bean添加了三个新的作用域：request、session和global session.</p><p>ConfigurableWebApplicationContext扩展了WebApplicationContext，它允许通过配置的方式实例化WebApplicationContext，同时定义了两个重要的方法。</p><p>setServletContext（ServletContext context）:为Spring设置Web应用上下文，以便二者整合。</p><p>setConfigLocations(String[] configLocation): 设置Spring配置文件地址。</p><p><b>3. WebApplicationContext初始化</b></p><p>1）使用配置文件</p><p>2）使用注解的方式</p><p>3）使用Groovy DSL的方式</p><p><b>4.3 父子容器</b></p><p>通过HierarchicalBeanFactory接口，Spring的IoC容器可以建立父子层级关联的容器体系，子容器可以访问如容器中的Bean，但是父容器不能访问自容器中的Bean。</p><p>例如：Spring使用父子容器实现很多功能，比如在Spring MVC中，展现层Bean位于一个子容器中，而业务层和持久层Bean位于如容器中。这样，展现层Bean就可以引用业务层和持久层Bean，而业务层和持久层Bean则看不到展现层Bean。</p><h2><b>五、BeanFactory中的Bean的生命周期</b></h2><p>Spring为Bean提供了细致周全的生命周期过程，通过实现特定的接口或通过&lt;bean&gt;属性设置，都可以对Bean的生命周期过程施加影响。Bean的生命周期不但和其实现的接口相关，还与Bean的作用范围有关。为了让Bean绑定在Spring框架上，我们推荐使用配置方式而非接口方式进行Bean生命周期的控制。</p>", 
            "topic": [
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }, 
                {
                    "tag": "IOC", 
                    "tagLink": "https://api.zhihu.com/topics/19628542"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71261956", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 7, 
            "title": "面试我还是想说一下：面试中常问的List去重问题，你都答对了吗？", 
            "content": "<p>面试中经常被问到的list如何去重，用来考察你对list数据结构，以及相关方法的掌握，体现你的java基础学的是否牢固。</p><p>我们大家都知道，set集合的特点就是没有重复的元素。如果集合中的数据类型是基本数据类型，可以直接将list集合转换成set，就会自动去除重复的元素，这个就相对比较简单。</p><p>如下示例：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a546984421ee5b19d89b31480b779b80_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-a546984421ee5b19d89b31480b779b80_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;370&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-a546984421ee5b19d89b31480b779b80_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a546984421ee5b19d89b31480b779b80_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>输出结果为：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-24c9d52eb3cd9f0e4c39f91fca498f0a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-24c9d52eb3cd9f0e4c39f91fca498f0a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-24c9d52eb3cd9f0e4c39f91fca498f0a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-24c9d52eb3cd9f0e4c39f91fca498f0a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以看到去重成功了。</p><p>在面试中被问到list去重问题，大部分回答都会是list和set互转，利用set自动去除重复属性的方法去重，但是这样的回答并不会得分。</p><p>当list集合中存储的类型是对象类型的时候，我们就不能简单的只把list集合转换成set集合。</p><p>我们定义一个对象类：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2e055d594f9b0563a8743c497d91d8c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-2e055d594f9b0563a8743c497d91d8c4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;632&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-2e055d594f9b0563a8743c497d91d8c4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2e055d594f9b0563a8743c497d91d8c4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们使用上面的set去重的方法去重：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4179da215963a92f7995824a2200f581_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-4179da215963a92f7995824a2200f581_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;236&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-4179da215963a92f7995824a2200f581_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4179da215963a92f7995824a2200f581_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>运行后输出的结果为：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d6049959a93676ac6919a44a804dbfae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1354\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb\" width=\"1354\" data-original=\"https://pic3.zhimg.com/v2-d6049959a93676ac6919a44a804dbfae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1354&#39; height=&#39;154&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1354\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1354\" data-original=\"https://pic3.zhimg.com/v2-d6049959a93676ac6919a44a804dbfae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d6049959a93676ac6919a44a804dbfae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以看到第二个张三和最后一个张三，信息都一样，却没有被去重。</p><p>当list集合中存储的是对象时，我们需要在对象的实体类中去重写equals()方法和hashCode()方法，如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6e55e7eec522074c626eec02dd84f1ad_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"604\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-6e55e7eec522074c626eec02dd84f1ad_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;604&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"604\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-6e55e7eec522074c626eec02dd84f1ad_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6e55e7eec522074c626eec02dd84f1ad_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6e6b86e229057774f44e51b1c3515f84_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"280\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-6e6b86e229057774f44e51b1c3515f84_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;280&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"280\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-6e6b86e229057774f44e51b1c3515f84_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6e6b86e229057774f44e51b1c3515f84_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>此时运行上面的test方法，去重就成功了。</p><p>最后，我们拿出String中的equals()方法和hashCode()方法源码来加深认识：</p><p><b>equals()</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f853d200af8ca043be040e2bd6498540_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f853d200af8ca043be040e2bd6498540_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;375&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f853d200af8ca043be040e2bd6498540_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f853d200af8ca043be040e2bd6498540_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>比较两个对象时，首先先去判断两个对象是否具有相同的地址，如果是同一个对象的引用，则直接放回true；如果地址不一样，则证明不是引用同一个对象，接下来就是挨个去比较两个字符串对象的内容是否一致，完全相等返回true，否则false。</p><p><b>hashCode()</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-057e6dcf6d35938c748e404eae595435_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-057e6dcf6d35938c748e404eae595435_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;236&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-057e6dcf6d35938c748e404eae595435_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-057e6dcf6d35938c748e404eae595435_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>hashCode()官方定义：</b></p><p>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。</p><p><b>hashCode 的常规协定是：</b></p><p>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</p><p>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。</p><p>以下情况不是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。</p><p>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）</p><p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p><p>当然，List去重的方法很多，可以用for循环或者使用java8新特性stream等等，欢迎讨论，</p><p>写在最后：</p><p>码字不易看到最后了，那就点个关注呗，只收藏不点关注的都是在耍流氓！</p><p>关注并私信我“架构”，免费送一些Java架构资料，先到先得！</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "面试技巧", 
                    "tagLink": "https://api.zhihu.com/topics/19591490"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71352834", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 9, 
            "title": "阿里面试官：HashMap数据结构之道", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-250bfeba5cd54d69a85550796891c79c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"200\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic1.zhimg.com/v2-250bfeba5cd54d69a85550796891c79c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>问题1：HashMap的数据结构是什么样的？</b></p><p>同学1：嗯...数组+链表</p><p>同学2：数组+链表...</p><p>同学3：数组+链表...</p><p>同学4：数组+链表+红黑树...</p><p>同学n：.....</p><p>为什么答案会有两种？难道大家学习的HashMap有两个版本？我突然想起马克思哲学里面的一句话，真理是相对的，不是绝对的，变化才是唯一的真理。</p><p>不错，对于Java这种语言排行榜经常排于榜首的高级语言，变化也是它的生存之道。Java在推出新版本的同时，不断的完善重要class的数据结构，提升它的性能，稳固它的安全性。HashMap就是其中之一。</p><p><b>HashMap在Java1.7里使用的是数组+链表的数据结构，在Java1.8里使用的是数组+链表+红黑树。</b></p><p><b>问题2：HashMap为什么在1.8的版本，对它的数据结构进行了修改？</b></p><p>同学1：嗯，有bug（标准的程序员思维）</p><p>同学2：有漏洞...(有黑客思维的同学)</p><p>同学3：没事，无聊，寂寞，想搞事情...(有创业者思维的同学)</p><p>同学4：提升性能...(有架构师思维的同学)</p><p>......</p><p>Java在维护它全球顶级语言，近趋于霸主地位的时候，当然要从细节入手，从源码入手，完善它的性能，修复它的漏洞。Java如此，其他语言也是如此。</p><p><b>问题3：HashMap在1.7和1.8，性能上究竟有了多大的提升，我们上代码，看看速度如何？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-39599eefbbbc005c4e7a5403bcd712b7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"276\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-39599eefbbbc005c4e7a5403bcd712b7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;276&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"276\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-39599eefbbbc005c4e7a5403bcd712b7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-39599eefbbbc005c4e7a5403bcd712b7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>测试结果如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b70f0614cd0804cca461aab96f66b210_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"714\" data-rawheight=\"87\" class=\"origin_image zh-lightbox-thumb\" width=\"714\" data-original=\"https://pic1.zhimg.com/v2-b70f0614cd0804cca461aab96f66b210_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;714&#39; height=&#39;87&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"714\" data-rawheight=\"87\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"714\" data-original=\"https://pic1.zhimg.com/v2-b70f0614cd0804cca461aab96f66b210_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b70f0614cd0804cca461aab96f66b210_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以清楚的看见HashMap在1.8的版本，数据量非常大（10万条）的时候，查询的总时间明显比较低，也就是说HashMap在1.8的版本查找速度很快，插入或者是删除相对较慢。那么为什么会这样？</p><p><b>思考题：为什么HashMap在1.8的版本，查找速度有了大幅提升？</b></p><p>接下来，我将逐一带大家进行全面剖析HashMap的数据结构。</p><h2><b>一. 数据结构不同</b></h2><p>1. HashMap在1.7的版本数据结构如下：</p><p>数组+链表（单向链表）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1256ad9ba71653902df4fd37b981aa72_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"322\" data-rawheight=\"243\" class=\"content_image\" width=\"322\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;322&#39; height=&#39;243&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"322\" data-rawheight=\"243\" class=\"content_image lazy\" width=\"322\" data-actualsrc=\"https://pic3.zhimg.com/v2-1256ad9ba71653902df4fd37b981aa72_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.1 从数据结构我们来分析HashMap的put过程</b></p><p>插入元素的数据结构如下代码：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4571205c5f9e3d2055118bbeb2af678a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb\" width=\"552\" data-original=\"https://pic3.zhimg.com/v2-4571205c5f9e3d2055118bbeb2af678a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;552&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"552\" data-original=\"https://pic3.zhimg.com/v2-4571205c5f9e3d2055118bbeb2af678a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4571205c5f9e3d2055118bbeb2af678a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>第一步：计算key对应数组的index（索引），是通过hashcode &amp; （length-1），就是hashcode值和（数组长度-1）的与运算。</p><p>第二步：将插入的元素放入数组index的位置，将next指针指向之前的元素。</p><p>图解过程：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bee6e03c16a57c89a03db88e593dd12a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"328\" data-rawheight=\"256\" class=\"content_image\" width=\"328\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;328&#39; height=&#39;256&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"328\" data-rawheight=\"256\" class=\"content_image lazy\" width=\"328\" data-actualsrc=\"https://pic3.zhimg.com/v2-bee6e03c16a57c89a03db88e593dd12a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.2 HashMap在1.7的版本的get过程</b></p><p>第一步：计算key对应数组的index（索引）,找到数组的头结点</p><p>第二步：从头结点逐个向下遍历，直到key的hash值与节点的hash值碰撞相等，然后取出value值。</p><p>思考一下：get过程的时间复杂度应该是O(n)，试着想一下，如果我们在插入的过程中对节点进行一些变换，例如将单向链表变成二叉树，或者是平衡二叉树，是不是下次在查找的过程，就能减少遍历的时间复杂度呢？</p><p>下面，我们引入HashMap在Java1.8里的数据结构</p><p><b>2. HashMap在1.8的版本数据结构如下：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ebc72df41b824e9ae5f9c0dc241308e7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"352\" data-rawheight=\"245\" class=\"content_image\" width=\"352\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;352&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"352\" data-rawheight=\"245\" class=\"content_image lazy\" width=\"352\" data-actualsrc=\"https://pic4.zhimg.com/v2-ebc72df41b824e9ae5f9c0dc241308e7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从源码中分析：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cd36d3e47e31de26bd3a7db7f9c3dc4d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"130\" class=\"origin_image zh-lightbox-thumb\" width=\"557\" data-original=\"https://pic2.zhimg.com/v2-cd36d3e47e31de26bd3a7db7f9c3dc4d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;557&#39; height=&#39;130&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"130\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"557\" data-original=\"https://pic2.zhimg.com/v2-cd36d3e47e31de26bd3a7db7f9c3dc4d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cd36d3e47e31de26bd3a7db7f9c3dc4d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们来翻译这句话：</p><p>HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞结点较少时，采用链表存储，当较大时（&gt;8个），采用红黑树（特点是查询时间是O（logn））存储（有一个阀值控制，大于阀值(8个)，将链表存储转换成红黑树存储。</p><p>可能此时，对于数据结构，你会有知识断层，那么没关系，我来为你一一介绍这些数据结构。</p><p>1. 数组，带有索引的容器，固定长度(ArrayList中数据结构，自动扩容)</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b9e0e8829387b8f63538bce8d6ed548d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic2.zhimg.com/v2-b9e0e8829387b8f63538bce8d6ed548d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;89&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic2.zhimg.com/v2-b9e0e8829387b8f63538bce8d6ed548d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b9e0e8829387b8f63538bce8d6ed548d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>2. 双向链表，如下图（LinkedList）</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ee9202fe0fbf8a1220c5962e11cf7671_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"506\" data-rawheight=\"105\" class=\"origin_image zh-lightbox-thumb\" width=\"506\" data-original=\"https://pic2.zhimg.com/v2-ee9202fe0fbf8a1220c5962e11cf7671_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;506&#39; height=&#39;105&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"506\" data-rawheight=\"105\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"506\" data-original=\"https://pic2.zhimg.com/v2-ee9202fe0fbf8a1220c5962e11cf7671_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ee9202fe0fbf8a1220c5962e11cf7671_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>3. 单向链表</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3befbf1f550872db40049d7da333bf89_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"114\" class=\"origin_image zh-lightbox-thumb\" width=\"522\" data-original=\"https://pic2.zhimg.com/v2-3befbf1f550872db40049d7da333bf89_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;522&#39; height=&#39;114&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"114\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"522\" data-original=\"https://pic2.zhimg.com/v2-3befbf1f550872db40049d7da333bf89_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3befbf1f550872db40049d7da333bf89_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>4. 红黑树</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-69abd9f50918399bfbc9a83d1c6b32b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-69abd9f50918399bfbc9a83d1c6b32b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;293&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-69abd9f50918399bfbc9a83d1c6b32b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-69abd9f50918399bfbc9a83d1c6b32b2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>特点：</p><p>1）每个节点非红即黑</p><p>2）根节点是黑的;</p><p>3）每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p><p>4）如图所示，如果一个节点是红的，那么它的两儿子都是黑的;</p><p>5）对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p><p>6）每条路径都包含相同的黑节点;</p><p>2.1 此时，我们分析一下HashMap在1.8版本里面的put过程</p><p>插入元素包含如下</p><p>1）单向链表，代码如上面对应的1.7版本</p><p>2）红黑树</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fe6d4d1cf84dbe2fb7cb6fbb39f5bb55_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"140\" class=\"origin_image zh-lightbox-thumb\" width=\"541\" data-original=\"https://pic2.zhimg.com/v2-fe6d4d1cf84dbe2fb7cb6fbb39f5bb55_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;541&#39; height=&#39;140&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"140\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"541\" data-original=\"https://pic2.zhimg.com/v2-fe6d4d1cf84dbe2fb7cb6fbb39f5bb55_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fe6d4d1cf84dbe2fb7cb6fbb39f5bb55_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>分析put过程</b></p><p>第一步：计算key对应数组的index（索引），是通过hashcode &amp; （length-1），就是hashcode值和（数组长度-1）的与运算。</p><p>第二步：当前索引所对应的单向链表长度&lt;=8时，将插入的元素放入数组index的位置，将next指针指向之前的元素。反之，则把当前索引所有的元素转化为红黑树。</p><p>2.2 HashMap在1.8的版本的get过程</p><p>第一步：计算key对应数组的index（索引）,找到数组的头结点</p><p>第二步：如果头节点是单向链表结构，则从头结点逐个向下遍历，知道key的hash值与节点的hash值碰撞相等，然后取出value值。如果是红黑树，则用红黑树的遍历，碰撞hash值，然后取出value值。</p><h2>二. HashMap的扩容</h2><p>当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。</p><p>比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p><h2>总结：</h2><p>一. HashMap在Java1.7的版本是数组+单向链表存储，在1.8的版本是数组+单向链表+红黑树（如果当前索引对应的单向链表长度小于等于8，则用单向链表，如果大于8，则转化为红黑树）</p><p>二. HashMap在1.8的版本中，大数据量的查找，性能有了提升，是因为在put的过程中，增加了红黑树的转化，牺牲了put的时间和空间复杂度</p><p>三. HashMap的扩容过程，是个非常消耗性能的，扩容后的HashMap，需要重新计算之前数组各个索引对应的头结点（根节点）在新数组中对应的索引。</p>", 
            "topic": [
                {
                    "tag": "比如 HashMap", 
                    "tagLink": "https://api.zhihu.com/topics/20105559"
                }, 
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70698418", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 1, 
            "title": "我的面试心得与总结：BAT、网易、蘑菇街", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b6871f31a6f851815021d3b92fa8aec8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-b6871f31a6f851815021d3b92fa8aec8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;470&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-b6871f31a6f851815021d3b92fa8aec8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b6871f31a6f851815021d3b92fa8aec8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>先说一下LZ的基本情况，LZ是四川某985学校通信专业的研究生（非计算机），大学阶段也就学了C语言，根本没想过最后要成为码农。大四才开始学Java，研一下开始学Android，所以LZ觉得自己开始就是一个小白，慢慢成长起来的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>一、心态</b></p><p>心态很重要！</p><p>心态很重要！</p><p>心态很重要！</p><p>重要的事情说三遍，这一点我觉得是必须放到前面来讲。</p><p>找工作之前，有一点你必须清楚，就是找工作是一件看缘分的事情，不是你很牛逼，你就一定能进你想进的公司，都是有一个概率在那。如果你基础好，项目经验足，同时准备充分，那么你拿到offer的概率就会比较高；相反，如果你准备不充分，基础也不好，那么你拿到offer的概率就会比较低，但是你可以多投几家公司，这样拿到offer的几率就要大一点，因为你总有运气好的时候。所以，不要惧怕面试，刚开始失败了没什么的，多投多尝试，面多了你就自然能成面霸了。得失心也不要太重，最后每个人都会有offer的。</p><p>还有一个对待工作的心态，有些人可能觉得自己没有动力去找一个好工作。其实你需要明白一件事情，你读了十几二十年的书，为的是什么，最后不就是为了找到一个好工作么。现在到了关键时刻，你为何不努力一把呢，为什么不给自己一个好的未来呢，去一个自己不满意的公司工作，你甘心吗?</p><p>想清楚这一点，我相信大多数人都会有一股干劲了，因为LZ刚刚准备开始找实习的时候，BAT这种公司想都不敢想，觉得能进个二线公司就很不错了，后来发现自己不逼自己一把，你真不知道自己有多大能耐，所以请对找工作保持积极与十二分的热情，也请认真对待每一次笔试面试。</p><p><b>二、基础</b></p><p>基础这东西，各个公司都很看重，尤其是BAT这种大公司，他们看中人的潜力，他们舍得花精力去培养，所以基础是重中之重。之前很多人问我，项目经历少怎么办，那就去打牢基础，当你的基础好的发指的时候，你的其他东西都不重要了。</p><p>基础无外乎几部分：语言（C/C++或java），操作系统，TCP/IP，数据结构与算法，再加上你所熟悉的领域。这里面其实有很多东西，各大面试宝典都有列举。</p><p>在这只列举了Android客户端所需要的和我面试中所遇到的知识点，尽量做到全面，如果你掌握了以下知识点，去面android客户端应该得心应手。</p><p><b>J2SE基础</b></p><p>1. 九种基本数据类型的大小，以及他们的封装类。</p><p>2. Switch能否用string做参数？</p><p>3. equals与==的区别。</p><p>4. Object有哪些公用方法？</p><p>5. Java的四种引用，强弱软虚，用到的场景。</p><p>6. Hashcode的作用。</p><p>7. ArrayList、LinkedList、Vector的区别。</p><p>8. String、StringBuffer与StringBuilder的区别。</p><p>9. Map、Set、List、Queue、Stack的特点与用法。</p><p>10. HashMap和HashTable的区别。</p><p>11. HashMap和ConcurrentHashMap的区别，HashMap的底层源码。</p><p>12. TreeMap、HashMap、LindedHashMap的区别。</p><p>13. Collection包结构，与Collections的区别。</p><p>14. try catch finally，try里有return，finally还执行么？</p><p>15. Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。</p><p>16. Java面向对象的三个特征与含义。</p><p>17. Override和Overload的含义去区别。</p><p>18. Interface与abstract类的区别。</p><p>19. Static class 与non static class的区别。</p><p>20. java多态的实现原理。</p><p>21. 实现多线程的两种方法：Thread与Runable。</p><p>22. 线程同步的方法：sychronized、lock、reentrantLock等。</p><p>23. 锁的等级：方法锁、对象锁、类锁。</p><p>24. 写出生产者消费者模式。</p><p>25. ThreadLocal的设计理念与作用。</p><p>26. ThreadPool用法与优势。</p><p>27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</p><p>28. wait()和sleep()的区别。</p><p>29. foreach与正常for循环效率对比。</p><p>30. Java IO与NIO。</p><p>31. 反射的作用于原理。</p><p>32. 泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt;。</p><p>33. 解析XML的几种方式的原理与特点：DOM、SAX、PULL。</p><p>34. Java与C++对比。</p><p>35. Java1.7与1.8新特性。</p><p>36. 设计模式：单例、工厂、适配器、责任链、观察者等等。</p><p>37. JNI的使用。</p><p>Java里有很多很杂的东西，有时候需要你阅读源码，大多数可能书里面讲的不是太清楚，需要你在网上寻找答案。</p><p>推荐书籍：《java核心技术卷I》《Thinking in java》《java并发编程》《effictive java》《大话设计模式》</p><p><b>JVM</b></p><p>1. 内存模型以及分区，需要详细到每个区放什么。</p><p>2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。</p><p>3. 对象创建方法，对象的内存分配，对象的访问定位。</p><p>4. GC的两种判定方法：引用计数与引用链。</p><p>5. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</p><p>6. GC收集器有哪些？CMS收集器与G1收集器的特点。</p><p>7. Minor GC与Full GC分别在什么时候发生？</p><p>8. 几种常用的内存调试工具：jmap、jstack、jconsole。</p><p>9. 类加载的五个过程：加载、验证、准备、解析、初始化。</p><p>10. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。</p><p>11. 分派：静态分派与动态分派。</p><p>JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。</p><p>推荐书籍：《深入理解java虚拟机》</p><p><b>操作系统</b></p><p>1. 进程和线程的区别。</p><p>2. 死锁的必要条件，怎么处理死锁。</p><p>3. Window内存管理方式：段存储，页存储，段页存储。</p><p>4. 进程的几种状态。</p><p>5. IPC几种通信方式。</p><p>6. 什么是虚拟内存。</p><p>7. 虚拟地址、逻辑地址、线性地址、物理地址的区别。</p><p>因为是做android的这一块问得比较少一点，还有可能上我简历上没有写操作系统的原因。</p><p>推荐书籍：《深入理解现代操作系统》</p><p><b>TCP/IP</b></p><p>1. OSI与TCP/IP各层的结构与功能，都有哪些协议。</p><p>2. TCP与UDP的区别。</p><p>3. TCP报文结构。</p><p>4. TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。</p><p>5. TCP拥塞控制。</p><p>6. TCP滑动窗口与回退N针协议。</p><p>7. Http的报文结构。</p><p>8. Http的状态码含义。</p><p>9. Http request的几种类型。</p><p>10. Http1.1和Http1.0的区别</p><p>11. Http怎么处理长连接。</p><p>12. Cookie与Session的作用于原理。</p><p>13. 电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。</p><p>14. Ping的整个过程。ICMP报文是什么。</p><p>15. C/S模式下使用socket通信，几个关键函数。</p><p>16. IP地址分类。</p><p>17. 路由器与交换机区别。</p><p>网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。</p><p>推荐书籍：《TCP/IP协议族》</p><p><b>数据结构与算法</b></p><p>1. 链表与数组。</p><p>2. 队列和栈，出栈与入栈。</p><p>3. 链表的删除、插入、反向。</p><p>4. 字符串操作。</p><p>5. Hash表的hash函数，冲突解决方法有哪些。</p><p>6. 各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。</p><p>7. 快排的partition函数与归并的Merge函数。</p><p>8. 对冒泡与快排的改进。</p><p>9. 二分查找，与变种二分查找。</p><p>10. 二叉树、B+树、AVL树、红黑树、哈夫曼树。</p><p>11. 二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。</p><p>12. 图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。</p><p>13. KMP算法。</p><p>14. 排列组合问题。</p><p>15. 动态规划、贪心算法、分治算法。（一般不会问到）</p><p>16. 大数据处理：类似10亿条数据找出最大的1000个数………等等</p><p>算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看。</p><p>推荐书籍：《大话数据结构》《剑指offer》《编程之美》</p><p><b>Android</b></p><p>1. Activity与Fragment的生命周期。</p><p>2. Acitivty的四中启动模式与特点。</p><p>3. Activity缓存方法。</p><p>4. Service的生命周期，两种启动方法，有什么区别。</p><p>5. 怎么保证service不被杀死。</p><p>6. 广播的两种注册方法，有什么区别。</p><p>7. Intent的使用方法，可以传递哪些数据类型。</p><p>8. ContentProvider使用方法。</p><p>9. Thread、AsycTask、IntentService的使用场景与特点。</p><p>10. 五种布局： FrameLayout 、 LinearLayout 、 AbsoluteLayout 、 RelativeLayout 、TableLayout 各自特点及绘制效率对比。</p><p>11. Android的数据存储形式。</p><p>12. Sqlite的基本操作。</p><p>13. Android中的MVC模式。</p><p>14. Merge、ViewStub的作用。</p><p>15. Json有什么优劣势。</p><p>16. 动画有哪两类，各有什么特点？</p><p>17. Handler、Loop消息队列模型，各部分的作用。</p><p>18. 怎样退出终止App。</p><p>19. Asset目录与res目录的区别。</p><p>20. Android怎么加速启动Activity。</p><p>21. Android内存优化方法：ListView优化，及时关闭资源，图片缓存等等。</p><p>22. Android中弱引用与软引用的应用场景。</p><p>23. Bitmap的四中属性，与每种属性队形的大小。</p><p>24. View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。</p><p>25. Touch事件分发机制。</p><p>26. Android长连接，怎么处理心跳机制。</p><p>27. Zygote的启动过程。</p><p>28. Android IPC:Binder原理。</p><p>29. 你用过什么框架，是否看过源码，是否知道底层原理。</p><p>30. Android5.0、6.0新特性。</p><p>Android的话，多是一些项目中的实践，使用多了，自然就知道了，还有就是多逛逛一些名人的博客，书上能讲到的东西不多。另外android底层的东西，有时间的话可以多了解一下，加分项。</p><p>推荐书籍：《疯狂android讲义》《深入理解android》</p><p>其他综合性的书籍也需要阅读，推荐：《程序员面试笔试宝典》《程序员面试金典》。另外“牛客网www.newcoder.com”是个好地方，里面有各种面试笔试题，也有自己在线的OJ，强烈推荐，还有左程云老师的算法视屏课（已经出书了），反正我看了之后对我帮助很大（这不是植入广告）。</p><p><b>三、 项目</b></p><p>关于项目，这部分每个人的所做的项目不同，所以不能具体的讲。项目不再与好与不好，在于你会不会包装，有时候一个很low的项目也能包装成比较高大上的项目，多用一些专业名词，突出关键字，能使面试官能比较容易抓住重点。在聊项目的过程中，其实你的整个介绍应该是有一个大体的逻辑，这个时候是在考验你的表达与叙述能力，所以好好准备很重要。</p><p>面试官喜欢问的问题无非就几个点：</p><p>1. XXX（某个比较重要的点）是怎么实现的？</p><p>2. 你在项目中遇到的最大的困难是什么，怎么解决的？</p><p>3. 项目某个部分考虑的不够全面，如果XXXX，你怎么优化？</p><p>4. XXX（一个新功能）需要实现，你有什么思路？</p><p>其实你应该能够预料到面试官要问的地方，请提前准备好，如果被问到没有准备到的地方，也不要紧张，一定要说出自己的想法，对不对都不是关键，主要是有自己的想法，另外，你应该对你的项目整体框架和你做的部分足够熟悉。</p><p><b>四、 其他</b></p><p>你应该问的问题</p><p>面试里，最后面完之后一般面试官都会问你，你有没有什么要问他的。其实这个问题是有考究的，问好了其实是有加分的，一般不要问薪资，主要应该是：关于公司的、技术和自身成长的。</p><p>以下是我常问的几个问题，如果需要可以参考：</p><p>1. 贵公司一向以XXX著称，能不能说明一下公司这方面的特点？</p><p>2. 贵公司XXX业务发展很好，这是公司发展的重点么？</p><p>3. 对技术和业务怎么看？</p><p>4. 贵公司一般的团队是多大，几个人负责一个产品或者业务？</p><p>5. 贵公司的开发中是否会使用到一些最新技术？</p><p>6. 对新人有没有什么培训，会不会安排导师？</p><p>7. 对Full Stack怎么看？</p><p>8. 你觉得我有哪些需要提高的地方？</p><p><b>知识面</b></p><p>除了基础外，你还应该对其他领域的知识有多少有所涉猎。对于你所熟悉的领域，你需要多了解一点新技术与科技前沿，你才能和面试官谈笑风生。</p><p><b>软实力</b></p><p>什么是软实力，就是你的人际交往、灵活应变能力，在面试过程中，良好的礼节、流畅的表达、积极的交流其实都是非常重要的。很多公司可能不光看你的技术水平怎么样，而更看重的是你这个人怎么样的。所以在面试过程中，请保持诚信、积极、乐观、幽默，这样更容易得到公司青睐。</p><p>很多时候我们都会遇到一个情况，就是面试官的问题我不会，这时候大多数情况下不要马上说我不会，要懂得牵引，例如面试官问我C++的多态原理，我不懂，但我知道java的，哪我可以向面试官解释说我知道java的，类似的这种可以往相关的地方迁移（但是需要注意的是一定不要不懂装懂，被拆穿了是很尴尬的），意思就是你要尽可能的展示自己，表现出你的主动性，向面试官推销自己。</p><p>还有就是遇到智力题的时候，不要什么都不说，面试官其实不是在看你的答案，而是在看你的逻辑思维，你只要说出你自己的见解，有一定的思考过程就行。</p><p><b>五、 面经</b></p><p>LZ应聘的职位都是android客户端开发。</p><p>面经其实说来话长，包括实习的话面过的公司有：CVTE、腾讯、阿里、百度、网易、蘑菇街、小米。最早得追溯到到今年3月份，那时候刚过完年，然后阿里的实习内推就开始了，我基本都没什么准备，就突如其来的接到了人生中第一个面试电话。</p><p>阿里实习内推一面： 电话面试， 由于是第一次面试，所以非常紧张，项目都没怎么说清楚。然后面试官就开始问项目细节了，这里我关于一个项目细节和面试官有不同的看法，面试官说我这样做有问题，然后我说我们确实是这样做的，并没有出什么错，差点和面试官吵起来，最后我还是妥协了。然后问了我一个怎么对传输的数据加密，我答的很挫，然后面试官就开始鄙视我：你这个基础不好，那个基础不好，那你说说你还有其他什么优势没？Blabla紧张的说了一些…………只面了30分钟不到，然后妥妥的就挂了。</p><p>经过这次面试突然感觉人生的艰辛，几天后我们教研室的其他同学陆续开始了面试，他们都很顺利，其中我的室友（单程车票）很顺利的拿到了offer，他是个大神，然后我就压力无比的大。制定了整套复习计划，从早上9点看书看到晚上10点。</p><p>到了3月15号左右有CVTE面试，第一次面试是群面，比较坑，坐了一个小时的车过去群面了5分钟，没什么好说的。</p><p>CVTE实习面 ：在自我介绍和项目后，面试官开始问一些java基础，object有哪些方法？这个还能说了一些。问hashmap有多大，这个当时一脸茫然，还sb的答了一个65535。然后面试官让我写三分钟内写一个二分查找，当时也是第一次手写代码，并且还计时，完全没经验，最后超时写了出来。中间又问了我一堆基础，都答得不是很完整。最后问我遇到过OOM的情况没有，什么情况下会OOM。这个也没答出来，然后又妥妥的挂了。</p><p>这次经历告诉我，我是缺少面试经验，和现场写代码的能力，基础还需要多加强。所以我开始各种准备，在一个月的时间里看了四本面试书（程序员面试宝典、java程序员面试宝典、程序员面试笔试宝典、剑指offer），把所有关于数据结构和算法的东西用代码写了一遍。</p><p>然后到了四月初，腾讯来了，我最开始还是非常向往腾讯的，但就当时那个情况，我对自己不报太大希望，觉得能进BAT这样的顶级公司是个奢侈的梦想。</p><p>腾讯的面试是在一个5星级酒店里面，逼格高大上，感觉问的东西也比较多，感觉喜欢问智力题，但是我没遇到。</p><p>腾讯实习1面： 50分钟左右， 面试的时候还是有些紧张的，但是运气好，遇到了一个学校的师兄，他一直叫我不要紧张。几个比较关键的问题：死锁的必要条件，怎么解决，java和c++比有什么优势，java同步方法，activity生命周期，中间让我设计了个银行排队系统，我说了一堆。然后让我写了一个计算一个int里面二进制有几个1，然后我用最高效的方法（n=n&amp;n-1）写出来之后，面试官有点意外，还说没见过这么写的，让我跟他解释一下。后面就是拉拉家常，问我对工作地点怎么看，让我对比qq和微信，一面出来之后，面试官让我留意通知，心想是过了，其实发挥的不怎么好。</p><p>就在会学校的路上，都要到学校了，收到了腾讯二面的通知，下午3点。然后我又跑回去二面。</p><p>腾讯实习2面： 二面是一个很严肃的人，看上去就比较资深那种，一直都不笑，后面才知道是手机管家T4的专家。一开始就问我项目里，心跳包是怎么设计的，我项目里并没有用心跳，然后只能跟他说没做，问我用json传输数据有什么不好（我只知道用哪想过有什么不好）。又问了http和socket的区别，两个协议哪个更高效一点，遇到过java内存泄露没有，用过哪些调试java内存工具，java四种引用。多数都是项目上的东西，基础的东西没问太多，然后感觉自己答的不是很好，很多都不知道，而且还答错了。其实我感觉我应该是过不了的，但是最后我问问题的时候，我让他评价下我的表现，他说不好评价，我自己说了一堆，说在学校里确实见识到的东西比较少，很多东西没考虑全面，然后他表示赞同，和我探讨了一番，我觉得最后这个问题给我加了不少分。二面也面了50分钟左右。</p><p>回来后发现我的状态一直没变，而他们二面完了的都到了HR面了，我以为我已经挂定了，后来在一天晚上12点的时候，惊喜的收到了第二天HR面的短信，当晚上几乎高兴得一晚上没睡着觉。</p><p>腾讯实习3面（HR）： 就是hr面，也就面了十几分钟，聊聊天，问问哪的人，未来什么打算的等等，基本不怎么挂人就不详细写了。</p><p>就这样拿到了人生中第一个实习offer。</p><p>后面找实习的心就放松了，没有复习了。然后到了5月5号，阿里来了。对阿里也只是想去面一面的心态了，因为已经有腾讯的offer了，就没想太多。</p><p>阿里实习1面： 面过腾讯之后发现自己已经比较淡定了，面试得时候能够比较好的交谈了。这一面也遇到一个比较好的面试官，能很轻松的和他交流。主要的问题是android的：activity的生命周期、activity的四种启动模式（当时忘了一些没答全）、线性布局和相对布局、多线程请求，java GC算法与GC方法，内存模型，有一个比较特别的问题是问我微信的朋友圈怎么设计，然后我把思路跟他说了，其他的就是问了项目相关的了。还问了我一个觉得技术深度重要还是技术宽度重要，一面感觉还是比较基础的。</p><p>阿里实习2面： 这一面就比较虐心，碰到一个阿里云的CTO，一上去项目看都不看，直接问我写过多少行代码，我说至少3、4万行，然后他让我写了两个题：一个找素数，一个递归求阶层，对我也算手下留情（他后来让我同学写AVL树的插入算法，想想也是醉了）。后面就各种基础了，java的基础挨个问了一遍，比较关键多线程实现，锁的几种等级等，反射的用法，wait()和sleep()（讨论这个的时候他把我说晕了），Java还好，多数能应付，然后他就开始问c++的了。虽然是基础，但是lz忘了差不多了，什么指针数组和数组指针，虚函数，多态实现（这个我扯到java上了）等等，问了很多，很多都没答上来，然后他说我基础不太好（我想说我简历上写的了解C++，为什么要追着我问TT）。</p><p>就这样出来了，本来以为挂了，后面被通知过了。同学都只有2面技术面，我居然多了一面，叫交叉面试，心想这下肯定完了。</p><p>阿里实习3面： 这一面遇到了后面我去实习时候的部门boss，人非常好，来的时候走的时候都要和我握手，非常的平易近人。这一面还是问项目上的一些东西居多，基础就问了个java多线程，各个排序的时间复杂度、思想。技术问了半个小时，后面半个小时就开始各种聊人生了（@_@），我家是哪的，父母干嘛的，中学怎么样，大学怎么样，等等，完全就不像是技术面嘛（后来才知道，我一个同学一开始来就和他聊人生，还聊过了。再次感叹找工作是看缘分呐）。</p><p>阿里实习4面（HR） ：阿里hr比腾讯hr面专业，面了一个小时，把我的生活经历趴了一遍，（问了类似你的优缺点，最让你高兴的一件事，最让你伤心的一件事，你的职业规划，你的理想等等，这种，现在想不起来了）也没什么特别好说的。</p><p>面完后第二天去圆桌签offer，就这样又拿到了阿里的实习offer。</p><p>LZ后面衡量了杭州阿里B2B和广州腾讯MIG，最后选择去了阿里，因为在总部，感觉大boss人比较好，发展前途可能不错，而且留下来的几率比较大，而腾讯是一个分部门，感觉可能不是很有前景（但是后来了解到其实广州腾讯MIG发展前景非常好，环境也非常和谐，我同学去实习的都留下来了。哎，只能感叹选择是个大问题）。在阿里实习的两个月时间也挺愉快的，学到了不少东西，也认识了很好的师兄和主管，只因最后被拥抱了变化没有拿到正式offer。</p><p>实习面经就已经写完了，后面是正式找工作的经历，主要是内推比较多：腾讯、网易、蘑菇街、小米，校招就面了家百度。</p><p>在阿里实习的时候，面了网易和蘑菇街。</p><p>网易面试是我面了这么多中，问得最专业的了。</p><p>网易内推1面： 电话面，一天在里中午休息的时候面的。这一面我面得很烂，由于在阿里实习，面试官恰好也在阿里呆过，问了我在阿里学到了哪些东西，看过哪些框架，看过源码没有，我支支吾吾说了一些，面试官不太满意（我表示我都说不全啊，在阿里就来了不久，哪那么多时间看源码）。项目各种细节问一通之后，开始问基础，Http报文结构，Handler、Looper模型，ThreadLocal（这个LZ当时没答上来），怎么使service不被杀死，android内存优化，自己实现线程队列模型，问我怎么设计（这个当时被前面的问题问蒙了，直接说不知道了），面了20+分钟，感觉答得都不怎么好，然后面试官问我说还有没有什么比较擅长的他没有问道的，我就把android Framework里zygote的启动和Binder通信说了一遍（这里强行装了一次逼）。</p><p>面完之后本以为挂定了，然后师姐跟我说居然过了，也是够神奇，我觉得是我后面补充的内容救了我。</p><p>网易内推2面： 二面是现场面，就在阿里滨江区的隔壁。时间是一天中午，吃了饭就到了隔壁。面试官是个比较年轻人，可能大不了我几岁，也是非常好说话，开始也是聊项目，我把在阿里做的app和自己写的小框架拿出来，他就指着上面各种问，这里怎么实现，会有什么问题，你怎么解决，然后他描述了一个场景说，两个activity，前面的是个dialog activity，怎么在dialog activity存在的情况下改变后面的activity（lz答的用广播）。android怎么解决缓存，要是内存超了怎么办？然后扯到了JVM，GC判定算法与方法，哪个区域用什么GC算法，怎么改进复制算法。然后是基础，也像一面一样问了一些，hashmap和concurrntHashmap的区别、泛型能否强制转换。然后是算法，问了快排和归并的平均时间复杂度与最差时间复杂度，出了个算法题：怎么找到一个随机数组的前50大数、中间50大数，（这个用最小堆和partition函数），复杂度是多少。</p><p>面完之后其实感觉还不错，基本都打答上来了，顺利进入三面。</p><p>网易内推3面（HR）： hr面也是现场，也聊了很多，问我为什么要从阿里来网易，有什么打算，你看中网易的什么（主要是针对我是在阿里实习来问的，我就讲了一堆网易的优势），让来杭州工作愿不愿意。还跟我说了，这次内推是优中选优，有名额限制，如果没有通过，请继续关注网易校招。</p><p>后面让师姐查了下状态，状态显示是三面已通过。但是最后没有收到offer，还是有点小失望。</p><p>蘑菇街面试感觉比较基础，没有什么技术难度。</p><p>蘑菇街内推1面： 电话面，也是在一个中午面的。18分钟，问了一些项目，主要是问基础、问得非常基础：Arraylist与LinkedList区别，String与StringBuffer用法，HashMap与HashTable区别，Synchronized用法等等等等（非常基础），这不一一列举了，然后很顺利的就过了。</p><p>2面是在20天后了，也不知道蘑菇街出了什么岔子。</p><p>蘑菇街内推2面 ：也是电话面，CTO面试，就整体聊了项目，我在项目中学到了什么，遇到什么困难怎么解决的，在阿里实习学到了哪些东西，有看过源码么，我的优缺点，我为什么选择蘑菇街，我了解蘑菇街哪些东西。最后答完感觉自己答得还行但是也没有过，不知道为什么。</p><p>小米是投的内推精英计划，50个名额，解决北京户口。</p><p>小米内推1面： 电话面，大概40分钟，面试的时候那边很吵，不过幸好面试官语速慢，而且我答完一个问题后，面试官会和我交流哪里没有答好。没有问项目，就问了基础，问题也不多：HashMap删除元素的方法，for each和正常for的用在不同数据结构（ArrayList、set、hashmap）上的效率区别（LZ表示没有看过源码，不知道），static class和non-static class的区别，一个大文件几个GB，怎么实现复制（这个也没有答好）。然后问了两个算法：之前一个出现过，另一个是在Git里面，如果有n个分支，m次commit怎么找到任意两个节点共同的那个父节点（这个当时我想错了，想到二叉树上去了，没有答好）。然后让两个算法用代码实现，1个小时内写好email给他。</p><p>小米面了以后也杳无音信，估计也是要求很高，毕竟解决北京户口。</p><p>其实在阿里实习的时候很早就开始投简历了，因为出去实习一段时间后，感觉还是很想留在成都（因为lz是四川人）。腾讯我没有参加校招面试，直接走的内推流程。</p><p>腾讯1面： 电话面，7月20+号，很水，就问了项目，聊了可能有十多分钟，然后面试官说，内推没有什么作用，还是要走校招面试（我觉得他可能是有其他事情，想节省时间），你在实习不能回来，还是要现场面一次才行，然后就留了个电话让我校招联系他，这样就完了。</p><p>2面是在我回学校后了。</p><p>腾讯2面： 9月6号我回学校之后，下午3点接到电话，让我晚上7点去腾讯现场面的（我在想为何是在晚上，lz学校到腾讯要2个小时，还让不让人回来了），当时紧张得要死，因为刚从阿里回来不久，都没怎么好好准备基础，在地铁上看了两本基础书，亚历山大。面试是在腾讯里面，微信部门，面试官是个中年人（现在是LZ的主管），看起来还是比较沉稳的那种。也没问基础技术问题，就聊项目细节和一些可优化的地方，然后把lz的简历看了翻了一遍，问了一遍，然后就是问我在阿里学到了什么，为什么当时选择了阿里（这时候肯定要各种跪舔啊）。然后后来他说他是做iOS的，我在想难怪不问我基础。</p><p>面完了说一周之内通知我结果，也没报太大希望，感觉并不太对口，因为搞不懂为什么是做ios的来面我。</p><p>两天之后，在阿里HRG电话通知我拥抱变化之后，几乎同一时间，腾讯电话通知我拿到了成都offer，我只能感叹太巧了（大概这大半辈子的运气都花光了）。</p><p>后来校招开始后，只面了百度一家公司，百度确实比较重视基础与算法，看中技术。</p><p>百度1面： 大概1个小时，又是个做ios的师兄面试我，自然就只能聊项目了，我给他展示了我做的app后，也问了些技术问题，缓存怎么做的，内存溢出怎么处理。然后两个算法题：把一个数组中奇数放前面，偶数放后面，这个要求写出来。另一个是3亿条IP中，怎么找到次数出现最多的5000条IP。最后问了是否愿意去北京，对于技术的看法。</p><p>百度2面： 50分钟，写个4个程序题：反转链表、冒泡排序、生产者消费者，这三个都还好写，很快的写出来了，还有一个题是在一组排序数中，给定一个数，返回最接近且不大于这个数的位置，要求时间在O(logn)（这个想了一会，用二分查找，然后特殊处理了一下），最后他看不懂，要我一步一步解释。花了好一整子，最后问了个java反射，就让我走了。百度果然是重视算法。</p><p>百度3面： 这一面应该是个技术高层，笼统的问了我一下项目的问题，然后问了几个基础：java反射机制；android动画有哪些，什么特点？TCP/IP层次架构，每层的作用与协议；TCP拥塞控制；滑动窗口是怎么设计的，有什么好处；android的布局都有哪些。问完这些之后，然后就是有点类似于HR的聊天了：如果这次面试过了你觉得是因为什么原因，没过呢？你觉得百度怎么样？你对技术路线什么打算？有些和前面重复的就不写了。然后他让我问他问题，我就连续问了5、6个问题，最后愉快的走了。</p><p>百度这两天给结果。</p><p><b>六、 写在最后</b></p><p>关于选择</p><p>LZ当时实习的时候，杭州阿里和广州腾讯选择去了阿里，但是却因为拥抱变化没有留下来，相反这边在腾讯实习的同学却很顺利。但是也是因为没有去广州腾讯，最后我能留在成都腾讯。选择是一件非常重要的事情，它决定着你的未来，但是也有一点你得知道：塞翁失马焉知非福，现在看起来不太好的选择，不一定将来就好，未来有太多未知数。</p><p>心怀感恩</p><p>其实一路走来，我也是在成长，从最初的不自信，到了最后面试一切都比较冷静与沉着。我一直相信，机会是留给有准备的人，所以，请提早准备，越早越好。我很感激能有那么多人帮助我和肯定我，没有最初腾讯的肯定，我肯定不会走的这么顺利，所以我很感恩哪些让我通过的人，也感谢我们实验室的兄弟姐妹，给了我良好的学习成长环境，心怀感恩才能好运常在。</p><p>找工作其实就像是一场战役，前面我们经历了高考或者考研，现在是找工作，你不在这个时候搏一搏，怎么对得起你之前的努力。不要担心找不到好工作，你要相信：天道酬勤！</p><p>码字不易看到最后了，那就点个关注呗，只收藏不点关注的都是在耍流氓！</p><p>关注并私信我“架构”，免费送一些Java架构资料，先到先得！</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "面试技巧", 
                    "tagLink": "https://api.zhihu.com/topics/19591490"
                }, 
                {
                    "tag": "Java 虚拟机（JVM）", 
                    "tagLink": "https://api.zhihu.com/topics/19566470"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70496321", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 3, 
            "title": "微服务架构之「 容错隔离 」", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-10829aade3ed80ee62890390fcd2aeca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-10829aade3ed80ee62890390fcd2aeca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-10829aade3ed80ee62890390fcd2aeca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-10829aade3ed80ee62890390fcd2aeca_b.jpg\"/></figure><p><br/><br/>我们知道，在单体应用的架构下一旦程序发生了故障，那么整个应用可能就没法使用了，所以我们要把单体应用拆分成具有多个服务的微服务架构，来减少故障的影响范围。但是在微服务架构下，有一个新的问题就是，由于服务数变多了，假设单个服务的故障率是不变的，那么整体微服务系统的故障率其实是提高了的。<br/>比如：假设单个服务的故障率是0.01%，也就是可用性是99.99%，如果我们总共有10个微服务，那么我们整体的可用性就是99.99%的十次方，得到的就是99.90%的可用性（也就是故障率为0.1%）。可见，相对于之前的单体应用，整个系统可能发生故障的风险大幅提升。<br/>那么在这种情况下，我们应该怎么去保证微服务架构的可用性呢？<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a5bcdb7f80f5ae4c0cc0eb818351fbde_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"548\" data-original=\"https://pic3.zhimg.com/v2-a5bcdb7f80f5ae4c0cc0eb818351fbde_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;548&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"548\" data-original=\"https://pic3.zhimg.com/v2-a5bcdb7f80f5ae4c0cc0eb818351fbde_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a5bcdb7f80f5ae4c0cc0eb818351fbde_b.jpg\"/></figure><p><br/><br/>其实我们参考造船行业对船舱进水风险的隔离方法，如上图。<br/>造船行业有一个专业术语叫做「舱壁隔离」，利用舱壁将不同的船舱隔离起来，如果某一个船舱进了水，那么就可以立即封闭舱门，形成舱壁隔离，只损失那一个船舱，其他船舱不受影响，整个船只还是可以正常航行。<br/>对应到微服务架构中，我们要做的就是最大限度的隔离单个服务的风险，也就是「 容错隔离 」的方法。<br/><b>一、微服务架构中可用性风险有哪些？</b><br/>在聊「容错隔离」方法之前，我们先来看一下微服务架构中，常见的可用性风险到底有哪些吧，知道了有哪些风险我们才知道该如何去规避、去隔离风险。<br/>我们可以从项目部署规模的角度去分析风险：<br/></p><ol><li><b>单机可用性风险：</b></li><li>这个很好理解，就是微服务部署所在的某一台机器出现了故障，造成的可用性风险。这种风险发生率很高，因为单机器在运维中本身就容易发生各种故障，例如 硬盘坏了、机器电源故障等等，这些都是时有发生的事情。不过虽然这种风险发生率高，但危害有限，因为我们大多数服务并不只部署在一台机器上，可能多台都有，因此只需要做好监控，发现故障之后，及时的将这台故障机器从服务集群中剔除即可，等修复了再重新上线到集群里。</li><li><b>单机房可用性风险：</b></li><li>这种风险的概率比单机器的要低很多，但是也不是完全不可能发生，在实际情况中，还是有一定概率的。比如最为常见的就是通往机房的光纤被挖断了，前段时间支付宝所在机房不是就发生过光纤被挖么。</li><li>咱们全国大小城市都在疯狂的进行基建，修桥修路修房子，GDP就这么搞起来了，地下的光纤挖断几根不是再正常不过的事情了么，哈哈。</li><li>如果我们的服务全部都部署在单个机房，而机房又出故障了，那就没辙了。好在，现在大多数中大型项目都会采用多机房部署的方案，比如同城双活、异地多活等。一旦某个机房出现了故障不可用了，咱们立即采用切换路由的方式，把这个机房的流量切到其它机房里。</li><li><b>跨机房集群可用性风险：</b></li><li>既然都跨机房集群了，可用性理论上应该没啥问题啊。但要知道这是在物理层面没有问题了，如果咱们的代码有坑，或者因为特殊原因用户流量激增，导致我们的服务扛不住了，那在跨机房集群的情况下一样会不可用。但如果我们提前做好了「容错隔离」的一些方案，比如 限流、熔断 等等，用上这些方法还是可以保证一部分服务或者一部分用户的访问是正常。</li></ol><p><b>二、「 容错隔离 」的方法有哪些？</b><br/>好了，上面讲了微服务架构中可能遇到这么多的可用性风险，并且也知道了「容错隔离」的重要性，下面我们再来看看常见的「容错隔离」方法有哪些：<br/></p><ol><li><b>超时：</b></li><li>这也是简单的容错方式。就是指在服务之间调用时，设置一个 主动超时时间，超过了这个时间阈值后，如果“被依赖的服务”还没有返回数据的话，“调用者”就主动放弃，防止因“被依赖的服务”的故障所影响。</li><li><b>限流</b></li><li>顾名思义，就是限制最大流量。系统能提供的最大并发有限，同时来的请求又太多，服务不过来啊，就只好排队限流了，就跟去景点排队买票、去商场吃饭排队等号的道理一样一样儿的。</li><li><b>降级</b></li><li>这个与限流类似，一样是流量太多，系统服务不过来。这个时候可以可将不是那么重要的功能模块进行降级处理，停止服务，这样可以释放出更多的资源供给核心功能的去用。同时还可以对用户分层处理，优先处理重要用户的请求，比如VIP收费用户等。</li><li><b>延迟处理</b></li><li>这个方式是指设置一个流量缓冲池，所有的请求先进入这个缓冲池等待处理，真正的服务处理方按顺序从这个缓冲池中取出请求依次处理，这种方式可以减轻后端服务的压力，但是对用户来说体验上有延迟。</li><li><b>熔断</b></li><li>可以理解成就像电闸的保险丝一样，当流量过大或者错误率过大的时候，保险丝就熔断了，链路就断开了，不提供服务了。当流量恢复正常，或者后端服务稳定了，保险丝会自动街上（熔断闭合），服务又可以正常提供了。这是一种很好的保护后端微服务的一种方式。</li><li>熔断技术中有个很重要的概念就是：断路器，可以参考下图：</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-daa3a78a2b915fab02aaea13cd09c48f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"557\" data-original=\"https://pic4.zhimg.com/v2-daa3a78a2b915fab02aaea13cd09c48f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;557&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"557\" data-original=\"https://pic4.zhimg.com/v2-daa3a78a2b915fab02aaea13cd09c48f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-daa3a78a2b915fab02aaea13cd09c48f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>断路器其实就是一个状态机原理，有三种状态：Closed（闭合状态，也就是正常状态）、Open（开启状态，也就是当后端服务出故障后链路断开，不提供服务的状态）、Half-Open(半闭合状态，就是允许一小部分流量进行尝试，尝试后发现服务正常就转为Closed状态，服务依旧不正常就转为Open状态)。</li></ol><p><b>三、「 容错隔离 」的应用？</b><br/>在容错隔离或者说熔断技术方面做得最出名的框架就是 <b>Hystrix</b> 了。Hystrix是由Netflix开源，在业内应用非常广泛。<br/>下面是Hystrix的原理流程图：<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1480ebcb756ffa9cc6377254a74cd83b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"304\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-1480ebcb756ffa9cc6377254a74cd83b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;304&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"304\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-1480ebcb756ffa9cc6377254a74cd83b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1480ebcb756ffa9cc6377254a74cd83b_b.jpg\"/></figure><p><br/><br/>这是新版流程，比之前旧版本又复杂很多，如果不讲解一下，估计很多人都不容易看懂。<br/>图中标注了数字1-9，可以按照这个数字顺序去理解这个流程。<br/>当我们使用了Hystrix之后，请求会被封装到HystrixCommand中，这也就是第一步。然后第二步就是开始执行请求，Hystrix支持同步执行(图中.execute方法)、异步执行(图中.queue方法)和响应式执行(图中.observer)。然后第三步判断缓存，如果存在与缓存中，则直接返回缓存结果。如果不在缓存中，则走第四步，判断 断路器 的状态是否是开启的，如果是开启状态，也就是短路了，那就进行失败返回，跳到第八步，第八步需要对失败返回的处理也需要再做一次判断，要么正常失败返回，返回相应信息，要么根本没有实现失败返回的处理逻辑，就直接报错。如果 断路器 不是开启状态，那请求就继续走，进行第五步，判断线程/队列是否满了，如果满了，那么同样跳到第八步，如果线程没满，则走到第六步，执行远程调用逻辑，然后判断远程调用是否成功，调用发生异常了就挑到第八步，调用正常就挑到第九步正常返回信息。<br/>图中的第七步，非常牛逼的一个模块，是来收集Hystrix流程中的各种信息来对系统做监控判断的。<br/>另外，Hystrix的断路器实现原理也很关键，下面就是Hystrix断路器的原理图：<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ff97964407d66af0bdbdf132305c288a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"517\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ff97964407d66af0bdbdf132305c288a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;517&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"517\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ff97964407d66af0bdbdf132305c288a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ff97964407d66af0bdbdf132305c288a_b.jpg\"/></figure><p><br/><br/>Hystrix通过滑动时间窗口算法来实现断路器的，是以秒为单位的滑桶式统计，它总共包含10个桶，每秒钟一个生成一个新的桶，往前推移，旧的桶就废弃掉。<br/>每一个桶中记录了所有服务调用的状态，调用次数、是否成功等信息，断路器的开关就是把这10个桶进行聚合计算后，来判断当前是应该开启还是闭合的。<br/>以上，就是对微服务架构中「容错隔离」的一些思考。<br/>在微服务架构的系列文章中，前面已经通过文章介绍过了「服务注册 」、「服务网关 」、「配置中心 」、「 监控系统 」、「调用链监控」，大家可以翻阅历史文章查看。<br/>写在最后：<br/>码字不易看到最后了，那就点个关注呗，只收藏不点关注的都是在耍流氓！<br/>关注并私信我“架构”，免费送一些Java架构资料，先到先得！</p><p><br/> </p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70186787", 
            "userName": "JavaStorm", 
            "userLink": "https://www.zhihu.com/people/ed4ff2a46bc893c503121db0958c2b71", 
            "upvote": 1, 
            "title": "设计模式-模板方法", 
            "content": "<p>关注公众号 <b>JavaStorm</b> 获取更多精彩。</p><blockquote> 模板方法模式在一个方法中定义了一个算法骨架，并且 final 修饰防止子类重写。方法中包含一些抽象方法，也就是一些步骤延迟到字类实现。模板方法使得在不改变算法结构的情况下，重新定义算法中的某些步骤。完整代码可以查看GitHub：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/UniqueDong/zero-design-stu\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/UniqueDong/z</span><span class=\"invisible\">ero-design-stu</span><span class=\"ellipsis\"></span></a><br/> </blockquote><h2>类图</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7d48635a452cb97affe2aab972f3d8ac_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"390\" class=\"origin_image zh-lightbox-thumb\" width=\"659\" data-original=\"https://pic1.zhimg.com/v2-7d48635a452cb97affe2aab972f3d8ac_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;659&#39; height=&#39;390&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"390\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"659\" data-original=\"https://pic1.zhimg.com/v2-7d48635a452cb97affe2aab972f3d8ac_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7d48635a452cb97affe2aab972f3d8ac_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>模式实现</h2><p>在实现模板方法模式时，开发抽象类的软件设计师和开发具体子类的软件设计师之间可以进行协作。一个设计师负责给出一个算法的轮廓和框架，另一些设 计师则负责给出这个算法的各个逻辑步骤。实现这些具体逻辑步骤的方法即为基本方法，而将这些基本方法汇总起来的方法即为模板方法，模板方法模式的 名字也因此而来。下面将详细介绍模板方法和基本方法： 1. 模板方法 一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改 地完全继承下来。模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法 是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口。 2.  基本方法 基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。 (1) 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。 (2) 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。 (3) 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实 现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。 钩子可以让子类实现算法中可选的部分，或者在钩子对于子类的实现并不重要的时候，子类可以对此钩子置之不理。钩子的另一个用法，是让子类能够有机会 对模板方法中某些即将发生的（或刚刚发生的）步骤做出反应。</p><h2>使用场景</h2><p>开一家咖啡、茶馆，泡茶和咖啡的冲泡方式非常相似：</p><h3>星巴克咖啡冲泡法</h3><ol><li>把水煮沸</li><li>用沸水冲泡咖啡</li><li>把咖啡倒进杯子</li><li>加糖和牛奶</li></ol><h3>功夫茶冲泡法</h3><ol><li>把水煮沸</li><li>用沸水冲泡茶叶</li><li>把茶倒进杯子</li><li>加柠檬</li></ol><p><b>我们可以发现两种茶的步骤1，和步骤3是一样的。整体算法结构是固定的，只是有的部分不一样。这时候我们就可以使用模板方法设计模式定义制作骨架，然后部分细节留给子类实现。</b></p><h2>代码实现</h2><p>首先我们先抽象一个制作饮料的模板，定义算法逻辑  AbstractBeverage。同时有一个钩子方法，一般是空实现，在这里我们可以通过它（customerWantsCondiments()）来控制是否加调料。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.design.actions.template</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 抽象制作饮料模板:定义算法骨架\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">AbstractBeverage</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 这就是模板方法。它被声明为final，以免子类改变这个算法的顺序。\n</span><span class=\"cm\">     * 算法步骤组合\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">prepareRecipe</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 模板方法定义了一连串的步骤，每个步骤由一个方法代表\n</span><span class=\"c1\"></span>        <span class=\"n\">boilWater</span><span class=\"o\">();</span>\n        <span class=\"n\">brew</span><span class=\"o\">();</span>\n        <span class=\"n\">pourInCup</span><span class=\"o\">();</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">customerWantsCondiments</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"n\">addCondiments</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     *  我们在这里定义了一个方法，（通常）是空的缺省实现。这个方法只会返回true，不做别的事。\n</span><span class=\"cm\">     * 这就是一个钩子，子类可以覆盖这个方法，但不见得一定要这么。\n</span><span class=\"cm\">     * @return\n</span><span class=\"cm\">     */</span>\n    <span class=\"kt\">boolean</span> <span class=\"nf\">customerWantsCondiments</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 添加佐料:不同饮料也有不同佐料：申明为抽象类，由子类取操心\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">protected</span> <span class=\"kd\">abstract</span> <span class=\"kt\">void</span> <span class=\"nf\">addCondiments</span><span class=\"o\">();</span>\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 酿制:不同饮料方式也不同，申明为抽象类，由子类取操心\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">protected</span> <span class=\"kd\">abstract</span> <span class=\"kt\">void</span> <span class=\"nf\">brew</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 共通方法:倒入杯中\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pourInCup</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;倒入杯子中...&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 把水煮沸,共通方法\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">boilWater</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;把水煮沸...&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>接着我们定义泡茶具体算法，并且继承 AbstractBeverage 抽象算法，实现泡茶的具体逻辑。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.design.actions.template</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Tea</span> <span class=\"kd\">extends</span> <span class=\"n\">AbstractBeverage</span> <span class=\"o\">{</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 这样通过钩子就可以选择是都要加佐料了\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"n\">addCondiments</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 添加糖、牛奶\n</span><span class=\"cm\">     */</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">addCondiments</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;添加柠檬，茶更好喝&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 咖啡冲泡方法\n</span><span class=\"cm\">     */</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">brew</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;秘制泡茶方式放入茶叶&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 使用钩子，不加佐料\n</span><span class=\"cm\">     * @return\n</span><span class=\"cm\">     */</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kt\">boolean</span> <span class=\"nf\">customerWantsCondiments</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">addCondiments</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isAddCondiments</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">addCondiments</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setAddCondiments</span><span class=\"o\">(</span><span class=\"kt\">boolean</span> <span class=\"n\">addCondiments</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">addCondiments</span> <span class=\"o\">=</span> <span class=\"n\">addCondiments</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>定义咖啡的算法细节</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.design.actions.template</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 咖啡具体实现：只需要自行处理冲泡和添加调料部分\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Coffe</span> <span class=\"kd\">extends</span> <span class=\"n\">AbstractBeverage</span> <span class=\"o\">{</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 这样通过钩子就可以选择是都要加佐料了\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"n\">addCondiments</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 添加糖、牛奶\n</span><span class=\"cm\">     */</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">addCondiments</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;添加糖跟牛奶&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 咖啡冲泡方法\n</span><span class=\"cm\">     */</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">brew</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;放入咖啡豆，使用秘制方法冲泡&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 重写钩子\n</span><span class=\"cm\">     * @return\n</span><span class=\"cm\">     */</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kt\">boolean</span> <span class=\"nf\">customerWantsCondiments</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">addCondiments</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isAddCondiments</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">addCondiments</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setAddCondiments</span><span class=\"o\">(</span><span class=\"kt\">boolean</span> <span class=\"n\">addCondiments</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">addCondiments</span> <span class=\"o\">=</span> <span class=\"n\">addCondiments</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>接着就是客户点单，我们通过模板方法模式制作咖啡或者功夫茶。达到代码复用。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.design.actions.template</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * Created by unique on 2017/6/7.\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Test</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Tea</span> <span class=\"n\">tea</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Tea</span><span class=\"o\">();</span>\n        <span class=\"n\">tea</span><span class=\"o\">.</span><span class=\"na\">setAddCondiments</span><span class=\"o\">(</span><span class=\"kc\">false</span><span class=\"o\">);</span>\n        <span class=\"n\">tea</span><span class=\"o\">.</span><span class=\"na\">prepareRecipe</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;-------------------&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">Coffe</span> <span class=\"n\">coffe</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Coffe</span><span class=\"o\">();</span>\n        <span class=\"n\">coffe</span><span class=\"o\">.</span><span class=\"na\">prepareRecipe</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>输出如下</p><div class=\"highlight\"><pre><code class=\"language-text\">把水煮沸...\n秘制泡茶方式放入茶叶\n倒入杯子中...\n-------------------\n把水煮沸...\n放入咖啡豆，使用秘制方法冲泡\n倒入杯子中...\n添加糖跟牛奶</code></pre></div><h2>模板方法模式的优缺点</h2><h3>优点</h3><p>1）良好的封装性。把公有的不变的方法封装在父类，而子类负责实现具体逻辑。</p><p>2）良好的扩展性：增加功能由子类实现基本方法扩展，符合单一职责原则和开闭原则。</p><p>3）复用代码。</p><h3>缺点</h3><p>1）由于是通过继承实现代码复用来改变算法，灵活度会降低。</p><p>2）子类的执行影响父类的结果，增加代码阅读难度。</p><p>点赞与收藏是最大的鼓励。欢迎关注公众号 JavaStorm </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-56755d8a71b40f096b5012307978c6f8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic1.zhimg.com/v2-56755d8a71b40f096b5012307978c6f8_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70147855", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 4, 
            "title": "面试官问你为什么要用Spring,你是怎么答的了", 
            "content": "<p>相信每个读者在工作中，学习中都了解Spring怎么使用，对于一个初级的开发工程师来说，仅仅了解怎么使用，能够很快的通过Spring来完成任务，这应该是足够了，但是呢，如果你还想向更高的级别去前进，系统的学习，掌握它的底层原理是必不可少的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f89f9b739ddfa28e95543b27c4945b78_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"448\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f89f9b739ddfa28e95543b27c4945b78_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;448&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"448\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f89f9b739ddfa28e95543b27c4945b78_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f89f9b739ddfa28e95543b27c4945b78_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>每个人在面试的时候，Spring应该都是逃不过的关卡，能够熟练的使用，这并不难，知道它的底层原理才是高出别人一步的地方。这篇文章就说简单说下Spring的一些知识，希望能在面试的路上帮助到你们。</p><p>Spring是个开源框架，它被创建出来的初衷就是解决企业级应用开发的复杂性。Spring不仅仅局限于服务端开发，任何的java应用都能借助于Spring变得更加简单，可测试性更强，松耦合性更好。</p><p>为了降低Java开发的复杂性，Spring采取了一下4种关键策略：</p><ul><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul><p>几乎Spring所做的任何事情，都是围绕着以上四种策略来实现的，其核心就是：简化java开发。</p><p><b>1、轻量级POJO</b></p><p>在日常的开发过程中，可能大部分人都感受到了，很多框架都会强迫应用继承他们的类或者是实现他们的接口，这样就会导致程序和框架绑死，说到这，我们的现在所用的框架就是这样，各个模块，包括DAO，Service，都会强制性的继承框架的中的类，应用程序和框架绑定的死死的。Spring竭力的避免因为自身的API来搞乱你的应用代码，Spring也不会强迫你实现他的接口或者是继承它的类，最严重的也就是一个雷会使用Spring注解。Spring的非侵入式编程意味着这个类在Spring应用和非Spring应用中发挥着同样的作用。</p><p><b>2、依赖注入</b></p><p>任何一个有实际意义的应用，肯定是会有多个类组成，在没有Spring的时候，每个对象负责管理着与自己相互协作的对象的引用，这样会导致高耦合和难以测试的代码。</p><ul><li><br/></li></ul><blockquote>public class Train implements Transport{<br/>private Water water;<br/>public Train() {<br/>water = new Water();<br/>}<br/>public void catchGoods(){<br/>water.waterSomthing();<br/>}<br/>}</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>可以看到上面的代码，Train在自己的构造函数中自己创建了 Water对象，这样就造成了这两个对象的紧耦合，这个火车可以运水来浇灌农田，但是如果让这个火车来运煤供暖，可能就不太符合了。</p><p>而在单元测试的时候，我们要确保catchGoods方法执行的时候，waterSomthing也能够执行，如果这样来做，那就执行不了单元测试了。</p><p>耦合是具有两面性的，一方面紧密的耦合的代码，难以测试，难以服用，难以理解，修改了一处就可能会引起别的bug(记得刚去公司的时候，讲开发规范，一个接口尽量的只做一件事情，千万不要一个接口同时为多个地方提供服务)，另一方面呢完全没有耦合的代码也什么都干不了。</p><p>有了Spring之后，对象的依赖关系由负责协调各对象的第三方组件来完成，对象无需自行创建，依赖注入会将所依赖的关系自动交给目标对象，而不是让对象自己去获取。</p><ul><li><br/></li></ul><blockquote>public class Train implements Transport{<br/>private Water water;<br/>public Train(Water water) {<br/>this.water = water;<br/>}<br/>public void catchGoods(){<br/>water.waterSomthing();<br/>}<br/>}</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>上面在我们的改动之后，不再由Train自行创建，而是当成一个构造器参数传进来，这也是依赖注入的一种方式：构造器注入。这也就实现了松耦合。</p><p>创建应用组件之间协作的行为通常称为装配，Spring有着多种装配bean的方式，XML就是一种常用的方式。</p><ul><li><br/></li></ul><blockquote>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;<br/>&lt;!--DOCTYPE beans PUBLIC &#34;-//SPRING//DTD BEAN//EN&#34; &#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/dtd/spring-beans.dtd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/dtd</span><span class=\"invisible\">/spring-beans.dtd</span><span class=\"ellipsis\"></span></a>&#34; --&gt;<br/>&lt;beans xmlns=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans</span><span class=\"ellipsis\"></span></a>&#34;<br/>xmlns:xsi=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.w3.org/2001/XMLSchema-instance\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">w3.org/2001/XMLSchema-i</span><span class=\"invisible\">nstance</span><span class=\"ellipsis\"></span></a>&#34;<br/>xsi:schemaLocation=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans</span><span class=\"ellipsis\"></span></a><br/><a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans/spring-beans.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans/spring-beans.xsd</span><span class=\"ellipsis\"></span></a>&#34;&gt;<br/>&lt;bean id=&#34;train&#34; class=&#34;com.kr.caption.spring.Train&#34;&gt;<br/>&lt;constructor-arg ref=&#34;water&#34;/&gt;<br/>&lt;/bean&gt;<br/>&lt;bean id=&#34;water&#34; class=&#34;com.kr.caption.spring.Water&#34;/&gt;<br/>&lt;/beans&gt;</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>在上面的xml文件中，两个对象被声明为了Spring中的bean，在Train中，在构造时传入了对Water的引用，作为构造器参数。</p><ul><li><br/></li></ul><blockquote>@Configuration<br/>public class TrainConfig {<br/>@Bean<br/>public Transport train(){<br/>return new Train(water());<br/>}<br/>@Bean<br/>public Water water(){<br/>return new Water();<br/>}<br/>}</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>上面的是基于java的配置，这两种配置都是一样的效果。</p><p>Spring通过应用的上下文，来装载bean的定义，并把他们组装起来，Spring应用上下文全权负责对象的创建和组装，Spring有多种上下文的实现，它们之间主要的区别仅仅在于如何加载配置。</p><ul><li><br/></li></ul><blockquote>public class application {<br/>public static void main(String[] args) {<br/>ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&#34;classpath:application_example.xml&#34;);<br/>Train bean = context.getBean(Train.class);<br/>bean.catchGoods();<br/>}<br/>}</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>这里的main方法基于application_example.xml创建了一个Spring应用上下文，随后就能得到一个实例对象，直接调用方法即可。</p><p><b>3、面向切面编程</b></p><p>系统由不同的组件组成，而这些组件除了实现自身的核心功能外，还承担着其他的一些职责。比如日志、事务管理和安全这些通常会贯穿着整个项目中的各个组件。如果没有系统性的处理这部分，那么你的代码会含有大量的重复代码。如果你把这些单独抽象为一个模块，其他模块只是调用它的方法，方法的调用还是会出现各个模块。</p><p>AOP会使这些服务模块化，以声明的方式应用到它们需要影响的模块去，这样其他的模块就会只关注它们自身的业务，完全不需要了解这些服务的相关逻辑和代码。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-192edc9f63db07bb2435c91e70ed46bc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-192edc9f63db07bb2435c91e70ed46bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;393&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-192edc9f63db07bb2435c91e70ed46bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-192edc9f63db07bb2435c91e70ed46bc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>看到上面的图片，我们可以把切面想象为覆盖在很多组件上的一个外壳，借助AOP可以使那些功能层去包裹核心业务层，这些功能层以声明的方式灵活的应用到系统中，其他的业务应用根本不知道它的存在。</p><p><b>写在最后</b></p><p>码字不易看到最后了，那就点个关注呗，只收藏不点关注的都是在耍流氓！</p><p>关注并私信我“架构”，免费送一些Java架构资料，先到先得！</p>", 
            "topic": [
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }, 
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70094046", 
            "userName": "Java小仙", 
            "userLink": "https://www.zhihu.com/people/170d0b73787b18aab79c1d1234ea7899", 
            "upvote": 1, 
            "title": "Synchronized锁在Spring事务管理下，为啥还线程不安全？", 
            "content": "<blockquote>开启10000个线程，每个线程给员工表的money字段【初始值是0】加1，没有使用悲观锁和乐观锁，但是在业务层方法上加了synchronized关键字，问题是代码执行完毕后数据库中的money 字段不是10000，而是小于10000 问题出在哪里？</blockquote><p>Service层代码：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-dd47bc0892b46c912818819dbfe63196_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"204\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic3.zhimg.com/v2-dd47bc0892b46c912818819dbfe63196_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;204&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"204\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic3.zhimg.com/v2-dd47bc0892b46c912818819dbfe63196_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-dd47bc0892b46c912818819dbfe63196_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>SQL代码(没有加悲观/乐观锁)：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6687585b72815bca8bf2a7f6da96b368_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-6687585b72815bca8bf2a7f6da96b368_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;143&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-6687585b72815bca8bf2a7f6da96b368_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6687585b72815bca8bf2a7f6da96b368_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>用1000个线程跑代码：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6687585b72815bca8bf2a7f6da96b368_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-6687585b72815bca8bf2a7f6da96b368_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;143&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-6687585b72815bca8bf2a7f6da96b368_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6687585b72815bca8bf2a7f6da96b368_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>简单来说：多线程跑一个使用synchronized关键字修饰的方法，方法内操作的是数据库，按正常逻辑应该最终的值是1000，但经过多次测试，结果是低于1000。这是为什么呢？</p><p>一、我的思考</p><p>既然测试出来的结果是低于1000，那说明这段代码不是线程安全的。不是线程安全的，那问题出现在哪呢？众所周知，synchronized方法能够保证所修饰的代码块、方法保证有序性、原子性、可见性。</p><p>讲道理，以上的代码跑起来，问题中Service层的increaseMoney()是有序的、原子的、可见的，所以断定跟synchronized应该没关系。</p><p>(参考我之前写过的synchronize锁笔记：Java锁机制了解一下)</p><p>既然Java层面上找不到原因，那分析一下数据库层面的吧(因为方法内操作的是数据库)。在increaseMoney()方法前加了@Transcational注解，说明这个方法是带有事务的。事务能保证同组的SQL要么同时成功，要么同时失败。讲道理，如果没有报错的话，应该每个线程都对money值进行+1。从理论上来说，结果应该是1000的才对。</p><p>(参考我之前写过的Spring事务：一文带你看懂Spring事务！)</p><p>根据上面的分析，我怀疑是提问者没测试好(hhhh，逃)，于是我也跑去测试了一下，发现是以提问者的方式来使用是真的有问题。</p><p>首先贴一下我的测试代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">@RestController\npublic class EmployeeController {\n @Autowired\n private EmployeeService employeeService;\n @RequestMapping(&#34;/add&#34;)\n public void addEmployee() {\n for (int i = 0; i &lt; 1000; i++) {\n new Thread(() -&gt; employeeService.addEmployee()).start();\n }\n }\n}\n@Service\npublic class EmployeeService {\n @Autowired\n private EmployeeRepository employeeRepository;\n @Transactional\n public synchronized void addEmployee() {\n // 查出ID为8的记录，然后每次将年龄增加一\n Employee employee = employeeRepository.getOne(8);\n System.out.println(employee);\n Integer age = employee.getAge();\n employee.setAge(age + 1);\n employeeRepository.save(employee);\n }\n}\n</code></pre></div><p>简单地打印了每次拿到的employee值，并且拿到了SQL执行的顺序，如下(贴出小部分)：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8425c34bd47f02c2897d64b8aa302394_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-8425c34bd47f02c2897d64b8aa302394_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;239&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-8425c34bd47f02c2897d64b8aa302394_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8425c34bd47f02c2897d64b8aa302394_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从打印的情况我们可以得出：多线程情况下并没有串行执行addEmployee()方法。这就导致对同一个值做重复的修改，所以最终的数值比1000要少。</p><p>二、图解出现的原因</p><p>发现并不是同步执行的，于是我就怀疑synchronized关键字和Spring肯定有点冲突。于是根据这两个关键字搜了一下，找到了问题所在。</p><p>我们知道Spring事务的底层是Spring AOP，而Spring AOP的底层是动态代理技术。跟大家一起回顾一下动态代理：</p><div class=\"highlight\"><pre><code class=\"language-text\">public static void main(String[] args) {\n // 目标对象\n Object target ;\n Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), Main.class, new InvocationHandler() {\n @Override\n public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n // 但凡带有@Transcational注解的方法都会被拦截\n // 1... 开启事务\n method.invoke(target);\n // 2... 提交事务\n return null;\n }\n });\n }\n</code></pre></div><p>(详细请参考我之前写过的动态代理：给女朋友讲解什么是代理模式)</p><p>实际上Spring做的处理跟以上的思路是一样的，我们可以看一下TransactionAspectSupport类中invokeWithinTransaction()：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-81a115d26ea7ad43bbe843e737cb76ff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-81a115d26ea7ad43bbe843e737cb76ff_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;316&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-81a115d26ea7ad43bbe843e737cb76ff_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-81a115d26ea7ad43bbe843e737cb76ff_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>调用方法前开启事务，调用方法后提交事务</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-847529faa1365b87c247a60dd55242ec_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-847529faa1365b87c247a60dd55242ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;372&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-847529faa1365b87c247a60dd55242ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-847529faa1365b87c247a60dd55242ec_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在多线程环境下，就可能会出现：方法执行完了(synchronized代码块执行完了)，事务还没提交，别的线程可以进入被synchronized修饰的方法，再读取的时候，读到的是还没提交事务的数据，这个数据不是最新的，所以就出现了这个问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-cde29db0e96feb149f53a4076fa3ff9c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-cde29db0e96feb149f53a4076fa3ff9c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;324&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-cde29db0e96feb149f53a4076fa3ff9c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-cde29db0e96feb149f53a4076fa3ff9c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>三、解决问题</p><p>从上面我们可以发现，问题所在是因为@Transcational注解和synchronized一起使用了，加锁的范围没有包括到整个事务。所以我们可以这样做：</p><p>新建一个名叫SynchronizedService类，让其去调用addEmployee()方法，整个代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">@RestController\npublic class EmployeeController {\n @Autowired\n private SynchronizedService synchronizedService ;\n @RequestMapping(&#34;/add&#34;)\n public void addEmployee() {\n for (int i = 0; i &lt; 1000; i++) {\n new Thread(() -&gt; synchronizedService.synchronizedAddEmployee()).start();\n }\n }\n}\n// 新建的Service类\n@Service\npublic class SynchronizedService {\n @Autowired\n private EmployeeService employeeService ;\n // 同步\n public synchronized void synchronizedAddEmployee() {\n employeeService.addEmployee();\n }\n}\n@Service\npublic class EmployeeService {\n @Autowired\n private EmployeeRepository employeeRepository;\n @Transactional\n public void addEmployee() {\n // 查出ID为8的记录，然后每次将年龄增加一\n Employee employee = employeeRepository.getOne(8);\n System.out.println(Thread.currentThread().getName() + employee);\n Integer age = employee.getAge();\n employee.setAge(age + 1);\n employeeRepository.save(employee);\n }\n}\n</code></pre></div><p>我们将synchronized锁的范围包含到整个Spring事务上，这就不会出现线程安全的问题了。在测试的时候，我们可以发现1000个线程跑起来比之前要慢得多，当然我们的数据是正确的：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-01369fa4fdb46d43dab2f55f3ddca7b0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"359\" data-rawheight=\"97\" class=\"content_image\" width=\"359\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;359&#39; height=&#39;97&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"359\" data-rawheight=\"97\" class=\"content_image lazy\" width=\"359\" data-actualsrc=\"https://pic1.zhimg.com/v2-01369fa4fdb46d43dab2f55f3ddca7b0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最后</p><p>可以发现的是，虽然说Spring事务用起来我们是非常方便的，但如果不了解一些Spring事务的细节，很多时候出现Bug了就百思不得其解。还是得继续加油努力呀~~~</p><p>如果想学习Java工程化、高性能及分布式、深入浅出。微服务、Spring，MyBatis，Netty源码分析的朋友可以加我的Java高级交流：787707172，群里有阿里大牛直播讲解技术，以及Java大型互联网技术的视频免费分享给大家。</p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69862758", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "阿里架构师教你如何使用ThreadLocal及原理分析", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f32d84e19247ea3202b5b3b880f25399_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic2.zhimg.com/v2-f32d84e19247ea3202b5b3b880f25399_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic2.zhimg.com/v2-f32d84e19247ea3202b5b3b880f25399_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f32d84e19247ea3202b5b3b880f25399_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>内容导航</b></p><ul><li>什么是ThreadLocal</li><li>ThreadLocal的使用</li><li>分析ThreadLocal的实现原理</li><li>ThreadLocal的应用场景及问题</li></ul><h2><b>一、什么是ThreadLocal</b></h2><p>ThreadLocal，简单翻译过来就是本地线程，但是直接这么翻译很难理解ThreadLocal的作用，如果换一种说法，可以称为线程本地存储。简单来说，就是ThreadLocal为共享变量在每个线程中都创建一个副本，每个线程可以访问自己内部的副本变量。这样做的好处是可以保证共享变量在多线程环境下访问的线程安全性</p><h2><b>二、ThreadLocal的使用演示</b></h2><p><b>ThreadLocal的使用</b></p><p>没有使用ThreadLocal时</p><p>通过一个简单的例子来演示一下ThreadLocal的作用，这段代码是定义了一个静态的成员变量 num，然后通过构造5个线程对这个 num做递增</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-66fe67aed0a9485d8e79856374ed2a55_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"634\" data-rawheight=\"348\" class=\"origin_image zh-lightbox-thumb\" width=\"634\" data-original=\"https://pic2.zhimg.com/v2-66fe67aed0a9485d8e79856374ed2a55_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;634&#39; height=&#39;348&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"634\" data-rawheight=\"348\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"634\" data-original=\"https://pic2.zhimg.com/v2-66fe67aed0a9485d8e79856374ed2a55_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-66fe67aed0a9485d8e79856374ed2a55_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>运行结果</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4eb74411b1aa964cb58a1e001797b77d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"383\" data-rawheight=\"108\" class=\"content_image\" width=\"383\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;383&#39; height=&#39;108&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"383\" data-rawheight=\"108\" class=\"content_image lazy\" width=\"383\" data-actualsrc=\"https://pic2.zhimg.com/v2-4eb74411b1aa964cb58a1e001797b77d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>每个线程都会对这个成员变量做递增，如果线程的执行顺序不确定，那么意味着每个线程获得的结果也是不一样的。</p><p><b>使用了ThreadLocal以后</b></p><p>通过ThreadLocal对上面的代码做一个改动</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1a68ba46353f450e6d27ebb2a25167b8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-1a68ba46353f450e6d27ebb2a25167b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;415&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-1a68ba46353f450e6d27ebb2a25167b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1a68ba46353f450e6d27ebb2a25167b8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>运行结果</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-56766be33ab249cfcbdc1dd25dca16f0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"456\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb\" width=\"456\" data-original=\"https://pic1.zhimg.com/v2-56766be33ab249cfcbdc1dd25dca16f0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;456&#39; height=&#39;111&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"456\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"456\" data-original=\"https://pic1.zhimg.com/v2-56766be33ab249cfcbdc1dd25dca16f0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-56766be33ab249cfcbdc1dd25dca16f0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从结果可以看到，每个线程的值都是5，意味着各个线程都是从ThreadLocal的 initialValue方法中拿到默认值0并且做了 num+=5的操作，同时也意味着每个线程从ThreadLocal中拿到的值都是0，这样使得各个线程对于共享变量num来说，是完全隔离彼此不相互影响.</p><blockquote>ThreadLocal会给定一个初始值，也就是 initialValue()方法，而每个线程都会从ThreadLocal中获得这个初始化的值的副本，这样可以使得每个线程都拥有一个副本拷贝</blockquote><h2><b>三、从源码分析ThreadLocal的实现</b></h2><p>看到这里，估计有很多人都会和我一样有一些疑问</p><ol><li>每个线程的变量副本是怎么存储的?</li><li>ThreadLocal是如何实现多线程场景下的共享变量副本隔离?</li></ol><p>带着疑问，来看一下ThreadLocal这个类的定义(默认情况下,JDK的源码都是基于1.8版本)</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4fa8e89c45a5af9b85e2b14fa0da65fb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"505\" data-rawheight=\"215\" class=\"origin_image zh-lightbox-thumb\" width=\"505\" data-original=\"https://pic4.zhimg.com/v2-4fa8e89c45a5af9b85e2b14fa0da65fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;505&#39; height=&#39;215&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"505\" data-rawheight=\"215\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"505\" data-original=\"https://pic4.zhimg.com/v2-4fa8e89c45a5af9b85e2b14fa0da65fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4fa8e89c45a5af9b85e2b14fa0da65fb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从ThreadLocal的方法定义来看,还是挺简单的。就几个方法</p><ul><li>get: 获取ThreadLocal中当前线程对应的线程局部变量</li><li>set：设置当前线程的线程局部变量的值</li><li>remove：将当前线程局部变量的值删除</li></ul><p>另外，还有一个initialValue()方法，在前面的代码中有演示，作用是返回当前线程局部变量的初始值，这个方法是一个 protected方法，主要是在构造ThreadLocal时用于设置默认的初始值</p><p>set方法的实现</p><p>set方法是设置一个线程的局部变量的值，相当于当前线程通过set设置的局部变量的值，只对当前线程可见。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8bba7f81f5494d43cf3cf5af1bf6366f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"178\" class=\"origin_image zh-lightbox-thumb\" width=\"639\" data-original=\"https://pic4.zhimg.com/v2-8bba7f81f5494d43cf3cf5af1bf6366f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;639&#39; height=&#39;178&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"178\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"639\" data-original=\"https://pic4.zhimg.com/v2-8bba7f81f5494d43cf3cf5af1bf6366f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8bba7f81f5494d43cf3cf5af1bf6366f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>Thread.currentThread 获取当前执行的线程</li><li>getMap(t) ,根据当前线程得到当前线程的ThreadLocalMap对象，这个对象具体是做什么的?稍后分析</li><li>如果map不为空，说明当前线程已经构造过ThreadLocalMap，直接将值存储到map中</li><li>如果map为空，说明是第一次使用，调用 createMap构造</li></ul><p><b>ThreadLocalMap是什么?</b></p><p>我们来分析一下这句话， ThreadLocalMapmap=getMap(t)获得一个ThreadLocalMap对象，那这个对象是干嘛的呢?</p><p>其实不用分析，基本上也能猜测出来，Map是一个集合，集合用来存储数据，那么在ThreadLocal中，应该就是用来存储线程的局部变量的。 ThreadLocalMap这个类很关键。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ebb78422587c58c2ea50a75a6b27e07e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"74\" class=\"origin_image zh-lightbox-thumb\" width=\"503\" data-original=\"https://pic3.zhimg.com/v2-ebb78422587c58c2ea50a75a6b27e07e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;503&#39; height=&#39;74&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"74\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"503\" data-original=\"https://pic3.zhimg.com/v2-ebb78422587c58c2ea50a75a6b27e07e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ebb78422587c58c2ea50a75a6b27e07e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>t.threadLocals实际上就是访问Thread类中的ThreadLocalMap这个成员变量</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bd4424f8054b2ca7dbb41f24dda72275_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"155\" class=\"origin_image zh-lightbox-thumb\" width=\"605\" data-original=\"https://pic2.zhimg.com/v2-bd4424f8054b2ca7dbb41f24dda72275_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;605&#39; height=&#39;155&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"155\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"605\" data-original=\"https://pic2.zhimg.com/v2-bd4424f8054b2ca7dbb41f24dda72275_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bd4424f8054b2ca7dbb41f24dda72275_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从上面的代码发现每一个线程都有自己单独的ThreadLocalMap实例，而对应这个线程的所有本地变量都会保存到这个map内</p><p><b>ThreadLocalMap是在哪里构造?</b></p><p>在 set方法中，有一行代码 createmap(t,value);，这个方法就是用来构造ThreadLocalMap，从传入的参数来看，它的实现逻辑基本也能猜出出几分吧</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-11651944ea88a3f8cf145b8467070e47_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"627\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb\" width=\"627\" data-original=\"https://pic4.zhimg.com/v2-11651944ea88a3f8cf145b8467070e47_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;627&#39; height=&#39;75&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"627\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"627\" data-original=\"https://pic4.zhimg.com/v2-11651944ea88a3f8cf145b8467070e47_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-11651944ea88a3f8cf145b8467070e47_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Threadt 是通过 Thread.currentThread()来获取的表示当前线程，然后直接通过 newThreadLocalMap将当前线程中的 threadLocals做了初始化</p><p>ThreadLocalMap是一个静态内部类，内部定义了一个Entry对象用来真正存储数据</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-045b23d2571fe370c4f7992291e1859c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"621\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb\" width=\"621\" data-original=\"https://pic1.zhimg.com/v2-045b23d2571fe370c4f7992291e1859c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;621&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"621\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"621\" data-original=\"https://pic1.zhimg.com/v2-045b23d2571fe370c4f7992291e1859c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-045b23d2571fe370c4f7992291e1859c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>分析到这里，基本知道了ThreadLocalMap长啥样了，也知道它是如何构造的?那么我看到这里的时候仍然有疑问</blockquote><ul><li>Entry集成了 WeakReference,这个表示什么意思?</li><li>在构造ThreadLocalMap的时候 newThreadLocalMap(this,firstValue);,key其实是this，this表示当前对象的引用，在当前的案例中，this指的是 ThreadLocal&lt;Integer&gt;local。那么多个线程对应同一个ThreadLocal实例，怎么对每一个ThreadLocal对象做区分呢？</li></ul><p><b>解惑WeakReference</b></p><p>weakReference表示弱引用，在Java中有四种引用类型，强引用、弱引用、软引用、虚引用。</p><p>使用弱引用的对象，不会阻止它所指向的对象被垃圾回收器回收。</p><p>在Java语言中, 当一个对象o被创建时, 它被放在Heap里. 当GC运行的时候, 如果发现没有任何引用指向o, o就会被回收以腾出内存空间. 也就是说, 一个对象被回收, 必须满足两个条件:</p><ul><li>没有任何引用指向它</li><li>GC被运行.</li></ul><p>这段代码中，构造了两个对象a,b，a是对象DemoA的引用，b是对象DemoB的引用，对象DemoB同时还依赖对象DemoA，那么这个时候我们认为从对象DemoB是可以到达对象DemoA的。这种称为强可达(strongly reachable)</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5628d19188b69184cae51b2d816be3b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"56\" class=\"content_image\" width=\"373\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;373&#39; height=&#39;56&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"56\" class=\"content_image lazy\" width=\"373\" data-actualsrc=\"https://pic1.zhimg.com/v2-5628d19188b69184cae51b2d816be3b4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果我们增加一行代码来将a对象的引用设置为null，当一个对象不再被其他对象引用的时候，是会被GC回收的，但是对于这个场景来说，即时是a=null，也不可能被回收，因为DemoB依赖DemoA，这个时候是可能造成内存泄漏的</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-673f3874902fb436bb7ebb055063db7b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb\" width=\"492\" data-original=\"https://pic4.zhimg.com/v2-673f3874902fb436bb7ebb055063db7b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;492&#39; height=&#39;75&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"492\" data-original=\"https://pic4.zhimg.com/v2-673f3874902fb436bb7ebb055063db7b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-673f3874902fb436bb7ebb055063db7b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>通过弱引用，有两个方法可以避免这样的问题</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-49c4638a24f554b57edc83d01ac3dd1e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"536\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb\" width=\"536\" data-original=\"https://pic3.zhimg.com/v2-49c4638a24f554b57edc83d01ac3dd1e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;536&#39; height=&#39;194&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"536\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"536\" data-original=\"https://pic3.zhimg.com/v2-49c4638a24f554b57edc83d01ac3dd1e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-49c4638a24f554b57edc83d01ac3dd1e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>对于方法2来说，DemoA只是被弱引用依赖，假设垃圾收集器在某个时间点决定一个对象是弱可达的(weakly reachable)（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后把这个弱可达对象标记为可终结(finalizable)的，这样它随后就会被回收。</p><blockquote>试想一下如果这里没有使用弱引用，意味着ThreadLocal的生命周期和线程是强绑定，只要线程没有销毁，那么ThreadLocal一直无法回收。而使用弱引用以后，当ThreadLocal被回收时，由于Entry的key是弱引用，不会影响ThreadLocal的回收防止内存泄漏，同时，在后续的源码分析中会看到，ThreadLocalMap本身的垃圾清理会用到这一个好处，方便对无效的Entry进行回收</blockquote><p><b>解惑ThreadLocalMap以this作为key</b></p><p>在构造ThreadLocalMap时，使用this作为key来存储，那么对于同一个ThreadLocal对象，如果同一个Thread中存储了多个值，是如何来区分存储的呢？</p><p>答案就在 firstKey.threadLocalHashCode&amp;(INITIAL_CAPACITY-1)</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6e2cd77e6c0ff1a714402f88f9a9b4dd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb\" width=\"605\" data-original=\"https://pic2.zhimg.com/v2-6e2cd77e6c0ff1a714402f88f9a9b4dd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;605&#39; height=&#39;226&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"605\" data-original=\"https://pic2.zhimg.com/v2-6e2cd77e6c0ff1a714402f88f9a9b4dd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6e2cd77e6c0ff1a714402f88f9a9b4dd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>关键点是 threadLocalHashCode，它相当于一个ThreadLocal的ID，实现的逻辑如下</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4e3ff51bb9d1fedc11d8e38fd5ff443b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"606\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb\" width=\"606\" data-original=\"https://pic4.zhimg.com/v2-4e3ff51bb9d1fedc11d8e38fd5ff443b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;606&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"606\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"606\" data-original=\"https://pic4.zhimg.com/v2-4e3ff51bb9d1fedc11d8e38fd5ff443b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4e3ff51bb9d1fedc11d8e38fd5ff443b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里用到了一个非常完美的散列算法，可以简单理解为，对于同一个ThreadLocal下的多个线程来说，当任意线程调用set方法存入一个数据到Entry中的时候，其实会根据 threadLocalHashCode生成一个唯一的id标识对应这个数据，存储在Entry数据下标中。</p><ul><li>threadLocalHashCode是通过</li><li>nextHashCode.getAndAdd(HASH_INCREMENT)来实现的</li><li>i*HASH_INCREMENT+HASH_INCREMENT,每次新增一个元素(ThreadLocal)到Entry[],都会自增0x61c88647,目的为了让哈希码能均匀的分布在2的N次方的数组里</li><li>Entry[i]= hashCode &amp; (length-1)</li></ul><p><b>魔数0x61c88647</b></p><p>从上面的分析可以看出，它是在上一个被构造出的ThreadLocal的threadLocalHashCode的基础上加上一个魔数0x61c88647。我们来做一个实验，看看这个散列算法的运算结果</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3b343b3f40ec32300a083f755b5c6b34_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"595\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb\" width=\"595\" data-original=\"https://pic1.zhimg.com/v2-3b343b3f40ec32300a083f755b5c6b34_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;595&#39; height=&#39;286&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"595\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"595\" data-original=\"https://pic1.zhimg.com/v2-3b343b3f40ec32300a083f755b5c6b34_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3b343b3f40ec32300a083f755b5c6b34_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>输出结果</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d293270d554478d70e89f6a0a5a79e92_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"60\" class=\"origin_image zh-lightbox-thumb\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-d293270d554478d70e89f6a0a5a79e92_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;659&#39; height=&#39;60&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"60\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-d293270d554478d70e89f6a0a5a79e92_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d293270d554478d70e89f6a0a5a79e92_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>根据运行结果，这个算法在长度为2的N次方的数组上，确实可以完美散列，没有任何冲突, 是不是很神奇。</p><blockquote>魔数0x61c88647的选取和斐波那契散列有关，<b>0x61c88647</b>对应的十进制为1640531527。而斐波那契散列的乘数可以用 (long)((1L&lt;&lt;31)*(Math.sqrt(5)-1)); 如果把这个值给转为带符号的int，则会得到-1640531527。也就是说(long)((1L&lt;&lt;31)*(Math.sqrt(5)-1));得到的结果就是1640531527，也就是魔数<b>0x61c88647</b></blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-243bb6d59a927d71c9fda268b9267dbb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"619\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb\" width=\"619\" data-original=\"https://pic4.zhimg.com/v2-243bb6d59a927d71c9fda268b9267dbb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;619&#39; height=&#39;119&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"619\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"619\" data-original=\"https://pic4.zhimg.com/v2-243bb6d59a927d71c9fda268b9267dbb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-243bb6d59a927d71c9fda268b9267dbb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>总结，我们用0x61c88647作为魔数累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀。</p><p><b>图形分析</b></p><p>为了更直观的体现 set方法的实现，通过一个图形表示如下</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7ea09ed5365d3f2b653dd79be9cffa80_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"265\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-7ea09ed5365d3f2b653dd79be9cffa80_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;265&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"265\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-7ea09ed5365d3f2b653dd79be9cffa80_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7ea09ed5365d3f2b653dd79be9cffa80_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>set剩余源码分析</b></p><p>前面分析了set方法第一次初始化ThreadLocalMap的过程，也对ThreadLocalMap的结构有了一个全面的了解。那么接下来看一下map不为空时的执行逻辑</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-777543747526aa18e510723aaee4414a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-777543747526aa18e510723aaee4414a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;542&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-777543747526aa18e510723aaee4414a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-777543747526aa18e510723aaee4414a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>主要逻辑</p><ul><li>根据key的散列哈希计算Entry的数组下标</li><li>通过线性探索探测从i开始往后一直遍历到数组的最后一个Entry</li><li>如果map中的key和传入的key相等，表示该数据已经存在，直接覆盖</li><li>如果map中的key为空，则用新的key、value覆盖，并清理key=null的数据</li><li>rehash扩容</li></ul><p><b>replaceStaleEntry</b></p><p>由于Entry的key为弱引用，如果key为空，说明ThreadLocal这个对象被GC回收了。 replaceStaleEntry的作用就是把陈旧的Entry进行替换</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-15eb089feeae23825f72e16dbe42d169_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"895\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-15eb089feeae23825f72e16dbe42d169_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;895&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"895\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-15eb089feeae23825f72e16dbe42d169_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-15eb089feeae23825f72e16dbe42d169_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>cleanSomeSlots</b></p><p>这个函数有两处地方会被调用，用于清理无效的Entry</p><ul><li>插入的时候可能会被调用</li><li>替换无效slot的时候可能会被调用</li></ul><p>区别是前者传入的n为元素个数，后者为table的容量</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fb7856ee78cb4971c0dff3612838daee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-fb7856ee78cb4971c0dff3612838daee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;319&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-fb7856ee78cb4971c0dff3612838daee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-fb7856ee78cb4971c0dff3612838daee_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>expungeStaleEntry</b></p><p>执行一次全量清理</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7c84588b90ff60154fc192ec1af22900_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"646\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-7c84588b90ff60154fc192ec1af22900_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;646&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"646\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-7c84588b90ff60154fc192ec1af22900_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7c84588b90ff60154fc192ec1af22900_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>get操作</b></p><p>set的逻辑分析完成以后，get的源码分析就很简单了</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-44c2bd4149135f78cc64ebcc1b149829_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-44c2bd4149135f78cc64ebcc1b149829_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;320&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-44c2bd4149135f78cc64ebcc1b149829_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-44c2bd4149135f78cc64ebcc1b149829_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>setInitialValue</b></p><p>根据 initialValue()的value初始化ThreadLocalMap</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d5682ca75cff3761fea848f031787437_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-d5682ca75cff3761fea848f031787437_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-d5682ca75cff3761fea848f031787437_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d5682ca75cff3761fea848f031787437_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>从当前线程中获取ThreadLocalMap，查询当前ThreadLocal变量实例对应的Entry，如果不为null,获取value,返回</li><li>如果map为null,即还没有初始化，走初始化方法</li></ul><p><b>remove方法</b></p><p>remove的方法比较简单，从Entry[]中删除指定的key就行</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-eaa9ff375438a04d678c53742ba5fb78_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"381\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-eaa9ff375438a04d678c53742ba5fb78_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;381&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"381\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-eaa9ff375438a04d678c53742ba5fb78_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-eaa9ff375438a04d678c53742ba5fb78_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>四、ThreadLocal的应用场景及问题</b></h2><p><b>应用场景</b></p><p>ThreadLocal的实际应用场景：</p><ol><li>比如在线程级别，维护session,维护用户登录信息userID（登陆时插入，多个地方获取）</li><li>数据库的链接对象 Connection，可以通过ThreadLocal来做隔离避免线程安全问题</li></ol><p>问题</p><blockquote>ThreadLocal的内存泄漏</blockquote><p>ThreadLocalMap中Entry的key使用的是ThreadLocal的弱引用，如果一个ThreadLocal没有外部强引用，当系统执行GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现一个key为null的Entry，而这个key=null的Entry是无法访问的，当这个线程一直没有结束的话，那么就会存在一条强引用链</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4d7ff11f04941cb7572c6b1422f5f7a0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"604\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb\" width=\"604\" data-original=\"https://pic1.zhimg.com/v2-4d7ff11f04941cb7572c6b1422f5f7a0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;604&#39; height=&#39;314&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"604\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"604\" data-original=\"https://pic1.zhimg.com/v2-4d7ff11f04941cb7572c6b1422f5f7a0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4d7ff11f04941cb7572c6b1422f5f7a0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Thread Ref - &gt; Thread -&gt; ThreadLocalMap - &gt; Entry -&gt; value 永远无法回收而造成内存泄漏</p><blockquote>其实我们从源码分析可以看到，ThreadLocalMap是做了防护措施的</blockquote><ul><li>首先从ThreadLocal的直接索引位置(通过</li><li>ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e</li><li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li></ul><p>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</p><p>但是这个设计一来与一个前提条件，就是调用get或者set方法，但是不是所有场景都会满足这个场景的，所以为了避免这类的问题，我们可以在合适的位置手动调用ThreadLocal的remove函数删除不需要的ThreadLocal，防止出现内存泄漏</p><blockquote>所以建议的使用方法是</blockquote><ul><li>将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露</li><li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</li></ul>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "编程语言", 
                    "tagLink": "https://api.zhihu.com/topics/19552826"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69807037", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 1, 
            "title": "放下手中的事情，来了解下什么是分布式锁？", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c24a0ca11d532b7168aa446d3e4bacb7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-c24a0ca11d532b7168aa446d3e4bacb7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-c24a0ca11d532b7168aa446d3e4bacb7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c24a0ca11d532b7168aa446d3e4bacb7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2295a0a45b8c5710cef42620579f8e47_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-2295a0a45b8c5710cef42620579f8e47_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-2295a0a45b8c5710cef42620579f8e47_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2295a0a45b8c5710cef42620579f8e47_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>————— 第二天 —————</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1812dcfb16890ef6c2086e296260f52b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-1812dcfb16890ef6c2086e296260f52b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-1812dcfb16890ef6c2086e296260f52b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1812dcfb16890ef6c2086e296260f52b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-359d3ecaf0b4225f769df66d290dc85d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-359d3ecaf0b4225f769df66d290dc85d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-359d3ecaf0b4225f769df66d290dc85d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-359d3ecaf0b4225f769df66d290dc85d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7d1204cb0d838dc4c111f5f1101551eb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-7d1204cb0d838dc4c111f5f1101551eb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-7d1204cb0d838dc4c111f5f1101551eb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7d1204cb0d838dc4c111f5f1101551eb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3ae5901163f05723d848baefcd002066_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-3ae5901163f05723d848baefcd002066_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-3ae5901163f05723d848baefcd002066_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3ae5901163f05723d848baefcd002066_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7483fa4efeaea08bde4ae68d2ca423b0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-7483fa4efeaea08bde4ae68d2ca423b0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-7483fa4efeaea08bde4ae68d2ca423b0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7483fa4efeaea08bde4ae68d2ca423b0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d5c2ba85e0f5f179e0d679b1f6b2f83e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-d5c2ba85e0f5f179e0d679b1f6b2f83e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;556&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-d5c2ba85e0f5f179e0d679b1f6b2f83e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d5c2ba85e0f5f179e0d679b1f6b2f83e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-401d9d19ad365c840daf78fca574f558_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-401d9d19ad365c840daf78fca574f558_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-401d9d19ad365c840daf78fca574f558_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-401d9d19ad365c840daf78fca574f558_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d594c6d6d6c7c47e56cfa722fa880292_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic3.zhimg.com/v2-d594c6d6d6c7c47e56cfa722fa880292_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;567&#39; height=&#39;341&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"567\" data-original=\"https://pic3.zhimg.com/v2-d594c6d6d6c7c47e56cfa722fa880292_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d594c6d6d6c7c47e56cfa722fa880292_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f456a937c8eef9b63ee8c99b2cf51752_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-f456a937c8eef9b63ee8c99b2cf51752_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-f456a937c8eef9b63ee8c99b2cf51752_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f456a937c8eef9b63ee8c99b2cf51752_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e269c13adf3fa0d82cef589f96f3da13_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-e269c13adf3fa0d82cef589f96f3da13_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-e269c13adf3fa0d82cef589f96f3da13_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e269c13adf3fa0d82cef589f96f3da13_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1407ead54c43bea25bb3e0de67c5f286_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-1407ead54c43bea25bb3e0de67c5f286_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-1407ead54c43bea25bb3e0de67c5f286_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1407ead54c43bea25bb3e0de67c5f286_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>————————————</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-90b816f531051ef182491279d0dcbd75_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-90b816f531051ef182491279d0dcbd75_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-90b816f531051ef182491279d0dcbd75_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-90b816f531051ef182491279d0dcbd75_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4c78f11134102013897bf53e5f52412e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-4c78f11134102013897bf53e5f52412e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-4c78f11134102013897bf53e5f52412e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4c78f11134102013897bf53e5f52412e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7247d616806354781487daa709547dca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-7247d616806354781487daa709547dca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-7247d616806354781487daa709547dca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7247d616806354781487daa709547dca_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-436bfb3bc6d62ea7bce3de3a4fedf0f7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-436bfb3bc6d62ea7bce3de3a4fedf0f7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-436bfb3bc6d62ea7bce3de3a4fedf0f7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-436bfb3bc6d62ea7bce3de3a4fedf0f7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-dc10fe0c582a180d9b0125cc9f889f87_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-dc10fe0c582a180d9b0125cc9f889f87_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-dc10fe0c582a180d9b0125cc9f889f87_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-dc10fe0c582a180d9b0125cc9f889f87_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-eed7af48afc0b995b880c75fa555a7f7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-eed7af48afc0b995b880c75fa555a7f7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-eed7af48afc0b995b880c75fa555a7f7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-eed7af48afc0b995b880c75fa555a7f7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>分布式锁的实现有哪些？</b></p><p><b>1.Memcached分布式锁</b></p><p>利用Memcached的<b>add命令</b>。此命令是原子性操作，只有在key不存在的情况下，才能add成功，也就意味着线程得到了锁。</p><p><b>2.Redis分布式锁</b></p><p>和Memcached的方式类似，利用Redis的<b>setnx命令</b>。此命令同样是原子性操作，只有在key不存在的情况下，才能set成功。（setnx命令并不完善，后续会介绍替代方案）</p><p><b>3.Zookeeper分布式锁</b></p><p>利用Zookeeper的<b>顺序临时节点</b>，来实现分布式锁和等待队列。Zookeeper设计的初衷，就是为了实现分布式锁服务的。</p><p><b>4.Chubby</b></p><p>Google公司实现的粗粒度分布式锁服务，底层利用了Paxos一致性算法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1de46eccd565075851f6e346e7fc609e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-1de46eccd565075851f6e346e7fc609e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-1de46eccd565075851f6e346e7fc609e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1de46eccd565075851f6e346e7fc609e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-150415f90351eda6329123dc2deda2f8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-150415f90351eda6329123dc2deda2f8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-150415f90351eda6329123dc2deda2f8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-150415f90351eda6329123dc2deda2f8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>如何用Redis实现分布式锁？</b></p><p>Redis分布式锁的基本流程并不难理解，但要想写得尽善尽美，也并不是那么容易。在这里，我们需要先了解分布式锁实现的三个核心要素：</p><p><b>1.加锁</b></p><p>最简单的方法是使用setnx命令。key是锁的唯一标识，按业务来决定命名。比如想要给一种商品的秒杀活动加锁，可以给key命名为 “lock_sale_商品ID” 。而value设置成什么呢？我们可以姑且设置成1。加锁的伪代码如下：</p><p><b>setnx（key，1）</b></p><p>当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败。</p><p><b>2.解锁</b></p><p>有加锁就得有解锁。当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式是执行del指令，伪代码如下：</p><p><b>del（key）</b></p><p>释放锁之后，其他线程就可以继续执行setnx命令来获得锁。</p><p><b>3.锁超时</b></p><p>锁超时是什么意思呢？如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住，别的线程再也别想进来。</p><p>所以，setnx的key必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放。setnx不支持超时参数，所以需要额外的指令，伪代码如下：</p><p><b>expire（key， 30）</b></p><p>综合起来，我们分布式锁实现的第一版伪代码如下：</p><p><b>if（setnx（key，1） == 1）{</b></p><p><b>expire（key，30）</b></p><p><b>try {</b></p><p><b>do something ......</b></p><p><b>} finally {</b></p><p><b>del（key）</b></p><p><b>}</b></p><p><b>}</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5cfd884edece286582dec793379c01a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-5cfd884edece286582dec793379c01a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-5cfd884edece286582dec793379c01a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5cfd884edece286582dec793379c01a2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-184b33df3dacd6d3f2a8a2a93e0a82f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-184b33df3dacd6d3f2a8a2a93e0a82f6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-184b33df3dacd6d3f2a8a2a93e0a82f6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-184b33df3dacd6d3f2a8a2a93e0a82f6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a29800f891b14e58a623273438594929_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-a29800f891b14e58a623273438594929_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-a29800f891b14e58a623273438594929_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a29800f891b14e58a623273438594929_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>好端端的代码，怎么就回家等通知了呢？</p><p>因为上面的伪代码中，存在着三个致命问题：</p><p><b>1. setnx和expire的非原子性</b></p><p>设想一个极端场景，当某线程执行setnx，成功得到了锁：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f4efe2df2df8dcc19ebc93d786fd23a3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic4.zhimg.com/v2-f4efe2df2df8dcc19ebc93d786fd23a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;567&#39; height=&#39;341&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"567\" data-original=\"https://pic4.zhimg.com/v2-f4efe2df2df8dcc19ebc93d786fd23a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f4efe2df2df8dcc19ebc93d786fd23a3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>setnx刚执行成功，还未来得及执行expire指令，节点1 Duang的一声挂掉了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-65358e8129dad8a513d09f60ca59c439_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"585\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb\" width=\"585\" data-original=\"https://pic2.zhimg.com/v2-65358e8129dad8a513d09f60ca59c439_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;585&#39; height=&#39;341&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"585\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"585\" data-original=\"https://pic2.zhimg.com/v2-65358e8129dad8a513d09f60ca59c439_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-65358e8129dad8a513d09f60ca59c439_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样一来，这把锁就没有设置过期时间，变得“长生不老”，别的线程再也无法获得锁了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>怎么解决呢？setnx指令本身是不支持传入超时时间的，幸好Redis 2.6.12以上版本为<b>set</b>指令增加了可选参数，伪代码如下：</p><p><b>set（key，1，30，NX）</b></p><p>这样就可以取代setnx指令。</p><p><b>2. del 导致误删</b></p><p>又是一个极端场景，假如某线程成功得到了锁，并且设置的超时时间是30秒。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-63bb47cf1e5f3adc647a803ad3ab0d54_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic1.zhimg.com/v2-63bb47cf1e5f3adc647a803ad3ab0d54_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;567&#39; height=&#39;341&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"567\" data-original=\"https://pic1.zhimg.com/v2-63bb47cf1e5f3adc647a803ad3ab0d54_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-63bb47cf1e5f3adc647a803ad3ab0d54_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果某些原因导致线程A执行的很慢很慢，过了30秒都没执行完，这时候锁过期自动释放，线程B得到了锁。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a90681aa4c082c620139fc7dbfa2c9b5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic2.zhimg.com/v2-a90681aa4c082c620139fc7dbfa2c9b5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;567&#39; height=&#39;341&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"567\" data-original=\"https://pic2.zhimg.com/v2-a90681aa4c082c620139fc7dbfa2c9b5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a90681aa4c082c620139fc7dbfa2c9b5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>随后，线程A执行完了任务，线程A接着执行del指令来释放锁。但这时候线程B还没执行完，<b>线程A实际上删除的是线程B加的锁</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-50f0b44fbd9c8575c2baffde00dc0cda_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic3.zhimg.com/v2-50f0b44fbd9c8575c2baffde00dc0cda_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;567&#39; height=&#39;341&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"567\" data-original=\"https://pic3.zhimg.com/v2-50f0b44fbd9c8575c2baffde00dc0cda_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-50f0b44fbd9c8575c2baffde00dc0cda_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>怎么避免这种情况呢？可以在del释放锁之前做一个判断，验证当前的锁是不是自己加的锁。</p><p>至于具体的实现，可以在加锁的时候把当前的线程ID当做value，并在删除之前验证key对应的value是不是自己线程的ID。</p><p>加锁：</p><p><b>String threadId = Thread.currentThread().getId()</b></p><p><b>set（key，threadId ，30，NX）</b></p><p>解锁：</p><p><b>if（threadId .equals(redisClient.get(key))）{</b></p><p><b>del(key)</b></p><p><b>}</b></p><p>但是，这样做又隐含了一个新的问题，<b>判断和释放锁是两个独立操作，不是原子性</b>。</p><p>我们都是追求极致的程序员，所以这一块要用Lua脚本来实现：</p><p><b>String luaScript = &#34;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&#34;;</b></p><p><b>redisClient.eval(luaScript , Collections.singletonList(key), Collections.singletonList(threadId));</b></p><p>这样一来，验证和删除过程就是原子操作了。</p><p><b>3. 出现并发的可能性</b></p><p>还是刚才第二点所描述的场景，虽然我们避免了线程A误删掉key的情况，但是同一时间有A，B两个线程在访问代码块，仍然是不完美的。</p><p>怎么办呢？我们可以让获得锁的线程开启一个<b>守护线程</b>，用来给快要过期的锁“续航”。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ed5e95053c0d88d14db2da9b25fa135e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic3.zhimg.com/v2-ed5e95053c0d88d14db2da9b25fa135e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;567&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"567\" data-original=\"https://pic3.zhimg.com/v2-ed5e95053c0d88d14db2da9b25fa135e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ed5e95053c0d88d14db2da9b25fa135e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>当过去了29秒，线程A还没执行完，这时候守护线程会执行expire指令，为这把锁“续命”20秒。守护线程从第29秒开始执行，每20秒执行一次。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3d9fb54d5cf679b331a079db78eb48d0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic1.zhimg.com/v2-3d9fb54d5cf679b331a079db78eb48d0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;567&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"567\" data-original=\"https://pic1.zhimg.com/v2-3d9fb54d5cf679b331a079db78eb48d0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3d9fb54d5cf679b331a079db78eb48d0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>当线程A执行完任务，会显式关掉守护线程。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b49dc05b0d905545554b923a5b83a38b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic4.zhimg.com/v2-b49dc05b0d905545554b923a5b83a38b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;567&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"567\" data-original=\"https://pic4.zhimg.com/v2-b49dc05b0d905545554b923a5b83a38b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b49dc05b0d905545554b923a5b83a38b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>另一种情况，如果节点1 忽然断电，由于线程A和守护线程在同一个进程，守护线程也会停下。这把锁到了超时的时候，没人给它续命，也就自动释放了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c0ac9e7957a7e06b4e5f997153ee0bc6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"585\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"585\" data-original=\"https://pic3.zhimg.com/v2-c0ac9e7957a7e06b4e5f997153ee0bc6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;585&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"585\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"585\" data-original=\"https://pic3.zhimg.com/v2-c0ac9e7957a7e06b4e5f997153ee0bc6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c0ac9e7957a7e06b4e5f997153ee0bc6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>守护线程的代码并不难实现，有了大体思路，大家可以自己尝试实现一下。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f63ee862a4dd9c64fcceee565ab32f36_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-f63ee862a4dd9c64fcceee565ab32f36_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-f63ee862a4dd9c64fcceee565ab32f36_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f63ee862a4dd9c64fcceee565ab32f36_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-36d5f8ece862e534e2cab32fb86c933a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-36d5f8ece862e534e2cab32fb86c933a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-36d5f8ece862e534e2cab32fb86c933a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-36d5f8ece862e534e2cab32fb86c933a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-87ac5c48181a82059b151611a5e4f518_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-87ac5c48181a82059b151611a5e4f518_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-87ac5c48181a82059b151611a5e4f518_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-87ac5c48181a82059b151611a5e4f518_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>几点补充：</b></p><p><b>漫画纯属娱乐，为了减轻工作压力，还请大家尽量珍惜当下的工作，切勿模仿小灰的行为哦。</b></p><p>要是感觉对Java技术，架构技术感兴趣的朋友，欢迎加QQ群728821520，一起学习。</p>", 
            "topic": [
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "沙发！通俗易懂，帮我把困扰的setnx搞通了", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69801815", 
            "userName": "Java小仙", 
            "userLink": "https://www.zhihu.com/people/170d0b73787b18aab79c1d1234ea7899", 
            "upvote": 3, 
            "title": "synchronized到底锁住的是谁？", 
            "content": "<p><b>题目：利用5个线程并发执行，num数字累计计数到10000，并打印。</b></p><div class=\"highlight\"><pre><code class=\"language-text\"> 1 /**\n 2 * Description:\n 3 * 利用5个线程并发执行，num数字累加计数到10000，并打印。\n 4 * 2019-06-13\n 5 * Created with OKevin.\n 6 */\n 7 public class Count {\n 8 private int num = 0;\n 9 \n10 public static void main(String[] args) throws InterruptedException {\n11 Count count = new Count();\n12 \n13 Thread thread1 = new Thread(count.new MyThread());\n14 Thread thread2 = new Thread(count.new MyThread());\n15 Thread thread3 = new Thread(count.new MyThread());\n16 Thread thread4 = new Thread(count.new MyThread());\n17 Thread thread5 = new Thread(count.new MyThread());\n18 thread1.start();\n19 thread2.start();\n20 thread3.start();\n21 thread4.start();\n22 thread5.start();\n23 thread1.join();\n24 thread2.join();\n25 thread3.join();\n26 thread4.join();\n27 thread5.join();\n28 \n29 System.out.println(count.num);\n30 \n31 }\n32 \n33 private synchronized void increse() {\n34 for (int i = 0; i &lt; 2000; i++) {\n35 num++;\n36 }\n37 }\n38 \n39 class MyThread implements Runnable {\n40 @Override\n41 public void run() {\n42 increse();\n43 }\n44 }\n45 }\n</code></pre></div><p>这道<b>校招级</b>的并发编程面试题，题目不难，方法简单。其中涉及一个核心知识点——synchronized（当然这题的解法有很多），这也是本文想要弄清的主题。</p><p>synchronized被大大小小的程序员广泛使用，有的程序员偷懒，在要求保证线程安全时，不加思索的就在方法前加入了synchronized关键字（例如我刚才那道<b>校招级</b>大题）。偷懒归偷懒，CodeReview总是要进行的，面对同事的“指责”，要求优化这个方法，将synchronized使用同步代码块的方式提高效率。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a04197af6faa98f7dfa02d139841779f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic4.zhimg.com/v2-a04197af6faa98f7dfa02d139841779f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;489&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic4.zhimg.com/v2-a04197af6faa98f7dfa02d139841779f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a04197af6faa98f7dfa02d139841779f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>synchronized要按照同步代码块来保证线程安全，这可就加在方法“复杂”多了。有：synchronized(this){}这么写的，也有synchronized(Count.class){}这么写的，还有定义了一个private Object obj = new Object; ….synchronized(obj){}这么写的。此时不禁在心里“W*F”。</p><p>synchronized你到底锁住的是谁？</p><p>synchronized从语法的维度一共有3个用法：</p><ol><li>静态方法加上关键字</li><li>实例方法（也就是普通方法）加上关键字</li><li>方法中使用同步代码块</li></ol><p>前两种方式最为偷懒，第三种方式比前两种性能要好。</p><p>synchronized从锁的是谁的维度一共有两种情况：</p><ol><li>锁住类</li><li>锁住对象实例</li></ol><p>我们还是从直观的语法结构上来讲述synchronized。</p><p><b>1）静态方法上的锁</b></p><p>静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，<b>锁住的就是这个类</b>。</p><p><b>2）实例方法（普通方法）上的锁</b></p><p>实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。这也比较能推出，在实例方法上加入synchronized，那么它获取的就是这个累的锁，<b>锁住的就是这个对象实例</b>。</p><p>那锁住类还是锁住对象实例，这跟我线程安全关系大吗？大，差之毫厘谬以千里的大。为了更好的理解锁住类还是锁住对象实例，在进入“3）方法中使用同步代码块”前，先直观的感受下这两者的区别。</p><p><b>对实例方法（普通方法）上加关键字锁住对象实例锁的解释</b></p><p>首先定义一个Demo类，其中的实例方法加上了synchronized关键字，按照所述也就是说锁住的对象实例。</p><div class=\"highlight\"><pre><code class=\"language-text\"> 1 /**\n 2 * Description:\n 3 * 死循环，目的是两个线程抢占一个锁时，只要其中一个线程获取，另一个线程就会一直阻塞\n 4 * 2019-06-13\n 5 * Created with OKevin.\n 6 */\n 7 public class Demo {\n 8 \n 9 public synchronized void demo() {\n10 while (true) { //synchronized方法内部是一个死循环，一旦一个线程持有过后就不会释放这个锁\n11 System.out.println(Thread.currentThread());\n12 }\n13 }\n14 }\n</code></pre></div><p>可以看到在demo方法中定义了一个死循环，一旦一个线程持有这个锁后其他线程就不可能获取这个锁。结合上述synchronized修饰实例方法锁住的是对象实例，如果两个线程针对的是一个对象实例，那么其中一个线程必然不可能获取这个锁；如果两个线程针对的是两个对象实例，那么这两个线程不相关均能获取这个锁。</p><p>自定义线程，调用demo方法。</p><div class=\"highlight\"><pre><code class=\"language-text\"> 1 /**\n 2 * Description:\n 3 * 自定义线程\n 4 * 2019-06-13\n 5 * Created with OKevin.\n 6 */\n 7 public class MyThread implements Runnable {\n 8 private Demo demo;\n 9 \n10 public MyThread(Demo demo) {\n11 this.demo = demo;\n12 }\n13 \n14 @Override\n15 public void run() {\n16 demo.demo();\n17 }\n18 }\n</code></pre></div><p><b>测试程序1：两个线程抢占一个对象实例的锁</b></p><div class=\"highlight\"><pre><code class=\"language-text\"> 1 /**\n 2 * Description:\n 3 * 两个线程抢占一个对象实例的锁\n 4 * 2019-06-13\n 5 * Created with OKevin.\n 6 */\n 7 public class Main1 {\n 8 public static void main(String[] args) {\n 9 Demo demo = new Demo();\n10 Thread thread1 = new Thread(new MyThread(demo));\n11 Thread thread2 = new Thread(new MyThread(demo));\n12 thread1.start();\n13 thread2.start();\n14 }\n15 }\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a336c095486edbda53fb2b9cf696ebef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"634\" class=\"origin_image zh-lightbox-thumb\" width=\"492\" data-original=\"https://pic4.zhimg.com/v2-a336c095486edbda53fb2b9cf696ebef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;492&#39; height=&#39;634&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"634\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"492\" data-original=\"https://pic4.zhimg.com/v2-a336c095486edbda53fb2b9cf696ebef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a336c095486edbda53fb2b9cf696ebef_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如上图所示，输出结果显然只会打印一个线程的信息，另一个线程永远也获取不到这个锁。</p><p><b>测试程序2：两个线程分别抢占两个对象实例的锁</b></p><div class=\"highlight\"><pre><code class=\"language-text\"> 1 /**\n 2 * Description:\n 3 * 两个线程分别抢占两个对象实例的锁\n 4 * 2019-06-13\n 5 * Created with OKevin.\n 6 */\n 7 public class Main2 {\n 8 public static void main(String[] args) {\n 9 Demo demo1 = new Demo();\n10 Demo demo2 = new Demo();\n11 Thread thread1 = new Thread(new MyThread(demo1));\n12 Thread thread2 = new Thread(new MyThread(demo2));\n13 thread1.start();\n14 thread2.start();\n15 }\n16 }\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-756429a190370918d5e51ac05071285b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"524\" data-rawheight=\"666\" class=\"origin_image zh-lightbox-thumb\" width=\"524\" data-original=\"https://pic4.zhimg.com/v2-756429a190370918d5e51ac05071285b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;524&#39; height=&#39;666&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"524\" data-rawheight=\"666\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"524\" data-original=\"https://pic4.zhimg.com/v2-756429a190370918d5e51ac05071285b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-756429a190370918d5e51ac05071285b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如上图所示，显然，两个线程均进入到了demo方法，也就是均获取到了锁，证明，两个线程抢占的就不是同一个锁，这就是<b>synchronized修饰实例方法时，锁住的是对象实例的解释。</b></p><p><b>对静态方法上加关键字锁住类锁的解释</b></p><p>静态方法是类所有对象实例所共享的，无论定义多少个实例，是要是静态方法上的锁，它至始至终只有1个。将上面的程序Demo中的方法加上static，无论使用“测试程序1”还是“测试程序2”，均只有一个线程可以抢占到锁，另一个线程仍然是永远无法获取到锁。</p><p>让我们重新回到从语法结构上解释synchronized。</p><p><b>3）方法中使用同步代码块</b></p><p>程序的改良优化需要建立在有坚实的基础，如果在不了解其内部机制，改良也仅仅是“形式主义”。</p><p>结合开始CodeReview的例子：</p><p>你的同事在CodeReview时，要求你将实例方法上的synchronized，改为效率更高的同步代码块方式。在你不清楚同步代码的用法时，网上搜到了一段synchronized(this){}代码，复制下来发现也能用，此时你以为你改良优化了代码。但实际上，你可能只是做了一点形式主义上的优化。</p><p>为什么这么说？这需要清楚地认识同步代码块到底应该怎么用。</p><p><b>3.1）synchronized(this){...}</b></p><p>this关键字所代表的意思是该对象实例，换句话说，这种用法synchronized锁住的仍然是对象实例，他和public synchronized void demo(){}可以说仅仅是做了语法上的改变。</p><div class=\"highlight\"><pre><code class=\"language-text\"> 1 /**\n 2 * 2019-06-13\n 3 * Created with OKevin.\n 4 **/\n 5 public class Demo {\n 6 \n 7 public synchronized void demo1() {\n 8 while (true) { //死循环目的是为了让线程一直持有该锁\n 9 System.out.println(Thread.currentThread());\n10 }\n11 }\n12 \n13 public synchronized void demo2() {\n14 while (true) {\n15 System.out.println(Thread.currentThread());\n16 }\n17 }\n18 }\n</code></pre></div><p>改为以下方式：</p><div class=\"highlight\"><pre><code class=\"language-text\"> 1 /**\n 2 * Description:\n 3 * synchronized同步代码块对本实例加锁（this）\n 4 * 假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，只要其中一个线程获取到了锁即执行了demo1或者demo2，此时另一个线程会永远处于阻塞状态\n 5 * 2019-06-13\n 6 * Created with OKevin.\n 7 */\n 8 public class Demo {\n 9 \n10 public void demo1() {\n11 synchronized (this) {\n12 while (true) { //死循环目的是为了让线程一直持有该锁\n13 System.out.println(Thread.currentThread());\n14 }\n15 }\n16 }\n17 \n18 public void demo2() {\n19 synchronized (this) {\n20 while (true) {\n21 System.out.println(Thread.currentThread());\n22 }\n23 }\n24 }\n25 }\n</code></pre></div><p>也许后者在JVM中可能会做一些特殊的优化，但从代码分析上来讲，两者并没有做到很大的优化，线程1执行demo1，线程2执行demo2，由于两个方法均是抢占对象实例的锁，只要有一个线程获取到锁，另外一个线程只能阻塞等待，即使两个方法不相关。</p><p><b>3.2）private Object obj = new Object(); synchronized(obj){...}</b></p><div class=\"highlight\"><pre><code class=\"language-text\"> 1 /**\n 2 * Description:\n 3 * synchronized同步代码块对对象内部的实例加锁\n 4 * 假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，均能获取各自的锁\n 5 * 2019-06-13\n 6 * Created with OKevin.\n 7 */\n 8 public class Demo {\n 9 private Object lock1 = new Object();\n10 private Object lock2 = new Object();\n11 \n12 public void demo1() {\n13 synchronized (lock1) {\n14 while (true) { //死循环目的是为了让线程一直持有该锁\n15 System.out.println(Thread.currentThread());\n16 }\n17 }\n18 }\n19 \n20 public void demo2() {\n21 synchronized (lock2) {\n22 while (true) {\n23 System.out.println(Thread.currentThread());\n24 }\n25 }\n26 }\n27 }\n</code></pre></div><p>经过上面的分析，看到这里，你可能会开始懂了，可以看到demo1方法中的同步代码块锁住的是lock1对象实例，demo2方法中的同步代码块锁住的是lock2对象实例。如果线程1执行demo1，线程2执行demo2，由于两个方法抢占的是不同的对象实例锁，也就是说两个线程均能获取到锁执行各自的方法（当然前提是两个方法互不相关，才不会出现逻辑错误）。</p><p><b>3.3)synchronized(Demo.class){...}</b></p><p>这种形式等同于抢占获取类锁，这种方式，同样和3.1一样，收效甚微。</p><p><b>所以CodeReivew后的代码应该是3.2) private Object obj = new Object(); synchronized(obj){...}，这才是对你代码的改良优化。</b></p><p><b>如果想学习Java工程化、高性能及分布式、深入浅出。微服务、Spring，MyBatis，Netty源码分析的朋友可以加我的Java高级交流：787707172，群里有阿里大牛直播讲解技术，以及Java大型互联网技术的视频免费分享给大家。</b></p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "shallow", 
                    "userLink": "https://www.zhihu.com/people/c5ff8f81f1450ec08662d4acd5388d0b", 
                    "content": "老哥，代码风格可以写工整一点吗，深夜看文要瞎了[飙泪笑][飙泪笑]", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69638683", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 5, 
            "title": "如何用Zookeeper实现分布式锁？", 
            "content": "<p>小灰介绍了如何使用redis实现分布式锁。</p><p>那么，如何用Zookeeper来实现分布式锁呢？</p><p>这一次我们会为大家详细讲述。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3814e657e55a82623be6950344da621d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic2.zhimg.com/v2-3814e657e55a82623be6950344da621d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic2.zhimg.com/v2-3814e657e55a82623be6950344da621d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3814e657e55a82623be6950344da621d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7987b6a0f5e60d7af40ac410628c8f14_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic1.zhimg.com/v2-7987b6a0f5e60d7af40ac410628c8f14_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic1.zhimg.com/v2-7987b6a0f5e60d7af40ac410628c8f14_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7987b6a0f5e60d7af40ac410628c8f14_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>什么是临时顺序节点？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>让我们来回顾一下Zookeeper节点的概念：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><b><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e2619266f025654313556cb198ae81a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"648\" data-original=\"https://pic1.zhimg.com/v2-e2619266f025654313556cb198ae81a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;648&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"648\" data-original=\"https://pic1.zhimg.com/v2-e2619266f025654313556cb198ae81a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e2619266f025654313556cb198ae81a4_b.jpg\"/></figure></b><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Zookeeper的数据存储结构就像一棵树，这棵树由节点组成，这种节点叫做Znode。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Znode分为四种类型：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.持久节点 （PERSISTENT）</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2.持久节点顺序节点（PERSISTENT_SEQUENTIAL）</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a2382efd25e0a3a518b2bdd7e3bb47a0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"451\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb\" width=\"451\" data-original=\"https://pic1.zhimg.com/v2-a2382efd25e0a3a518b2bdd7e3bb47a0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;451&#39; height=&#39;247&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"451\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"451\" data-original=\"https://pic1.zhimg.com/v2-a2382efd25e0a3a518b2bdd7e3bb47a0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a2382efd25e0a3a518b2bdd7e3bb47a0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3.临时节点（EPHEMERAL） </b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d039199e2ccf053f81db1a2d9324db5b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb\" width=\"708\" data-original=\"https://pic4.zhimg.com/v2-d039199e2ccf053f81db1a2d9324db5b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;708&#39; height=&#39;292&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"708\" data-original=\"https://pic4.zhimg.com/v2-d039199e2ccf053f81db1a2d9324db5b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d039199e2ccf053f81db1a2d9324db5b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4d4e047ccb0fb50e552d614bcd12b36c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb\" width=\"708\" data-original=\"https://pic1.zhimg.com/v2-4d4e047ccb0fb50e552d614bcd12b36c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;708&#39; height=&#39;292&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"708\" data-original=\"https://pic1.zhimg.com/v2-4d4e047ccb0fb50e552d614bcd12b36c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4d4e047ccb0fb50e552d614bcd12b36c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-892efb0741d4d27acd6fdd68a26d9212_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb\" width=\"708\" data-original=\"https://pic3.zhimg.com/v2-892efb0741d4d27acd6fdd68a26d9212_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;708&#39; height=&#39;292&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"708\" data-original=\"https://pic3.zhimg.com/v2-892efb0741d4d27acd6fdd68a26d9212_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-892efb0741d4d27acd6fdd68a26d9212_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>4.临时顺序节点（EPHEMERAL_SEQUENTIAL） </b></p><p><br/>顾名思义，临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6903552cfbf33091d4f1173800616aba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-6903552cfbf33091d4f1173800616aba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-6903552cfbf33091d4f1173800616aba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6903552cfbf33091d4f1173800616aba_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0175a8c5bb9a301e59b7f0579645102f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic4.zhimg.com/v2-0175a8c5bb9a301e59b7f0579645102f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic4.zhimg.com/v2-0175a8c5bb9a301e59b7f0579645102f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0175a8c5bb9a301e59b7f0579645102f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Zookeeper分布式锁的原理</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Zookeeper分布式锁恰恰应用了临时顺序节点。具体如何实现呢？让我们来看一看详细步骤：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>获取锁</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先，在Zookeeper当中创建一个持久节点ParentLock。当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个<b>临时顺序节点 </b>Lock1。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-46b59bc545f8edf7f5301b4b33fce413_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb\" width=\"768\" data-original=\"https://pic4.zhimg.com/v2-46b59bc545f8edf7f5301b4b33fce413_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;768&#39; height=&#39;292&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"768\" data-original=\"https://pic4.zhimg.com/v2-46b59bc545f8edf7f5301b4b33fce413_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-46b59bc545f8edf7f5301b4b33fce413_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>之后，Client1查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bbe8ef4c142662742236efdba3cd2137_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb\" width=\"768\" data-original=\"https://pic4.zhimg.com/v2-bbe8ef4c142662742236efdba3cd2137_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;768&#39; height=&#39;296&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"768\" data-original=\"https://pic4.zhimg.com/v2-bbe8ef4c142662742236efdba3cd2137_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bbe8ef4c142662742236efdba3cd2137_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这时候，如果再有一个客户端 Client2 前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock2。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-789b961c774689c12da8574ac958e1b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-789b961c774689c12da8574ac958e1b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-789b961c774689c12da8574ac958e1b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-789b961c774689c12da8574ac958e1b6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Client2查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock2是不是顺序最靠前的一个，结果发现节点Lock2并不是最小的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>于是，Client2向排序仅比它靠前的节点Lock1注册<b>Watcher</b>，用于监听Lock1节点是否存在。这意味着Client2抢锁失败，进入了等待状态。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-26c421a241a4ced7a0bfafef5579582d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic2.zhimg.com/v2-26c421a241a4ced7a0bfafef5579582d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic2.zhimg.com/v2-26c421a241a4ced7a0bfafef5579582d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-26c421a241a4ced7a0bfafef5579582d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这时候，如果又有一个客户端Client3前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock3。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4c455371332c64e3465c9fbc9bfb6cc6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-4c455371332c64e3465c9fbc9bfb6cc6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-4c455371332c64e3465c9fbc9bfb6cc6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4c455371332c64e3465c9fbc9bfb6cc6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Client3查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock3是不是顺序最靠前的一个，结果同样发现节点Lock3并不是最小的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>于是，Client3向排序仅比它靠前的节点<b>Lock2</b>注册Watcher，用于监听Lock2节点是否存在。这意味着Client3同样抢锁失败，进入了等待状态。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b65362853991669aaae81af1cc708d90_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic1.zhimg.com/v2-b65362853991669aaae81af1cc708d90_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;335&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic1.zhimg.com/v2-b65362853991669aaae81af1cc708d90_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b65362853991669aaae81af1cc708d90_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样一来，Client1得到了锁，Client2监听了Lock1，Client3监听了Lock2。这恰恰形成了一个等待队列，很像是Java当中ReentrantLock所依赖的<b>AQS</b>（AbstractQueuedSynchronizer）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0bcd98b81047cc9183799542056aec80_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic1.zhimg.com/v2-0bcd98b81047cc9183799542056aec80_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic1.zhimg.com/v2-0bcd98b81047cc9183799542056aec80_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0bcd98b81047cc9183799542056aec80_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-171306ef2d008b0ce051af15f2e459e6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-171306ef2d008b0ce051af15f2e459e6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-171306ef2d008b0ce051af15f2e459e6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-171306ef2d008b0ce051af15f2e459e6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>释放锁</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>释放锁分为两种情况：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.任务完成，客户端显示释放</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>当任务完成时，Client1会显示调用删除节点Lock1的指令。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6da258f1cdf76b0c3b8c6cd726881faa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-6da258f1cdf76b0c3b8c6cd726881faa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;345&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-6da258f1cdf76b0c3b8c6cd726881faa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6da258f1cdf76b0c3b8c6cd726881faa_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2.任务执行过程中，客户端崩溃</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>获得锁的Client1在任务执行过程中，如果Duang的一声崩溃，则会断开与Zookeeper服务端的链接。根据临时节点的特性，相关联的节点Lock1会随之自动删除。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4209f5f49c18efd6581a54057d62e27b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic4.zhimg.com/v2-4209f5f49c18efd6581a54057d62e27b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;315&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic4.zhimg.com/v2-4209f5f49c18efd6581a54057d62e27b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4209f5f49c18efd6581a54057d62e27b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>由于Client2一直监听着Lock1的存在状态，当Lock1节点被删除，Client2会立刻收到通知。这时候Client2会再次查询ParentLock下面的所有节点，确认自己创建的节点Lock2是不是目前最小的节点。如果是最小，则Client2顺理成章获得了锁。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4b26f743bda017f4509d84d47f18633e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-4b26f743bda017f4509d84d47f18633e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;315&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-4b26f743bda017f4509d84d47f18633e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4b26f743bda017f4509d84d47f18633e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>同理，如果Client2也因为任务完成或者节点崩溃而删除了节点Lock2，那么Client3就会接到通知。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e5bdcdf9c4637eace84f1cb7cb30daaf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic4.zhimg.com/v2-e5bdcdf9c4637eace84f1cb7cb30daaf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;315&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic4.zhimg.com/v2-e5bdcdf9c4637eace84f1cb7cb30daaf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e5bdcdf9c4637eace84f1cb7cb30daaf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>最终，Client3成功得到了锁。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c9afaf82187ced90d5406989b12cd862_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-c9afaf82187ced90d5406989b12cd862_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"295\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-c9afaf82187ced90d5406989b12cd862_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c9afaf82187ced90d5406989b12cd862_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7ce20c1e689b23295cb586bd0f23d5eb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic4.zhimg.com/v2-7ce20c1e689b23295cb586bd0f23d5eb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic4.zhimg.com/v2-7ce20c1e689b23295cb586bd0f23d5eb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7ce20c1e689b23295cb586bd0f23d5eb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c8d21e1c4deb0c987c9197c6789f19cb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic4.zhimg.com/v2-c8d21e1c4deb0c987c9197c6789f19cb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic4.zhimg.com/v2-c8d21e1c4deb0c987c9197c6789f19cb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c8d21e1c4deb0c987c9197c6789f19cb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Zookeeper和Redis分布式锁的比较</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面的表格总结了Zookeeper和Redis分布式锁的优缺点：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3eb283471b689d14dd21185072aed5cb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"503\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-3eb283471b689d14dd21185072aed5cb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;503&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"503\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-3eb283471b689d14dd21185072aed5cb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3eb283471b689d14dd21185072aed5cb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>有人说Zookeeper实现的分布式锁支持可重入，Redis实现的分布式锁不支持可重入，这是<b>错误的观点</b>。两者都可以在客户端实现可重入逻辑。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在Apache的开源框架<b> Apache Curator</b> 中，包含了对Zookeeper分布式锁的实现，有兴趣的小伙伴可以看看源码：</p><p>喜欢的点点关注，点点赞。</p><p>对Java技术，架构技术感兴趣的朋友，欢迎加QQ群728821520，一起学习，相互讨论。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/apache/curator/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/apache/curat</span><span class=\"invisible\">or/</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-eb10c8d84b035317fffb0573aa50dc8e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-eb10c8d84b035317fffb0573aa50dc8e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-eb10c8d84b035317fffb0573aa50dc8e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-eb10c8d84b035317fffb0573aa50dc8e_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "ZooKeeper", 
                    "tagLink": "https://api.zhihu.com/topics/19657747"
                }, 
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69480740", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 1, 
            "title": "「阿里面试系列」搞懂并发编程，轻松应对80%的面试场景", 
            "content": "<p>作为一个合格的Java程序员，必须要对并发编程有一个深层次的了解，在很多互联网企业都会重点考察这一块。可能很多工作3年以上的Java程序员对于这一领域几乎没有太多研究。所以在接下来内容中，我会将并发编程整个领域由浅到深做非常全面的分析。</p><p><b>内容导航</b></p><ul><li>从操作系统的发展了解进程、线程模型</li><li>线程的优势</li><li>线程的生命周期</li><li>线程的应用场景</li></ul><p><b>了解进程、线程模型</b></p><p>每次学习一个新技术，我会先去了解这个技术的背景，这个过程看似浪费时间，其实在后续的学习过程中，能够促进理解很多问题。所以对于线程这个概念，我会先从操作系统讲起。因为操作系统的发展带来了软件层面的变革。 从多线程的发展来看，可以操作系统的发展分为三个历史阶段：</p><ul><li>真空管和穿孔卡片</li><li>晶体管和批处理系统</li><li>集成电路和多道程序设计</li></ul><p>最早的计算机只能解决简单的数学运算问题，比如正弦、余弦等。运行方式：程序员首先把程序写到纸上，然后穿孔成卡票，再把卡片盒带入到专门的输入室。输入室会有专门的操作员将卡片的程序输入到计算机上。计算机运行完当前的任务以后，把计算结果从打印机上进行输出，操作员再把打印出来的结果送入到输出室，程序员就可以从输出室取到结果。然后，操作员再继续从已经送入到输入室的卡片盒中读入另一个任务重复上述的步骤。</p><blockquote>操作员在机房里面来回调度资源，造成计算机存在大量的空闲状态 。而当时的计算机是非常昂贵的，人们为了减少这种资源的浪费。就采用了 批处理系统来解决</blockquote><p><b>批处理操作系统</b>的运行方式：在输入室收集全部的作业，然后用一台比较便宜的计算机把它们读取到磁带上。然后把磁带输入到计算机，计算机通过读取磁带的指令来进行运算，最后把结果输出磁带上。批处理操作系统的好处在于，计算机会一直处于运算状态，合理的利用了计算机资源。（运行流程如下图所示）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d5933315184a872246816abdfb9bb146_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"633\" data-original=\"https://pic3.zhimg.com/v2-d5933315184a872246816abdfb9bb146_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;633&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"633\" data-original=\"https://pic3.zhimg.com/v2-d5933315184a872246816abdfb9bb146_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d5933315184a872246816abdfb9bb146_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>（注：此图来源于现代操作系统）</p><blockquote>批处理操作系统虽然能够解决计算机的空闲问题，但是当某一个作业因为等待磁盘或者其他I/O操作而暂停，那CPU就只能阻塞直到该I/O完成，对于CPU操作密集型的程序，I/O操作相对较少，因此浪费的时间也很少。但是对于I/O操作较多的场景来说，CPU的资源是属于严重浪费的。</blockquote><p><b>多道程序设计</b>的出现解决了这个问题，就是把内存分为几个部分，每一个部分放不同的程序。当一个程序需要等待I/O操作完成时。那么CPU可以切换执行内存中的另外一个程序。如果内存中可以同时存放足够多的程序，那CPU的利用率可以接近100%。 在这个时候，引入了第一个概念- <b>进程</b>, 进程的本质是一个正在执行的程序，程序运行时系统会创建一个进程，并且给每个进程分配独立的内存地址空间保证每个进程地址不会相互干扰。同时，在CPU对进程做时间片的切换时，保证进程切换过程中仍然要从进程切换之前运行的位置出开始执行。所以进程通常还会包括程序计数器、堆栈指针。</p><p>有了进程以后，可以让操作系统从宏观层面实现多应用并发。而并发的实现是通过CPU时间片不端切换执行的。对于单核CPU来说，在任意一个时刻只会有一个进程在被CPU调度</p><blockquote>有了进程以后，为什么还会出现线程呢？</blockquote><p>在一个应用进程中，会存在多个同时执行的任务，如果其中一个任务被阻塞，将会引起不依赖该任务的任务也被阻塞。举个具体的例子来说，我们平常用word文档编辑内容的时候，都会有一个自动保存的功能，这个功能的作用是，当计算机出现故障的情况下如果用户未保存文档，则能够恢复到上一次自动保存的点。假设word的自动保存因为磁盘问题导致写入较慢，势必会影响到用户的文档编辑功能，直到磁盘写入完成用户才可编辑，这种体验是很差的。如果我们把一个进程中的多个任务通过线程的方式进行隔离，那么按照前面提到的进程演进的理论来说，在单核心CPU架构中可以通过CPU的时间片切换实现线程的调度充分利用CPU资源以达到最大的性能。</p><p>我们用了比较长的篇幅介绍了进程、线程发展的历史。总的来说是人们对于计算机的要求越来越高；对于计算机本身的资源的利用率也在不断提高。</p><p><b>线程的优势</b></p><p>前面分析了线程的发展历史，这里简单总结一下线程有的优势如下</p><ul><li>线程可以认为是轻量级的进程，所以线程的创建、销毁要比进程更快</li><li>从性能上考虑，如果进程中存在大量的I/O处理，通过多线程能够加快应用程序的执行速度(通过CPU时间片的快速切换)。</li><li>由于线程是CPU的最小调度单元，所以在多CPU架构中能够实现真正的<b>并行</b>执行。每一个CPU可以调度一个线程</li></ul><blockquote>这里有两个概念很多人没有搞明白，就是并行和并发<b>并行</b>：同时执行多个任务，在多核心CPU架构中，一个CPU核心运行一个线程，那么4核心CPU，可以同时执行4个线程<b>并发</b>：同处理多个任务的能力,通常我们会通过TPS或者QPS来表示某某系统支持的并发数是多少。</blockquote><p>总的来说，并行是并发的子集。也就是说我们可以写一个拥有多线程并行的程序，如果在没有多核心CPU来执行这些线程，那就不能以并行的方式来运行程序中的多个线程。所以并发程序可以是并行的，也可以不是。<i>Erlang之父Joe Armstrong通过一张图型的方式来解释并发和并行的区别，图片如下</i></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e36449ffee20625634ae9743c6f349b1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"455\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic2.zhimg.com/v2-e36449ffee20625634ae9743c6f349b1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;455&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"455\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic2.zhimg.com/v2-e36449ffee20625634ae9743c6f349b1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e36449ffee20625634ae9743c6f349b1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>「阿里面试系列」搞懂并发编程，轻松应对80%的面试场景</p><p><b>线程的生命周期</b></p><p>线程是存在生命周期的，从线程的创建到销毁，可能会经历6种不同的状态，但是在一个时刻线程只能处于其中一种状态</p><ul><li>NEW：初始状态，线程被创建时候的状态，还没有调用start方法</li><li>RUNNABLE：运行状态，运行状态包含就绪和运行两种状态，因为线程启动以后，并不是立即执行，而是需要通过调度去分配CPU时间片</li><li>BLOCKED：阻塞状态，当线程去访问一个加锁的方法时，如果已经有其他线程获得锁，那么当前线程会处于阻塞状态</li><li>WAITING：等待状态，设置线程进入等待状态等待其他线程做一些特定的动作进行触发</li><li>TIME_WAITING：超时等待状态，和WAITING状态的区别在于超时以后自动返回</li><li>TERMINATED：终止状态，线程执行完毕</li></ul><p>下图整理了线程的状态变更过程及变更的操作，每一个具体的操作原理，我会在后续的文章中进行详细分析。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2444156a0748c4275c904871770e0e51_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb\" width=\"638\" data-original=\"https://pic2.zhimg.com/v2-2444156a0748c4275c904871770e0e51_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;638&#39; height=&#39;411&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"638\" data-original=\"https://pic2.zhimg.com/v2-2444156a0748c4275c904871770e0e51_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2444156a0748c4275c904871770e0e51_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>「阿里面试系列」搞懂并发编程，轻松应对80%的面试场景</p><blockquote>这里有一个问题大家可能搞不明白，BLOCKED和WAITING这两个阻塞有什么区别？</blockquote><ul><li>BLOCKED状态是指当前线程在等待一个获取锁的操作时的状态。</li><li>WAITING是通过Object.wait或者Thread.join、LockSupport.park等操作实现的</li><li>BLOCKED是被动的标记，而WAITING是主动操作</li><li>如果说得再深入一点，处于WAITING状态的线程，被唤醒以后，需要进入同步队列去竞争锁操作，而在同步队列中，如果已经有其他线程持有锁，则线程会处于BLOCKED状态。所以可以说BLOCKED状态是处于WAITING状态的线程重新唤醒的必经的状态</li></ul><p><b>线程的应用场景</b></p><p>线程的出现，在多核心CPU架构下实现了真正意义上的并行执行。也就是说，一个进程内多个任务可以通过多线程并行执行来提高程序运行的性能。那线程的使用场景有哪些呢？</p><ul><li>执行后台任务，在很多场景中，可能会有一些定时的批量任务，比如定时发送短信、定时生成批量文件。在这些场景中可以通过多线程的来执行</li><li>异步处理，比如在用户注册成功以后给用户发送优惠券或者短信，可以通过异步的方式来执行，一方面提升主程序的执行性能；另一方面可以解耦核心功能，防止非核心功能对核心功能造成影响</li><li>分布式处理，比如fork/join，将一个任务拆分成多个子任务分别执行</li><li>BIO模型中的线程任务分发，也是一种比较常见的使用场景，一个请求对应一个线程。</li></ul><p>喜欢的点点关注，点点赞。</p><p>对Java技术，架构技术感兴趣的同学，欢迎加QQ群728821520，一起学习，</p><h2>合理的利用多线程，可以提升程序的吞吐量。同时，还可以通过增加CPU的核心数来提升程序的性能，这就体现了伸缩性的特点</h2>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69276445", 
            "userName": "JavaStorm", 
            "userLink": "https://www.zhihu.com/people/ed4ff2a46bc893c503121db0958c2b71", 
            "upvote": 1, 
            "title": "设计模式-命令模式", 
            "content": "<p>﻿ 关注公众号 JavaStorm 获取更多成长。</p><blockquote> 命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。<br/> </blockquote><h2>概述</h2><p>命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。</p><p>每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p><p>命令允许请求的一方和接收请求的一方能够独立演化，从而具有以下的优点：</p><p>（1）命令模式使新的命令很容易地被加入到系统里。</p><p>（2）允许接收请求的一方决定是否要否决请求。</p><p>（3）能较容易地设计一个命令队列。</p><p>（4）可以容易地实现对请求的撤销和恢复。</p><p>（5）在需要的情况下，可以较容易地将命令记入日志。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fba46245f4a9981ddda6200b2ecccaa9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb\" width=\"633\" data-original=\"https://pic2.zhimg.com/v2-fba46245f4a9981ddda6200b2ecccaa9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;633&#39; height=&#39;232&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"633\" data-original=\"https://pic2.zhimg.com/v2-fba46245f4a9981ddda6200b2ecccaa9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fba46245f4a9981ddda6200b2ecccaa9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>角色</h2><ul><li><b>客户端(Client)角色：</b> 创建一个 ConcreteCommand，并设置其接受者。</li><li><b>命令(Command)角色：</b> 为所有的命令申明一个接口。调用命令对象的 execute 方法就可以让接受者执行相关的动作，同事接口还具备一个 undo() 撤回方法。</li><li><b>具体命令(ConcreteCommand)角色：</b> 定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。调用者只需要调用 execute 方法就可以发出请求，然后由 ConcreteCommand 调用接受者的一个或者多个动作。</li><li><b>调用者(Invoker)角色：</b> 调用者持有一个命令对象，提供一个触发方法调用命令对象的 execute 方法，将命令执行。</li><li><b>接收者(Receiver)角色：</b> 负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li></ul><h3>执行流程</h3><ol><li>客户端创建一个命令对象。</li><li>客户端在调用者对象上调用 setCommand 方法。</li><li>在未来合适的时间点，调用者调用命令对象的 execute 方法。</li><li>命令通过调用者委托到对应的接受者执行。完成任务。</li></ol><h2>场景模拟</h2><p>一个全能遥控器 6个可编程插槽（每个可以指定一个不同的家电装置），用来控制家电（电视、空调、冰箱、音响）。每个插槽有对应的 [开] 和 [关] 按钮。同时还具备一个整体一键撤回按钮。撤回需求是这样的，比如电灯是关的，然后按下开启按钮电灯就开了。现在假如按下撤销按钮，那么上一个动作将会翻转。在这里，电灯将会关闭。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4a29a62408965a75abce54efbc6ce656_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb\" width=\"503\" data-original=\"https://pic3.zhimg.com/v2-4a29a62408965a75abce54efbc6ce656_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;503&#39; height=&#39;538&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"503\" data-original=\"https://pic3.zhimg.com/v2-4a29a62408965a75abce54efbc6ce656_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4a29a62408965a75abce54efbc6ce656_b.jpg\"/></figure><p> 插槽连接对应的家电，开关是对应的指令。每个家电对应两个指令，分别是 【开】和【关】按键。</p><p>许多家电都有 on() 和 off() 方法，除此之外还有一些 setVolumn()、setTV()、setTemperature() 方法。 我们总不能 写 if slot1 == Light then light.on()。</p><h2>代码实现</h2><h3>命令接受者角色</h3><p>首先我们拥有很多家电。他们其实就是不同命令的接受者执行。</p><ul><li>灯</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.command.receiver</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Light</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">on</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;打开电灯。&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">off</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;关灯。&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>音响</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.command.receiver</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Stereo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">on</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;打开音响&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">off</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;关闭音响&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setCD</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;放入CD&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setVolume</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;音响音量设置为20&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>命令角色</h3><p>首先让所有的命令对象实现该接口，分别有命令执行与撤回</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.command</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 命令(Command)角色\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">Command</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 命令执行\n</span><span class=\"cm\">     */</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">execute</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 命令撤销\n</span><span class=\"cm\">     */</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">undo</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h3>具体命令角色</h3><ul><li>定义开灯命令，实现 execute 。持有 命令接受者 灯的引用，从而当调用者调用  execute  将委托给对应的 灯执行开灯操作。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.command.impl</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.Command</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.receiver.Light</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">LightOnCommand</span> <span class=\"kd\">implements</span> <span class=\"n\">Command</span> <span class=\"o\">{</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 持有接受者实例，以便当命令execute执行的时候由接受者执行开灯\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Light</span> <span class=\"n\">light</span><span class=\"o\">;</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">execute</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">light</span><span class=\"o\">.</span><span class=\"na\">on</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">undo</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">light</span><span class=\"o\">.</span><span class=\"na\">off</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 设置命令的接受者\n</span><span class=\"cm\">     * @param light\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setLight</span><span class=\"o\">(</span><span class=\"n\">Light</span> <span class=\"n\">light</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">light</span> <span class=\"o\">=</span> <span class=\"n\">light</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>定义关灯命令</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.command.impl</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.Command</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.receiver.Light</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">LightOffCommand</span> <span class=\"kd\">implements</span> <span class=\"n\">Command</span> <span class=\"o\">{</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 持有接受者实例，以便当命令execute执行的时候由接受者执行\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Light</span> <span class=\"n\">light</span><span class=\"o\">;</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">execute</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">light</span><span class=\"o\">.</span><span class=\"na\">off</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">undo</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">light</span><span class=\"o\">.</span><span class=\"na\">on</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setLight</span><span class=\"o\">(</span><span class=\"n\">Light</span> <span class=\"n\">light</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">light</span> <span class=\"o\">=</span> <span class=\"n\">light</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>定义打开音响命令 </li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.command.impl</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.Command</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.receiver.Stereo</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 音响开指令\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">StereoOnCommand</span> <span class=\"kd\">implements</span> <span class=\"n\">Command</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">Stereo</span> <span class=\"n\">stereo</span><span class=\"o\">;</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">execute</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">stereo</span><span class=\"o\">.</span><span class=\"na\">on</span><span class=\"o\">();</span>\n        <span class=\"n\">stereo</span><span class=\"o\">.</span><span class=\"na\">setCD</span><span class=\"o\">();</span>\n        <span class=\"n\">stereo</span><span class=\"o\">.</span><span class=\"na\">setVolume</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">undo</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">stereo</span><span class=\"o\">.</span><span class=\"na\">off</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setStereo</span><span class=\"o\">(</span><span class=\"n\">Stereo</span> <span class=\"n\">stereo</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">stereo</span> <span class=\"o\">=</span> <span class=\"n\">stereo</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>定义关闭音响命令</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.command.impl</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.Command</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.receiver.Stereo</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">StereoOffCommand</span> <span class=\"kd\">implements</span> <span class=\"n\">Command</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">Stereo</span> <span class=\"n\">stereo</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setStereo</span><span class=\"o\">(</span><span class=\"n\">Stereo</span> <span class=\"n\">stereo</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">stereo</span> <span class=\"o\">=</span> <span class=\"n\">stereo</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">execute</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">stereo</span><span class=\"o\">.</span><span class=\"na\">off</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">undo</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">stereo</span><span class=\"o\">.</span><span class=\"na\">on</span><span class=\"o\">();</span>\n        <span class=\"n\">stereo</span><span class=\"o\">.</span><span class=\"na\">setCD</span><span class=\"o\">();</span>\n        <span class=\"n\">stereo</span><span class=\"o\">.</span><span class=\"na\">setVolume</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>剩下的打开电视机、关闭电视机、打开空调、关闭空调的就不一一写了。都是一样的模板套路。具体代码可以查阅 GitHub地址： <a href=\"https://link.zhihu.com/?target=https%3A//github.com/UniqueDong/zero-design-stu\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/UniqueDong/z</span><span class=\"invisible\">ero-design-stu</span><span class=\"ellipsis\"></span></a> 中的 headfirst 包下代码。</p><h3>调用者角色</h3><p>其实就是我们的遥控器。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.command</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.impl.NoCommand</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.Arrays</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 调用者：遥控器\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">RemoteControl</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 一共4个家电插槽，每个插槽有 开与关命令。\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Command</span><span class=\"o\">[]</span> <span class=\"n\">onCommands</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Command</span><span class=\"o\">[]</span> <span class=\"n\">offCommands</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">//用来保存前一个命令，用来实现撤销功能\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"n\">Command</span> <span class=\"n\">undoCommand</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 通过构造器初始化开关数组\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">RemoteControl</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">onCommands</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Command</span><span class=\"o\">[</span><span class=\"n\">4</span><span class=\"o\">];</span>\n        <span class=\"n\">offCommands</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Command</span><span class=\"o\">[</span><span class=\"n\">4</span><span class=\"o\">];</span>\n        <span class=\"c1\">//初始化所有插槽为空指令\n</span><span class=\"c1\"></span>        <span class=\"n\">Command</span> <span class=\"n\">noCommand</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">NoCommand</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">4</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">onCommands</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">noCommand</span><span class=\"o\">;</span>\n            <span class=\"n\">offCommands</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">noCommand</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"c1\">//一开始没有所谓的前一个命令，所以默认无指令\n</span><span class=\"c1\"></span>        <span class=\"n\">undoCommand</span> <span class=\"o\">=</span> <span class=\"n\">noCommand</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 设置指定插槽对应的按钮指令\n</span><span class=\"cm\">     * @param slot 插槽位置\n</span><span class=\"cm\">     * @param onCommand 开指令\n</span><span class=\"cm\">     * @param offCaommand 关指令\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setCommand</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">slot</span><span class=\"o\">,</span><span class=\"n\">Command</span> <span class=\"n\">onCommand</span><span class=\"o\">,</span> <span class=\"n\">Command</span> <span class=\"n\">offCaommand</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">onCommands</span><span class=\"o\">[</span><span class=\"n\">slot</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">onCommand</span><span class=\"o\">;</span>\n        <span class=\"n\">offCommands</span><span class=\"o\">[</span><span class=\"n\">slot</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">offCaommand</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 模拟按下指定插槽对应的【开】按键\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pressOnButton</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">slot</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">onCommands</span><span class=\"o\">[</span><span class=\"n\">slot</span><span class=\"o\">].</span><span class=\"na\">execute</span><span class=\"o\">();</span>\n        <span class=\"c1\">//将当前指令记录下来，用于在撤销的时候能执行命令对应的 undo 方法从而实现撤销功能\n</span><span class=\"c1\"></span>        <span class=\"n\">undoCommand</span> <span class=\"o\">=</span> <span class=\"n\">onCommands</span><span class=\"o\">[</span><span class=\"n\">slot</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 模拟按下指定插槽对应的【关】按键\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pressOffButton</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">slot</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">offCommands</span><span class=\"o\">[</span><span class=\"n\">slot</span><span class=\"o\">].</span><span class=\"na\">execute</span><span class=\"o\">();</span>\n        <span class=\"n\">undoCommand</span> <span class=\"o\">=</span> <span class=\"n\">offCommands</span><span class=\"o\">[</span><span class=\"n\">slot</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 撤销功能\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pressUndoButton</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">undoCommand</span><span class=\"o\">.</span><span class=\"na\">undo</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">toString</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"s\">&#34;RemoteControl{&#34;</span> <span class=\"o\">+</span>\n                <span class=\"s\">&#34;onCommands=&#34;</span> <span class=\"o\">+</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">(</span><span class=\"n\">onCommands</span><span class=\"o\">)</span> <span class=\"o\">+</span>\n                <span class=\"s\">&#34;, offCommands=&#34;</span> <span class=\"o\">+</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">(</span><span class=\"n\">offCommands</span><span class=\"o\">)</span> <span class=\"o\">+</span>\n                <span class=\"sc\">&#39;}&#39;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>客户端角色</h3><p>获取遥控器，并且拿到灯、空调等命令接受者。分别创建对应的 【开】，【关】指令。 链接到对应的插槽。当按下按钮的时候触发指定的指令。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.command</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.impl.*</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.receiver.AirConditioning</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.receiver.Light</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.receiver.Stereo</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">com.zero.headfirst.command.receiver.TV</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 客户端角色\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CommandClient</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">//创建一个遥控器-调用者角色\n</span><span class=\"c1\"></span>        <span class=\"n\">RemoteControl</span> <span class=\"n\">remoteControl</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">RemoteControl</span><span class=\"o\">();</span>\n        <span class=\"c1\">//1. 创建电灯-接受者角色\n</span><span class=\"c1\"></span>        <span class=\"n\">Light</span> <span class=\"n\">light</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Light</span><span class=\"o\">();</span>\n        <span class=\"c1\">//创建开灯、关灯命令-命令具体角色\n</span><span class=\"c1\"></span>        <span class=\"n\">LightOnCommand</span> <span class=\"n\">lightOnCommand</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LightOnCommand</span><span class=\"o\">();</span>\n        <span class=\"n\">lightOnCommand</span><span class=\"o\">.</span><span class=\"na\">setLight</span><span class=\"o\">(</span><span class=\"n\">light</span><span class=\"o\">);</span>\n        <span class=\"n\">LightOffCommand</span> <span class=\"n\">lightOffCommand</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LightOffCommand</span><span class=\"o\">();</span>\n        <span class=\"n\">lightOffCommand</span><span class=\"o\">.</span><span class=\"na\">setLight</span><span class=\"o\">(</span><span class=\"n\">light</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">//调用者设置电灯插槽以及对应的开关按键指令-调用者角色\n</span><span class=\"c1\"></span>        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">setCommand</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">lightOnCommand</span><span class=\"o\">,</span> <span class=\"n\">lightOffCommand</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// 2. 设置音响插槽与对应按键指令\n</span><span class=\"c1\"></span>        <span class=\"n\">Stereo</span> <span class=\"n\">stereo</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stereo</span><span class=\"o\">();</span>\n        <span class=\"n\">StereoOnCommand</span> <span class=\"n\">stereoOnCommand</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StereoOnCommand</span><span class=\"o\">();</span>\n        <span class=\"n\">stereoOnCommand</span><span class=\"o\">.</span><span class=\"na\">setStereo</span><span class=\"o\">(</span><span class=\"n\">stereo</span><span class=\"o\">);</span>\n        <span class=\"n\">StereoOffCommand</span> <span class=\"n\">stereoOffCommand</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StereoOffCommand</span><span class=\"o\">();</span>\n        <span class=\"n\">stereoOffCommand</span><span class=\"o\">.</span><span class=\"na\">setStereo</span><span class=\"o\">(</span><span class=\"n\">stereo</span><span class=\"o\">);</span>\n\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">setCommand</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">stereoOnCommand</span><span class=\"o\">,</span> <span class=\"n\">stereoOffCommand</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">//3. 空调\n</span><span class=\"c1\"></span>        <span class=\"n\">AirConditioning</span> <span class=\"n\">airConditioning</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AirConditioning</span><span class=\"o\">();</span>\n        <span class=\"n\">AirConditioningOnCommand</span> <span class=\"n\">airConditioningOnCommand</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AirConditioningOnCommand</span><span class=\"o\">();</span>\n        <span class=\"n\">airConditioningOnCommand</span><span class=\"o\">.</span><span class=\"na\">setAirConditioning</span><span class=\"o\">(</span><span class=\"n\">airConditioning</span><span class=\"o\">);</span>\n        <span class=\"n\">AirConditioningOffCommand</span> <span class=\"n\">airConditioningOffCommand</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AirConditioningOffCommand</span><span class=\"o\">();</span>\n        <span class=\"n\">airConditioningOffCommand</span><span class=\"o\">.</span><span class=\"na\">setAirConditioning</span><span class=\"o\">(</span><span class=\"n\">airConditioning</span><span class=\"o\">);</span>\n\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">setCommand</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">airConditioningOnCommand</span><span class=\"o\">,</span> <span class=\"n\">airConditioningOffCommand</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">//4. 电视\n</span><span class=\"c1\"></span>        <span class=\"n\">TV</span> <span class=\"n\">tv</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">TV</span><span class=\"o\">();</span>\n        <span class=\"n\">TVOnCommand</span> <span class=\"n\">tvOnCommand</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">TVOnCommand</span><span class=\"o\">();</span>\n        <span class=\"n\">tvOnCommand</span><span class=\"o\">.</span><span class=\"na\">setTv</span><span class=\"o\">(</span><span class=\"n\">tv</span><span class=\"o\">);</span>\n        <span class=\"n\">TVOffCommand</span> <span class=\"n\">tvOffCommand</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">TVOffCommand</span><span class=\"o\">();</span>\n        <span class=\"n\">tvOffCommand</span><span class=\"o\">.</span><span class=\"na\">setTv</span><span class=\"o\">(</span><span class=\"n\">tv</span><span class=\"o\">);</span>\n\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">setCommand</span><span class=\"o\">(</span><span class=\"n\">3</span><span class=\"o\">,</span> <span class=\"n\">tvOnCommand</span><span class=\"o\">,</span> <span class=\"n\">tvOffCommand</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">//模拟按键\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;-------码农回家了，使用遥控开启电灯、音响、空调、电视----&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressOnButton</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressOnButton</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressOnButton</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">);</span>\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressOnButton</span><span class=\"o\">(</span><span class=\"n\">3</span><span class=\"o\">);</span>\n\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;------码农睡觉了，使用遥控关闭电灯、音响、电视。不关空调--------&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressOffButton</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressOffButton</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressOffButton</span><span class=\"o\">(</span><span class=\"n\">3</span><span class=\"o\">);</span>\n\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;----撤销测试，先打开电灯。再关闭电灯。然后按撤销----&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressOnButton</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressOffButton</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n        <span class=\"c1\">//一键撤销\n</span><span class=\"c1\"></span>        <span class=\"n\">remoteControl</span><span class=\"o\">.</span><span class=\"na\">pressUndoButton</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>测试结果</h3><div class=\"highlight\"><pre><code class=\"language-text\">-------码农回家了，使用遥控开启电灯、音响、空调、电视----\n打开电灯。\n打开音响\n放入CD\n音响音量设置为20\n打开空调\n空调温度设置28°\n打开电视\n设置频道为宇宙电视台\n电视音量设置为20\n------码农睡觉了，使用遥控关闭电灯、音响、电视。不关空调--------\n关灯。\n关闭音响\n关闭电视\n----撤销测试，先打开电灯。再关闭电灯。然后按撤销----\n打开电灯。\n关灯。\n打开电灯。</code></pre></div><h2>总结</h2><p>使用场景： 1. 工作队列：在某一端添加指令，只要是实现命令模式的对象都可以放到队列里。另外一端是线程。线程进项下面的工作：从队列取出一个命令，然后调用execute 方法，调用完后将该命令丢弃，再继续取下一个命令。 2. 线程池。</p><blockquote> 关注公众号 JavaStorm 获取更多模式<br/> </blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0d9f7cb823de0463c130feea8d6db122_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic3.zhimg.com/v2-0d9f7cb823de0463c130feea8d6db122_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69165462", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 1, 
            "title": "面试中考官会问：Kafka为什么速度那么快？", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c3d9b150e67e6cdae0a9a43d2e1989b1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-c3d9b150e67e6cdae0a9a43d2e1989b1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;336&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-c3d9b150e67e6cdae0a9a43d2e1989b1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c3d9b150e67e6cdae0a9a43d2e1989b1_b.jpg\"/></figure><p><br/><br/>Kafka的消息是保存或缓存在磁盘上的，一般认为在磁盘上读写数据是会降低性能的，因为寻址会比较消耗时间，但是实际上，Kafka的特性之一就是高吞吐率。即使是普通的服务器，Kafka也可以轻松支持每秒百万级的写入请求，超过了大部分的消息中间件，这种特性也使得Kafka在日志处理等海量数据场景广泛应用。<br/>针对Kafka的基准测试可以参考，Apache Kafka基准测试：每秒写入2百万（在三台廉价机器上）<br/><b>下面从数据写入和读取两方面分析，为什么Kafka速度这么快。</b><br/><b>一、写入数据</b><br/>Kafka会把收到的消息都写入到硬盘中，它绝对不会丢失数据。为了优化写入速度Kafka采用了两个技术， 顺序写入和MMFile 。<br/><b>顺序写入</b><br/>磁盘读写的快慢取决于你怎么使用它，也就是顺序读写或者随机读写。在顺序读写的情况下，磁盘的顺序读写速度和内存持平。<br/>因为硬盘是机械结构，每次读写都会寻址-&gt;写入，其中寻址是一个“机械动作”，它是最耗时的。所以硬盘最讨厌随机I/O，最喜欢顺序I/O。为了提高读写硬盘的速度，Kafka就是使用顺序I/O。<br/>而且Linux对于磁盘的读写优化也比较多，包括read-ahead和write-behind，磁盘缓存等。如果在内存做这些操作的时候，一个是JAVA对象的内存开销很大，另一个是随着堆内存数据的增多，JAVA的GC时间会变得很长，使用磁盘操作有以下几个好处：<br/>1、顺序写入磁盘顺序读写速度超过内存随机读写<br/>2、顺序写入JVM的GC效率低，内存占用大。使用磁盘可以避免这一问题<br/>3、顺序写入系统冷启动后，磁盘缓存依然可用<br/>下图就展示了Kafka是如何写入数据的， 每一个Partition其实都是一个文件 ，收到消息后Kafka会把数据插入到文件末尾（虚框部分）：<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-dd1eadfbb64da421a269c7dc58ee8e93_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"391\" data-rawheight=\"252\" class=\"content_image\" width=\"391\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;391&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"391\" data-rawheight=\"252\" class=\"content_image lazy\" width=\"391\" data-actualsrc=\"https://pic4.zhimg.com/v2-dd1eadfbb64da421a269c7dc58ee8e93_b.jpg\"/></figure><p><br/><br/><br/>这种方法有一个缺陷——没有办法删除数据 ，所以Kafka是不会删除数据的，它会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个offset用来表示读取到了第几条数据 。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-917dbe838b6023407570426713329cc5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"308\" data-rawheight=\"188\" class=\"content_image\" width=\"308\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;308&#39; height=&#39;188&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"308\" data-rawheight=\"188\" class=\"content_image lazy\" width=\"308\" data-actualsrc=\"https://pic2.zhimg.com/v2-917dbe838b6023407570426713329cc5_b.jpg\"/></figure><p><br/><br/><br/>两个消费者：<br/>1、顺序写入Consumer1有两个offset分别对应Partition0、Partition1（假设每一个Topic一个Partition）；<br/>2、顺序写入Consumer2有一个offset对应Partition2。<br/>这个offset是由客户端SDK负责保存的，Kafka的Broker完全无视这个东西的存在；一般情况下SDK会把它保存到Zookeeper里面，所以需要给Consumer提供zookeeper的地址。<br/><b>如果不删除硬盘肯定会被撑满，所以Kakfa提供了两种策略来删除数据：</b><br/>1、顺序写入一是基于时间。<br/>2、顺序写入二是基于partition文件大小。<br/>具体配置可以参看它的配置文档<br/><b>Memory Mapped Files</b><br/>即便是顺序写入硬盘，硬盘的访问速度还是不可能追上内存。所以Kafka的数据并不是实时的写入硬盘 ，它充分利用了现代操作系统分页存储来利用内存提高I/O效率。<br/>Memory Mapped Files(后面简称mmap)也被翻译成 内存映射文件 ，在64位操作系统中一般可以表示20G的数据文件，它的工作原理是直接利用操作系统的Page来实现文件到物理内存的直接映射。<br/>完成映射之后你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。<br/>通过mmap，进程像读写硬盘一样读写内存（当然是虚拟机内存），也不必关心内存的大小有虚拟内存为我们兜底。<br/>使用这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销（调用文件的read会把数据先放到内核空间的内存中，然后再复制到用户空间的内存中。）<br/>但也有一个很明显的缺陷——不可靠，写到mmap中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用flush的时候才把数据真正的写到硬盘。<br/>Kafka提供了一个参数——producer.type来控制是不是主动flush，如果Kafka写入到mmap之后就立即flush然后再返回Producer叫 同步 (sync)；写入mmap之后立即返回Producer不调用flush叫异步 (async)。<br/><b>二、读取数据</b><br/>Kafka在读取磁盘时做了哪些优化？<br/><b>基于sendfile实现Zero Copy</b><br/>传统模式下，当需要对一个文件进行传输的时候，其具体流程细节如下：<br/>1、基于sendfile实现Zero Copy调用read函数，文件数据被copy到内核缓冲区<br/>2、read函数返回，文件数据从内核缓冲区copy到用户缓冲区<br/>3、write函数调用，将文件数据从用户缓冲区copy到内核与socket相关的缓冲区。<br/>4、数据从socket缓冲区copy到相关协议引擎。<br/>以上细节是传统read/write方式进行网络文件传输的方式，我们可以看到，在这个过程当中，文件数据实际上是经过了四次copy操作：<br/>硬盘—&gt;内核buf—&gt;用户buf—&gt;socket相关缓冲区—&gt;协议引擎<br/><br/>而sendfile系统调用则提供了一种减少以上多次copy，提升文件传输性能的方法。<br/>在内核版本2.1中，引入了sendfile系统调用，以简化网络上和两个本地文件之间的数据传输。sendfile的引入不仅减少了数据复制，还减少了上下文切换。<br/>sendfile(socket, file, len);<br/><b>运行流程如下：</b><br/>1、sendfile系统调用，文件数据被copy至内核缓冲区<br/>2、再从内核缓冲区copy至内核中socket相关的缓冲区<br/>3、最后再socket相关的缓冲区copy到协议引擎<br/>相较传统read/write方式，2.1版本内核引进的sendfile已经减少了内核缓冲区到user缓冲区，再由user缓冲区到socket相关缓冲区的文件copy，而在内核版本2.4之后，文件描述符结果被改变，sendfile实现了更简单的方式，再次减少了一次copy操作。<br/>在Apache、Nginx、lighttpd等web服务器当中，都有一项sendfile相关的配置，使用sendfile可以大幅提升文件传输性能。<br/>Kafka把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候Kafka直接把文件发送给消费者，配合mmap作为文件读写方式，直接把它传给sendfile。<br/><b>批量压缩</b><br/>在很多情况下，系统的瓶颈不是CPU或磁盘，而是网络IO，对于需要在广域网上的数据中心之间发送消息的数据流水线尤其如此。进行数据压缩会消耗少量的CPU资源,不过对于kafka而言,网络IO更应该需要考虑。<br/>1、如果每个消息都压缩，但是压缩率相对很低，所以Kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩<br/>2、Kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩<br/>3、Kafka支持多种压缩协议，包括Gzip和Snappy压缩协议<br/><b>三、总结</b><br/>Kafka速度的秘诀在于，它把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络IO损耗，通过mmap提高I/O速度，写入数据的时候由于单个Partion是末尾添加所以速度最优；读取数据的时候配合sendfile直接暴力输出。<br/>喜欢的点点关注，点点赞。<br/>对Java技术，架构技术感兴趣的同学，欢迎加QQ群728821520，一起学习，相互讨论。</p><p><br/> </p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Kafka", 
                    "tagLink": "https://api.zhihu.com/topics/20012159"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69077104", 
            "userName": "Tnlj", 
            "userLink": "https://www.zhihu.com/people/2b4ccac031e1115aaafb2322596a7288", 
            "upvote": 7, 
            "title": "递归 那些事儿", 
            "content": "<h2>0、写在前面</h2><p><b><i>To Iterate is Human,</i></b></p><p><b><i>     To Recure, Divine </i></b>        ---人理解迭代，神理解递归</p><h2>1、如何理解递归</h2><p>递归的数学模型其实就是<sup data-text=\"数学归纳法用来证明任意一个给定的情形都是正确的，证明过程一般分两步。1、证明当n=1时命题成立   2、证明如果在n=m时命题成立，那么就可以推导出在n=m+ 1时命题也成立\" data-url=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup>，归纳法适用于想解决一个问题转换为解决他的子问题，而他的子问题又变成子问题的子问题，而且这些子问题都有一个模型，也就是说可以用相同的逻辑去处理这些问题。当然有一个是例外的，也就是递归结束的那一个处理方法不适用于我们的归纳处理项，当然也不能适用，否则递归就将无止尽的继续。这里也就引出了归纳的终结条件（退出条件）以及求解的表达式（处理逻辑）：</p><ul><li>递归模式： 大问题是如何分解成子问题的</li><li>终结条件： 何时不需要继续将问题再变成子问题</li></ul><p>递归的一般形式：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">(</span><span class=\"n\">big_mode</span><span class=\"o\">){</span>\n   <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">endCondition</span><span class=\"o\">){</span>       <span class=\"c1\">//终结条件\n</span><span class=\"c1\"></span>      <span class=\"k\">return</span><span class=\"o\">;</span>     <span class=\"c1\">//终结条件对应操作\n</span><span class=\"c1\"></span>   <span class=\"o\">}</span><span class=\"k\">else</span><span class=\"o\">{</span>\n      <span class=\"n\">small_mode</span><span class=\"o\">;</span>   <span class=\"c1\">//将大问题分解\n</span><span class=\"c1\"></span>      <span class=\"n\">func</span><span class=\"o\">(</span><span class=\"n\">small_mode</span><span class=\"o\">)</span>           <span class=\"c1\">//调用自身处理子问题，递归\n</span><span class=\"c1\"></span>   <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>2、递归的两个条件</h2><p>递归的思想是：把问题分解成规模更小的、具有与原问题相同解法的问题。典型的如二分查找，就是不断的把问题的规模变为原来的一半，而新问题与原问题又有着相同的处理逻辑。</p><p>总的来说，能有递归处理的问题都有以下两个特点：</p><ol><li><b>可以通过递归来缩小问题规模，且新问题与原问题有着相同的形式（解决逻辑相同）。</b></li><li><b>存在着一种简单情景，可以使递归在此情况下返回退出。</b></li></ol><p>如果不满足两个条件中的任何一个，都不能用递归解决。</p><h2>3、递归最佳实践</h2><h3>a、斐波那契数列</h3><p>为了更好的理解这两个条件，我们以斐波那契数列为例。斐波那契数列是这样定义的：</p><div class=\"highlight\"><pre><code class=\"language-text\">f(0) = 0;\nf(1) = 1;\nf(n) = f(n- 1)+ f(n- 2);n&gt; 2</code></pre></div><p>这是一个很明显能够用递归解决的问题。</p><ol><li><b>对于 f(n) 的求解，可以通过求解 f(n- 1) 与 f(n- 2) 的和，并且 f(n- 1) 、 f(n- 2)、f(n) 都有着相同的求解函数 f 。</b></li><li><b>存在着一种简单语境，f(0)、f(1) 他们对应着 0 与 1。</b> </li></ol><p>因此，仿照上文中提到的递归的一般形式，也就能够很容易的写出下列代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">private Integer fib(int num){\n        if (1 == num || 0 == num){               //结束条件： num为0或1\n            return num;\n        }else {\n            return fib(num- 1)+ fib(num- 2);    //递归项，转换为子问题的和\n        }\n}</code></pre></div><p>在写递归调用函数的时候，一定要把简单情景的判断写在最前面，以保证函数调用在检查到简单情景的时候能够及时终止递归。</p><h3>b、判断回文字符串</h3><p>回文字符串正读、反读结果都一样，比如 eye、level 都是回文，有很多种方式能够判断字符串是否回文，现在我们尝试着利用递归去判断字符串是否回文。</p><p>回到 1 中提到的递归需要满足的两个条件，我们分析下这个问题：</p><ol><li><b>如果一个字符串是回文的，那么该字符串的第一个字符与最后一个字符一定是相同的，并且去除该字符串的第一个和最后一个字符后的字符串（此时，问题已被缩小）应该依然是回文的，也就能用相同的逻辑去进行判断。</b></li><li><b>长度为1和0的字符串是回文的，着也就为我们提供了一个结束条件。</b></li></ol><p>基于以上两点的分析，也就能够很容易的写出解决回文问题的递归实现方案：</p><div class=\"highlight\"><pre><code class=\"language-text\">private Boolean isHuiWen(String str){\n        if (null == str || 1 == str.length()){                          //结束条件\n            return true;\n        }else if (str.charAt(0) == str.charAt(str.length()- 1)){\n            return isHuiWen(str.substring(1, str.length()- 1));         //递归项，问题已被缩小\n        }\n        return false;\n}</code></pre></div><h3>c、计算数字长度</h3><a href=\"https://www.zhihu.com/question/329254945/answer/714638821\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">java 输入一个整数，输出此数为几位数?</a><p>这个是当时自己在研究递归的时候知乎给推荐的一个问题，要解决这个问题其实很简单，转换成 String ,再直接调用 length() 方法轻轻松松就解决了，简单粗暴。无奈自己当时正想验证下自己对递归的理解，于是就有了以下代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">public int length(Integer num){\n        if (num&lt; 10){\n            return 1;\n        }else {\n            return 1+ length(num/ 10);\n        }\n    }</code></pre></div><h3>d、整数的倒序输出</h3><a href=\"https://www.zhihu.com/question/20610266/answer/714807863\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">用 Java 如何编写函数使整数的每一位倒序排列？</a><p>故事背景与 c 相似，这个问题也用到了 c 中计算整数长度的代码，完整代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n            Integer num = scanner.nextInt();\n            System.out.println(length(num));\n            System.out.println(reverse(num, length(num)- 1));\n        }\n    }\n    //递归\n    private static int length(Integer num){\n        if (num&lt; 10){\n            return 1;\n        }else {\n            return 1+ length(num/ 10);\n        }\n    }\n\n    //递归\n    private static int reverse(Integer num, int length){\n        if (num&lt; 10){\n            return num;\n        }else {\n            int code = reverse(num/ 10, length- 1);\n            return code+ (num% 10)* (int)Math.pow(10, length);\n        }\n    }</code></pre></div><h2>4、总结</h2><p>当遇到一个问题你第一反应是可以用栈去实现时，不妨考虑下运用递归去解决，即便最后用递归解决不了也能够使你对递归的了解进一步加深。写递归代码时，可以套模板一样运用 1 中提到的递归的一般形式，其实 a、b、c、d 这四个例子就是这个模板的最佳实践，好好体会下这四个例子。这四个例子中第 1、2 个是教科书上经常会提到的例子，后两个则是自己运用上文涉及到的思路实践出来的代码，大家可以参考下。</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "递归", 
                    "tagLink": "https://api.zhihu.com/topics/19631498"
                }
            ], 
            "comments": [
                {
                    "userName": "蒋霍尔", 
                    "userLink": "https://www.zhihu.com/people/60d852f6b87734c20d238772051e841a", 
                    "content": "讲的很清楚，学习了！", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69032252", 
            "userName": "自学java高级架构", 
            "userLink": "https://www.zhihu.com/people/51f82809b13840d14df92c2c94828efc", 
            "upvote": 1, 
            "title": "记录Spring Cloud应用在阿里云架构部署", 
            "content": "<p>常用的Spring Cloud体系架构<br/>系统部署采用阿里云平台，采用的技术架构为SpringCloud.<br/>采用在线阿里云架构制图工具: Freedgo Design 地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.freedgo.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">freedgo.com</span><span class=\"invisible\"></span></a>, 具体架构如下：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d6bbdd4d8a43f789c785598aa7eb83fd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"501\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-d6bbdd4d8a43f789c785598aa7eb83fd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;501&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"501\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-d6bbdd4d8a43f789c785598aa7eb83fd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d6bbdd4d8a43f789c785598aa7eb83fd_b.jpg\"/></figure><p><br/><b>整体架构</b><br/>主要居于Spring Cloud的分布式微服务架构。主要功能包括：<br/><b>服务注册发现中心（Eureka server）</b><br/>通过服务发现可以抽象出部署服务的物理位置如IP，服务调用通过了逻辑名称而不是实际的物理位置，同时服务发现也处理了注册和注销。<br/><b>服务配置中心（config server）</b><br/>通过集中式的服务来处理应用程序配置数据。做到无论启动多少个微服务实例，这些实例始终使用相同的配置，同时服务的配置可以和微服务系统分离<br/><b>服务网关（ZUUL）</b><br/>通过ZUUL网关，可以强制执行一些功能如内容过滤，路由转发，过滤器等等<br/><b>Spring Sleuth &amp; ZIPKIN（分布式服务跟踪）</b><br/>通过Sleuth 相关ID进行全链路跟踪，可以分析服务调用的性能<br/><b>事件驱动及异步消息</b><br/>用于处理异步事件如短消息推送，邮件发送等。<br/><b>用户认证中心（auth2）</b><br/><b>ZUUL网关</b><br/><b>ZUUL网关主要的功能</b><br/><b>路由及过滤器设置</b><br/>通常在ZUUL网关设置过滤器包括前置过滤器、后置过滤器、路由过滤器，可以自定义一些逻辑，在大多数情况下，这种自定义逻辑用于强制执行一组一致的应用程序策略，如安全性、日志记录和对所有服务的跟踪等等。<br/>路由的设置可以指定路由地址URL对应的微服务如下图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0a76eae86a1a340a98ead9e53108be7a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"406\" data-rawheight=\"189\" class=\"content_image\" width=\"406\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;406&#39; height=&#39;189&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"406\" data-rawheight=\"189\" class=\"content_image lazy\" width=\"406\" data-actualsrc=\"https://pic3.zhimg.com/v2-0a76eae86a1a340a98ead9e53108be7a_b.jpg\"/></figure><p><br/><b>服务注册与发现：</b><br/>ZUUL网关服务器通过注册到Eureka服务器，实现了Eureka上注册的微服务的发现从而转发用户的请求到各应用模块，网关服务器中Ribbon同时会缓存微服务相关信息以减少对EureKa访问。<br/><b>微服务应用</b><br/><b>Oauth2授权访问</b><br/>ZUUL网关负责请求的路由转发，Request请求不仅仅来在用户浏览器，有可能是微服务之间的相互调用。<br/>登录用户请求或服务之前调用会在request请求头中携带Authorization 头信息来表示当前用户的身份信息，<br/><b>Http Restful Api</b><br/>微服务应用采用 Spring RestController 对外发布 Http Restful Api服务，<br/><b>微服务之间的调用</b><br/>微服务之间相互调用而不必知道被调用者所在位置是通过Eureka服务发现实现，当微服务启动时会注册自己到Eureka服务中心，服务消费者可以使 Ribbon 来进行交互。有三种方式的调用：<br/></p><ul><li>Spring DiscoveryClient</li><li>启用了 RestTemplate 的 Spring DiscoveryClient</li><li>通过 Netflix Feign 客户端方式</li></ul><p><b>部署方案(docker)</b><br/>采用Docker通过spotify 的docker-maven-plugin工具进行docker image进行打包镜像<br/><b>灰度测试</b><br/>通过ZUUL的过滤对新上线的服务做路由的权重算法，做到限流，A/B测试。<br/><b>平台开发</b><br/></p><ul><li>开发语言：java，Java是一种可以撰写跨平台应用程序的面向对象的程序设计语言。</li><li>开发工具：eclipse，Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。</li><li>主要使用的开源软件</li></ul><p><b>软件功能版本</b><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8c64ef09f4d978b762ca0a74e5fd6098_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-8c64ef09f4d978b762ca0a74e5fd6098_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;262&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-8c64ef09f4d978b762ca0a74e5fd6098_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8c64ef09f4d978b762ca0a74e5fd6098_b.jpg\"/></figure><p><br/>写在最后：</p><p>码字不易看到最后了，那就点个关注呗，只收藏不点关注的都是在耍流氓！</p><p>关注并私信我“架构”，免费送一些Java架构资料，先到先得！<br/> </p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Spring Cloud", 
                    "tagLink": "https://api.zhihu.com/topics/20073976"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68726060", 
            "userName": "JavaStorm", 
            "userLink": "https://www.zhihu.com/people/ed4ff2a46bc893c503121db0958c2b71", 
            "upvote": 1, 
            "title": "设计模式-单例模式", 
            "content": "<h2> 关注公众号 JavaStorm，给你更多精彩。</h2><blockquote> 单例模式(Singleton)也叫单态模式，是设计模式中最为简单的一种模式，甚至有些模式大师都不称其为模式，称其为一种实现技巧，因为设计模式讲究对象之间的关系的抽象，而单例模式只有自己一个对象，也因此有些设计大师并把把其称为设计模式之一。<br/> </blockquote><h2>使用场景</h2><p>许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。实际场景又哪些？如下</p><ol><li>Windows的Task Manager（任务管理器）就是很典型的单例模式。我们是不能打开两个 windows task manager。</li><li>windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li><li>网站的计数器，通常采用单例模式实现，否则难以同步。</li><li>应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li><li>Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。</li><li>多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。</li><li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。</li><li>工具类对象。</li></ol><p>总结一下：单例模式一般发生在一下情况：</p><p>（1）资源共享，避免由于资源操作导致的性能或者损耗。</p><p>（2）控制资源的情况下，资源见的相互通信。如线程池。</p><h2>基本实现思路</h2><p>单例模式要求类永远只返回一个对象引用和一个获得该实例的方法（必须是静态方法，通常使用 getInstance 这个名称）。网上又很多种写法，但是有的写法是有问题的这种我就不展示了，只记住正确的。</p><p>实现思路主要以下步骤：</p><ul><li>将该类的构造方法定义私有方法，这样其他地方就不能通过该类的构造方法来任意实例化该类的对象，只有通过该类提供的 getInstance 静态方法获取。</li><li>提供一个静态方法，如果该类持有的引用不为空则返回这个引用，否则就创建该类的实例并将实例赋值给引用。</li></ul><h2>单例模式写法</h2><p>饿汉式 （静态常量）【可用】</p><blockquote> 优点：写法简单，类加载的时候就完成实例化。避免了多线程实例化的同步问题。<br/> 缺点：在类加载的时候就实例化，没有达到 Lazy Loanding 的思想。假如至始至终没有使用这个实例们就会造成内存浪费。<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Singleton</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"n\">INSTANCE</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Singleton</span><span class=\"o\">();</span>\n\n    <span class=\"kd\">private</span> <span class=\"nf\">Singleton</span><span class=\"o\">(){}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"nf\">getInstance</span><span class=\"o\">(){</span>\n        <span class=\"k\">return</span> <span class=\"n\">INSTANCE</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li> 懒汉式（通过同步方法）【不推荐使用】</li></ul><blockquote> 缺点：通过 synchronized 同步实现多线程的安全问题，但是效率太低了，每个线程获取实例的时候都要同步，只需要在初始化的时候同步即可，后面可以直接 return 而不需要同步。<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Singleton</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"n\">singleton</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"nf\">Singleton</span><span class=\"o\">()</span> <span class=\"o\">{}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">synchronized</span> <span class=\"n\">Singleton</span> <span class=\"nf\">getInstance</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">singleton</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Singleton</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">singleton</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>双重检验（Double Check）【可使用】</li></ul><blockquote> volatile 修饰 singleton 变量，主要防止指令重排：<br/>要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。  给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。<br/> 优点：线程安全，也实现了延迟加载。同时效率也高，非空判断然后再同步，同步的代码块再判断非空创建。<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Singleton</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">volatile</span> <span class=\"n\">Singleton</span> <span class=\"n\">singleton</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"nf\">Singleton</span><span class=\"o\">()</span> <span class=\"o\">{}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"nf\">getInstance</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">Singleton</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">singleton</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Singleton</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">singleton</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>静态内部类【可使用】</li></ul><blockquote> 跟饿汉式一样通过类加载机制初始化保证只有一个线程保证安全。但是饿汉式没有实现懒加载。<br/> 静态内部类实现了懒加载，当Singleton加载时并不立即实例化 INSTANCE。而是在调用 getInstance() 方法才会 加载 SingletonHolder类从而完成  Singleton 的实例化。<br/> 优点：避免了线程安全问题，延迟加载，效率高。<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Singleton</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"nf\">Singleton</span><span class=\"o\">()</span> <span class=\"o\">{}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">SingletonHolder</span> <span class=\"o\">{</span>\n        <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Singleton</span> <span class=\"n\">INSTANCE</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Singleton</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"nf\">getInstance</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">SingletonHolder</span><span class=\"o\">.</span><span class=\"na\">INSTANCE</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>枚举 【可使用】</li></ul><blockquote> 利用枚举特性，不仅避免多线程同步问题，还能防止序列化重新创建对象。实例就是我们的 INSTANCE<br/> INSTANCE.method();<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">enum</span> <span class=\"n\">Singleton</span> <span class=\"o\">{</span>\n    <span class=\"n\">INSTANCE</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>关注公众号，给你精彩。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2a1f85495b2a0c6e2469e015b3364b66_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic3.zhimg.com/v2-2a1f85495b2a0c6e2469e015b3364b66_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }, 
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": [
                {
                    "userName": "Tnlj", 
                    "userLink": "https://www.zhihu.com/people/2b4ccac031e1115aaafb2322596a7288", 
                    "content": "<p>双重校验中的volatile是为了防止指令重排的吧？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "JavaStorm", 
                            "userLink": "https://www.zhihu.com/people/ed4ff2a46bc893c503121db0958c2b71", 
                            "content": "<p>感谢纠正：的确是为了防止指令重排。</p><p>要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。<br><br>给 instance 分配内存<br>调用 Singleton 的构造函数来初始化成员变量<br>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）<br>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Tnlj"
                        }, 
                        {
                            "userName": "Tnlj", 
                            "userLink": "https://www.zhihu.com/people/2b4ccac031e1115aaafb2322596a7288", 
                            "content": "[大笑][大笑]", 
                            "likes": 0, 
                            "replyToAuthor": "JavaStorm"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68175317", 
            "userName": "雁高飞", 
            "userLink": "https://www.zhihu.com/people/5b57ecb4e6645723ec2add412c503926", 
            "upvote": 0, 
            "title": "高考倒数 2 天！程序员惊现最燃表白！", 
            "content": "<p>我现在在某互联网公司做Java架构师，每天都会写几篇架构师的技术文章，感兴趣的朋友可以关注我后私信我，回复【资料】即可免费领取架构师资料</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>高考最后倒数两天！</b><br/>还记得几年前高考前夕的你，现在正在做什么？紧张地背滚瓜烂熟的诗句？再看一眼错题集？或者干脆放松心情，睡个不踏实的懒觉？<br/>近日，一则衡水中学学霸演讲《这世间，唯有青春与梦想不可辜负》，燃爆了朋友圈：<br/>相信，很多人都会跟我一样，因为这是一种念想，一种发自内心，由内而外的，对城市的渴望，少年们早已不想拘泥于这里，只能在所谓抖音、电影里，去观望别人的生活。<br/>可是，为什么我们就只能做哪个躲在阴暗的角落里，新鲜的舞台上，观望着别人的那个卑微的人。<br/>这样不行，一点儿也不好玩，我们会走出去，顺境也好，逆境也好，<b>人生本就是一场与种种困难无休无尽的斗争。</b> <br/>如果说青春是足迹，那梦想，一定叫做远方。<br/>请你们相信，生活明朗，万物可爱，人间值得，未来可期。<br/>你的理想是诗理想是梦，理想是远方的田野，是穿越世界的旅行！<br/><b>但现在你能做的所有，只是，把手握紧！厚积薄发！</b><br/><b>你，只有付出！</b><br/>付出你的时间，赌上你的尊严，拿出你的全部！你的EveryThing！<br/>当别人打游戏时你在学习，当别人睡懒觉时你在学习！<br/>你含着泪在深夜里舞蹈，在回忆里奔跑！<br/><b>没有人，在年少时想成为一个普通人。</b><br/>尽管生活，它会剥夺你的所爱，践踏你的尊严，把你踩在脚下遍体鳞伤。<br/><b>但你，怎能，倒下！</b><br/>你的身后，是挚爱的人，那些受过的伤都将成为你的勋章，都是你，送给未来的自己最好的礼物！<br/><b>我，也有梦想啊！</b><br/></p><a class=\"video-box\" href=\"https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1119677913120808960\" target=\"_blank\" data-video-id=\"\" data-video-playable=\"true\" data-name=\"衡水中学励志演讲\" data-poster=\"https://pic2.zhimg.com/v2-8f36117403c6902527da76fdf33c15d9.jpg\" data-lens-id=\"1119677913120808960\"><img class=\"thumbnail\" src=\"https://pic2.zhimg.com/v2-8f36117403c6902527da76fdf33c15d9.jpg\"/><span class=\"content\"><span class=\"title\">衡水中学励志演讲<span class=\"z-ico-extern-gray\"></span><span class=\"z-ico-extern-blue\"></span></span><span class=\"url\"><span class=\"z-ico-video\"></span>https://www.zhihu.com/video/1119677913120808960</span></span></a><p><br/>掷地有声地说出很多人的心声！<br/>让人想起曾疾笔奋书的岁月，那时候还有自己咬牙坚持的梦想。可如今进入职场没几年，棱角已被磨平，每天麻木地CURD，吐槽工作的繁重，公司福利的欠缺，抱怨越来越高的房价，生活的琐碎……<br/><b>梦想是什么？</b><br/><br/><b>不知道，好多年没有谈过这个词了。</b><br/>当初何为从事程序员的初心已被遗忘，剩下的是陷入生活泥潭的麻木。<br/>如果没有看到<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzA5MzY4NTQwMA%3D%3D%26mid%3D2651011343%26idx%3D1%26sn%3D02be8dccf3b0c2871564752c8227e1d4%26chksm%3D8bad8af8bcda03eededa47428a8a6102ad6b3d2c0a0d88764a5b68a08bf2b9da3ff1fd3156f4%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">重来一次高考，你还选择当程序员吗？</a>的留言，压根没想到，假如重新选择，还有很多人仍会选择当程序员的。<br/>现在让我们回过头来看看，属于程序人生读者朋友们的“高考”宣言：<br/><br/><br/><b>再来一次，Just Do IT！</b><br/><br/><b>Nick：</b><br/>依然还是会学计算机，如果可以的话汽修也可以，打小就喜欢计算机，当然是在玩游戏的时候，后来因为游戏配置高了打游戏卡了，我琢磨电脑硬件的问题，什么电脑装机啊什么，组装机什么的，那时候的我最好奇了，到后来打暑假工的时候，一个上天津医科大的大哥给我说电脑硬件你钻研钻研那硬件还是那样，搞软件吧，编程程序那种。<br/>后来的后来吧，就慢慢的接触了编程，开始的是C到后来的C++。至于高考的话，重来一次的机会的话当然是高考了，考上大学，去外面见识见识世面，开阔开阔眼界，然后选择计算机软件，或者硬件的专业。<br/>还有火好久的编程语言Python，人工智能、爬虫都超感兴趣，尤其是人工智能，我想知道图灵，艾伦·麦席森·图灵我想了解他那样的人工智能。<br/><b>SEE YOU@LOVE：</b><br/>毕业之后做了不下五个行业，程序员是唯一自己喜欢做，能做出小有成就的，再来一次，一定更加努力，做一个更优秀的程序员……程序改变世界！<br/><b>胡子：</b><br/>再来一次还是会选CS专业，但一定会好好读书，不会上这么个不入流的本科。<br/><b>初心：</b><br/>会，然后为自己的喜爱买单，当一个正经出身的程序媛，扎实基础。<br/><b>李墨白：</b><br/>当程序员没后悔过，要说后悔的话只有没能考个好的学校吧。<br/><b>周小森：</b><br/>重来一次的话，一定好好读书，绝不是现在的专科，学科肯定还是计算机，说是新时代的搬砖工，但是程序员可以创建一个新的世界。<br/><br/><br/><b>重来一次，想当选科班出身的程序员</b><br/><br/><b>colper：</b><br/>后悔不是科班的，虽然现在也能好好干活，但是有时候还是相对科班的会有一些不自信的。尤其是他们在你面前比比操作系统编译原理计算机组成等，对了，还有汇编。真的有一种，脸上笑嘻嘻，心里***之感。不过，最底层不熟悉，中层上层还是可以的。哎，该说啥呢，其实底层和上层最重要😂。继续努力补上吧。br/&gt;UTF杠8：<br/>最遗憾的是高考是艺考生，家里不让读音乐专业，就没有上大学，后来去了社会上的培训班。如果可以重来，一定考入计算机专业，堂堂正正的做一名科班程序员，给自己一个名分！br/&gt;&amp;：<br/>我还是会选择，现在的后悔大部分是因为之前的不努力。br/&gt;gxl：<br/>如果可以重来一次高考，一定不顾家人反对选择当程序员，现在干通信真的又累又没钱。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7c470fce4f1dd792ccd89ee11b50455c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"31\" class=\"content_image\" width=\"28\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;28&#39; height=&#39;31&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"31\" class=\"content_image lazy\" width=\"28\" data-actualsrc=\"https://pic1.zhimg.com/v2-7c470fce4f1dd792ccd89ee11b50455c_b.jpg\"/></figure><p>：<br/>财务狗表示关注这个公众号几年了，如果可以重新选择，一定会选择当码农。<br/><b>life：</b><br/>后悔进入这个行业太晚了，如果高考再一次选择会提前规划好，it对于家庭情况一般的孩子来说还是一个不错的行业的。<br/> <br/><br/><b>考虑更多选择</b><br/> <br/><b>Treasure：</b><br/>2016年，我开始了我的大学生涯。在此之前的高中生涯里一直表现的中规中矩，能考上一所一本学校也是在我意料之外的。我的专业是物联网专业，到现在我已经快要大四，回顾这三年感觉啥都学了也啥都没学，我们这个专业分为软件、Java、云计算、大数据方向、硬件、嵌入式、传感器。<br/>如果只选一个到还好，但是我们都学了， 而且讲都不深。我自己比较喜欢软件方向，所以自学了服务器开发方向，从C、C++、操作系统、数据结构算法到网络，但是和软件工程专业还是会有差距，如果重来高考，我不会选择物联网，或者不会选择这个大学的物联网专业。<br/><br/><b>脱离语言：</b><br/>2002年高考，离本科线太远，跟随同学们复读。2003年离本科线还差14分，但还是将就上了省内一所师范院校。为了读本科，服从调剂。不会报志愿，报的是物理数学这种，被分配到了工商管理专业。为了考计算机二级C，自学了C语言，感觉挺有意思，于是开始学习写代码。后来考二级C++，再后来跨专业考研，就是想学学计算机理论。2010年毕业偶然进入移动互联网领域，搭了一波顺风车到现在。</p><p>END</p><p>推荐阅读：</p><a href=\"https://zhuanlan.zhihu.com/p/68128632\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-701331e85d7555b2c9105e6da2887698_180x120.jpg\" data-image-width=\"385\" data-image-height=\"240\" class=\"internal\">雁高飞：面试百位研发人员后，他总结出了超全面的技术岗进阶技巧</a><a href=\"https://zhuanlan.zhihu.com/p/68022808\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-c0217d9ac660ca72af37e2a38cdf5e26_180x120.jpg\" data-image-width=\"593\" data-image-height=\"309\" class=\"internal\">雁高飞：Android &amp; Java面试详细个人总结</a><p></p>", 
            "topic": [
                {
                    "tag": "高考", 
                    "tagLink": "https://api.zhihu.com/topics/19567664"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "理想", 
                    "tagLink": "https://api.zhihu.com/topics/19559635"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68457823", 
            "userName": "JavaStorm", 
            "userLink": "https://www.zhihu.com/people/ed4ff2a46bc893c503121db0958c2b71", 
            "upvote": 1, 
            "title": "设计模式-装饰器模式", 
            "content": "<p>微信关注公众号 JavaStorm 获取最新内容。</p><blockquote> 装饰器模式（Decorator），动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活；它允许向一个现有的对象添加新的功能，同时又不改变其结构。==装饰器模式属于结构型模式==。<br/> </blockquote><h2>UML 类图</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-07fc577a7174c8774842404d8b05a6c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"646\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb\" width=\"646\" data-original=\"https://pic1.zhimg.com/v2-07fc577a7174c8774842404d8b05a6c4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;646&#39; height=&#39;438&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"646\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"646\" data-original=\"https://pic1.zhimg.com/v2-07fc577a7174c8774842404d8b05a6c4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-07fc577a7174c8774842404d8b05a6c4_b.jpg\"/></figure><p><i> Component：接口，定义一个抽象接口装饰对象与真实对象具有相同的接口，以便装饰器动态的添加职责。 </i> ConcreteComponent： 接口的具体对象。 <i> Decorator：装饰类，继承了 Component ， 从外类来拓展 Component 的功能 并且持有一个 Component 的引用，通过构造器实例化，从而实现对真实对象的职责装饰增强。 </i> ConcreteDecorator：具体装饰类，用于给实际对象添加职责。</p><h2>使用场景</h2><p>现在有一个场景：煎饼果子，科技园上班族早上去买煎饼果子（Pancake），有的人要加鸡蛋 （Egg）、有的人加火腿 （Ham）、有的人加生菜 （Lettuce）。有的土豪煎饼果子来一套全都要。现在我们来定义煎饼烹饪实现。（ps：留一个功能读者自己实现：不同的套餐价格是不一样的，如何计算出不同煎饼果子的价格？有兴趣的读者可以留言或者微信公众号后台留言）。</p><h2>代码实现</h2><blockquote> 代码可以左右滑动 1. 先定义煎饼接口也就是我们的被装饰类，以及烹饪的方法 。<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.decorator</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">Pancake</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 烹饪方法\n</span><span class=\"cm\">     */</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">cook</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><ol><li>定义一个乞丐版煎饼，被装饰对象。</li></ol><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.decorator</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 被装饰对象：定义最基本的乞丐版煎饼，啥都没加\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">BeggarPancake</span> <span class=\"kd\">implements</span> <span class=\"n\">Pancake</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">cook</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;乞丐版基本煎饼&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ol><li>定义抽象装饰类 煎饼果子装饰器 PancakeDecorator：抽象装饰器角色，实现煎饼接口（被装饰器接口），持有被装饰器的引用 （pancake）将烹饪行为转发具体的装饰器。</li></ol><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.decorator</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 抽象装饰器角色，实现煎饼接口（被装饰器接口），持有被装饰器的引用将烹饪行为转发具体的装饰器。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">PancakeDecorator</span> <span class=\"kd\">implements</span> <span class=\"n\">Pancake</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">Pancake</span> <span class=\"n\">pancake</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">PancakeDecorator</span><span class=\"o\">(</span><span class=\"n\">Pancake</span> <span class=\"n\">pancake</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">pancake</span> <span class=\"o\">=</span> <span class=\"n\">pancake</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">cook</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pancake</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">pancake</span><span class=\"o\">.</span><span class=\"na\">cook</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ol><li>各种具体装饰类对乞丐版煎饼进行不等级别的土豪加工。首先继承 抽象出来的 PancakeDecorator  ，重写 cook 方法，实现加工。 EggDecorator 鸡蛋装饰器：继承 PancakeDecorator，重写 cook 方法。动态添加鸡蛋，然后调用pancake 的cook。<br/> <br/> </li></ol><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.decorator</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 鸡蛋装饰器：覆盖cook方法，加入自身的实现，并且调用父类的cook方法，也就是构造函数中\n</span><span class=\"cm\"> * EggDecorator(Pancake pancake)，这里传入的pancake的cook操作\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">EggDecorator</span> <span class=\"kd\">extends</span> <span class=\"n\">PancakeDecorator</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">EggDecorator</span><span class=\"o\">(</span><span class=\"n\">Pancake</span> <span class=\"n\">pancake</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">pancake</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">cook</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;加一个鸡蛋；&#34;</span><span class=\"o\">);</span>\n        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">cook</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><blockquote> 火腿装饰器： HamDecorator<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.decorator</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 火腿装饰器\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">HamDecorator</span> <span class=\"kd\">extends</span> <span class=\"n\">PancakeDecorator</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">HamDecorator</span><span class=\"o\">(</span><span class=\"n\">Pancake</span> <span class=\"n\">pancake</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">pancake</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">cook</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;加一个火腿;&#34;</span><span class=\"o\">);</span>\n        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">cook</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><blockquote> 生菜装饰器<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.decorator</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 生菜装饰器\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">LettuceDecorator</span> <span class=\"kd\">extends</span> <span class=\"n\">PancakeDecorator</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">LettuceDecorator</span><span class=\"o\">(</span><span class=\"n\">Pancake</span> <span class=\"n\">pancake</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">pancake</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">cook</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;加生菜；&#34;</span><span class=\"o\">);</span>\n        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">cook</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><ol><li>定义一个煎饼果子摊位。</li></ol><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.zero.headfirst.decorator</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 煎饼果子店\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">PancakeShop</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;========土豪来了，全都加上。======&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">BeggarPancake</span> <span class=\"n\">beggarPancake</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BeggarPancake</span><span class=\"o\">();</span>\n        <span class=\"n\">EggDecorator</span> <span class=\"n\">eggDecorator</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">EggDecorator</span><span class=\"o\">(</span><span class=\"n\">beggarPancake</span><span class=\"o\">);</span>\n        <span class=\"n\">HamDecorator</span> <span class=\"n\">hamAndEggDecorator</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HamDecorator</span><span class=\"o\">(</span><span class=\"n\">eggDecorator</span><span class=\"o\">);</span>\n        <span class=\"n\">LettuceDecorator</span> <span class=\"n\">lettuceAndHamAndEggDecorator</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LettuceDecorator</span><span class=\"o\">(</span><span class=\"n\">hamAndEggDecorator</span><span class=\"o\">);</span>\n        <span class=\"n\">lettuceAndHamAndEggDecorator</span><span class=\"o\">.</span><span class=\"na\">cook</span><span class=\"o\">();</span>\n\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;========苦逼码农来了，只要鸡蛋补补脑。=====&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">BeggarPancake</span> <span class=\"n\">beggarPancake1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BeggarPancake</span><span class=\"o\">();</span>\n        <span class=\"n\">EggDecorator</span> <span class=\"n\">eggDecorator1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">EggDecorator</span><span class=\"o\">(</span><span class=\"n\">beggarPancake1</span><span class=\"o\">);</span>\n        <span class=\"n\">eggDecorator1</span><span class=\"o\">.</span><span class=\"na\">cook</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ol><li>运行结果</li></ol><div class=\"highlight\"><pre><code class=\"language-text\">========土豪来了，全都加上。======\n\n加生菜；\n\n加一个火腿;\n\n加一个鸡蛋；\n\n乞丐版基本煎饼\n\n========苦逼码农来了，只要鸡蛋补补脑。=====\n\n加一个鸡蛋；\n\n乞丐版基本煎饼</code></pre></div><h2>总结</h2><p>真实世界的装饰： Java I/O。 <b>注意事项与要点</b></p><ul><li>抽象装饰器与具体被装饰对象实现同一个接口。</li><li>抽象装饰器持有被装饰器接口对象，以便请求传递。</li><li>具体装饰器需要重写抽象装饰器的方法并引用super进行条用，转发请求。</li></ul><h3>适用场景</h3><ul><li> 拓展一个类的功能。<br/> </li><li> 动态的添加与撤销职责。<br/> </li></ul><p>### 优点 <i> 装饰类与被装饰类只关心自己的核心逻辑，实现了解耦。 </i> 方便动态拓展，开闭原则。且比继承灵活。</p><h3>缺点</h3><ul><li>如果功能拓展太多，将产生大量的类。</li><li>多层装饰会变得复杂。</li></ul><blockquote> 以上代码可参考我的 GitHub : <a href=\"https://link.zhihu.com/?target=https%3A//github.com/UniqueDong/zero-design-stu\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/UniqueDong/z</span><span class=\"invisible\">ero-design-stu</span><span class=\"ellipsis\"></span></a>。headfirst包下。欢迎关注公众号: JavaStorm 获取最新文章，也可在后台留言提出意见。收藏与关注是最大的鼓励。<br/> </blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0d9f7cb823de0463c130feea8d6db122_b.jpg\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic3.zhimg.com/v2-0d9f7cb823de0463c130feea8d6db122_b.jpg\"/><figcaption>JavaStorm</figcaption></figure><p></p>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }, 
                {
                    "tag": "装饰者模式", 
                    "tagLink": "https://api.zhihu.com/topics/20115075"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67906078", 
            "userName": "雁高飞", 
            "userLink": "https://www.zhihu.com/people/5b57ecb4e6645723ec2add412c503926", 
            "upvote": 4, 
            "title": "被 Oracle 裁员的程序员们，现在怎么样了？", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-12408fd08356fd2cf6e35a3cb78039b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"964\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-12408fd08356fd2cf6e35a3cb78039b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;964&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"964\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-12408fd08356fd2cf6e35a3cb78039b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-12408fd08356fd2cf6e35a3cb78039b2_b.jpg\"/></figure><p><br/><b>据甲骨文员工透漏，前一天晚上还在加班改Bug，第二天就通知被裁了，甚至要求被裁员工在30分钟内交出公司资产，离开大楼。</b><br/>甲骨文公司，全称甲骨文股份有限公司(甲骨文软件系统有限公司)，是全球最大的企业级软件公司，总部位于美国加利福尼亚州的红木滩。1989年正式进入中国市场。2013年，甲骨文已超越 IBM ，成为继 Microsoft 后全球第二大软件公司。<br/></p><h2>01</h2><p><b>曾经的“西二旗养老院”</b>甲骨文（中国）是一家很有趣的公司，势头强劲，却被公认为养老公司（俗称西二旗养老院）。风光无限，却也走上了裁员之路。<br/><br/>但是，和其他公司裁员不同的是：这次被裁的员工还没走出甲骨文的大门，门口就已经蹲守了一大批等着抢人的大厂，包括BAT、华为、网易等<b>八十余家</b>企业，等着接盘这数百名被裁的甲骨文前员工。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ed645cbd7a2c88376b8d16e2ab275867_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"498\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"498\" data-original=\"https://pic4.zhimg.com/v2-ed645cbd7a2c88376b8d16e2ab275867_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;498&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"498\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"498\" data-original=\"https://pic4.zhimg.com/v2-ed645cbd7a2c88376b8d16e2ab275867_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ed645cbd7a2c88376b8d16e2ab275867_b.jpg\"/></figure><p><br/>当时华为的招聘人员，下手最快，把招聘的牌子放到了甲骨文公司的园区内。其他公司也不甘示弱，纷纷效仿。<br/>让人不禁想感叹一声：同样是被裁员，为啥差距咋这么大呢？<br/></p><h2><br/>02</h2><p><b>如今却物是人非，令人唏嘘</b>不过俗话说乐极生悲、物极必反。就在一片抢人的热闹中，<b>打脸来的太快，就像龙卷风</b>。<br/>据面试人员爆料：甲骨文的前员工在面试中多是一轮游，即使通过了面试，在技术测试时，一样挂掉，和不会干没什么区别。<br/>要知道，甲骨文对研发人员的招聘门槛相当高：“必须在清华、北大、上交、复旦和北邮，这五所学校读过本科才有资格进。”<br/>但恰恰是这些名校毕业的学生，却表现出了能力欠缺的一面。当时热热闹闹的抢人大战，最后却给人这样的收场，令人唏嘘。<br/>不过我们可以通过甲骨文被裁员工这一波乌龙就可以看的出，虽然大厂的镀金很重要，但无论什么时候，技术能力都是程序员的安生立命之本。<br/>不管去哪，都得手上有活儿，否则你只是另一个苏明哲。<br/><br/>一个扎心的事实是：在一个精密庞大的机器面前，绝大多数人，都并不是那么不可或缺。<br/></p><h2><br/>03</h2><p><b>《孙子·谋攻篇》：知己知彼，百战不殆</b><br/>再而言之，不妨我们大家一起来看看，现在各公司对五年左右的Java程序员的一个详细需求。 <br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-78ca54888c56a960817f09690ca191fc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"907\" data-rawheight=\"653\" class=\"origin_image zh-lightbox-thumb\" width=\"907\" data-original=\"https://pic1.zhimg.com/v2-78ca54888c56a960817f09690ca191fc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;907&#39; height=&#39;653&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"907\" data-rawheight=\"653\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"907\" data-original=\"https://pic1.zhimg.com/v2-78ca54888c56a960817f09690ca191fc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-78ca54888c56a960817f09690ca191fc_b.jpg\"/></figure><p><br/>从这些招聘需求不难看出，不管是大厂还是普通企业，不管是1-3年还是5-10年的招聘需求，其中都有一个共性，那就是对微服务、分布式、多线程、JVM等知识都是硬性需求。这也代表着这些知识点是当下互联网企业的主流技术选型。<br/><br/></p><h2>04</h2><p><b>《增广贤文》中说：“学如逆水行舟，不进则退。”</b>在这个技术能力迭代快速的行业，你只有不断的保持学习，才能更好的应对未知的一切，刚好，小编我平时在整理文章时也经常能够收到粉丝朋友在后台留言分享的资料，今天就在这里给大家无套路分享一波，相信我，这套资料，绝对可以对你进阶高级工程师有帮助！<br/><b>Java架构进阶路线图</b>此图内容包涵目前互联网Java架构的主流技术里面有高并发、分布式、源码分析、性能优化跟微服务等，感兴趣的可以在文末找小编拿图，然后捋一捋帮自己好好梳理一下。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ff9e125662c12a79dd218fb432ef1052_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-ff9e125662c12a79dd218fb432ef1052_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;148&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-ff9e125662c12a79dd218fb432ef1052_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ff9e125662c12a79dd218fb432ef1052_b.jpg\"/></figure><p><br/>（篇幅展示有限，后面的内容更精彩）<b>Java架构资料分享</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1cb238c79572bdaa13d8e0f8c162815e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"472\" data-rawheight=\"802\" class=\"origin_image zh-lightbox-thumb\" width=\"472\" data-original=\"https://pic3.zhimg.com/v2-1cb238c79572bdaa13d8e0f8c162815e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;472&#39; height=&#39;802&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"472\" data-rawheight=\"802\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"472\" data-original=\"https://pic3.zhimg.com/v2-1cb238c79572bdaa13d8e0f8c162815e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1cb238c79572bdaa13d8e0f8c162815e_b.jpg\"/></figure><p><b>BATJ面试资料分享</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e9cfd519460809b2cfa2701bbbfbb342_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"465\" data-rawheight=\"759\" class=\"origin_image zh-lightbox-thumb\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-e9cfd519460809b2cfa2701bbbfbb342_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;465&#39; height=&#39;759&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"465\" data-rawheight=\"759\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-e9cfd519460809b2cfa2701bbbfbb342_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e9cfd519460809b2cfa2701bbbfbb342_b.jpg\"/></figure><p>另外小编还收集了今年BATJ等互联网的最新Java岗位的面试题，感兴趣的小伙伴可恶意在关注后私信我加群</p><p><b>（资料的价值取决于你领完后的行动千万莫做收藏党</b></p><b><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-67d3b81d7d5217814e247de56759624a_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"64\" data-rawheight=\"64\" class=\"content_image\" width=\"64\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;64&#39; height=&#39;64&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"64\" data-rawheight=\"64\" class=\"content_image lazy\" width=\"64\" data-actualsrc=\"https://pic3.zhimg.com/v2-67d3b81d7d5217814e247de56759624a_b.png\"/></figure></b><p>推荐阅读：</p><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://zhuanlan.zhihu.com/p/67641434\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-701331e85d7555b2c9105e6da2887698_180x120.jpg\" data-image-width=\"385\" data-image-height=\"240\" class=\"internal\">雁高飞：每个程序员都该学会的Maven知识</a><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://zhuanlan.zhihu.com/p/67554999\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-76a076028334b410b03dd373f5020060_180x120.jpg\" data-image-width=\"1062\" data-image-height=\"568\" class=\"internal\">雁高飞：如何创建一个对象</a><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://zhuanlan.zhihu.com/p/67504722\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-76a076028334b410b03dd373f5020060_180x120.jpg\" data-image-width=\"1062\" data-image-height=\"568\" class=\"internal\">雁高飞：Netty实战：设计一个IM框架</a><p class=\"ztext-empty-paragraph\"><br/></p><b><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a96b132ef56c351387132554fa7843f4_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"160\" data-thumbnail=\"https://pic1.zhimg.com/v2-a96b132ef56c351387132554fa7843f4_b.jpg\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;160&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"160\" data-thumbnail=\"https://pic1.zhimg.com/v2-a96b132ef56c351387132554fa7843f4_b.jpg\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic1.zhimg.com/v2-a96b132ef56c351387132554fa7843f4_b.gif\"/></figure></b><p class=\"ztext-empty-paragraph\"><br/></p><p><b>原文：</b></p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3Ftimestamp%3D1559547619%26src%3D3%26ver%3D1%26signature%3D-Aja3P7oDy4Xvrl7%2APK3qaNo7JDFHFkrls9PwocM%2AZVfoLhEQSZFvEvdJQAlztsfDH75pEDCQq1y67zBa5A9A6zGLvu5HtwCyC9ZMGZvVAzEfROOoWqQC2UB5tr88d86aPGElruy%2A5qGNOQ0hiG7C6rnKPS80abRj2TvkevTfOM%3D\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">mp.weixin.qq.com/s?</span><span class=\"invisible\">timestamp=1559547619&amp;src=3&amp;ver=1&amp;signature=-Aja3P7oDy4Xvrl7*PK3qaNo7JDFHFkrls9PwocM*ZVfoLhEQSZFvEvdJQAlztsfDH75pEDCQq1y67zBa5A9A6zGLvu5HtwCyC9ZMGZvVAzEfROOoWqQC2UB5tr88d86aPGElruy*5qGNOQ0hiG7C6rnKPS80abRj2TvkevTfOM=</span><span class=\"ellipsis\"></span></a><p></p>", 
            "topic": [
                {
                    "tag": "甲骨文 (Oracle)", 
                    "tagLink": "https://api.zhihu.com/topics/19557607"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "辞职", 
                    "tagLink": "https://api.zhihu.com/topics/19582002"
                }
            ], 
            "comments": [
                {
                    "userName": "IRIS", 
                    "userLink": "https://www.zhihu.com/people/0a7fb6fa1467db43d9f05476b08cde9b", 
                    "content": "“必须在清华、北大、上交、复旦和北邮，这五所学校读过本科才有资格进。” 还有这种规定吗？北邮好像跟另外一起好像也有点奇怪？北航不行？", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "雁高飞", 
                            "userLink": "https://www.zhihu.com/people/5b57ecb4e6645723ec2add412c503926", 
                            "content": "<p>这就不是特别清楚了，我转载的</p>", 
                            "likes": 0, 
                            "replyToAuthor": "IRIS"
                        }, 
                        {
                            "userName": "果壳果壳君", 
                            "userLink": "https://www.zhihu.com/people/c542baa562a07c64acb495f884de4418", 
                            "content": "中科大不行北航也就不行呗[调皮]", 
                            "likes": 0, 
                            "replyToAuthor": "IRIS"
                        }
                    ]
                }, 
                {
                    "userName": "一介无名", 
                    "userLink": "https://www.zhihu.com/people/9da4a3a29da42b58d51187e31d9b0131", 
                    "content": "前面写得好好的，突然就开始打广告？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "雁高飞", 
                            "userLink": "https://www.zhihu.com/people/5b57ecb4e6645723ec2add412c503926", 
                            "content": "<p>我写技术文章不打广告，这种文章实在是不会写，这篇文章是我转载的，原创有广告我咋删啊？</p>", 
                            "likes": 0, 
                            "replyToAuthor": "一介无名"
                        }
                    ]
                }, 
                {
                    "userName": "anchen", 
                    "userLink": "https://www.zhihu.com/people/644de7bbd3862164befdda1360f76600", 
                    "content": "这人血馒头吃的", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "汤洌", 
                    "userLink": "https://www.zhihu.com/people/33babe58ab9acde7c6ab20713c50aad6", 
                    "content": "<p>真正切题的内容就只有“甲骨文的前员工在面试中多是一轮游”这么一句抄来的话，而且也不是很新了。然后就开始打广告。</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66789473", 
            "userName": "Tnlj", 
            "userLink": "https://www.zhihu.com/people/2b4ccac031e1115aaafb2322596a7288", 
            "upvote": 4, 
            "title": "CORS与@CrossOrigin详解", 
            "content": "<h2>1、跨域的基本概念</h2><h3>a、跨域的解释</h3><p>要了解跨域，首先需要知晓浏览器的<a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Same-origin_policy_for_file%3A_URIs\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">同源策略</a>，简单的说就是两个请求<b>协议、端口、主机</b>都相同，则两个请求具有相同的源，可以自由访问。下表以<a href=\"https://link.zhihu.com/?target=http%3A//store.company.com/dir/page.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">store.company.com/dir/p</span><span class=\"invisible\">age.html</span><span class=\"ellipsis\"></span></a>为例，进行一些 url 的同源检测：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-23a5c9cbfaecf366a504f6100781507e_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1402\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb\" width=\"1402\" data-original=\"https://pic3.zhimg.com/v2-23a5c9cbfaecf366a504f6100781507e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1402&#39; height=&#39;226&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1402\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1402\" data-original=\"https://pic3.zhimg.com/v2-23a5c9cbfaecf366a504f6100781507e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-23a5c9cbfaecf366a504f6100781507e_b.png\"/></figure><p>浏览器的同源策略控制了不同源之间的交互，也就出现了跨域的问题，对于为什么引入同源策略，官方给出的解释是 <b>“同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。”</b>浏览器的同源策略在一定程度上能规避一些危险、提高攻击的成本。</p><h3>b、跨域问题的解决</h3><ul><li>JSONP： 这种解决跨域问题的方式前后端都需要有改动，在此不做介绍。</li><li>CORS：  一个W3C标准，全程跨域资源共享 (Cross-Origin Resource Sharing)，本文也主要讲解该种解决方式。</li></ul><h2>2、CORS</h2><h3>a、简单请求&amp;非简单请求</h3><p>浏览器将 CORS 请求分为两类：简单请求和复杂请求，简单请求需要满足以下两种条件：</p><ol><li>请求方式为<b> HEAD、GET、POST</b> 这三种方式之一</li><li>HTTP头信息中开发者添加的信息不超过以下几种：</li></ol><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type : 只限于三个值 : application/x-www-form-urlencode、multipart/form-data、text/plain</li></ul><p>凡是不同时满足上述两个条件的，就属于复杂请求。浏览器对两种请求的处理方式也是不一样的。</p><h3>b、简单请求</h3><p>对于简单请求，浏览器直接发出 CORS 请求，具体来说，就是在头信息之中，添加一个 Origin 字段.</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-74f137920d97001cb10a9370022d0f34_b.jpg\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"172\" class=\"origin_image zh-lightbox-thumb\" width=\"460\" data-original=\"https://pic1.zhimg.com/v2-74f137920d97001cb10a9370022d0f34_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;460&#39; height=&#39;172&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"172\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"460\" data-original=\"https://pic1.zhimg.com/v2-74f137920d97001cb10a9370022d0f34_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-74f137920d97001cb10a9370022d0f34_b.jpg\"/><figcaption>简单请求</figcaption></figure><p>上图头信息中， Origin 字段用来说明，本次请求来自来个源，服务器根据这个值决定是否同意这个请求。如果该值在许可范围（即允许跨域访问），服务器就会返回一个正常的 HTTP 回应，会多出几个头信息字段：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fd8ad58502f88edafd31aa95f032eeec_b.jpg\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb\" width=\"616\" data-original=\"https://pic1.zhimg.com/v2-fd8ad58502f88edafd31aa95f032eeec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;616&#39; height=&#39;111&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"616\" data-original=\"https://pic1.zhimg.com/v2-fd8ad58502f88edafd31aa95f032eeec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fd8ad58502f88edafd31aa95f032eeec_b.jpg\"/><figcaption>简单请求 Response</figcaption></figure><p>上图中的头信息中，有三个与跨域有关的字段，都以 Access-Control- 开头。</p><ol><li><b>Access-Control-Allow-Origin : </b>该字段必须的，表示接受该值对应的域名的请求。</li><li><b>Access-Control-Allow-Credentials :</b> 该值是一个布尔值，表示是否允许发送 Cookie 。默认情况下， Cookie 不包括在 CORS 请求之中，设置为 true，即表示服务器明确许可， Cookie 可以包含中跨域请求中，一起发送给服务器。这个值也只能设置为 true ，如果服务器不要浏览器发送 Cookie，删除该字段即可。<b>需要注意的是，当前端通过设置 xhr.withCredentials = true 允许携带cookie信息时， Access-Control-Allow-Origin 就不能设置为 * ，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源策略，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传。</b></li><li><b>Access-Control-Expose-Headers : </b>该字段可选。 CORS 请求时， XMLHttpRequest 对象的 getResponseHeader() 字段只能拿到6个基本字段： Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma 。如果想要拿到这6个值之外的值，就必须在 Access-Control-Expose-Headers 指定。</li></ol><h3>c、非简单请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方式是 PUT、DELETE，或者 Content-Type 字段类型是 application/json。非简单请求的  CORS请求，会在正式通信之前，增加一次 HTTP 查询请求，称为预检请求（preflight）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-41268483258bc52a64f4bbacb0d73ac0_b.jpg\" data-size=\"normal\" data-rawwidth=\"628\" data-rawheight=\"655\" class=\"origin_image zh-lightbox-thumb\" width=\"628\" data-original=\"https://pic1.zhimg.com/v2-41268483258bc52a64f4bbacb0d73ac0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;628&#39; height=&#39;655&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"628\" data-rawheight=\"655\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"628\" data-original=\"https://pic1.zhimg.com/v2-41268483258bc52a64f4bbacb0d73ac0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-41268483258bc52a64f4bbacb0d73ac0_b.jpg\"/><figcaption>预检请求</figcaption></figure><p>预检请求用的请求方法是 OPTIONS。下图是该预检请求对应的正式请求：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-07fa987065f010b4100802108360aee5_b.jpg\" data-size=\"normal\" data-rawwidth=\"726\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb\" width=\"726\" data-original=\"https://pic2.zhimg.com/v2-07fa987065f010b4100802108360aee5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;726&#39; height=&#39;650&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"726\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"726\" data-original=\"https://pic2.zhimg.com/v2-07fa987065f010b4100802108360aee5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-07fa987065f010b4100802108360aee5_b.jpg\"/><figcaption>预检请求对应正式请求信息</figcaption></figure><h2>3、基于filter的跨域实现</h2><p>这种实现方式较为简单，判断允许跨域访问后在 Response 头信息中添加 Access-Control-Allow-Origin、Access-Control-Allow-Method等字段信息。代码如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CorsFilter</span> <span class=\"kd\">extends</span> <span class=\"n\">OncePerRequestFilter</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">Logger</span> <span class=\"n\">log</span> <span class=\"o\">=</span> <span class=\"n\">LoggerFactory</span><span class=\"o\">.</span><span class=\"na\">getLogger</span><span class=\"o\">(</span><span class=\"n\">CorsFilter</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">);</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">whiteList</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span><span class=\"c1\">//跨域白名单\n</span><span class=\"c1\"></span>    <span class=\"kd\">static</span> <span class=\"o\">{</span>\n        <span class=\"n\">whiteList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"s\">&#34;http://mall.yjc.jd.com&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">whiteList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"s\">&#34;http://jshopx.jd.com&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">whiteList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"s\">&#34;http://mall.yao.jd.com&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">whiteList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"s\">&#34;http://yao-shop.jd.com&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doFilterInternal</span><span class=\"o\">(</span><span class=\"n\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"n\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">,</span> <span class=\"n\">FilterChain</span> <span class=\"n\">filterChain</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">ServletException</span><span class=\"o\">,</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n        <span class=\"c1\">//请求的地址\n</span><span class=\"c1\"></span>        <span class=\"n\">String</span> <span class=\"n\">originUrl</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"na\">getHeader</span><span class=\"o\">(</span><span class=\"s\">&#34;origin&#34;</span><span class=\"o\">);</span>\n        <span class=\"c1\">//查看是否在白名单里面\n</span><span class=\"c1\"></span>        <span class=\"kt\">boolean</span> <span class=\"n\">isAllow</span> <span class=\"o\">=</span> <span class=\"n\">whiteList</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">originUrl</span><span class=\"o\">);</span>\n\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">isAllow</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"na\">setHeader</span><span class=\"o\">(</span><span class=\"s\">&#34;Access-Control-Allow-Origin&#34;</span><span class=\"o\">,</span> <span class=\"n\">originUrl</span><span class=\"o\">);</span>\n            <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"na\">setHeader</span><span class=\"o\">(</span><span class=\"s\">&#34;Access-Control-Allow-Credentials&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;true&#34;</span><span class=\"o\">);</span>\n            <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"na\">setHeader</span><span class=\"o\">(</span><span class=\"s\">&#34;Access-Control-Allow-Methods&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;POST, GET, OPTIONS&#34;</span><span class=\"o\">);</span>\n            <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"na\">setHeader</span><span class=\"o\">(</span><span class=\"s\">&#34;Access-Control-Max-Age&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;1800&#34;</span><span class=\"o\">);</span><span class=\"c1\">//30分钟\n</span><span class=\"c1\"></span>            <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"na\">setHeader</span><span class=\"o\">(</span><span class=\"s\">&#34;Access-Control-Allow-Headers&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;x-requested-with, content-type&#34;</span><span class=\"o\">);</span>\n            <span class=\"n\">filterChain</span><span class=\"o\">.</span><span class=\"na\">doFilter</span><span class=\"o\">(</span><span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"n\">response</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span><span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"c1\">//对于非白名单域名的请求，不予进行访问，不然还会进入到controller方法中执行对应的逻辑\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>4、@CrossOrigin注解</h2><p>Spring 从4.2版本后开始支持 @CrossOrigin 注解实现跨域，这在一定程度上简化了我们实现跨域访问的开发成本，在需要跨域访问的方法或者类上加上这个注解便大功告成。但在不知晓其原理的情况下使用该注解跨域出了问题将无从下手解决。以下是  @CrossOrigin 的一些基础知识，部分设计到 Spring 框架加载 Bean 的源码。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2d0d39d03c4e5b9e6e245e034bd2c5a8_b.jpg\" data-size=\"normal\" data-rawwidth=\"739\" data-rawheight=\"579\" class=\"origin_image zh-lightbox-thumb\" width=\"739\" data-original=\"https://pic1.zhimg.com/v2-2d0d39d03c4e5b9e6e245e034bd2c5a8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;739&#39; height=&#39;579&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"739\" data-rawheight=\"579\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"739\" data-original=\"https://pic1.zhimg.com/v2-2d0d39d03c4e5b9e6e245e034bd2c5a8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2d0d39d03c4e5b9e6e245e034bd2c5a8_b.jpg\"/><figcaption>@CrossOrigin</figcaption></figure><ol><li><b>String[] origins: </b> 允许来源域名的列表，例如 &#39;www.jd.com&#39;，匹配的域名是跨域预请求 Response 头中的 &#39;Access-Control-Aloow_origin&#39; 字段值。不设置确切值时默认支持所有域名跨域访问。</li><li><b>String[] allowedHeaders:</b>  跨域请求中允许的请求头中的字段类型， 该值对应跨域预请求 Response 头中的 &#39;Access-Control-Allow-Headers&#39; 字段值。 不设置确切值默认支持所有的header字段（Cache-Controller、Content-Language、Content-Type、Expires、Last-Modified、Pragma）跨域访问。</li><li><b>String[] exposedHeaders: </b> 跨域请求请求头中允许携带的除Cache-Controller、Content-Language、Content-Type、Expires、Last-Modified、Pragma这六个基本字段之外的其他字段信息，对应的是跨域请求 Response 头中的 &#39;Access-control-Expose-Headers&#39;字段值。</li><li><b>RequestMethod[] methods: </b> 跨域HTTP请求中支持的HTTP请求类型（GET、POST...），不指定确切值时默认与 Controller 方法中的 methods 字段保持一致。</li><li><b>String allowCredentials:</b>  该值对应的是是跨域请求 Response 头中的 &#39;Access-Control-Allow-Credentials&#39; 字段值。浏览器是否将本域名下的 cookie 信息携带至跨域服务器中。默认携带至跨域服务器中，但要实现 cookie 共享还需要前端在 AJAX 请求中打开 withCredentials 属性。</li><li><b>long maxAge:</b>  该值对应的是是跨域请求 Response 头中的 &#39;Access-Control-Max-Age&#39; 字段值，表示预检请求响应的缓存持续的最大时间，目的是减少浏览器预检请求/响应交互的数量。默认值1800s。<b>设置了该值后，浏览器将在设置值的时间段内对该跨域请求不再发起预请求。</b></li></ol><p>Spring对支持跨域访问的请求所做的操作：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ff28d47a24a797185e4e4656cb8cfbfa_b.jpg\" data-size=\"normal\" data-rawwidth=\"1173\" data-rawheight=\"819\" class=\"origin_image zh-lightbox-thumb\" width=\"1173\" data-original=\"https://pic3.zhimg.com/v2-ff28d47a24a797185e4e4656cb8cfbfa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1173&#39; height=&#39;819&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1173\" data-rawheight=\"819\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1173\" data-original=\"https://pic3.zhimg.com/v2-ff28d47a24a797185e4e4656cb8cfbfa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ff28d47a24a797185e4e4656cb8cfbfa_b.jpg\"/><figcaption>图1、DefaultCorsProcessor#handlerInternal设置response的header</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c25d0409b153eea5d4e4fdff980bb5e0_b.jpg\" data-size=\"normal\" data-rawwidth=\"1352\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb\" width=\"1352\" data-original=\"https://pic1.zhimg.com/v2-c25d0409b153eea5d4e4fdff980bb5e0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1352&#39; height=&#39;650&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1352\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1352\" data-original=\"https://pic1.zhimg.com/v2-c25d0409b153eea5d4e4fdff980bb5e0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c25d0409b153eea5d4e4fdff980bb5e0_b.jpg\"/><figcaption>图2、DefaultCorsProcessor#processRequest处理请求，判断是否支持跨域</figcaption></figure><p>问题: 图2中，判断是否需要往 response 头中 set 相关值的依据是 config == null，这里不禁好奇，CorsConfiguration 有何作用？在哪里初始化？以下将揭晓。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-415ffa02c90ced7c559458a9180c4e40_b.jpg\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb\" width=\"553\" data-original=\"https://pic1.zhimg.com/v2-415ffa02c90ced7c559458a9180c4e40_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;553&#39; height=&#39;530&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"553\" data-original=\"https://pic1.zhimg.com/v2-415ffa02c90ced7c559458a9180c4e40_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-415ffa02c90ced7c559458a9180c4e40_b.jpg\"/><figcaption>图3、CorsConfiguration</figcaption></figure><p>看到这些属性是不是有点眼熟，对的，就是对应 @CrossOrigin 注解的字段信息。</p><p>CorsConfiguration 的初始化过程涉及到 Spring 对 bean 的加载过程，以下为一些关键步骤的截图。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e81a37d4880f1267262b6f8a6e71cbfb_b.jpg\" data-size=\"normal\" data-rawwidth=\"1253\" data-rawheight=\"781\" class=\"origin_image zh-lightbox-thumb\" width=\"1253\" data-original=\"https://pic4.zhimg.com/v2-e81a37d4880f1267262b6f8a6e71cbfb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1253&#39; height=&#39;781&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1253\" data-rawheight=\"781\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1253\" data-original=\"https://pic4.zhimg.com/v2-e81a37d4880f1267262b6f8a6e71cbfb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e81a37d4880f1267262b6f8a6e71cbfb_b.jpg\"/><figcaption>图4、AbstractAutowireCapableBeanFactory#invokeInitMethods初始化bean</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7a446a726aa8ad70546b6aa444afa7c5_b.jpg\" data-size=\"normal\" data-rawwidth=\"1399\" data-rawheight=\"771\" class=\"origin_image zh-lightbox-thumb\" width=\"1399\" data-original=\"https://pic2.zhimg.com/v2-7a446a726aa8ad70546b6aa444afa7c5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1399&#39; height=&#39;771&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1399\" data-rawheight=\"771\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1399\" data-original=\"https://pic2.zhimg.com/v2-7a446a726aa8ad70546b6aa444afa7c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7a446a726aa8ad70546b6aa444afa7c5_b.jpg\"/><figcaption>图5、AbstractHandlerMethodMapping#initHandlerMethods  判断bean是否有@Controller等注解</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0d11b2f7a098fe1eb0899a3f088103d1_b.jpg\" data-size=\"normal\" data-rawwidth=\"1372\" data-rawheight=\"714\" class=\"origin_image zh-lightbox-thumb\" width=\"1372\" data-original=\"https://pic2.zhimg.com/v2-0d11b2f7a098fe1eb0899a3f088103d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1372&#39; height=&#39;714&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1372\" data-rawheight=\"714\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1372\" data-original=\"https://pic2.zhimg.com/v2-0d11b2f7a098fe1eb0899a3f088103d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0d11b2f7a098fe1eb0899a3f088103d1_b.jpg\"/><figcaption>图6、关键步骤，AbstractHandlerMethodMapping#register</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ac771cb21015acb63ca30f8cdfeff70f_b.jpg\" data-size=\"normal\" data-rawwidth=\"1373\" data-rawheight=\"770\" class=\"origin_image zh-lightbox-thumb\" width=\"1373\" data-original=\"https://pic4.zhimg.com/v2-ac771cb21015acb63ca30f8cdfeff70f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1373&#39; height=&#39;770&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1373\" data-rawheight=\"770\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1373\" data-original=\"https://pic4.zhimg.com/v2-ac771cb21015acb63ca30f8cdfeff70f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ac771cb21015acb63ca30f8cdfeff70f_b.jpg\"/><figcaption>图7、根据注解信息初始化CorsConfiguration, RequestMappingHandlerMapping#initCorsConfiguration</figcaption></figure><p>处理跨域/非跨域请求的过程：</p><p>DispatcherServlet#doService() --&gt;  DispatcherServlet#doDispatch() --&gt; HttpRequestHandlerAdapter#handle() --&gt; PreFlightHandler#handleRequest() --&gt; DefaultCorsProcessor#processRequest() --&gt; DefaultCorsProcessor#handleInternal()</p><h2>5、总结：</h2><h3>a、注解方式与过滤器方式适用场景：</h3><p>过滤器方式适合于大范围的控制跨域，比如某个controller类的所有放大全部支持某个或几个具体的域名跨域访问的情形。而对于细粒度的跨域控制，比如一个 controller 类中 methodA 支持域名 originA 跨域访问， methodB 支持域名 originB 跨域访问的情况，当然过滤器方式也能实现，但适用注解的方式能轻松很多，尤其是上述情况比较多的情形。</p><h3>b、@CrossOrigin 注解是基于拦截器还是过滤器实现的？</h3><p>答案是都不是。由图6内容可知，在初始化 bean 的时候有在一个 ConcurrentHashMap 中保存 url 与与其对应的跨域对象 CorsConfiguration （该 url 不支持跨域访问时该对象为空），图2 在处理请求的时候会 get url对应的 CorsConfiguration 对象对象不为空的情况下，执行 handleInternal 为 Response 头添加对应的字段信息。这个过程是在 DispatcherServlet 执行 doService() 方法过程中进行的，并不涉及到过滤器或者拦截器。虽然有一个 CorsFilter 的类，但 debug 发现，并不会经过这个过滤器。 </p><h3>c、适用过程中遇到的问题：</h3><p>在正确配置注解或者添加过滤器的情况下，仍然提示跨域失败。后来排查问题是由于项目未完全前后端分离且登陆拦截器对于需要登陆而未登陆的请求直接重定向到登陆页，这就导致<b>跨域访问一些需要经过登陆拦截器的接口时预请求被重定向至登陆页而跨域失败。</b>处理方式也很简单，放开登陆拦截，在接口中进行判断并返回相应的实体对象。</p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "跨域", 
                    "tagLink": "https://api.zhihu.com/topics/19612046"
                }, 
                {
                    "tag": "Spring注解", 
                    "tagLink": "https://api.zhihu.com/topics/20139043"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66244285", 
            "userName": "Tnlj", 
            "userLink": "https://www.zhihu.com/people/2b4ccac031e1115aaafb2322596a7288", 
            "upvote": 2, 
            "title": "Java锁相关", 
            "content": "<h2>0、写在前面</h2><p>UML图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-be7d227cb00c83dc79628c0cefbb5da9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1018\" data-rawheight=\"665\" class=\"origin_image zh-lightbox-thumb\" width=\"1018\" data-original=\"https://pic2.zhimg.com/v2-be7d227cb00c83dc79628c0cefbb5da9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1018&#39; height=&#39;665&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1018\" data-rawheight=\"665\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1018\" data-original=\"https://pic2.zhimg.com/v2-be7d227cb00c83dc79628c0cefbb5da9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-be7d227cb00c83dc79628c0cefbb5da9_b.jpg\"/></figure><h2>1、Lock接口</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0d5c5921b755bcd4320f671cc4063065_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"481\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb\" width=\"481\" data-original=\"https://pic2.zhimg.com/v2-0d5c5921b755bcd4320f671cc4063065_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;481&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"481\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"481\" data-original=\"https://pic2.zhimg.com/v2-0d5c5921b755bcd4320f671cc4063065_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0d5c5921b755bcd4320f671cc4063065_b.jpg\"/></figure><p>Lock接口是在Java SE5之后加入到并发包中的，在这之前，Java程序主要靠<b>synchronized</b>关键字来实现锁功能的。Lock接口实现了与synchronized类似的同步功能，只是在使用时需要显式的去获取、释放锁资源。虽然他缺少了synchronized隐式获取锁的便捷性，但却拥有了获取锁的可操作性、<b>可中断</b>的获取锁以及<b>超时获取锁资源</b>的特性。</p><p>Lock的使用：</p><div class=\"highlight\"><pre><code class=\"language-text\">Lock lock = new ReentranLock();\nlock.lock();\ntry{\n    //do something\n}finally{\n   lock.unLock();\n}</code></pre></div><p>注意事项：</p><ol><li>释放锁资源的操作一定要放在 finally 块中，目的是为保证锁资源一定能够被释放。</li><li>不要将获取锁的操作写在 try 块中。因为如果在获取锁的过程中发生了异常会导致锁无故释放。</li></ol><p>Lock较于synchronized的一些特征：</p><ul><li><b>尝试非阻塞的获取锁：</b>当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。</li><li><b>能被中断的获取锁：</b> 与synchronized不同，获取到锁的线程能够被响应中断，当获取到所得线程被中断时，将抛出中断异常，同时锁资源也会被释放。</li><li><b>超时获取锁资源：</b> 在指定的截止时间之前获取锁，如果到了截止时间仍无法获取锁，则返回，不会一直等待。</li></ul><h2>2、重入锁</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b62e9ed9bb5baa7d343908a929509d0e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"160\" class=\"origin_image zh-lightbox-thumb\" width=\"868\" data-original=\"https://pic3.zhimg.com/v2-b62e9ed9bb5baa7d343908a929509d0e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;868&#39; height=&#39;160&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"160\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"868\" data-original=\"https://pic3.zhimg.com/v2-b62e9ed9bb5baa7d343908a929509d0e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b62e9ed9bb5baa7d343908a929509d0e_b.jpg\"/></figure><p>重入锁ReentrantLock，顾名思义就是支持重进入的锁，他表示该锁能够支持一个线程对资源的重复加载。除此之外，该锁还支持获取锁时的公平和非公平性的选择。</p><p>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获得锁的线程，能够再次调用该方法而不被阻塞。</p><p>对于锁的公平性与否的问题，如果在绝对的时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等到锁资源时间最长的线程先获取锁。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</p><h3>2.1、重入锁之condition</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-266f9f780ebdcd405e39868bdfa8f004_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb\" width=\"468\" data-original=\"https://pic1.zhimg.com/v2-266f9f780ebdcd405e39868bdfa8f004_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;468&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"468\" data-original=\"https://pic1.zhimg.com/v2-266f9f780ebdcd405e39868bdfa8f004_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-266f9f780ebdcd405e39868bdfa8f004_b.jpg\"/></figure><p>通过 Lock 接口（重入锁实现了这一接口）的 Condition.newCondition() 方法可以生成一个与当前重入锁绑定的 Condition 实例， Condition 实例有 await()、 signal()方法，这与 Object.wait()、Object.notify() 类似，两者作用大致相同。但是 wait()、 notify() 方法是与synchronized 关键字使用的，而 Condition 是与重入锁相关联的。</p><p>主要方法介绍：</p><ul><li><b>await() throws InterruptedException:  </b>该方法会使当前线程进入等待状态，并释放锁资源。直到其他线程调用该 Condition 对象的 signal() 或 signalAll() 方法，当前线程才从 await() 方法中返回，或者其他线程调用 interrupted() 方法中断当前线程。注意，<b>如果当前等待线程从 await() 方法返回，那么表面该线程已经获取了 Condition 对象所对应的锁。换句话说，也就是当前线程要想从 condition.await() 继续执行，必须用到该 condition 对象的锁。</b></li><li><b>awaitUninterruptibly():  </b>与 await() 方法基本相同，但是他不会在等待过程中响应中断。</li><li><b>signal():  </b>唤醒一个等待在 Condition 上的线程，该线程从等待方法中返回必须拥有与Condition 相关联的锁。</li><li><b>signalAll():  </b>唤醒所有等待在 Condition 上的线程，该线程从等待方法中返回必须拥有与Condition 相关联的锁。</li></ul><p>一段有趣的代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class ReenterLockCondition implentments Runable{\n  public static ReentrantLock lock = new ReentrantLock();\n  //生成一个与lock绑定的Condition对象\n  public static Condition condition = lock.newCondition();\n  @Override\n  public void run(){\n    try{\n      //线程持有锁对象\n      lock.lock();\n      //线程释放持有的锁资源，进入到condition对象的等待序列中\n      condition.await();\n      System.out.println(&#34;Thread is going on&#34;);\n    }Catch(Throwable e){\n      e.printStackTrace();\n    }finaly{\n      lock.unlock();\n    }\n  }\n  public static void main(String[] args) throws Exception{\n    ReenterLockCondition t = new ReenterLockCondition();\n    Thread t1 = new Thread(t);\n    t1.start();\n    Thread.sleep(2000);\n    lock.lock();\n    //从当前condition对象的等待序列中唤醒一个线程\n    condition.singnal();\n    lock.unlock();\n  }\n}</code></pre></div><p><b>解析： </b>上述代码中condition.singnal() 唤醒等待在 condition 上的线程， lock.unlock() 则释放锁资源，如果没有 lock.unlock() 这行代码，虽然等待线程已经被唤醒，但 t1 线程仍然不会继续执行，这是因为<b>要使当前线程从 await() 中返回，必须拥有锁资源。</b>github详细解释：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/tianxianglan/Interview/blob/master/ReentrantLock.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">重入锁之Condition</a>。</p><h2>3、读写锁</h2><p>ReentantLock 实现了一种标准的互斥锁：每次最多只有一个线程能持有 ReentrantLock 。但对于维护数据的完整性来说，互斥通常是一种过于强硬的加锁规则，因此也就不必要的限制了并发性，虽然可以避免“写/写”冲突和“写/读”冲突，但同样也避免了“读/读”冲突。在许多情况下，数据结构上的操作都是“读操作”——虽然它们也是可变的并且在某些情况下被修改，但其中大部分操作都是读操作。此时，如果能够放宽加锁需求，允许多个执行读操作的线程同时访问数据结构，那么将提升程序的性能。<b>只要每个线程都能确保读取到最新的数据，并且在读取线程时不会有其他线程修改数据，那么就不会发生问题。</b>在这种情况下就可以使用读/写锁：一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能够同时进行。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-67d2e1f5ab375d224143460c70f74886_b.jpg\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"396\" class=\"origin_image zh-lightbox-thumb\" width=\"609\" data-original=\"https://pic3.zhimg.com/v2-67d2e1f5ab375d224143460c70f74886_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;609&#39; height=&#39;396&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"396\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"609\" data-original=\"https://pic3.zhimg.com/v2-67d2e1f5ab375d224143460c70f74886_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-67d2e1f5ab375d224143460c70f74886_b.jpg\"/><figcaption>ReadWriteLock接口</figcaption></figure><p>实现 ReadWriteLock 接口的实现类有 ReentrantReadWriteLock、ReadWriteLockView（内部类）。</p><p>读-写锁是一种性能优化措施，在一些特定的情况下能实现更高的并发性。在实际情况中，对于在多处理器系统上被频繁读取的数据结构，读-写锁能够提高性能。而在其他情况下，读-写锁的性能比独占锁的性能要略差一些，这是因为他们的复杂性更高。在读取锁和写入锁之间的交互可以采用多种实现方式。 ReadWriteLock 中的一些可选实现包括：</p><ul><li><b>释放优先：</b> 当一个写入操作释放写入锁时，并且队列中同时存在读线程和写线程，那么应该优先选择读线程、写线程，还是最先发出请求的线程？</li><li><b>读线程插队：</b> 如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立刻获得访问权，还是应该在写线程后面等待？如果允许写线程插队到写线程之前？如果允许读线程插队到写线程之前，那么将提高并发性，但却可能造成写线程发生饥饿问题。</li><li><b>重入性：</b> 读取锁和写入锁是否是可重入的？</li><li><b>降级：</b> 如果一个线程持有写入锁，那么能否在不释放该锁的情况下获取读取锁？这可能会使得写入锁被“降级”为读取锁，同时不允许其他写线程修改被保护得资源。</li><li><b>升级：</b>读取锁能否优先于其他正在等待得读线程和写线程而升级为一个写入锁？在大多数得读-写锁实现中并不支持升级，因为如果没有显式得升级操作，那么很容易造成死锁。（如果两个读线程试图同时升级为写入锁，那么二者都不会释放读取锁。）</li></ul><p>ReenrtrantReadWriteLock 为这两种锁都提供了可重入得加锁语义。与 ReentrantLock 类似，ReenrtrantReadWriteLock 在构造时也可以选择是一个<b>非公平的锁（默认）</b>还是一个公平的锁。</p><p><b>在公平锁中，等待时间最长的线程将优先获得锁。如果这个锁由读线程持有，而另一个线程请求写入锁，那么其他读线程都不能获得读取锁，直到写线程使用完并且释放了写入锁。在非公平锁中，线程获得访问许可的顺序是不确定的。写线程降级为读线程是可以的，但从读线程升级为写线程则是不可以的（这样会导致死锁）。</b></p><h2>4、小结</h2><p>与内置锁相比，显式的 Lock 提供了一些扩展功能，在处理锁的不可用性方面有着更高的灵活性，并且对队列行有着更好的控制。但 ReentrantLock 不能完全替代 synchronized ，只有在 synchronized 无法满足需求时，才应该使用它。</p><p>读-写锁允许多个读线程并发的访问被保护的对象，当访问以读取操作为主的数据结构时，它能提高程序的可伸缩性。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67601533", 
            "userName": "雁高飞", 
            "userLink": "https://www.zhihu.com/people/5b57ecb4e6645723ec2add412c503926", 
            "upvote": 7, 
            "title": "GitHub上的项目受美国出口管制吗？", 
            "content": "<p>参考：开源社、包云岗、GitHub、ASF<br/>5 月 20 日，外媒报道谷歌和华为暂停合作。因为涉及 Android 这个开源 OS，引起了开发圈内开始讨论开源和出口管制的相关话题。<br/><br/><br/>这个问题引起了 IT 界的恐慌。开源的风险到底在哪里？<br/><br/>其实很多人并没有亲自调查确认。我们认为只有获取足够的第一手有效信息，才能做出正确的判断，才能做出合适的应对方案。因此，我们在第一时间开展了调研，同时向一些海外朋友咨询。目前有一些初步的结果，更详细的报告会在后续给出。<br/><br/>针对开源的几个基本要素：开源基金会、开源协议、开源项目、开源代码托管平台。<br/><br/>我们对 12 个知名开源基金会、6 个常用的开源协议、3个代码托管平台进行了调研与分析，得出以下初步结论：<br/><br/>1️⃣开源基金会管理开源项目，但基金会的管理办法差异较大，而基金会旗下的开源项目也可以选择不同管理办法。<br/><br/>例如：①、Linux 基金会自身的管理办法不受美国出口管制，所以旗下的项目包括Linux Kernel 等默认遵循 Linux 基金会的管理办法，但虚拟化项目 Xen 明确说明遵循美国出口管制，就属于Linux基金会中的特例；<br/><br/>②、Apache 基金会的管理办法明确说明遵循美国出口管制，所以它旗下所有项目如Hadoop、Spark都将受到出口管制。<br/><br/>③、Mozilla 基金会明确声明遵守加州法律，出现各类纠纷将必须到Santa Clara的法庭裁决。<br/><br/>2️⃣ 目前调研的开源许可协议族（GPL、LGPL、BSD、MIT、Mozilla、Apache 2.0），均未涉及与政府出口管制无关的声明。<br/><br/>3️⃣ 目前调研的3个代码托管平台 GitHub、SourceForge、Google Code 均明确声明遵守美国出口管制条例，并按加州法律解决纠纷。<br/><br/>4️⃣ 小结：<br/>* 合理的开源基金会管理办法可以规避美国出口管制；<br/>* 开源协议与出口管制无关；<br/>* 代码托管平台是开源的最大风险；<br/><br/>5️⃣ 建议：<br/>* 选择开源软件时务必仔细阅读两个声明：一是所属开源基金会，二是项目本身；<br/><br/>* 尽快建立已有托管平台在美国以外的镜像平台；<br/><br/>* 长远来看，中国必须建立起自己的开源项目托管平台，并以更开放的方式吸引全世界的开源爱好者。<br/><br/>* 但是如何更开放？需要探索。比如，在这个世界上是否有可能设立一个支撑开源项目的特区 —— 一个完全由开源爱好者自治的法律特区？<br/><br/>6️⃣ 关于RISC-V<br/>RISC-V基金会隶属于Linux基金会，没有特别声明受美国出口管制，因此RISC-V基金会拥有的RISC-V开放指令集标准并不会受美国出口管制。这一点上周和RISC-V基金会的现任CEO专门进行了讨论并得到确认。后续我们也会再进一步确认。<br/><br/><br/><b>（开源社）林诚夏的看法：</b><br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2ccf19295c0812f55ed0ea76e34b6ae2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"516\" data-rawheight=\"1053\" class=\"origin_image zh-lightbox-thumb\" width=\"516\" data-original=\"https://pic3.zhimg.com/v2-2ccf19295c0812f55ed0ea76e34b6ae2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;516&#39; height=&#39;1053&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"516\" data-rawheight=\"1053\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"516\" data-original=\"https://pic3.zhimg.com/v2-2ccf19295c0812f55ed0ea76e34b6ae2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2ccf19295c0812f55ed0ea76e34b6ae2_b.jpg\"/></figure><p><br/><br/>希望后续能有同时懂开源和美国法律的朋友来发表看法。<br/><br/><br/>---（分隔线）---<br/><br/>除了很多程序员个人，国内也有很多公司在使用 GitHub 等代码托管平台。不妨一起来看看 GitHub 官网关于《GitHub 和出口管制》的详细说明。<br/><br/>提示：翻译可能不到位，英文好的童鞋，可以直接看英文<br/><a href=\"https://link.zhihu.com/?target=https%3A//help.github.com/en/articles/github-and-export-controls\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">help.github.com/en/arti</span><span class=\"invisible\">cles/github-and-export-controls</span><span class=\"ellipsis\"></span></a>  <br/><br/><b>《GitHub 和出口管制》</b><br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7937d5c694d3144944ff7fc6a2f43482_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"474\" data-rawheight=\"1314\" class=\"origin_image zh-lightbox-thumb\" width=\"474\" data-original=\"https://pic3.zhimg.com/v2-7937d5c694d3144944ff7fc6a2f43482_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;474&#39; height=&#39;1314&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"474\" data-rawheight=\"1314\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"474\" data-original=\"https://pic3.zhimg.com/v2-7937d5c694d3144944ff7fc6a2f43482_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7937d5c694d3144944ff7fc6a2f43482_b.jpg\"/></figure><p><br/><br/>据我们通过时光机查证，《GitHub 和出口管制》的说明，时光机中目前只有 1 次记录，时间是 2019 年 5 月 4 日。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bb445c9e8dc53edd351fe4327c38e8ca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"877\" data-rawheight=\"386\" class=\"origin_image zh-lightbox-thumb\" width=\"877\" data-original=\"https://pic3.zhimg.com/v2-bb445c9e8dc53edd351fe4327c38e8ca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;877&#39; height=&#39;386&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"877\" data-rawheight=\"386\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"877\" data-original=\"https://pic3.zhimg.com/v2-bb445c9e8dc53edd351fe4327c38e8ca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bb445c9e8dc53edd351fe4327c38e8ca_b.jpg\"/></figure><p><br/><br/>---（分隔线）---<br/><br/><b>Apache 基金会产品出口说明</b><br/><br/>在 Apache 基金会官网的出口协议页面，有明确说明：<br/><br/>Apache 软件基金会(ASF)是一家位于美国的 501(c)3 非营利性慈善机构。我们所有的产品都是通过公共论坛的在线协作开发的，并通过美国境内的一个中央服务器进行分发。因此，美国的出口法律法规适用于我们的发行版，并且产品和技术重新出口到世界各地不同的缔约方和地方时仍然有效。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ed205bb2122aa297ef79707bf1e7d0f4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"371\" class=\"origin_image zh-lightbox-thumb\" width=\"592\" data-original=\"https://pic1.zhimg.com/v2-ed205bb2122aa297ef79707bf1e7d0f4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;592&#39; height=&#39;371&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"371\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"592\" data-original=\"https://pic1.zhimg.com/v2-ed205bb2122aa297ef79707bf1e7d0f4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ed205bb2122aa297ef79707bf1e7d0f4_b.jpg\"/></figure><p><br/><a href=\"https://link.zhihu.com/?target=https%3A//www.apache.org/licenses/exports/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">apache.org/licenses/exp</span><span class=\"invisible\">orts/</span><span class=\"ellipsis\"></span></a><br/><br/>据我们通过时光机查证，Apache 基金会官网至少从 2007 年 5 月起，就明确了遵守美国出口管制。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2dbfdbedc0a41aabe2596b299a5d382c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"485\" class=\"origin_image zh-lightbox-thumb\" width=\"690\" data-original=\"https://pic1.zhimg.com/v2-2dbfdbedc0a41aabe2596b299a5d382c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;690&#39; height=&#39;485&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"485\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"690\" data-original=\"https://pic1.zhimg.com/v2-2dbfdbedc0a41aabe2596b299a5d382c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2dbfdbedc0a41aabe2596b299a5d382c_b.jpg\"/></figure><p><br/><br/>Apache 基金会拥有众多开源产品，比如 Hadoop、HBASE 和 ZooKeeper 等。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7e68e5d7b7be3aa64f6188bd355551b0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"875\" data-rawheight=\"2060\" class=\"origin_image zh-lightbox-thumb\" width=\"875\" data-original=\"https://pic1.zhimg.com/v2-7e68e5d7b7be3aa64f6188bd355551b0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;875&#39; height=&#39;2060&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"875\" data-rawheight=\"2060\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"875\" data-original=\"https://pic1.zhimg.com/v2-7e68e5d7b7be3aa64f6188bd355551b0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7e68e5d7b7be3aa64f6188bd355551b0_b.jpg\"/></figure><p><br/>提示：遵循 Apache 协议的开源项目，不等同于 Apache 基金会旗下项目。只有捐赠给某个基金会的开源项目，才算该基金会旗下项目。<br/><br/>希望后续能有更多同时懂开源和美国法律的朋友来发表看法。</p><p><b>我每天都会发表架构师的技术文章，需要架构师资料的同行们请关注我，同时也可以私信我获得架构师资料</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>原文：</p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3Ftimestamp%3D1559268964%26src%3D3%26ver%3D1%26signature%3Dd8g2ZS-%2A7KFlJQK7jMxNcia2wZTYAdIoTShJ9RbGWbFgiJhXHPtuO6Ymj42cpNAqNVhgiLIT-p6E1Zg9Ull9yoPIRNL8-lMgFAK8BvROM5H%2AEqur8YuCokzZr6KgL1UIAbWCS3sjGALrWgSKXJMLN7eYhSn8-O2TavJZqxttHUQ%3D\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">mp.weixin.qq.com/s?</span><span class=\"invisible\">timestamp=1559268964&amp;src=3&amp;ver=1&amp;signature=d8g2ZS-*7KFlJQK7jMxNcia2wZTYAdIoTShJ9RbGWbFgiJhXHPtuO6Ymj42cpNAqNVhgiLIT-p6E1Zg9Ull9yoPIRNL8-lMgFAK8BvROM5H*Equr8YuCokzZr6KgL1UIAbWCS3sjGALrWgSKXJMLN7eYhSn8-O2TavJZqxttHUQ=</span><span class=\"ellipsis\"></span></a><p></p>", 
            "topic": [
                {
                    "tag": "项目", 
                    "tagLink": "https://api.zhihu.com/topics/19557541"
                }, 
                {
                    "tag": "GitHub", 
                    "tagLink": "https://api.zhihu.com/topics/19566035"
                }, 
                {
                    "tag": "华为", 
                    "tagLink": "https://api.zhihu.com/topics/19565956"
                }
            ], 
            "comments": [
                {
                    "userName": "KazuoU", 
                    "userLink": "https://www.zhihu.com/people/c00b5b1b36a305d974d4f99b497e57a1", 
                    "content": "自建 更开放....... 多么讽刺啊", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64951028", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 2, 
            "title": "微服务后如何做一次系统梳理", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-407e3b41046bd8b08e4c38356a5446f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-407e3b41046bd8b08e4c38356a5446f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-407e3b41046bd8b08e4c38356a5446f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-407e3b41046bd8b08e4c38356a5446f9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>微服务的主要目的是将原本独立的系统拆分成多个小的，有独自进程运行的，同时这些小的服务单元之间通过RPC或者HTTP协议来相互通讯协作。每个独立的服务单元内部都有自己的数据存储、业务逻辑开发和自己的运维部署机制。我们在享受着微服务化后带来的灵活性便利的同时，对我们的运维和服务治理也提出了新的挑战。从早先单体应用中的代码依赖，变成了通信依赖。我们就不得不考虑以下问题，比如网络延迟、分布式事务、异步消息等等。</p><h2>一、系统分类与演进</h2><p>1. 系统分类</p><p>我们的系统如果按照功能划分的话，大概有如下三类系统。</p><p>第一类是接口服务系统，这类系统是提供外部接口比如JSF（京东自研RPC框架）、HTTP接口、hession接口等，这些接口有读，有写，尤其是写接口，要考虑好写的幂等性操作，读天然是幂等的，做好防刷即可。</p><p>第二类是网页类系统，用户直接使用网页，那么网页上的数据区域来源，就要分清楚，一张网页上面的数据从好多个源头过来，每个源头下面都有多个系统来支撑，如果一份数据来自多个渠道，需不需合并，都是要考虑的。</p><p>第三类是任务类系统，比如我们常见的统计、数据同步等功能的系统。这类系统要考虑任务是热备还是冷备，多数都是热备，此种情况下就需要考虑好分布式是任务调度的问题，资源分配，计算的准确性等。</p><p>每种系统对应的梳理方式又是不同的。</p><p>2. 系统演进</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c275cd14e222fdc405fac886ce018dfb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1031\" data-rawheight=\"196\" class=\"origin_image zh-lightbox-thumb\" width=\"1031\" data-original=\"https://pic4.zhimg.com/v2-c275cd14e222fdc405fac886ce018dfb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1031&#39; height=&#39;196&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1031\" data-rawheight=\"196\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1031\" data-original=\"https://pic4.zhimg.com/v2-c275cd14e222fdc405fac886ce018dfb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c275cd14e222fdc405fac886ce018dfb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>系统架构变化也是与时俱进的，早期的单体系统跟现在大家践行的微服务化系统，在系统梳理上以及治理上也是完全不同。上图是一个系统架构的演进（图参照：《分布式服务框架》1.5章节）</p><h2>二、梳理目的要搞清楚</h2><p>每一年618和双11之前，备战开始，我们都要对所有的系统做一次梳理。那么每一次梳理的目的，就是要找出系统薄弱点。现在系统多了，系统里面的业务也变得复杂了。不过没有关系，还是那句老话，打蛇打七寸，利用二八原理。集中精力到最重要的环节。另外80%不是说就不管了，这里面的业务可以走限流或者降级处理，当然也是要梳理的。只不过要有轻重之分。</p><h2>三、如何做</h2><p>我们要从大的方面梳理出一个系统包含哪些功能，这些功能里面哪些是核心功能也叫做黄金功能。同时从小的方面，对已经梳理出的核心功能，我要再梳理出这些功能对应的流程上包含的各个节点。每个节点要找出强依赖和弱依赖。强依赖，是说少了这个依赖功能不能完成，那么就要准备容灾方案，也就是比如依赖的DB挂了，那么我们可以用开关切到MQ里面。弱依赖，则是不影响功能使用的依赖，比如插入ES记录日志，那么ES挂掉，我们直接降级就好。</p><p>1. 接口服务类系统</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-daa4dac93a612f0d8b4deb1b71142acd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"434\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb\" width=\"434\" data-original=\"https://pic2.zhimg.com/v2-daa4dac93a612f0d8b4deb1b71142acd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;434&#39; height=&#39;235&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"434\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"434\" data-original=\"https://pic2.zhimg.com/v2-daa4dac93a612f0d8b4deb1b71142acd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-daa4dac93a612f0d8b4deb1b71142acd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们要梳理出提供的所有服务接口，找出其中的黄金接口，比如接口1是黄金接口，那么我们就要确保这个接口一定是可用的，如何保证，就是灾备。依赖资源比如redis集群，放两个机房，一个机房两套。总之这个接口是不可降级的，在不能降级的情况下，就要准备多套方案来确保接口1必须提供服务。</p><p>2. 网页类系统</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e8645fcc8011c94ed08145131e25a5ab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"520\" data-rawheight=\"392\" class=\"origin_image zh-lightbox-thumb\" width=\"520\" data-original=\"https://pic4.zhimg.com/v2-e8645fcc8011c94ed08145131e25a5ab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;520&#39; height=&#39;392&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"520\" data-rawheight=\"392\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"520\" data-original=\"https://pic4.zhimg.com/v2-e8645fcc8011c94ed08145131e25a5ab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e8645fcc8011c94ed08145131e25a5ab_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>网页类系统，比如首页，类目、展示区、导航栏，广告位，这些都不能挂，首页是一个网站的脸，企业的脸，一定不能丢脸。每个功能区域对应的信息都要有多级缓存，有托底数据，无论如何都要保证页面上是有内容的。</p><p>3. 任务类系统</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-452e707820e079000b72fc6c1d181d80_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"685\" data-rawheight=\"122\" class=\"origin_image zh-lightbox-thumb\" width=\"685\" data-original=\"https://pic1.zhimg.com/v2-452e707820e079000b72fc6c1d181d80_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;685&#39; height=&#39;122&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"685\" data-rawheight=\"122\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"685\" data-original=\"https://pic1.zhimg.com/v2-452e707820e079000b72fc6c1d181d80_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-452e707820e079000b72fc6c1d181d80_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>对于任务类系统，一样，要有分布式worker，切不可以单点。解决方案可以利用zookeeper+定时任务，自己实现，也可以采用开源的方案比如Elastic-Job, 上面的三类系统，在我们现有的结构中均都已微服务化，我们开篇也突出了微服务治理的特点，网络延迟、分布式事务、异步消息。因此我们针对微服务的梳理也是从这几个方面入手。关键点，就是找出通讯依赖，确定是强依赖，还是弱依赖。</p><p>4. 核心功能的核心流程梳理</p><p>梳理出核心功能以后，我们就要开始梳理核心流程，流程的梳理要找出关键节点，比如下面这张图，只是作为举例使用，一些类名和和字段都用XX代替。关键节点，就是我们重点对待的，强依赖哪些资源，弱依赖哪些资源。使用不同颜色标注，比如深黄色表示强依赖，浅绿色表示弱依赖。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-04e7dfbc38652f983418c98ca1ad941f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"1010\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-04e7dfbc38652f983418c98ca1ad941f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;1010&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"1010\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-04e7dfbc38652f983418c98ca1ad941f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-04e7dfbc38652f983418c98ca1ad941f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>四、总结</h2><p>上面描述的过程中，列举了系统的分类，系统的演进，流程的梳理。我们的最终目的就是要找出黄金功能，找出黄金流程，流程里面的强依赖和弱依赖。强依赖不可降级必须要有灾备方案。做到以上几点，确保梳理没有遗漏，无论系统如何演进与变化，我们的服务治理，618和双11的备战都能很好的完成！</p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }
            ], 
            "comments": [
                {
                    "userName": "软刀", 
                    "userLink": "https://www.zhihu.com/people/715d112d9f3c74a9ffcf55436f994efb", 
                    "content": "怎么做分布式worker？  只是多个程序副本，然后负载均衡下？还是要怎么处理？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63137334", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 7, 
            "title": "三种分布式锁：你锁了，人家就懂了", 
            "content": "<h2><b>0 前言</b></h2><p><b> 从前的锁很好看，钥匙精美有样子，你锁了，但一旦设计的不好，人家懂不懂就很难说了。关于分布式锁的设计，从以下四个角度考虑：</b></p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>具有容错性。只要大部分的节点正常运行，客户端就可以加锁和解锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ul><p><b>常见的，分布式锁有三种实现方式</b>：</p><ul><li>数据库乐观锁；</li><li>基于Redis的分布式锁；</li><li>基于ZooKeeper的分布式锁。</li></ul><p>三种常见分布式锁方案比较：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c77d37777c8ae31affc88401e7f8c1a9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"425\" data-rawheight=\"171\" class=\"origin_image zh-lightbox-thumb\" width=\"425\" data-original=\"https://pic2.zhimg.com/v2-c77d37777c8ae31affc88401e7f8c1a9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;425&#39; height=&#39;171&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"425\" data-rawheight=\"171\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"425\" data-original=\"https://pic2.zhimg.com/v2-c77d37777c8ae31affc88401e7f8c1a9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c77d37777c8ae31affc88401e7f8c1a9_b.jpg\"/></figure><h2><b>1 数据库乐观锁</b></h2><p>利用表的唯一索引<b>行级锁</b>进行加解锁，加锁：</p><div class=\"highlight\"><pre><code class=\"language-text\">insert into methodLock(method_name,desc) values (‘method_name’,‘desc’)</code></pre></div><p>释放锁，需要执行以下Sql:</p><div class=\"highlight\"><pre><code class=\"language-text\">delete from methodLock where method_name =&#39;method_nam</code></pre></div><p>另外还可以使用数据的<b>排他锁的形式加锁</b>，例如加上 for update:</p><div class=\"highlight\"><pre><code class=\"language-text\">result = select * from methodLock where method_name=xxx for update</code></pre></div><p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p><b>DB锁存在的问题：</b></p><ul><li>数据库单点故障，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是不可重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ul><p><b>DB锁问题解决方案：</b></p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍</li><li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的<b>机器的主机信息和线程信息</b>，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了</li></ul><h2><b>2 redis 分布式锁</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">jedis.setnx(String key, String value, String nxxx, String expx, int time)</code></pre></div><ul><li>· 第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>· 第二个为value，我们传的是requestId，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li><li>· 第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>· 第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>· 第五个为time，与第四个参数相呼应，代表key的过期时间。</li></ul><p>加锁还可以采用lua脚本形式：</p><div class=\"highlight\"><pre><code class=\"language-text\"> String script = &#34;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&#34;;\n Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</code></pre></div><p><b>错误加锁示例</b>：</p><div class=\"highlight\"><pre><code class=\"language-text\">public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) {\n   Long result = jedis.setnx(lockKey, requestId);\n     if (result == 1) {\n      // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁\n      jedis.expire(lockKey, expireTime);\n     }\n}</code></pre></div><p><b>原因：</b>两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p><p>释放锁的正确方式：</p><div class=\"highlight\"><pre><code class=\"language-text\"> /**\n * 释放分布式锁\n * @param jedis Redis客户端\n * @param lockKey 锁\n * @param requestId 请求标识\n * @return 是否释放成功\n */\n public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {\n \n String script = &#34;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&#34;;\n Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));\n \n if (RELEASE_SUCCESS.equals(result)) {\n return true;\n }\n return false;\n }</code></pre></div><p><b>释放锁错误示例1</b></p><p>最常见的解锁代码就是直接使用jedis.del()方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。</p><div class=\"highlight\"><pre><code class=\"language-text\">public static void wrongReleaseLock1(Jedis jedis, String lockKey) {\n jedis.del(lockKey);\n}</code></pre></div><p><b>释放锁错误示例2</b></p><p>这种解锁代码乍一看也是没问题，与正确姿势差不多，唯一区别的是分成两条命令去执行，代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public static void wrongReleaseLock2(Jedis jedis, String lockKey, String requestId) {\n// 判断加锁与解锁是不是同一个客户端\n if (requestId.equals(jedis.get(lockKey))) {\n // 若在此时，这把锁突然不是这个客户端的，则会误解锁\n jedis.del(lockKey);\n }\n}</code></pre></div><h2><b>3 zookeeper 分布式锁</b></h2><p>zk 是一种提供配置管理、分布式协同以及命名的中心化服务，用于集群配置中心管理，服务的注册监听等。zookeeper 分布式锁的实现利用zookeeper 管理配置中心的watcher机制（观察者模式），对竞争分布式锁的客户端维护了一张临时顺序表。表中每个节点代表一个客户端。</p><p> 手绘客户端加锁算法，原谅我拙劣的画技：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1fd39e13d153b51d76efe2ba2a0170a1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb\" width=\"756\" data-original=\"https://pic2.zhimg.com/v2-1fd39e13d153b51d76efe2ba2a0170a1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;756&#39; height=&#39;650&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"756\" data-original=\"https://pic2.zhimg.com/v2-1fd39e13d153b51d76efe2ba2a0170a1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1fd39e13d153b51d76efe2ba2a0170a1_b.jpg\"/></figure><p>注意，某个客户端节点在会话结束或者会话超时后，zookeeper会自动删除该节点。</p>", 
            "topic": [
                {
                    "tag": "分布式存储", 
                    "tagLink": "https://api.zhihu.com/topics/19558640"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }
            ], 
            "comments": [
                {
                    "userName": "elal ea", 
                    "userLink": "https://www.zhihu.com/people/c47c7799dba8ac8194c78fad9531a376", 
                    "content": "死锁问题不需要解决吗？  fencing问题也不考虑？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62788748", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 10, 
            "title": "分享：有赞百亿级日志系统架构设计", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1a2c2c10fbec07de9dffe011417903e1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"391\" data-rawheight=\"220\" class=\"content_image\" width=\"391\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;391&#39; height=&#39;220&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"391\" data-rawheight=\"220\" class=\"content_image lazy\" width=\"391\" data-actualsrc=\"https://pic2.zhimg.com/v2-1a2c2c10fbec07de9dffe011417903e1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>一、概述</h2><p>日志是记录系统中各种问题信息的关键，也是一种常见的海量数据。日志平台为集团所有业务系统提供日志采集、消费、分析、存储、索引和查询的一站式日志服务。主要为了解决日志分散不方便查看、日志搜索操作复杂且效率低、业务异常无法及时发现等等问题。</p><p>随着有赞业务的发展与增长，每天都会产生百亿级别的日志量（据统计，平均每秒产生 50 万条日志，峰值每秒可达 80 万条）。日志平台也随着业务的不断发展经历了多次改变和升级。本文跟大家分享有赞在当前日志系统的建设、演进以及优化的经历，这里先抛砖引玉，欢迎大家一起交流讨论。</p><h2>二、原有日志系统</h2><p>有赞从 16 年就开始构建适用于业务系统的统一日志平台，负责收集所有系统日志和业务日志，转化为流式数据，通过 flume 或者 logstash 上传到日志中心 (kafka 集群)，然后共 Track、Storm、Spark 及其它系统实时分析处理日志，并将日志持久化存储到 HDFS 供离线数据分析处理，或写入 ElasticSearch 提供数据查询。整体架构如下图 所示。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-41cbb0bdf969fe0429f49b1b55714dd6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"580\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb\" width=\"580\" data-original=\"https://pic3.zhimg.com/v2-41cbb0bdf969fe0429f49b1b55714dd6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;580&#39; height=&#39;315&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"580\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"580\" data-original=\"https://pic3.zhimg.com/v2-41cbb0bdf969fe0429f49b1b55714dd6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-41cbb0bdf969fe0429f49b1b55714dd6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>随着接入的应用的越来越多，接入的日志量越来越大，逐渐出现一些问题和新的需求，主要在以下几个方面：</p><ol><li>业务日志没有统一的规范，业务日志格式各式各样，新应用接入无疑大大的增加了日志的分析、检索成本。</li><li>多种数据日志数据采集方式，运维成本较高</li><li>存储方面，</li></ol><ul><li>采用了 Es 默认的管理策略，所有的 index 对应 3*2 个 shard（3 个 primary，3 个 replica），有部分 index 数量较大，对应单个 shard 对应的数据量就会很大，导致有 hot node，出现很多 bulk request rejected，同时磁盘 IO 集中在少数机器上。</li><li>对于 bulk request rejected 的日志没有处理，导致业务日志丢失</li><li>日志默认保留 7 天，对于 ssd 作为存储介质，随着业务增长，存储成本过于高昂</li><li>另外 Elasticsearch 集群也没有做物理隔离，Es 集群 oom 的情况下，使得集群内全部索引都无法正常工作，不能为核心业务运行保驾护航</li></ul><p>4. 日志平台收集了大量用户日志信息，当时无法直接的看到某个时间段，哪些错误信息较多，增加定位问题的难度。</p><h2>三、现有系统演进</h2><p>日志从产生到检索，主要经历以下几个阶段：采集 -&gt; 传输 -&gt; 缓冲 -&gt; 处理 -&gt; 存储 -&gt; 检索，详细架构如下图所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-808226708c9675792590a6d0353889b8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-808226708c9675792590a6d0353889b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;247&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-808226708c9675792590a6d0353889b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-808226708c9675792590a6d0353889b8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3.1 日志接入</b></p><p>日志接入目前分为两种方式，SDK 接入和调用 Http Web 服务接入</p><ul><li>SDK 接入：日志系统提供了不同语言的 SDK，SDK 会自动将日志的内容按照统一的协议格式封装成最终的消息体，并最后最终通过 TCP 的方式发送到日志转发层（rsyslog-hub）</li><li>Http Web 服务接入：有些无法使用 SDk 接入日志的业务，可以通过 Http 请求直接发送到日志系统部署的 Web 服务，统一由 web protal 转发到日志缓冲层的 kafka 集群</li></ul><p><b>3.2 日志采集</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-28bbeda91ed2db50a281eb648e967ed1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"509\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-28bbeda91ed2db50a281eb648e967ed1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;509&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"509\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-28bbeda91ed2db50a281eb648e967ed1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-28bbeda91ed2db50a281eb648e967ed1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>现在有 rsyslog-hub 和 web portal 做为日志传输系统，rsyslog 是一个快速处理收集系统日志的程序，提供了高性能、安全功能和模块化设计。之前系统演进过程中使用过直接在宿主机上部署 flume 的方式，由于 flume 本身是 java 开发的，会比较占用机器资源而统一升级为使用 rsyslog 服务。为了防止本地部署与 kafka 客户端连接数过多，本机上的 rsyslog 接收到数据后，不做过多的处理就直接将数据转发到 rsyslog-hub 集群，通过 LVS 做负载均衡，后端的 rsyslog-hub 会通过解析日志的内容，提取出需要发往后端的 kafka topic。</p><p><b>3.3 日志缓冲</b></p><p>Kafka 是一个高性能、高可用、易扩展的分布式日志系统，可以将整个数据处理流程解耦，将 kafka 集群作为日志平台的缓冲层，可以为后面的分布式日志消费服务提供异步解耦、削峰填谷的能力，也同时具备了海量数据堆积、高吞吐读写的特性。</p><p><b>3.4 日志切分</b></p><p>日志分析是重中之重，为了能够更加快速、简单、精确地处理数据。日志平台使用 spark streaming 流计算框架消费写入 kafka 的业务日志，Yarn 作为计算资源分配管理的容器，会跟不同业务的日志量级，分配不同的资源处理不同日志模型。</p><p>整个 spark 任务正式运行起来后，单个批次的任务会将拉取的到所有的日志分别异步的写入到 ES 集群。业务接入之前可以在管理台对不同的日志模型设置任意的过滤匹配的告警规则，spark 任务每个 excutor 会在本地内存里保存一份这样的规则，在规则设定的时间内，计数达到告警规则所配置的阈值后，通过指定的渠道给指定用户发送告警，以便及时发现问题。当流量突然增加，es 会有 bulk request rejected 的日志会重新写入 kakfa，等待补偿。</p><p><b>3.5 日志存储</b></p><p>- 原先所有的日志都会写到 SSD 盘的 ES 集群，logIndex 直接对应 ES 里面的索引结构，随着业务增长，为了解决 Es 磁盘使用率单机最高达到 70%~80% 的问题, 现有系统采用 Hbase 存储原始日志数据和 ElasticSearch 索引内容相结合的方式，完成存储和索引。</p><ul><li>Index 按天的维度创建，提前创建 index 会根据历史数据量，决定创建明日 index 对应的 shard 数量，也防止集中创建导致数据无法写入。现在日志系统只存近 7 天的业务日志，如果配置更久的保存时间的，会存到归档日志中。</li><li>对于存储来说，Hbase、Es 都是分布式系统，可以做到线性扩展。</li></ul><h2>四、多租户</h2><p>随着日志系统不断发展，全网日志的 QPS 越来越大，并且部分用户对日志的实时性、准确性、分词、查询等需求越来越多样。为了满足这部分用户的需求，日志系统支持多租户的的功能，根据用户的需求，分配到不同的租户中，以避免相互影响。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ea90a2bd1314c0bb5a9942db9c242545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-ea90a2bd1314c0bb5a9942db9c242545_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-ea90a2bd1314c0bb5a9942db9c242545_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ea90a2bd1314c0bb5a9942db9c242545_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>针对单个租户的架构如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c2a73db09897f80a167e2f5c12050481_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-c2a73db09897f80a167e2f5c12050481_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;368&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-c2a73db09897f80a167e2f5c12050481_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c2a73db09897f80a167e2f5c12050481_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>SDK：可以根据需求定制，或者采用天网的 TrackAppender 或 SkynetClient</li><li>Kafka 集群：可以共用，也可以使用指定 Kafka 集群</li><li>Spark 集群：目前的 Spark 集群是在 yarn 集群上，资源是隔离的，一般情况下不需要特地做隔离</li><li>存储：包含 ES 和 Hbase，可以根据需要共用或单独部署 ES 和 Hbase</li></ul><h2>五、现有问题和未来规划</h2><p>目前，有赞日志系统作为集成在天网里的功能模块，提供简单易用的搜索方式，包括时间范围查询、字段过滤、NOT/AND/OR、模糊匹配等方式，并能对查询字段高亮显示，定位日志上下文，基本能满足大部分现有日志检索的场景，但是日志系统还存在很多不足的地方，主要有:</p><ol><li>缺乏部分链路监控：日志从产生到可以检索，经过多级模块，现在采集，日志缓冲层还未串联，无法对丢失情况进行精准监控，并及时推送告警。</li><li>现在一个日志模型对应一个 kafka topic，topic 默认分配三个 partition，由于日志模型写入日志量上存在差异，导致有的 topic 负载很高，有的 topic 造成一定的资源浪费，且不便于资源动态伸缩。topic 数量过多，导致 partition 数量过多，对 kafka 也造成了一定资源浪费，也会增加延迟和 Broker 宕机恢复时间。</li><li>目前 Elasticsearch 中文分词我们采用 ik_max_word，分词目标是中文，会将文本做最细粒度的拆分，但是日志大部分都是英文，分词效果并不是很好。</li></ol><p>上述的不足之处也是我们以后努力改进的地方，除此之外，对于日志更深层次的价值挖掘也是我们探索的方向，从而为业务的正常运行保驾护航。</p><p></p>", 
            "topic": [
                {
                    "tag": "架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556226"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62652838", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 13, 
            "title": "我们用 WebAssembly 将 Web App 速度提升了 20 倍", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f673716a9a2334ef073fc5ff95c73fb5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f673716a9a2334ef073fc5ff95c73fb5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f673716a9a2334ef073fc5ff95c73fb5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f673716a9a2334ef073fc5ff95c73fb5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>WebAssembly 是除 JavaScript 之外另一门可以在浏览器上运行的语言，其他语言（如 C/C++/Rust）也可以被编译成 WebAssembly 在浏览器上运行。WebAssembly 是静态类型的语言，使用线性内存，并保存成紧凑的二进制格式，所以速度非常快，可以以“接近原生”的速度运行代码（与从本地命令行运行程序的速度相当）。</p><p>到目前为止，WebAssembly 已经被用在各种应用程序中，从游戏（如 Doom 3）到将桌面应用程序移植到 Web（如 Autocad 和 Figma）。它甚至也被用到了浏览器之外，例如被作为一门高效而灵活的 Serverless 计算编程语言。</p><p>这篇文章将介绍如何使用 WebAssembly 来加速一款 Web 数据分析工具。</p><h2>背景介绍</h2><p>这个 Web 工具就是 fastq.bio，它是一个交互式的 Web 工具，科学家用它来快速预览 DNA 序列数据的质量。下面是这个工具的一个截图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-52510dc1c18b11dc1ff9282db7ce97da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-52510dc1c18b11dc1ff9282db7ce97da_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;499&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-52510dc1c18b11dc1ff9282db7ce97da_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-52510dc1c18b11dc1ff9282db7ce97da_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我不打算深入介绍这个计算过程，但总的来说，上面的图表为科学家提供了一个有关 DNA 序列质量的信息，可以帮助他们快速发现数据质量问题。</p><p>虽然现在也有很多命令行工具可用来生成这类报告图表，但 fastq.bio 的目标是让用户可以在浏览器中直接通过交互式的方式预览数据质量，这对于不习惯使用命令行的科学家来说非常有用。</p><p>这个工具的输入是一个普通文本文件，其中包含了使用 DNA 序列指令生成的 DNA 序列和其中每个核苷酸的质量分数。这种格式被称为“FASTQ”，所以这个工具的名字叫作 fastq.bio。</p><h2>JavaScript 实现</h2><p>最初版本的 fastq.bio 要求用户从本地选择一个 FASTQ 文件，这个工具借助 File 对象（使用了 FileReader API）从文件的随机位置读取一小块数据，然后我们使用 JavaScript 对这个数据库执行基本的字符串操作，并计算相关的指标。这个指标可以帮助我们跟踪一个 DNA 片段中有多少 A、C、G 和 T。</p><p>在计算好指标之后，我们使用 Plotly.js 画出结果图表，然后继续读取下一个数据块。我们之所以每次只处理一小块数据，是为了获得更好的用户体验，因为一次性处理整个文件（一个 FASTQ 文件通常会有几个 GB 那么大）会让用户等待太长时间。我们发现，每次处理介于 0.5 MB 到 1 MB 之间的数据块可以让应用程序看起来是连续的，而且可以更快地为用户返回信息，但这个数字也取决于应用程序的具体细节以及计算机的处理速度。</p><p>初始架构非常简单：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9c0c6e94235a51e1dd55e6ad67f7d502_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-9c0c6e94235a51e1dd55e6ad67f7d502_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;350&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-9c0c6e94235a51e1dd55e6ad67f7d502_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9c0c6e94235a51e1dd55e6ad67f7d502_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>红色方框部分就是我们要进行的字符串操作，用来生成指标。这个部分是计算密集型的，所以很适合使用 WebAssembly 来优化。</p><h2>WebAssembly 实现</h2><p>为了搞清楚 WebAssembly 是否可以加快 Web 应用程序的速度，我们尝试了一些现成的工具，这些工具是使用 C/C++/Rust 开发的，这样就可以把它们移植成 WebAssembly，并且这些工具已经得到科学社区的认可。</p><p>经过一些调研，我们最终决定使用seqtk，这是一个被广泛使用的开源工具，使用 C 语言开发，可以用来评估序列数据的质量。</p><p>在将 seqtk 编译成 WebAssembly 之前，我们先来看看如何从源代码编译 seqtk，并在命令行中运行它。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-96b57bfcbd4a35ae0dc845d1bcc99d17_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb\" width=\"534\" data-original=\"https://pic4.zhimg.com/v2-96b57bfcbd4a35ae0dc845d1bcc99d17_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;534&#39; height=&#39;148&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"534\" data-original=\"https://pic4.zhimg.com/v2-96b57bfcbd4a35ae0dc845d1bcc99d17_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-96b57bfcbd4a35ae0dc845d1bcc99d17_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>另一方面，我们可以使用Emscripten工具链将 seqtk 编译成 WebAssembly。</p><p>如果你还没有安装 Emscripten，可以从Dockerhub上下载我们提供的 docker 镜像，其中就包含了这个工具链。</p><p>或者你也可以从头开始安装，只是这样需要更长的时间：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-af6bef63b426bc48ae8bc03a4c91d1e2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb\" width=\"545\" data-original=\"https://pic3.zhimg.com/v2-af6bef63b426bc48ae8bc03a4c91d1e2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;545&#39; height=&#39;82&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"545\" data-original=\"https://pic3.zhimg.com/v2-af6bef63b426bc48ae8bc03a4c91d1e2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-af6bef63b426bc48ae8bc03a4c91d1e2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在进入容器后，我们可以使用 emcc 代替 gcc：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6c230bdddafd4c72da567c37870622a5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"178\" class=\"origin_image zh-lightbox-thumb\" width=\"573\" data-original=\"https://pic2.zhimg.com/v2-6c230bdddafd4c72da567c37870622a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;573&#39; height=&#39;178&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"178\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"573\" data-original=\"https://pic2.zhimg.com/v2-6c230bdddafd4c72da567c37870622a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6c230bdddafd4c72da567c37870622a5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>编译成二进制文件和编译成 WebAssembly 其实并没有太多不同之处：</p><p>1.Emscripten 会生成一个.wasm 文件和一个.js 文件，而不是生成 seqtk 二进制文件。</p><p>2. 我们使用了 USE_ZLIB 标记，这样就可以支持 zlib 库。因为 zlib 已经被移植到 WebAssembly，并被广泛使用，所以 Emscripten 将会将其包含在项目中。</p><p>3. 我们启用了 Emscripten 的虚拟文件系统（POSIX 风格的文件系统），只是它是运行在浏览器的内存中，在页面被刷新时会消失，除非你使用 IndexedDB 把它的状态保存在浏览器中）。</p><p>为什么使用虚拟文件系统？为了回答这个问题，我们先来比较一下在命令行中调用 seqtk 和在 JavaScript 中调用编译过的 WebAssembly 模块：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d7069f950d2a5d50eecb2707c33df02c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"580\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb\" width=\"580\" data-original=\"https://pic1.zhimg.com/v2-d7069f950d2a5d50eecb2707c33df02c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;580&#39; height=&#39;134&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"580\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"580\" data-original=\"https://pic1.zhimg.com/v2-d7069f950d2a5d50eecb2707c33df02c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d7069f950d2a5d50eecb2707c33df02c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>访问虚拟文件系统是一个非常重要的能力，这意味着我们可以在不重写 seqtk 的情况下直接处理字符串。我们可以将数据块挂载到虚拟文件系统中（作为 data.fastq 文件），然后调用 seqtk 的 main() 函数。</p><p>在将 seqtk 编译成 WebAssembly 后的 fastq.bio 架构图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9fada5f389a94d1e4943326fa8ebad44_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-9fada5f389a94d1e4943326fa8ebad44_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;355&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-9fada5f389a94d1e4943326fa8ebad44_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9fada5f389a94d1e4943326fa8ebad44_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>如图所示，我们并没有在浏览器主线程上运行计算，而是使用了 WebWorker，这样就可以在后台线程上运行计算，避免给浏览器造成阻塞。WebWorker 的控制器负责启动 Worker，并管理与主线程之间的通信。</p><p>然后，我们让 Worker 运行 seqtk 命令来处理事先挂载好的文件。在 seqtk 运行完成之后，Worker 通过一个 Promise 将结果发送回主线程，主线程在接收到消息之后使用结果数据更新图表。与 JavaScript 实现一样，我们每次只处理一个数据块。</p><h2>性能优化</h2><p>为了评估使用 WebAssembly 是否确实为我们带来了速度上的优势，我们比较了 JavaScript 实现和 WebAssembly 实现每秒钟分别可以读取多少指标。我们忽略了生成交互式图表的时间，因为两者在这方面都使用了 JavaScript。</p><p>在什么都没做的情况下，我们已经可以看到 WebAssembly 比 JavaScript 有 9 倍左右的速度提升：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e45b828e4796a9b6eed11fe984481102_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-e45b828e4796a9b6eed11fe984481102_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-e45b828e4796a9b6eed11fe984481102_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e45b828e4796a9b6eed11fe984481102_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个结果已经很好了，不过，我们发现，seqtk 生成了很多有用的 QC 指标，但其中有很多并没有被用到。在移除了这些没有被用到的指标之后，速度提升达到了 13 倍。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-46189e4bad46592351819fbba16b7d61_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-46189e4bad46592351819fbba16b7d61_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-46189e4bad46592351819fbba16b7d61_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-46189e4bad46592351819fbba16b7d61_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后还有一个可改进的地方。到目前为止，fastq.bio 是通过调用两个不同的 C 函数来获取指标，其中每个函数负责计算一系列不同的指标。其中一个函数以直方图的形式返回信息，另一个则以 DNA 序列位置函数的形式返回信息。这意味着同一个数据块会被读取两次，而这其实是不必要的。</p><p>所以，我们将这两个函数的代码合成一个。因为原本的两个输出包含了不同数量的列，所以我们使用 JavaScript 来区分它们。但这样做是值得的：速度提升了 20 多倍！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1ca9cf87811e3286b710d8059b7cf77c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"447\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-1ca9cf87811e3286b710d8059b7cf77c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;447&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"447\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-1ca9cf87811e3286b710d8059b7cf77c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1ca9cf87811e3286b710d8059b7cf77c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>注意事项</h2><p>不要指望 WebAssembly 总能为我们带来 20 多倍的速度提升，有时候可能只能获得 2 倍甚至是 20% 的提升。而如果在内存中加载了太多的数据，有可能速度还会变慢，或者需要在 WebAssembly 和 JavaScript 之间进行很多的通信。</p>", 
            "topic": [
                {
                    "tag": "WebAssembly", 
                    "tagLink": "https://api.zhihu.com/topics/20024261"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>纯业务逻辑的话，是不是提升不大？我看大多数应用在图像方面。</p>", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62652715", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 14, 
            "title": "分享：12 个非常有用的 JavaScript 技巧", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ed32174d4081e2568a0e0c1df07cfcc7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-ed32174d4081e2568a0e0c1df07cfcc7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-ed32174d4081e2568a0e0c1df07cfcc7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ed32174d4081e2568a0e0c1df07cfcc7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在这篇文章中，将分享 12 个非常有用的 JavaScript 技巧，可以帮助你写出简洁且高性能的代码。</p><h2><b>1. 过滤唯一值</b></h2><p>ES6 引入了 Set 对象和延展（spread）语法…，我们可以用它们来创建一个只包含唯一值的数组。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6c17ceaa8f7fadf330ba099ce7aa96b0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"100\" class=\"origin_image zh-lightbox-thumb\" width=\"492\" data-original=\"https://pic1.zhimg.com/v2-6c17ceaa8f7fadf330ba099ce7aa96b0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;492&#39; height=&#39;100&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"100\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"492\" data-original=\"https://pic1.zhimg.com/v2-6c17ceaa8f7fadf330ba099ce7aa96b0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6c17ceaa8f7fadf330ba099ce7aa96b0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在 ES6 之前，获得同样的数组需要更多的代码！</p><p>这个技巧可以支持包含原始类型的数组：undefined、null、boolean、string 和 number。但如果你的数组包含了对象、函数或其他嵌套数组，就不能使用这种方法了。</p><h2>2. 在循环中缓存数组长度</h2><p>在我们学习使用 for 循环时，一般建议使用这种结构：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1b54f6a91e9ec2a4b3fcbb2b8d0dea49_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"517\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb\" width=\"517\" data-original=\"https://pic2.zhimg.com/v2-1b54f6a91e9ec2a4b3fcbb2b8d0dea49_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;517&#39; height=&#39;76&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"517\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"517\" data-original=\"https://pic2.zhimg.com/v2-1b54f6a91e9ec2a4b3fcbb2b8d0dea49_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1b54f6a91e9ec2a4b3fcbb2b8d0dea49_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在使用这种方式时，for 循环的每次迭代都会重复计算数组长度。</p><p>有时候这个会很有用，但在大多数情况下，如果能够缓存数组的长度会更好，这样只需要计算一次就够了。我们可以把数组长度复制给一个叫作 length 的变量，例如：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3d0f4a3987c748505b5a1e2eb846480d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb\" width=\"496\" data-original=\"https://pic2.zhimg.com/v2-3d0f4a3987c748505b5a1e2eb846480d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;496&#39; height=&#39;90&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"496\" data-original=\"https://pic2.zhimg.com/v2-3d0f4a3987c748505b5a1e2eb846480d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3d0f4a3987c748505b5a1e2eb846480d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这段代码和上面的差不多，但从性能方面来看，即使数组变得很大，也不需要花费额外的运行时重复计算 array.length。</p><h2>3. 短路求值</h2><p>使用三元运算符可以很快地写出条件语句，例如：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-012a5a138273b9c363210b5b12985b1a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"564\" data-rawheight=\"79\" class=\"origin_image zh-lightbox-thumb\" width=\"564\" data-original=\"https://pic3.zhimg.com/v2-012a5a138273b9c363210b5b12985b1a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;564&#39; height=&#39;79&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"564\" data-rawheight=\"79\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"564\" data-original=\"https://pic3.zhimg.com/v2-012a5a138273b9c363210b5b12985b1a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-012a5a138273b9c363210b5b12985b1a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>但有时候三元运算符仍然很复杂，我们可以使用逻辑运算符 &amp;&amp; 和||来替代，让代码更简洁一些。这种技巧通常被称为“短路求值”。</p><p>假设我们想要返回两个或多个选项中的一个，使用 &amp;&amp; 可以返回第一个 false。如果所有操作数的值都是 true，将返回最后一个表达式的值。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-321b5e9892297cd32da86bf515ae8e83_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb\" width=\"541\" data-original=\"https://pic4.zhimg.com/v2-321b5e9892297cd32da86bf515ae8e83_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;541&#39; height=&#39;104&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"541\" data-original=\"https://pic4.zhimg.com/v2-321b5e9892297cd32da86bf515ae8e83_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-321b5e9892297cd32da86bf515ae8e83_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>使用||可以返回第一个 true。如果所有操作数的值都是 false，将返回最后一个表达式的值。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5c9a039fb758799f957679cd3640003d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"99\" class=\"origin_image zh-lightbox-thumb\" width=\"532\" data-original=\"https://pic2.zhimg.com/v2-5c9a039fb758799f957679cd3640003d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;532&#39; height=&#39;99&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"99\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"532\" data-original=\"https://pic2.zhimg.com/v2-5c9a039fb758799f957679cd3640003d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5c9a039fb758799f957679cd3640003d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1</p><p>假设我们想要返回一个变量的 length，但又不知道变量的类型。</p><p>我们可以使用 if/else 来检查 foo 是否是一个可接受的类型，但这样会让代码变得很长。这个时候可以使用短路求值：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d4682d904e271ae4ea88294b89775564_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"437\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb\" width=\"437\" data-original=\"https://pic1.zhimg.com/v2-d4682d904e271ae4ea88294b89775564_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;437&#39; height=&#39;59&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"437\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"437\" data-original=\"https://pic1.zhimg.com/v2-d4682d904e271ae4ea88294b89775564_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d4682d904e271ae4ea88294b89775564_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于上述两种情况，如果变量 foo 具有 length 属性，这个属性的值将被返回，否则将返回 0。</p><p>示例 2</p><p>你是否曾经在访问嵌套对象属性时遇到过问题？你可能不知道对象或某个子属性是否存在，所以经常会碰到让你头疼的错误。</p><p>假设我们想要访问 this.state 中的一个叫作 data 的属性，但 data 却是 undefined 的。在某些情况下调用 this.state.data 会导致 App 无法运行。为了解决这个问题，我们可以使用条件语句：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5c85fe1bc30c6a3d0645fcb5481feef8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"130\" class=\"origin_image zh-lightbox-thumb\" width=\"539\" data-original=\"https://pic1.zhimg.com/v2-5c85fe1bc30c6a3d0645fcb5481feef8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;539&#39; height=&#39;130&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"130\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"539\" data-original=\"https://pic1.zhimg.com/v2-5c85fe1bc30c6a3d0645fcb5481feef8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5c85fe1bc30c6a3d0645fcb5481feef8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>但这样似乎有点啰嗦，而||提供了更简洁的解决方案：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ffea34ab9e5394de4094759e288c31b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"46\" class=\"origin_image zh-lightbox-thumb\" width=\"527\" data-original=\"https://pic3.zhimg.com/v2-ffea34ab9e5394de4094759e288c31b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;527&#39; height=&#39;46&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"46\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"527\" data-original=\"https://pic3.zhimg.com/v2-ffea34ab9e5394de4094759e288c31b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ffea34ab9e5394de4094759e288c31b6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>4. 转换成布尔值</h2><p>除了标准的布尔值 true 和 false，在 JavaScript 中，所有的值要么是“真值”要么是“假值”。</p><p>在 JavaScript 中，除了 0、“”、null、undefined、NaN 和 false 是假值之外，其他的都是真值。</p><p>我们可以使用! 云算法来切换 true 和 false。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-da66181d0773d7192b720c71962d82b7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"133\" class=\"origin_image zh-lightbox-thumb\" width=\"572\" data-original=\"https://pic4.zhimg.com/v2-da66181d0773d7192b720c71962d82b7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;572&#39; height=&#39;133&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"133\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"572\" data-original=\"https://pic4.zhimg.com/v2-da66181d0773d7192b720c71962d82b7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-da66181d0773d7192b720c71962d82b7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>5. 转换成字符串</h2><p>要快速将数字转换成字符串，我们可以使用 + 运算符，然后在后面跟上一个空字符串。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4c628a4c7e6b64addf8e7c6dda70b62c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"591\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"591\" data-original=\"https://pic1.zhimg.com/v2-4c628a4c7e6b64addf8e7c6dda70b62c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;591&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"591\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"591\" data-original=\"https://pic1.zhimg.com/v2-4c628a4c7e6b64addf8e7c6dda70b62c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4c628a4c7e6b64addf8e7c6dda70b62c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>6. 转换成数字</h2><p>要把字符串转成数字，也可以使用 + 运算符。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fe629e6bf0d10b71dd4b15b0c159ff88_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"528\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb\" width=\"528\" data-original=\"https://pic1.zhimg.com/v2-fe629e6bf0d10b71dd4b15b0c159ff88_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;528&#39; height=&#39;104&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"528\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"528\" data-original=\"https://pic1.zhimg.com/v2-fe629e6bf0d10b71dd4b15b0c159ff88_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fe629e6bf0d10b71dd4b15b0c159ff88_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>也可以使用这种方式将布尔值转成数字，例如：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-675670a1a6407bacdcb53749ed5147c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"508\" data-rawheight=\"69\" class=\"origin_image zh-lightbox-thumb\" width=\"508\" data-original=\"https://pic1.zhimg.com/v2-675670a1a6407bacdcb53749ed5147c8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;508&#39; height=&#39;69&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"508\" data-rawheight=\"69\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"508\" data-original=\"https://pic1.zhimg.com/v2-675670a1a6407bacdcb53749ed5147c8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-675670a1a6407bacdcb53749ed5147c8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在某些情况下，+ 运算符会被解析成连接操作，而不是加法操作。对于这种情况，可以使用两个波浪号：~~。</p><p>一个波浪号表示按位取反操作，例如，~15 等于 -16。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-162e8d85b2785c5ed17efdbafb597bea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb\" width=\"541\" data-original=\"https://pic3.zhimg.com/v2-162e8d85b2785c5ed17efdbafb597bea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;541&#39; height=&#39;102&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"541\" data-original=\"https://pic3.zhimg.com/v2-162e8d85b2785c5ed17efdbafb597bea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-162e8d85b2785c5ed17efdbafb597bea_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>使用两个波浪号可以再次取反，因为 -(-n-1)=n+1-1=n，所以~-16 等于 15。</p><h2>7. 快速幂运算</h2><p>从 ES7 开始，可以使用 ** 进行幂运算，比使用 Math.power(2,3) 要快得多。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-389cbf7cc806cc4b1b2aaf591d39cc92_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"47\" class=\"origin_image zh-lightbox-thumb\" width=\"553\" data-original=\"https://pic3.zhimg.com/v2-389cbf7cc806cc4b1b2aaf591d39cc92_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;553&#39; height=&#39;47&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"47\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"553\" data-original=\"https://pic3.zhimg.com/v2-389cbf7cc806cc4b1b2aaf591d39cc92_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-389cbf7cc806cc4b1b2aaf591d39cc92_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>但要注意不要把这个运算符于 ^ 混淆在一起了，^ 通常用来表示指数运算，但在 JavaScript 中，^ 表示位异或运算。</p><p>在 ES7 之前，可以使用位左移运算符 &lt;&lt; 来表示以 2 为底的幂运算：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9482c6669849a68e00bebefd085f6607_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"566\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb\" width=\"566\" data-original=\"https://pic4.zhimg.com/v2-9482c6669849a68e00bebefd085f6607_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;566&#39; height=&#39;101&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"566\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"566\" data-original=\"https://pic4.zhimg.com/v2-9482c6669849a68e00bebefd085f6607_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9482c6669849a68e00bebefd085f6607_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>例如，2 &lt;&lt; 3 = 16 等同于 2 ** 4 = 16。</p><h2>8. 快速取整</h2><p>我们可以使用 Math.floor()、Math.ceil() 或 Math.round() 将浮点数转换成整数，但有另一种更快的方式，即使用位或运算符 |。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8a1a9ca16d1979113f1cb9382d286aca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb\" width=\"539\" data-original=\"https://pic3.zhimg.com/v2-8a1a9ca16d1979113f1cb9382d286aca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;539&#39; height=&#39;68&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"539\" data-original=\"https://pic3.zhimg.com/v2-8a1a9ca16d1979113f1cb9382d286aca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8a1a9ca16d1979113f1cb9382d286aca_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>| 的实际行为取决于操作数是正数还是负数，所以在使用这个运算符时要确保你知道操作数是正是负。</p><p>如果 n 是正数，那么 n|0 向下取整，否则就是向上取整。它会移除小数部分，也可以使用~~ 达到同样的效果。</p><p><b>移除整数尾部数字</b></p><p>| 运算符也可以用来移除整数的尾部数字，这样就不需要像下面这样：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7473fffd10b48da24aba2c86f77db81d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"494\" data-rawheight=\"64\" class=\"origin_image zh-lightbox-thumb\" width=\"494\" data-original=\"https://pic2.zhimg.com/v2-7473fffd10b48da24aba2c86f77db81d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;494&#39; height=&#39;64&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"494\" data-rawheight=\"64\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"494\" data-original=\"https://pic2.zhimg.com/v2-7473fffd10b48da24aba2c86f77db81d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7473fffd10b48da24aba2c86f77db81d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>相反，我们可以这样：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5458f177cbcf61e662557dad93c881a1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"518\" data-rawheight=\"95\" class=\"origin_image zh-lightbox-thumb\" width=\"518\" data-original=\"https://pic2.zhimg.com/v2-5458f177cbcf61e662557dad93c881a1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;518&#39; height=&#39;95&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"518\" data-rawheight=\"95\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"518\" data-original=\"https://pic2.zhimg.com/v2-5458f177cbcf61e662557dad93c881a1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5458f177cbcf61e662557dad93c881a1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>9. 自动类绑定</h2><p>在 ES6 中，我们可以使用箭头进行隐式绑定，这样可以为类的构造器省下一些代码，并跟一些重复出现的表达式说再见，比如 this.myMethod = this.myMethod.bind(this)。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f4b91ca49b241bce6aef5993eb10aadb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb\" width=\"592\" data-original=\"https://pic4.zhimg.com/v2-f4b91ca49b241bce6aef5993eb10aadb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;592&#39; height=&#39;444&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"592\" data-original=\"https://pic4.zhimg.com/v2-f4b91ca49b241bce6aef5993eb10aadb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f4b91ca49b241bce6aef5993eb10aadb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>10. 截取数组</h2><p>如果你想从一个数组尾部移除某些元素，可以使用一种比 splice() 更快的方法。</p><p>例如，如果你知道初始数组的大小，可以像下面这样重新定义它的 length 属性：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3d7cc8c949b195fcb43fe94c534f35be_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb\" width=\"557\" data-original=\"https://pic3.zhimg.com/v2-3d7cc8c949b195fcb43fe94c534f35be_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;557&#39; height=&#39;102&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"557\" data-original=\"https://pic3.zhimg.com/v2-3d7cc8c949b195fcb43fe94c534f35be_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3d7cc8c949b195fcb43fe94c534f35be_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这显然是一种更简洁的解决方案。不过，我发现 slice() 的运行速度更快，所以，如果你更看重速度，可以像下面这样：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-cd90495616c51b9f1fce192490fddc48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"516\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb\" width=\"516\" data-original=\"https://pic1.zhimg.com/v2-cd90495616c51b9f1fce192490fddc48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;516&#39; height=&#39;75&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"516\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"516\" data-original=\"https://pic1.zhimg.com/v2-cd90495616c51b9f1fce192490fddc48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-cd90495616c51b9f1fce192490fddc48_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>11. 获取数组最后的元素</h2><p>数组的 slice() 方法可以接受负整数，并从数组的尾部开始获取元素。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-54e0c9b6b2a0fe6b2bcee40cb918bc27_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"113\" class=\"origin_image zh-lightbox-thumb\" width=\"552\" data-original=\"https://pic4.zhimg.com/v2-54e0c9b6b2a0fe6b2bcee40cb918bc27_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;552&#39; height=&#39;113&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"113\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"552\" data-original=\"https://pic4.zhimg.com/v2-54e0c9b6b2a0fe6b2bcee40cb918bc27_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-54e0c9b6b2a0fe6b2bcee40cb918bc27_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>12. 格式化 JSON</h2><p>你之前可能使用过 JSON.stringify，但你是否知道它还可以用来给 JSON 添加缩进？</p><p>stringify() 方法可以接受两个额外的参数，一个是函数（形参为 replacer），用于过滤要显示的 JSON，另一个是空格个数（形参为 space）。</p><p>space 可以是一个整数，表示空格的个数，也可以是一个字符串（比如’\t’表示制表符），这样得到的 JSON 更容易阅读。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-bd9274b9233493d4ab7479a1cd2b3f28_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"583\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb\" width=\"583\" data-original=\"https://pic1.zhimg.com/v2-bd9274b9233493d4ab7479a1cd2b3f28_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;583&#39; height=&#39;154&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"583\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"583\" data-original=\"https://pic1.zhimg.com/v2-bd9274b9233493d4ab7479a1cd2b3f28_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-bd9274b9233493d4ab7479a1cd2b3f28_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }
            ], 
            "comments": [
                {
                    "userName": "大头虾", 
                    "userLink": "https://www.zhihu.com/people/8733baaf91845aa333f1934ee21dc7c9", 
                    "content": "不用计算，它是从数组对象中获取长度值", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "sunormonth", 
                    "userLink": "https://www.zhihu.com/people/5ad91c3051868116c0fb9e192a60eca4", 
                    "content": "<p>第六条举例有问题，-(-n-1)=n+1-1=n（错），-(-n-1)-1=n+1-1=n(对)</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "春明在努力", 
                    "userLink": "https://www.zhihu.com/people/ece79a59df04b1a12862ba1215ede70f", 
                    "content": "<p>抄别人公众号里的内容有意思吗？自己又不做详细解释，就是为了多点粉丝？</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62397932", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "HBase权威指南，架构：存储", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c648544802494ae5768100ea38c590c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"495\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb\" width=\"495\" data-original=\"https://pic1.zhimg.com/v2-c648544802494ae5768100ea38c590c8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;495&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"495\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"495\" data-original=\"https://pic1.zhimg.com/v2-c648544802494ae5768100ea38c590c8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c648544802494ae5768100ea38c590c8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>存储</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3b0a41d475b6df2dab4cd9c29ccf9a0b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-3b0a41d475b6df2dab4cd9c29ccf9a0b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-3b0a41d475b6df2dab4cd9c29ccf9a0b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3b0a41d475b6df2dab4cd9c29ccf9a0b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>HBase 主要处理两种文件：一种是预写日志（Write-Ahead Log，WAL），另一种是实际的数据文件。这两种文件主要由 HRegionServer 管理。</p><p>一个基本的流程是客户端首先联系 ZooKeeper 子集群（quorum）查找行键，通过 ZooKeeper 获取含有 -ROOT- 的 region 服务器，通过 -ROOT- region 服务器可以查询到含有 .META. 表的 region 服务器，最终，通过查询 .META. 服务器来获取客户端查询的行键数据所在的 region 服务器。</p><p>在启动 HBase 时，HMaster 负责将所有 region 分配到 HRegion Server 上，其中也包括特别的 -ROOT- 和 .META. 表。</p><p>HRegionServer 负责打开 region，并创建对应的 HRegion 实例。当 HRegion 被打开后，它会为每个表的 HColumnFamily 创建一个 Store 实例，这些列族是用户之前创建表时定义的。每个 Store 实例包含一个或多个 StoreFile 实例，它们是实际数据存储文件 HFile 的轻量级封装。每个 Store 还有其对应的一个 MemStore，一个 HRegionServer 分享了一个 HLog 实例。</p><h2><b>写路径</b></h2><p>当用户向 HRegionServer 发起 HTable.put(Put) 请求时，其会将请求交给对应的 HRegion 实例来处理。</p><p>第一步要决定数据是否需要写到由 HLog 类实现的预写日志中。一旦数据被写入到 WAL 中，数据就会被防到 MemStore 中，同时还会检查 MemStore 是否已经满了，如果满了，就会被请求刷写到磁盘中去。刷写请求由另外一个 HRegionServer 的线程处理，它会把数据写到 HDFS 中的一个新 HFile。</p><p>另外，关闭 region 服务器会强制所有的 memstore 被刷写到磁盘。</p><h2><b>文件</b></h2><p>HBase 使用一个 HDFS 中可配置的根目录，默认设为 &#34;/hbase&#34;。</p><div class=\"highlight\"><pre><code class=\"language-text\">$HADOOP_HOME/bin/hadoop dfs -lsr /hbase\n0 /hbase/.logs\n0 /hbase/.logs/foo.internal,60020,1309812147645\n0 /hbase/.logs/foo.internal,60020,1309812147645/ \nfoo.internal%2C60020%2C1309812147645.1309812151180\n0 /hbase/.oldlogs\n38 /hbase/hbase.id\n3 /hbase/hbase.version\n0 /hbase/testtable\n487 /hbase/testtable/.tableinfo\n0 /hbase/testtable/.tmp\n0 /hbase/testtable/1d562c9c4d3b8810b3dbeb21f5746855\n0 /hbase/testtable/1d562c9c4d3b8810b3dbeb21f5746855/.oldlogs\n124 /hbase/testtable/1d562c9c4d3b8810b3dbeb21f5746855/.oldlogs/ \nhlog.1309812163957\n282 /hbase/testtable/1d562c9c4d3b8810b3dbeb21f5746855/.regioninfo\n0 /hbase/testtable/1d562c9c4d3b8810b3dbeb21f5746855/.tmp\n</code></pre></div><p>文件可以被分为两类，一类位于 HBase 根目录下，另一类位于根目录中的表目录下。</p><p><b>根级文件</b></p><p>第一组文件是被 HLog 实例管理的 WAL 文件，这些日志文件被创建在 HBase 的根目录下一个名为 .logs 的目录下。对于每个 HRegionServer，日志目录中都包含一个对应的子目录。在每个子目录中有多个 HLog 文件。一个 region 服务器的所有 region 共享同一组 HLog 文件。</p><p>当所有包含的修改都被持久化到存储文件中，从而不需要日志文件时，它们会被防到 HBase 根目录下的 .oldlogs 目录下。在 10 分钟后，旧的日志文件将被 maser 删除。</p><p>hbase.id 和 habse.version 文件包含集群的唯一 ID 和文件格式版本信息。</p><p><b>表级文件</b></p><p>在 HBase 中，每张表都有自己的目录，其位于文件系统中 HBase 根目录下。每张表目录包括一个名为 .tableinfo 的顶层文件，其中包括表和列族的定义。.tmp 目录中包含一些临时数据。</p><p><b>region 级文件</b></p><p>region 目录中也有一个 .regioninfo 文件，这个文件包含了对应 region 的 HRegionInfo 实例序列化后的信息。与 .tableinfo 文件类似，它能被外部工具用来查看 region 的相关信息。</p><p><b>region 拆分</b></p><p>一个 region 超过了配置中 region 大小的最大值，region 就需要拆分，其会创建一个对应的 splitis 目录，它被用来临时存放两个字 region 相关的数据。</p><p><b>合并</b></p><p>随着 memstore 的刷写会生成很多磁盘文件。如果文件的数目达到阈值，合并过程将把它们合并成数量更少的体积更大的文件。这个过程持续到这些文件最大的文件超过配置的最大存储文件大小，此时会触发一个 region 拆分。</p><p>压缩合并有两种，即 minor 和 major。minor 合并负责重写最后生成的几个文件到一个更大的文件中。major 合并将所有文件压缩成一个单独的文件。在执行压缩检查时，系统自动决定运行哪种合并。</p><h2><b>HFile 格式</b></h2><p>实际的存储文件功能是由 HFile 类实现的，它被专门创建以达到一个目的：有效地存储 HBase 的数据。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e4a8ebd0618b49ada5a345577afcef80_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1127\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb\" width=\"1127\" data-original=\"https://pic1.zhimg.com/v2-e4a8ebd0618b49ada5a345577afcef80_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1127&#39; height=&#39;239&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1127\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1127\" data-original=\"https://pic1.zhimg.com/v2-e4a8ebd0618b49ada5a345577afcef80_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e4a8ebd0618b49ada5a345577afcef80_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这些文件是可变长度的，唯一固定的块是 FIle Info 块和 Trailer 块。Index 块记录 Data 和 Meta 块的偏移量。每个块都包含一个 magic 头部和一定数量的序列化的 KeyValue 实例。</p><p>HBase 存储文件的块与 Hadoop 的块之间没有匹配关系。事实上，这两种块类型之间根本没有相关性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8c8b8aae14ff29597826a6d35ee72074_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-8c8b8aae14ff29597826a6d35ee72074_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;270&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-8c8b8aae14ff29597826a6d35ee72074_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8c8b8aae14ff29597826a6d35ee72074_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>KeyValue 格式</h2><p>本质上，HFile 中的每个 KeyValue 都是一个低级的字节数组，它允许零复制访问数据。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-78157fc9f60d68e2a36df0ed1d62db0f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1121\" data-rawheight=\"168\" class=\"origin_image zh-lightbox-thumb\" width=\"1121\" data-original=\"https://pic4.zhimg.com/v2-78157fc9f60d68e2a36df0ed1d62db0f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1121&#39; height=&#39;168&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1121\" data-rawheight=\"168\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1121\" data-original=\"https://pic4.zhimg.com/v2-78157fc9f60d68e2a36df0ed1d62db0f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-78157fc9f60d68e2a36df0ed1d62db0f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>该结构以两个分布表示键长度（Key Lengh）和值长度（Value Lengh）的定义数字开始。</p>", 
            "topic": [
                {
                    "tag": "HBase", 
                    "tagLink": "https://api.zhihu.com/topics/19600820"
                }, 
                {
                    "tag": "架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556226"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62398016", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "5 个有用的开源日志分析工具", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-79a4578e96294575f956c4ee6471a916_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"633\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-79a4578e96294575f956c4ee6471a916_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;633&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"633\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-79a4578e96294575f956c4ee6471a916_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-79a4578e96294575f956c4ee6471a916_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>监控网络活动可能是一项单调而乏味的工作，但你有充分的理由要这样做。首先，它可以帮助你查找和调查工作站、连网设备和服务器上的可疑登录，同时确定管理员滥用的源头。还可以跟踪软件安装和数据传输，以便实时识别潜在的问题。</p><p>这些日志还有助于公司遵守适用于欧盟内任何实体的《通用数据保护条例》（GDPR）。因为如果你的网站要在欧盟是可浏览的，那么就必须遵守 GDPR。</p><p>日志记录（跟踪和分析）应该是任何监控基础设施中的一个基本过程。要从灾难中恢复 SQL Server 数据库，就需要事务日志文件。此外，通过跟踪日志文件，DevOps 团队和数据库管理员（DBA）可以保持最佳的数据库性能，或者在网络受到攻击的情况下找到未授权活动的证据。因此，定期监视和分析系统日志非常重要。</p><p>现下有相当多的开源日志跟踪器和分析工具可供使用，这使得为活动日志选择正确的资源变得比想象中更容易。免费和开源软件社区提供了适用于各种站点以及几乎任何操作系统的日志设计，为大家推荐 5 个非常好用的开源日志分析工具。</p><h2>Graylog</h2><p>Graylog于 2011 年在德国创建，现在作为开源工具或商业解决方案提供。它被设计成一个集中式日志管理系统，接收来自不同服务器或端点的数据流，并允许用户快速浏览或分析该信息。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cb5637da465ebf2a206b5242f8f8dae5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-cb5637da465ebf2a206b5242f8f8dae5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-cb5637da465ebf2a206b5242f8f8dae5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cb5637da465ebf2a206b5242f8f8dae5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>由于其易于扩展，Graylog 在系统管理员中建立了良好的声誉。大多数 Web 项目开始时规模很小，但是之后可能会成倍增长。Graylog 可以平衡跨后端服务器网络的负载，每天处理几 TB 的日志数据。</p><p>IT 管理员会发现，Graylog 的前端界面易于使用，并且功能强大。Graylog 是围绕仪表板的概念构建的，它允许你选择你认为最有价值的度量标准或数据源，并快速查看随着时间的变化趋势。</p><p>当发生安全或性能事件时，IT 管理员希望能够尽可能快地从症状追溯到根源。Graylog 中的搜索功能使这项工作变得简单。它具有内置的容错功能，可以运行多线程搜索，因此，你可以同时分析多个潜在的威胁。</p><h2>Nagios</h2><p>Nagios始于 1999 年，当时只有一名开发人员，后来发展成为管理日志数据的最可靠的开源工具之一。当前版本的 Nagios 可以与运行 Microsoft Windows、Linux 或 Unix 的服务器集成。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-057c3c8c49b57673a7f72a9d53e256c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"399\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-057c3c8c49b57673a7f72a9d53e256c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;399&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"399\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-057c3c8c49b57673a7f72a9d53e256c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-057c3c8c49b57673a7f72a9d53e256c0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>它的主要产品是一个日志服务器，其目的是简化数据收集并使系统管理员更容易访问信息。Nagios 日志服务器引擎将实时捕获数据并将其提供给一个强大的搜索工具。由于内置了安装向导，集成新端点或应用程序变得很容易。</p><p>Nagios 最常用于需要监视本地网络安全性的组织。它可以审计一系列与网络相关的事件，并帮助你自动分发警报。如果满足特定的条件，甚至可以将 Nagios 配置为运行预定义的脚本，从而让你可以在人员介入之前解决问题。</p><p>作为网络审计的一部分，Nagios 将根据日志数据来源的地理位置过滤日志数据。这意味着你可以使用映射技术构建一个全面的仪表板，以了解 Web 流量是如何流动的。</p><h2>Elastic Stack （即 ELK Stack）</h2><p>Elastic Stack，通常称为 ELK Stack，是那些需要筛选大量数据并理解其系统日志的组织中最流行的开源工具之一（这是我个人的最爱）。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-753551887391f06c89388e37bb9c91e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb\" width=\"572\" data-original=\"https://pic1.zhimg.com/v2-753551887391f06c89388e37bb9c91e0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;572&#39; height=&#39;335&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"572\" data-original=\"https://pic1.zhimg.com/v2-753551887391f06c89388e37bb9c91e0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-753551887391f06c89388e37bb9c91e0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>它主要由以下三个独立的产品组成：</p><ul><li>顾名思义，*<b>Elasticsearch</b>* 旨在帮助用户使用多种查询语言和类型在数据集中找出匹配项。速度是这个工具的最大优势。它可以扩展成由数百个服务器节点组成的集群，轻松处理 PB 级的数据。</li><li>*<b>Kibana</b>* 是一个可视化工具，它与 Elasticsearch 一起运行，允许用户分析他们的数据并构建强大的报告。当你第一次在服务器集群上安装 Kibana 引擎时，你将获得一个显示数据统计、图形甚至动画的界面。</li><li>ELK Stack 的最后一部分是 *<b>Logstash</b>*，它是作为一个纯粹的、进入 Elasticsearch 数据库的服务器端管道。你可以使用各种编码语言和 API 集成 Logstash。这样，你的网站和移动应用程序中的信息就可以直接输入到强大的 Elastic Stalk 搜索引擎中。</li></ul><p>ELK Stack 的一个独特特性是，它允许你监控构建在 WordPress 开源版本上的应用程序。与大多数跟踪管理和 PHP 日志（仅此而已）的开箱即用的安全审计日志工具相比，ELK Stack 可以筛选 Web 服务器和数据库日志。</p><p>糟糕的日志跟踪和数据库管理是导致网站性能差的最常见原因之一。如果没有定期检查、优化和清空数据库日志，不仅会降低站点的运行速度，还可能导致完全崩溃。因此，ELK 堆栈对于每个 WordPress 开发人员的工具包来说都是一个优秀的工具。</p><h2>LOGalyze</h2><p>LOGalyze是一个位于匈牙利的组织，它为系统管理员和安全专家构建开源工具，帮助他们管理服务器日志并将其转换为有用的数据点。其主要产品可供个人或商业用户免费下载。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-56d06c2017d728378078cf0976ad2e7a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"416\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-56d06c2017d728378078cf0976ad2e7a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;416&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"416\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-56d06c2017d728378078cf0976ad2e7a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-56d06c2017d728378078cf0976ad2e7a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>LOGalyze 被设计成一个巨大的管道，其中可以有多个服务器、应用程序和网络设备使用简单对象访问协议（Simple Object Access Protocol，SOAP）方法提供信息。它提供了一个前端界面，管理员可以登录该界面监控数据收集并开始分析数据。</p><p>在 LOGalyze 的 Web 界面中，你可以运行动态报告，并将其导出成 Excel 文件、PDF 或其他格式。这些报告基于 LOGalyze 后台管理的多维统计数据。它甚至可以跨服务器或应用程序组合数据字段，以帮助你发现性能趋势。</p><p>LOGalyze 被设计成在不到一个小时内就可以完成安装和配置。它预先构建的功能使它能够以法规所要求的格式收集审计数据。例如，LOGalyze 可以很容易地运行不同的 HIPAA 报告，以确保你的组织遵守卫生法规并保持合规性。</p><h2>Fluentd</h2><p>如果你的组织的数据源位于许多不同的位置和环境中，那么你的目标应该是尽可能地集中它们。否则，你将难以监控性能并防范安全威胁。</p><p>Fluentd是一个健壮的数据收集解决方案，并且完全是开源的。它没有提供完整的前端界面，而是作为一个集合层来帮助组织不同的管道。Fluentd 被世界上一些最大的公司使用，但是也可以在较小的组织中实施。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7c2be100acb00ed2f75abbdca98f51ee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-7c2be100acb00ed2f75abbdca98f51ee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;402&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-7c2be100acb00ed2f75abbdca98f51ee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7c2be100acb00ed2f75abbdca98f51ee_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Fluentd 最大的好处是它与当今最常见的技术工具兼容。例如，你可以使用 Fluentd 从 Web 服务器（如 Apache）收集数据，从智能设备收集传感器数据，从 MongoDB 收集动态记录。如何处理这些数据完全由你决定。</p><p>Fluentd 基于 JSON 数据格式，可以与500 多个由著名开发人员创建的插件一起使用。这使你可以将日志数据扩展到其他应用程序中，并通过最少的手工工作来进行更好地分析。</p><h2>小结</h2><p>如果你还没有把活动日志用于安全考量、政府合规性和生产力度量，那么请务必改变这种情况。市场上有很多插件，它们可以用于多种环境和平台，甚至可以用在你的内部网络上。不要等到发生了严重的事件，才开始采取积极主动的方法来维护和监督日志。</p>", 
            "topic": [
                {
                    "tag": "开源", 
                    "tagLink": "https://api.zhihu.com/topics/19562746"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61233022", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "解读10x程序员工作法-以终为始", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4a040651e54708b6cdd91269ee00723d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-4a040651e54708b6cdd91269ee00723d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-4a040651e54708b6cdd91269ee00723d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4a040651e54708b6cdd91269ee00723d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>以终为始</h2><p><b>以终为始：如何让你的努力不白费？</b></p><p>网上流传着一个帖子，亚马逊 CTO 介绍亚马逊是如何开发一项产品的，简单来说，他们采用向后工作的方法，开发一项产品的顺序为：</p><ul><li>写新闻稿；</li><li>写 FAQ（常见问题解答）；</li><li>写用户文档；</li><li>写代码。</li></ul><p><b>DoD的价值：你完成了工作，为什么他们还不满意？</b></p><p>DoD（Definition of Done，完成的定义）</p><ul><li>DoD 是一个清单，清单是由一个个的检查项组成的，用来检查我们的工作完成情况。</li><li>DoD 的检查项应该是实际可检查的。</li><li>DoD 是团队成员间彼此汇报的一种机制。</li><li>当我们有了 DoD，做事只有两种状态，即“做完”和“没做完”。</li></ul><p>我们本着“以终为始”的方式做事情，DoD 让我们能够在一开始就把“终”清晰地定义出来。</p><p><b>接到需求任务，你要先做哪件事？</b></p><p>我认为就是用户故事的关键点：验收标准，它可以清晰地定义出需求边界。</p><p>验收标准非常重要的一环是异常流程的描述。</p><p>验收标准给出了这个需求最基本的测试用例，它保证了开发人员完成需求最基本的质量。</p><p>在做任何需求或任务之前，先定好验收标准。</p><p>持续集成：集成本身就是写代码的一个环节</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a42bf4ffc022058cbbea60e3d5ba82cb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-a42bf4ffc022058cbbea60e3d5ba82cb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;415&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-a42bf4ffc022058cbbea60e3d5ba82cb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a42bf4ffc022058cbbea60e3d5ba82cb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>精益创业：产品经历不靠谱，你该怎么办？</b></p><p>精益创业就是在尽可能少浪费的前提下，面向不确定性创造新事物。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ed01f02ce5c9a36834fa40df3c99364e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"409\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ed01f02ce5c9a36834fa40df3c99364e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;409&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"409\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ed01f02ce5c9a36834fa40df3c99364e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ed01f02ce5c9a36834fa40df3c99364e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>精益创业提出一个非常重要的概念，最小可行产品，也就是许多人口中的 MVP（Minimum Viable Product）。</p><p><b>解决了很多技术问题，为什么你依然在“坑”里</b></p><p>技术是一把利刃，程序员相信技术可以改变世界，但并不是所有问题都要用技术解决。花大力气去解决一个可能并不是问题的问题，常常是很多程序员的盲区。</p><p><b>为什么说做事之前要先进行推演？</b></p><p>对比我们的工作，多数情况下，即便目标清晰，路径却是模糊的。</p><p><b>你的工作可以用数字衡量吗？</b></p><p>一些人说，自己靠直觉就能把事情做好，其实这是一种误解，因为那种所谓的直觉，通常是一种洞见（Insight），洞见很大程度上依赖于一个人在一个领域长期的沉淀和积累，而这其实是某种意义上的大数据。</p><p>从数据出发：</p><ul><li>首先是基于数字进行技术决策。</li><li>其次是一个准备上线的案例。</li><li>再次，看一个从数字中发现问题的例子。</li></ul><p><b>迭代0: 启动开发之前，你应该准备什么？</b></p><p>所谓迭代 0，就是在迭代 1 之前的一个迭代，所以，我们可以把它理解成开发的准备阶段。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-11458ca909f239fb1a8196ec1e46ccb0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"469\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-11458ca909f239fb1a8196ec1e46ccb0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;469&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"469\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-11458ca909f239fb1a8196ec1e46ccb0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-11458ca909f239fb1a8196ec1e46ccb0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>如何管理你的上级？</b></p><p><b>领导要求的，无力反驳怎么办？</b></p><p>我们要敢于管理上级。</p><ul><li>第一，管理上级的预期。这个过程，相当于我把自己看到的问题暴露给上级，让他选择。</li><li>第二，帮助上级丰富知识。</li><li>第三，说出你的想法。这其实就是我们熟悉的一个最简单的道理：会哭的孩子有奶吃。</li></ul><p><b>产品经理总拿老板说事，怎么办？</b></p><p>实际上，老板要求的是方向，不是产品特性。大老板不会安排那么细的细节。所以，一个产品经理该做的事就是把老板给的方向，变成一个个可以实现的产品特性，他要分析其中的合理与不合理。</p><p>不合理的部分应该是他和老板去沟通的，而不是让开发团队来实现。</p><p><b>别人能做的，我们也要做</b></p><p>第一，竞争对手有的产品，我们也要有。</p><p>“抄”不是问题，问题是无脑地抄。</p><p>所以，如果你的产品经理只想无脑抄袭，本质上，他就是在偷懒，没干好他该干的活。</p><p>第二：人家能做到，说明技术上是可行的。</p><p>要做什么是需求，怎么做是技术。与产品经理要确认的是，这个需求是不是合理，该不该做。技术上能否实现，这是开发团队要考虑的事情，并不是产品经理说事的理由。</p>", 
            "topic": [
                {
                    "tag": "程序人生（知乎周刊）", 
                    "tagLink": "https://api.zhihu.com/topics/20136286"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61231899", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "原来这才是Kafka", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f1908dca2491e57bb4c84d9f913374c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f1908dca2491e57bb4c84d9f913374c8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f1908dca2491e57bb4c84d9f913374c8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f1908dca2491e57bb4c84d9f913374c8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>集群成员关系</h2><p>Kafka 使用 Zookeeper 来维护集群成员的信息。每个 broker 都有一个唯一标识符，这个标识符可以在配置文件里指定，也可以自动生成。在 broker 启动的时候，它通过创建临时节点把自己的 ID 注册到 Zookeeper。Kafka 组件订阅 Zookeeper 的 /broker/ids 路径。</p><h2>控制器</h2><p>控制器其实就是一个 broker。集群里第一个启动的 broker 通过在 Zookeeper 里创建一个临时节点 /controller 让自己成为控制器。其他 broker 在控制器节点上创建 Zookeeper watch 对象，如果控制器被关闭或者与 Zookeeper 断开连接，它们会尝试让自己成为新的控制器。每个新选出的控制器通过 Zookeeper 的条件递增操作获得一个全新的、数值更大的 controller epoch。</p><p>控制器遍历分区，并确定谁应该成为新首领，随后，新首领开始处理生产者和消费者的请求，而跟随者开始从首领那里复制消息。</p><p>简而言之，Kafka 使用 Zookeeper 的临时节点来选举控制器，并在节点加入集群或退出集群时通知控制器。控制器负责在节点加入或离开集群时进行分区首领选举。控制器使用 epoch 来避免“脑裂”，“脑裂”是指两个节点同时被认为自己是当前的控制器。</p><h2>复制</h2><p>复制功能是 Kafka 架构的核心。Kafka 把自己描述成一个分布式的、可分区的、可复制的提交日志服务。</p><p>Kafka 使用主题来组织数据，每个主题被分为若干个分区，每个分区有多个副本。每个 broker 可以保存成百上千个属于不同主题和分区的副本。</p><p>副本有两种类型：</p><ul><li>首领副本：每个分区都有一个首领副本。为了保证一致性，所有生产者请求和消费者请求都会经过这个副本。</li><li>跟随者副本：首领以外的副本都是跟随者副本。跟随者副本不处理来自客户端的请求，它们唯一的任务就是从首领那么复制消息，保持与首领一致的状态。</li></ul><p>为了与首领保持同步，跟随者向首领发送获取数据的请求，这种请求与消费者为了读取消息而发送的请求是一样的。请求消息里包含了跟随者想要获取消息的偏移量，而这些偏移量总是有序的。通过查看每个跟随者请求的最新偏移量，首领就会知道每个跟随者复制的进度。如果跟随者在10s内没有请求任何消息，或者虽然在请求消息，但是10s内没有请求最新的数据，那么它就被认为是不同步的。</p><h2>处理请求</h2><p>broker 的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求。Kafka 提供了一个二进制协议（基于 TCP），指定了请求消息的格式以及 broker 如何对请求作出响应。</p><p>broker 会在它所监听的每一个端口上运行一个 Acceptor 线程，这个线程会创建一个连接，并把它交给 Processor 线程去处理。Processor 线程负责从客户端获取请求消息，把它们放进请求队列，然后从响应队列获取响应消息，把它们发送给客户端。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0a64cd9b8d685b930457178b0cec8d3b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1047\" data-rawheight=\"338\" class=\"origin_image zh-lightbox-thumb\" width=\"1047\" data-original=\"https://pic4.zhimg.com/v2-0a64cd9b8d685b930457178b0cec8d3b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1047&#39; height=&#39;338&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1047\" data-rawheight=\"338\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1047\" data-original=\"https://pic4.zhimg.com/v2-0a64cd9b8d685b930457178b0cec8d3b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0a64cd9b8d685b930457178b0cec8d3b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>生产请求和获取请求都必须发送给分区的首领副本。Kafka 客户端负责把生产请求和获取请求发送到争取的 broker 上。客户端使用了另一种请求类型，也就是元数据请求。服务器端的响应消息里指明了这些主题所包含的分区、每个分区都有哪些副本，以及哪个副本是首领。一般情况下，客户端会把这些信息缓存起来。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d55352440ff49c51c8d945c1b1637ff8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-d55352440ff49c51c8d945c1b1637ff8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;249&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-d55352440ff49c51c8d945c1b1637ff8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d55352440ff49c51c8d945c1b1637ff8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Kafka 使用零复制技术向客户端发送消息 —— 也就是说，Kafka 直接把消息从文件（或者更确切的说是 Linux 文件系统缓存）里发送到网络通道，而不需要经过任何中间缓冲区。</p><p>并不是所有保存在分区首领上的数据都可以被客户端读取。大部分客户端只能读取已经被写入所有同步部分的消息。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-adcbba19122ad603fad6a90bcf735ecb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1043\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb\" width=\"1043\" data-original=\"https://pic4.zhimg.com/v2-adcbba19122ad603fad6a90bcf735ecb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1043&#39; height=&#39;292&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1043\" data-rawheight=\"292\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1043\" data-original=\"https://pic4.zhimg.com/v2-adcbba19122ad603fad6a90bcf735ecb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-adcbba19122ad603fad6a90bcf735ecb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>物理存储</h2><p>Kafka 的基本存储单元是分区。在配置 Kafka 的时候，管理员指定了一个用户存储分区的目录清单。</p><p><b>分区分配</b></p><p>在创建主题时，Kafka 会决定如何在 broker 间分配分区。为分区和副本选好 broker 之后，会决定哪些分区使用哪些目录。规则很简单：计算每个目录里的分区数量，新的分区总是被添加到数量最小的哪个目录里。</p><p>Kafka 管理员为每个主题配置了数据保留期限，规定数据被删除之前可以保留多长时间，或者清理数据之前可以保留数据量大小。</p><p><b>文件管理</b></p><p>因为一个大文件里查找和删除消息是很费时的，所以把分区分成若干个片段。在 broker 往分区写入数据时，如果达到片段上限，就关闭当前文件，并打开一个新文件。当前正在写入数据的片段叫做活跃片段。</p><p><b>文件格式</b></p><p>Kafka 把消息和偏移量保存在文件里。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-79dd0f45bfa39a2a41a2221782a58bfb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-79dd0f45bfa39a2a41a2221782a58bfb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-79dd0f45bfa39a2a41a2221782a58bfb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-79dd0f45bfa39a2a41a2221782a58bfb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>索引</b></p><p>消费者可以从 Kafka 的任意可用偏移量位置开始读取消息。Kafka 为每个分区维护了一个索引。索引把偏移量映射到片段文件和偏移量在文件里的位置。</p><p>索引也被分成片段，所以再删除消息时，也可以删除相应的所以。如果索引出现损坏，Kafka 会通过重新读取消息并录制偏移量和位置来重新生成索引。</p><p><b>清理的工作原理</b></p><p>每个日志片段可以分为两个部分：</p><ul><li>干净的部分：这些消息之前被清理过。</li><li>污浊的部分：这些消息是上一次清理之后写入的。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-18912a4e988b1b480192dbe1c69f03bc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"227\" class=\"origin_image zh-lightbox-thumb\" width=\"1044\" data-original=\"https://pic1.zhimg.com/v2-18912a4e988b1b480192dbe1c69f03bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1044&#39; height=&#39;227&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"227\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1044\" data-original=\"https://pic1.zhimg.com/v2-18912a4e988b1b480192dbe1c69f03bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-18912a4e988b1b480192dbe1c69f03bc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果在 Kafka 启动时启动了清理功能，每个 broker 会启动一个清理管理器线程和多个清理线程，它们负责清理任务。为了清理分区，清理线程会读取分区的污浊部分，并在内存里创建一个 map。map 里的每个元素包含了消息键的散列值和消息的偏移量。</p>", 
            "topic": [
                {
                    "tag": "Kafka", 
                    "tagLink": "https://api.zhihu.com/topics/20012159"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61092123", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "教你怎么用分布式锁解决并发问题？", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-99d685ae855e2df5a0f902fefbd570d2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-99d685ae855e2df5a0f902fefbd570d2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-99d685ae855e2df5a0f902fefbd570d2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-99d685ae855e2df5a0f902fefbd570d2_b.jpg\"/></figure><p>在系统中，当存在多个进程和线程可以改变某个共享数据时，就容易出现并发问题导致共享数据的不一致性。即多个进程同时获取到了对数据的操作权限并对数据进行了更新，很典型的场景就是在线销售系统在售卖热销商品时遇到多个并发请求在同一时间提交订单的情况则极有可能造成商品超卖的现象。只要访问流量不错的系统都有可能遭遇并发请求造成数据库中数据重复写入的情况。</p><p>针对程序块被多个进程并发执行问题的解决方案是确保同一个时刻同一个程序块只能有一个进程可执行，其他进程等待当前进程执行完成才能获取程序块的执行权对数据进行更新，以此类推将并发执行变为串行顺序执行。为了让获取执行权的进程不被其他干扰，就需要设置一个所有进程都能读取到的标记，当标记不存在时可以设置该标记，其余后续进程发现已经有标记了则等待拥有标记的进程结束执行程序块取消标记后再去尝试设置标记。这个标记可以理解为锁，设置标记的过程就是我们通常说的加锁。</p><h2>用redis 的 setnx、expire 方法做分布式锁</h2><ul><li><b>setnx()</b></li></ul><p>setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。</p><ul><li><b>expire()</b></li></ul><p>expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。</p><ul><li><b>具体步骤</b></li></ul><p>1、setnx(lockKey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功</p><p>2、expire() 命令对 lockKey 设置超时时间，为的是避免死锁问题。</p><p>3、执行完业务代码后，可以通过 delete 命令删除 key。</p><p>这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用 redis 的 setnx()、get() 和 getset() 方法来实现分布式锁。</p><h2>用 redis 的 setnx()、get()、getset()方法做分布式锁</h2><p>这个方案的背景主要是在 setnx() 和 expire() 的方案上针对可能存在的死锁问题，做了一些优化。</p><ul><li><b>getset()</b></li></ul><p>这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。假设 key 原来是不存在的，那么多次执行这个命令，会出现下边的效果：</p><ol><li>getset(key, &#34;value1&#34;) 返回 null 此时 key 的值会被设置为 value1</li><li>getset(key, &#34;value2&#34;) 返回 value1 此时 key 的值会被设置为 value2</li><li>依次类推！</li></ol><ul><li><b>使用步骤</b></li></ul><ol><li>setnx(lockKey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转到步骤 2。</li><li>get(lockKey) 获取值，值是当前lockKey的过期时间用oldExpireTime代表 ，并将这个 oldExpireTime与当前的系统时间进行比较，如果早于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 步骤3，否则等待指定时间后返回步骤2重新开始判定。</li><li>计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockKey, newExpireTime) 会返回当前 lockKey 之前设置的旧值currentExpireTime。</li><li>判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前进程getset 设置锁成功，获取到了锁。如果不相等，说明这个锁已经被别的进程获取走了，那么当前请求可以根据具体需求逻辑直接返回失败，或者返回步骤2继续重试。</li><li>在获取到锁之后，当前进程可以开始自己的业务处理，当处理完毕后，比较当前理时间和对锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，锁可能已由其他进程获得，这时执行 delete释放锁的操作会导致把其他进程已获得的锁释放掉。</li></ol><p>下面是用PHP代码实现的Redis分布式锁，关于Redis部分使用的是伪代码，请根据自己的情况用Redis连接对象替代其中的伪代码。</p><div class=\"highlight\"><pre><code class=\"language-text\">/**\n * 获取Redis分布式锁\n *\n * @param $lockKey\n * @return bool\n */\nfunction getRedisDistributedLock(string $lockKey) : bool\n{\n $lockTimeout = 2000;// 锁的超时时间2000毫秒\n $now = intval(microtime(true) * 1000);\n $lockExpireTime = $now + $lockTimeout;\n $lockResult = Redis::setnx($lockKey, $lockExpireTime);\n if ($lockResult) {\n // 当前进程设置锁成功\n return true;\n } else {\n $oldLockExpireTime = Redis::get($lockKey);\n if ($now &gt; $oldLockExpireTime &amp;&amp; $oldLockExpireTime == Redis::getset($lockKey, $lockExpireTime)) {\n return true;\n }\n }\n return false;\n}\n/**\n * 串行执行程序\n *\n * @param string $lockKey Key for lock\n * @param Closure $closure 获得锁后进程要执行的闭包\n * @return mixed\n */\nfunction serialProcessing(string $lockKey, Closure $closure)\n{\n if (getRedisDistributedLock($lockKey)) {\n $result = $closure();\n $now = intval(microtime(true) * 1000);\n if ($now &lt; Redis::get($lockKey)) {\n Redis::del($lockKey); \n }\n } else {\n // 延迟200毫秒再执行\n usleep(200 * 1000);\n return serialProcessing($lockKey, $closure);\n }\n return $result;\n}\n</code></pre></div><p>上面serialProcessing方法里当前进程设置锁成功，获取了代码块的执行权后就会执行闭包参数$closure里的代码块，通过传递闭包给方法，让我们可以在项目任何需要确保程序串行执行的地方使用serialProcessing方法给程序加分布式锁解决并发请求的问题。</p><p>上面代码实现用面向过程的方式是为了能简单明了的描述怎么设置分布式锁，读者可以针对自己的情况执行设计实现代码。针对于大型系统使用集群Redis的情况，设置分布式锁的步骤更复杂，有兴趣的可以查看Redlock 算法和redissonredis分布式锁组件。</p>", 
            "topic": [
                {
                    "tag": "分布式存储", 
                    "tagLink": "https://api.zhihu.com/topics/19558640"
                }, 
                {
                    "tag": "并发", 
                    "tagLink": "https://api.zhihu.com/topics/19757794"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61092019", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "Java，小而有料的final", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-811b326060abe023ebaa1f6f16d33b47_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"426\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-811b326060abe023ebaa1f6f16d33b47_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;426&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"426\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-811b326060abe023ebaa1f6f16d33b47_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-811b326060abe023ebaa1f6f16d33b47_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>final这块肉虽然小,但不可不知，因为不仅面试可能会问，实际中也常使用。</p><p>就问你常量声明时你为什么要加final？它有哪些作用？你思考过吗？</p><p>final通常指被修饰的东西不能被改变的，不能被改变的原因旺往往出于设计和效率的考虑。</p><p>先看final能修饰什么？</p><ul><li>修饰变量</li><li>修饰方法</li><li>修饰类</li><li>修饰参数</li></ul><p>不同的修饰有什么不同的作用呢？下面慢慢道来：</p><h2>final常量</h2><p>final修饰的常量必须在被使用前进行初始化，初始化的方式无非两种：定义时赋值或构造函数内赋值</p><p>final修饰常量基本类型和引用类型有些不同，我分开讲。</p><h2>基本数据类型</h2><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\n private final int A;\n private final int B = 3;\n private final int C = new Random().nextInt();\n public Test() {\n this.A = 5;\n }\n public Test(int a) {\n this.A = a;\n }\n}\n</code></pre></div><ul><li><b>为什么常量B要用final修饰？</b></li><li>因为这种确定值(定义便立即赋值)的final常量，编译器会在编译时将该常量值带入到任何可能用到它的计算式中，这会减轻运行时的一些负担。</li><li>比如 int d = 3 * B; 那么编译后相当于 int d = 9;</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>final修饰的常量值是在编译期间被确定的吗？</b></li><li>注意上面的变量C，我们并不能以为final修饰的就能在编译时知道它的值，C的值只有在运行时被初始化时才会显现。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>引用类型</h2><p>引用类型不能改变指的是引用被初始化指向一个对象后，就再也<b>无法改为指向其他对象，但其指向的对象本身是可以被修改的。</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class B {\n //final常量d指向了对象D\n private final D d =new D();\n //这个方法改变了对象D的内容\n public D change(){\n this.d.setS(&#34;change&#34;);\n return d;\n }\n //注意这个方法,将常量d的引用改变了\n public D refnewD(){\n this.d = new D();\n return d;\n }\n class D {\n private String s= &#34;init&#34;;\n public String getS() {\n return s;\n }\n public void setS(String s) {\n this.s = s;\n }\n }\n}\n</code></pre></div><p>上面代码是无法编译的，因为this.d=new D()会提示Cannot assign a value to final variable &#39;d&#39;,但是你却可以调用change()方法来改变d对象的s变量值。</p><h2>final方法</h2><ul><li><b>为什么使用final修饰方法</b></li></ul><p>1、设计：把方法锁定，防止继承类修改它的含义。</p><p>2、效率：早期编译器会将final方法所有的调用转为内嵌调用，随着JVM的提高，这种方式已被丢弃。</p><ul><li><b>final和private</b></li></ul><p>当一个方法被private修饰，这会隐式的指定为final，这也会使得子类无法覆盖此方法，可以对private方法增加final修饰，但对该方法并不能增加任何意义。</p><h2>final类</h2><p>String类是final应用的典型例子，可去查看面试别再问我String了。</p><ul><li><b>为什么要把类指定为final？</b></li></ul><p>出于安全考虑或其他原因，你不希望该类有任何变动或被继承。</p><p><i>一旦类被final修饰，即代表final类中的所有成员变量和方法都会隐式的final。</i></p><h2>final参数</h2><p>在方法的参数列表中将参数指定为final，即代表该参数引用所指向的对象是无法改变的；</p><p>若为基本类型，则表示值可以读取，但无法修改。修饰情况和final常量类似。也可结合这题不会！别说你懂值传递与引用传递看。</p><h2>final相关</h2><p><b>static 和 final</b></p><p>1、static强调的是该数据只存在一份，且是属于类的，不是属于对象。</p><p>2、final强调该数据不可变，且是属于对象的。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class C {\n private final double A = 3.14D;\n private static double b = 3.14D;\n public static void main(String[] args) {\n new C();\n new C();\n new C();\n }\n}\n</code></pre></div><h2>上面代码运行后，A会存在3个，但b只有一个。</h2><h2>final，finally和finalize</h2><ul><li><b>finally</b></li><li>是在异常处理时配合try-catch执行清理操作，需要清理的资源包括：打开的文件或网络连接等，它会把内存之外的资源恢复到他们的初始状态。无论try中是否有异常出现，finally里的操作都会被执行。</li><li><b>finalize</b></li><li>这是Object基类的一个方法，垃圾收集器在将对象清除出内存之前调用的清理资源方法，且此方法只会被系统调用一次，其实finalize能做的工作，try-finally能做的更好，《深入理解Java虚拟机》中建议大家忘掉这个方法的存在。</li></ul>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": [
                {
                    "userName": "恩同", 
                    "userLink": "https://www.zhihu.com/people/528cddab0bc8d9b135e925e2610d5ff9", 
                    "content": "<p>\"当一个方法被private修饰，这会隐式地指定为final\" 这几句话有什么依据或者有什么方式证明？还是仅从别人说过的话里摘抄的？</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61080106", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 2, 
            "title": "大牛简诉：MySQL 和 Redis 事务的对比", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-df7ce9d82afd08a49419062668e1cd1b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"360\" data-rawheight=\"243\" class=\"content_image\" width=\"360\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;360&#39; height=&#39;243&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"360\" data-rawheight=\"243\" class=\"content_image lazy\" width=\"360\" data-actualsrc=\"https://pic4.zhimg.com/v2-df7ce9d82afd08a49419062668e1cd1b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>简言</h2><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<b>A</b>tomicity，或称不可分割性）、一致性（<b>C</b>onsistency）、隔离性（<b>I</b>solation，又称独立性）、持久性（<b>D</b>urability）。</p><p>从标题来看，既然都是事务，那之间有什么区别？来一一解开，先从两个数据库说去。</p><p>MySQL 属于 关系型数据库 ， Redis 属于 非关系型数据库，两者对事务有着不同的解释。</p><h2>Redis</h2><p>[1] Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><p><b>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</b></p><p><b>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</b></p><h2>操作错误</h2><p>看着有点儿绕口，那就实际执行一下 看一下结果。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3659f655428f3bb080165686faacd514_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"555\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb\" width=\"555\" data-original=\"https://pic1.zhimg.com/v2-3659f655428f3bb080165686faacd514_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;555&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"555\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"555\" data-original=\"https://pic1.zhimg.com/v2-3659f655428f3bb080165686faacd514_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3659f655428f3bb080165686faacd514_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在上面的事务中，设置了一个 key 为 tr_1 的字符串数据，然后又通过 lpush 来添加元素，这很明显是错误的操作方式，当我们提交事务候出现了一个操作错误，这时候我们来看看 tr_1 的值是什么。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cdbc2a56bf8e18271bcf8628091528c7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"57\" class=\"origin_image zh-lightbox-thumb\" width=\"547\" data-original=\"https://pic4.zhimg.com/v2-cdbc2a56bf8e18271bcf8628091528c7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;547&#39; height=&#39;57&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"57\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"547\" data-original=\"https://pic4.zhimg.com/v2-cdbc2a56bf8e18271bcf8628091528c7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cdbc2a56bf8e18271bcf8628091528c7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>通过 get 命令来的tr_1 内容还是 <b>233</b> ，并没有变，那再看一下其他的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c786d5efc1675bc386a02bbb5dbb9426_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"542\" data-rawheight=\"130\" class=\"origin_image zh-lightbox-thumb\" width=\"542\" data-original=\"https://pic3.zhimg.com/v2-c786d5efc1675bc386a02bbb5dbb9426_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;542&#39; height=&#39;130&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"542\" data-rawheight=\"130\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"542\" data-original=\"https://pic3.zhimg.com/v2-c786d5efc1675bc386a02bbb5dbb9426_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c786d5efc1675bc386a02bbb5dbb9426_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里可以看到 tr_2 存在，并打印了值，这时候我们发现，即使出现了操作错误 ，但是错误并<b>没有</b>致使执行停止，错误之后的语句也执行了并成功执行，似乎符合上面提到的 <b>中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</b></p><p>语法错误</p><p>这时候还有另外一种情况 语法错误</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bebea8e8658c5ad1078c352ce7e7ec91_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb\" width=\"547\" data-original=\"https://pic2.zhimg.com/v2-bebea8e8658c5ad1078c352ce7e7ec91_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;547&#39; height=&#39;310&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"547\" data-original=\"https://pic2.zhimg.com/v2-bebea8e8658c5ad1078c352ce7e7ec91_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bebea8e8658c5ad1078c352ce7e7ec91_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当我们执行到 set时没有给任何参数，第二次执行时故意少给了一个参数。可以看到报了 语法错误，最后提交事务，也告诉了我们事务因为错误被丢失了，接着用 keys *检索发现确实如此。</p><h2>文档释义</h2><p>这里可以官方文档中提到的</p><blockquote>Errors inside a transaction<br/>// 在执行过程中 可能会遇到两种错误命令错误。<br/>During a transaction it is possible to encounter two kind of command errors:<br/>// 1.命令无法进入队列 ，比如 ：参数数量错误，命令名错误...，或者某些关键错误 如内存不足<br/>A command may fail to be queued, so there may be an error before EXEC is called. For instance the command may be syntactically wrong (wrong number of arguments, wrong command name, ...), or there may be some critical condition like an out of memory condition (if the server is configured to have a memory limit using the maxmemorydirective).<br/>// 2. 对键进行错误的操作 如上面的 对字符串使用 lpush<br/>A command may fail <i>after</i> EXEC is called, for instance since we performed an operation against a key with the wrong value (like calling a list operation against a string value).<br/>// 客户端检查键入的命令，大多数时候会在调用 exec 前发现第一类错误，如果命令执行返回来 QUEUED 则表示命令正常进入队列，否则错误，大多数情况下客户端会终止放弃这个事务。<br/>Clients used to sense the first kind of errors, happening before the EXEC call, by checking the return value of the queued command: if the command replies with QUEUED it was queued correctly, otherwise Redis returns an error. If there is an error while queueing a command, most clients will abort the transaction discarding it.</blockquote><p>关于 Redis 暂时看到这里 接下来看到 MySQL</p><h2>MySQL</h2><p>众所周知，MySQL 只有 InnoDB 引擎支持 事务，在启用 MySQL 事务之前需要先停掉自动提交</p><h2>测试表结构 user</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a0eb3f53c655e4987e301efd50e6545b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"852\" data-rawheight=\"188\" class=\"origin_image zh-lightbox-thumb\" width=\"852\" data-original=\"https://pic4.zhimg.com/v2-a0eb3f53c655e4987e301efd50e6545b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;852&#39; height=&#39;188&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"852\" data-rawheight=\"188\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"852\" data-original=\"https://pic4.zhimg.com/v2-a0eb3f53c655e4987e301efd50e6545b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a0eb3f53c655e4987e301efd50e6545b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在这里来模拟一个转账的操作：A给B转100元。</p><p>步骤解析 A+100 元，B -100元，即两步虽然很简单，简单走一下流程。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-44cbdd9ffc35cc05c3a5bed9e864dd57_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"393\" data-rawheight=\"800\" class=\"content_image\" width=\"393\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;393&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"393\" data-rawheight=\"800\" class=\"content_image lazy\" width=\"393\" data-actualsrc=\"https://pic4.zhimg.com/v2-44cbdd9ffc35cc05c3a5bed9e864dd57_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>可以看到，没有问题，那么我们从中人为的制造一些问题呢？</p><h2>操作错误</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2a357032bdcc0e4f1c540fe2bd55e11a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic3.zhimg.com/v2-2a357032bdcc0e4f1c540fe2bd55e11a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;197&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic3.zhimg.com/v2-2a357032bdcc0e4f1c540fe2bd55e11a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2a357032bdcc0e4f1c540fe2bd55e11a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里我们把 money 字段变成了无符号，即不能小于 0，并且，调整数据库中的数据如下。</p><div class=\"highlight\"><pre><code class=\"language-text\">`SELECT * FROM `user` LIMIT 50` (0.000 秒)\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-053b48456f03bb9d5373e014a3b004f5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb\" width=\"845\" data-original=\"https://pic2.zhimg.com/v2-053b48456f03bb9d5373e014a3b004f5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;845&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"845\" data-original=\"https://pic2.zhimg.com/v2-053b48456f03bb9d5373e014a3b004f5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-053b48456f03bb9d5373e014a3b004f5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>接着执行下面的 SQL</p><div class=\"highlight\"><pre><code class=\"language-text\">select version();\nSET AUTOCOMMIT=0;\nbegin;\nselect * from user where title in (&#39;A&#39;,&#39;B&#39;) for update;\nupdate user set money = money + 1000 where title = &#39;A&#39;;\nupdate user set money = money - 1000 where title = &#39;B&#39;;\nselect * from user where title in (&#39;A&#39;,&#39;B&#39;);\ncommit;\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-10a483132773883cef884441fc65ff49_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"719\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-10a483132773883cef884441fc65ff49_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;719&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"719\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-10a483132773883cef884441fc65ff49_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-10a483132773883cef884441fc65ff49_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>问题出现了，这里报出了错误，但是可以看到 前面的 SQL 已经是已执行的了，结果已经发生了变化，从这里看，<b>似乎</b>和 Redis 的处理差不多，除了错误之后语句继续执行。但是 值的注意的是， 在我们实际开发中，这种情况程序会直接抛出异常，以供我们在 catch 块中执行 rollback ，以回滚操作确保数据完整，即使是单独使用 MySQL 命令行 我们也可以用存储过程来对异常进行回滚。</p><h2>语法错误</h2><p>刚刚看到 Redis 当遇到 语法错误 时会自动丢弃事务，阻止提交，那 MySQL 呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-cdd977ffd187720fbc2eb10e93a3d72c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-cdd977ffd187720fbc2eb10e93a3d72c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-cdd977ffd187720fbc2eb10e93a3d72c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-cdd977ffd187720fbc2eb10e93a3d72c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>答案：不会，MySQL 在顺序执行时，如果未对异常进行处理，总会将成功执行的的提交，而不会触发自动终止，但是我们可以在程序执行时进行放弃提交。</p><h2>Redis 为什么没有回滚？</h2><p>Redis 的官方文档给出了这样的解释</p><blockquote>​ // 只有在使用错误的语法调用时才会失败Redis命令（并且在命令排队期间无法检测到问题），或者对于持有错误数据类型的键，Redis命令可能会失败：这意味着实际上失败的命令是编程错误的结果，以及在开发过程中很可能检测到的一种错误，而不是在生产中。</blockquote><ul><li>Redis commands can fail only if called with a wrong syntax (and the problem is not detectable during the command queueing), or against keys holding the wrong data type: this means that in practical terms a failing command is the result of a programming errors, and a kind of error that is very likely to be detected during development, and not in production.</li></ul><blockquote>// Redis内部简化且速度更快，因为它不需要回滚的能力。</blockquote><ul><li>Redis is internally simplified and faster because it does not need the ability to roll back.</li></ul><h2>总结</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3a6431ae737104ae63d9af94ca2425a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"858\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb\" width=\"858\" data-original=\"https://pic3.zhimg.com/v2-3a6431ae737104ae63d9af94ca2425a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;858&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"858\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"858\" data-original=\"https://pic3.zhimg.com/v2-3a6431ae737104ae63d9af94ca2425a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3a6431ae737104ae63d9af94ca2425a6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>但是 MySQL 支持手动回滚，实际开发过程中可以自行手动对已提交的操作进行回滚操作，更加友好。</b></p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61079821", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 2, 
            "title": "大佬分享：基于服务的分布式事务（下）", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-12f059bed69c02219cddd82d7c1d737f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-12f059bed69c02219cddd82d7c1d737f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;359&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-12f059bed69c02219cddd82d7c1d737f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-12f059bed69c02219cddd82d7c1d737f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>分布式事务协调场景介绍</h2><p>在基于服务的分布式事务（上）中，我们举了一个业务场景的例子，就是一个初始服务创建了一个分布式事务，在这个分布式事务中包含了两个参与服务的本地事务，这两个本地事务由初始服务通过调用两个参与事务的服务方式组合在一起。根据分布式事务一致性的要求，这两个本地事务要么同时成功，要么同时失败。由于这两个参与事务的服务并不知道对方的存在，当一个参与服务调用（Invocation A）成功而另外一个参与服务调用（Invocation B）失败，我们就需要分布式事务协调器的进行相关的补偿，保证分布式事务的一致性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-29307395f7ff9ec0b50c7684ac748096_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-29307395f7ff9ec0b50c7684ac748096_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;363&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-29307395f7ff9ec0b50c7684ac748096_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-29307395f7ff9ec0b50c7684ac748096_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>分布式Saga</h2><p>ServiceComb Pack默认采用的是名为Saga的分布式事务协调方案。Sagas这个概念来源于三十多年前的一篇数据库论文，一个Saga事务是一个由多个短时事务组成的长时事务。在分布式事务场景下，我们把一个Saga分布式事务看做是一个由多个本地事务组成的事务，每个本地事务都有一个与之对应的补偿事务。在Saga事务的执行过程中，如果出现某一步执行出现异常的，Saga事务会被终止，同时会调用之前执行成功的事务对应的补偿事务完成相关的恢复操作，这样保证Saga相关的本地事务要么同时成功，要么通过执行补偿恢复成为Saga执行之前的状态。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-21165c7573b9ac5b0efa725b5cf2cb1f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-21165c7573b9ac5b0efa725b5cf2cb1f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;249&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-21165c7573b9ac5b0efa725b5cf2cb1f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-21165c7573b9ac5b0efa725b5cf2cb1f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>ServiceComb Pack 在实现分布式Saga协调协议的过程中需要追踪分布式事务的执行情况。首先介绍一下正常流程下分布式事务执行流程是如何记录下来的，下图的红线部分是Omega端扩展与Alpha端交互序列图。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b1849461af73627094b82fdf3fdb7a9c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"299\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-b1849461af73627094b82fdf3fdb7a9c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;299&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"299\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-b1849461af73627094b82fdf3fdb7a9c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b1849461af73627094b82fdf3fdb7a9c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在分布式事务初始阶段由初始服务的Omega将SagaStarted事件发送到Alpha进行分布式事务备案。当有新的服务参与到这个分布式事务中，参与服务A的Omega会在本地事务执行前发送TxStarted到Alpha端；并在本地事务执行成功之后将TxEnded事件发送到Alpha。如果分布式事务正常结束，初始服务Omega会直接发送SagaEnded事件到Alpha，结束整个分布式事务。</p><p>参与分布式事务的服务在执行本地事务出现异常，如下图所示Transaction B执行出现错误。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-21e3d3d02f247aa53266d1274c8b4c3c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-21e3d3d02f247aa53266d1274c8b4c3c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;302&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-21e3d3d02f247aa53266d1274c8b4c3c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-21e3d3d02f247aa53266d1274c8b4c3c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>此时参与服务B会向Alpha发送一个TxAborted的事件，Alpha收到这个事件后会将整个Saga事务挂起，终止Saga事务的继续执行。如果这个时候还有其他的Omega向Alpha发送挂载在这个Saga事务下的TxStarted事件的话，Alpha会直接发送拒绝应答消息通知Omega这个Saga事务已经出现异常，不应该执行新的本地事务。由于初始服务在调用参与服务B的过程中，也知道了服务调用失败的消息，所以，初始服务也会发生SagaAborted事件给Alpha来关闭整个Saga事件。虽然在TxAborted存在的情况下，SagaAborted事件看上去有点多余，但是为了应对诸如初始服务无法调用参与服务B的情况下（此时Alpha没有收到TxAborted事件），设置SagaAborted事件还是非常有必要的。</p><p>现在Alpha可以通过查询TxEnded事件获取到需要进行补偿恢复的服务信息，Alpha会向相关的服务实例Omega发送TxCompensated事件，由Omega调用服务实例补偿方法进行相关的恢复操作。在具体的过程中，为了恢复本地事务执行上下文，ServiceComb Pack会将TxStarted传递过来的方法参数列表信息放入TxCompensated消息中传递给Omega，除此之外ServiceComb Pack 还会将OmegaContext的全局事务和本地事务设置成之前的状态，这样应用代码可以在此基础上扩展获取自定义的上下文环境。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fc00da1a63c3619d72e3f8aaa9ec03ad_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-fc00da1a63c3619d72e3f8aaa9ec03ad_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;315&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-fc00da1a63c3619d72e3f8aaa9ec03ad_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fc00da1a63c3619d72e3f8aaa9ec03ad_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>除了要考虑异常情况，我们还需要考虑事务执行超时的处理问题（为了简化场景，这里我们不考虑由于网络连接中断导致的事务异常或者结束消息丢包的情况）。目前我们可以在Saga以及本地事务之间设置超时时间，Alpha上的事件扫描器会定时查找Started事件在设定的超时时间内是否有对应的Aborted或者Ended事件，如果没有，则会生成对应的Aborted事件触发相关的补偿操作。</p><p>当整个Saga事务执行超时，Alpha事件扫描器会向Alpha发送SagaAborted事件终止整个Saga事务，并且调用恢复函数进行相关的恢复操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-118d9a93a99394a395346b8dce3571ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"301\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-118d9a93a99394a395346b8dce3571ed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;301&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"301\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-118d9a93a99394a395346b8dce3571ed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-118d9a93a99394a395346b8dce3571ed_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>下图展示的就是在本地事务执行超时的情况下，Alpha事件扫描器会识别出Transaction B 执行超时，同时会发生TxAborted事件终止整个Saga 事务，调用相关的恢复方法进行恢复。由于Alpha无法确认对应的事务的执行情况，Alpha会采用向Omega发送TxCompensated的方式恢复事务，即使这时参与的服务事务已经执行成功了，Alpha还是会执行相关的恢复操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-243c580d0329475b558db4b50466569d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"307\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-243c580d0329475b558db4b50466569d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;307&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"307\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-243c580d0329475b558db4b50466569d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-243c580d0329475b558db4b50466569d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>编写Saga应用代码</h2><p>在文章开头我们给大家介绍了一个典型的分布式事务业务场景，其中涉及到一个初始服务，以及两个参与服务。为了方便大家理解，我们将以ServiceComb PackSpring Demo为例介绍如何使用Saga实现分布式事务。</p><p>这里预订服务(Booking) 相当于之前提到的分布式事务初始服务，对外提供一个租车(Car)和酒店(Hotel)聚合服务，在BookingController中使用Spring提供的RestTemplate向租车和酒店服务转发请求。租车和酒店服务分别作为Saga事务参与方参与整个事务。预订服务、租车和酒店服务都是基于Spring-Boot编写独立进程应用，应用代码通过@EnableOmega加载Omega相关的配置，同时需要在Spring的配置文件中配置与Alpha服务相关的信息。</p><p>}</p><p>在应用代码中需要描述出Saga事务的边界，我们可以在BookingController的order方法上标准@SagaStart；</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e252782594e3e5fd80013ee5496f2afd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"630\" data-rawheight=\"328\" class=\"origin_image zh-lightbox-thumb\" width=\"630\" data-original=\"https://pic2.zhimg.com/v2-e252782594e3e5fd80013ee5496f2afd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;630&#39; height=&#39;328&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"630\" data-rawheight=\"328\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"630\" data-original=\"https://pic2.zhimg.com/v2-e252782594e3e5fd80013ee5496f2afd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e252782594e3e5fd80013ee5496f2afd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>本地事务是通过@Compensable来标识，并且在Compensable的compensationMethod属性中描述补偿方法。注意补偿方法和本地事务方法的参数必须一致，否则Omega在进行恢复操作的时候会报找不到方法的错误。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f332090bf2cf1b44317c759622553459_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"620\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb\" width=\"620\" data-original=\"https://pic2.zhimg.com/v2-f332090bf2cf1b44317c759622553459_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;620&#39; height=&#39;267&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"620\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"620\" data-original=\"https://pic2.zhimg.com/v2-f332090bf2cf1b44317c759622553459_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f332090bf2cf1b44317c759622553459_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>TCC实现</h2><p>ServiceComb Pack 还提供了一个名为TCC（Try-Cancel/Confirm实现）分布式事务协调实现。TCC借助两阶段提交协议提供了一种比较完美的恢复方式。在TCC方式下，cancel补偿显然是在第二阶段需要执行业务逻辑来取消第一阶段产生的后果。try是在第一阶段执行相关的业务操作，完成相关业务资源的占用，例如预先分配票务资源，或者检查并刷新用户账户信用额度。在取消阶段释放相关的业务资源，例如释放预先分配的票务资源或者恢复之前占用的用户信用额度。那我们为什么还要加入确认操作呢？这需要从业务资源的使用生命周期来入手。在try过程中，我们只是占用的业务资源，相关的执行操作还处于待定状态，只有在确认操作执行完毕之后，业务资源才能真正被确认。</p><p>下图展示了正常的TCC调用流程，可以看到参与服务A，B分别在尝试方法中完成相关业务资源的预先分配，然后在提交阶段完成业务资源的确认操作。在实现层面和前面提到的Saga实现一样，我们需要协调器在分布式事务执行完成时向各个参与服务发送执行确认消息，由服务实例执行确认操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3992509bb99ae5310ea4e48cc1eb0db6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-3992509bb99ae5310ea4e48cc1eb0db6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-3992509bb99ae5310ea4e48cc1eb0db6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3992509bb99ae5310ea4e48cc1eb0db6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果参与服务自身的本地事务执行出现错误了，事务协调器会终止整个分布式事务，同时事务协调器会向注册成功的参与服务发送取消消息，由服务实例执行取消操作。假如这时还有其他的服务想参与到这个分布式事务的话，事务协调器会以这个分布式事务已经失败为由，向参与的服务发送失败的应答消息。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-07d3107221f02ebcfe4cb797ca8ab5b8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-07d3107221f02ebcfe4cb797ca8ab5b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-07d3107221f02ebcfe4cb797ca8ab5b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-07d3107221f02ebcfe4cb797ca8ab5b8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在ServiceComb Pack中，为了实现上面描述的TCC业务诉求，初始服务需要在分布式事务开始时向Alpha协调器发送TccStarted事件，Alpha协调器在接收到TccStarted事件之后，会创建相关事务追踪资源跟踪这个TCC事务的整个生命周期。初始服务会在参与服务调用try方法之前发送ParticipationStarted事件来声明与TCC相关本地事务。Alpha协调器会根据TCC事务当前的状态决定是否允许参与服务参加到TCC事务中。如果参与的TCC事务没有终止，Alpha协调器会回复确认消息，参与服务会继续执行相关的try方法调用；如果TCC事务已经终止了，Alpha协调器会回复终止消息，参与服务所在的Omega将抛出异常，直接终止try方法调用。如果参与服务调用try方法成功，则会向Alpha发送ParticipationEnded事件，因为这个事件发送之后Omega端不需要做任何操作，为了提高系统效率，Omega可采用异步方式通知Alpha协调器。当初始服务执行完标注好的TCC调用之后，初始服务所在的Omega会向Alpha协调器发送TccEnded事件，Alpha协调器在接收到这个事件之后会查询与本次TCC调用相关的ParticipationStarted事件识别相关的参与服务实例，然后通过向这些服务实例所对应的Omega发送Coordinated事件，由Omega调用相关的确认方法，完成本地事务提交工作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-364d5027675410e0d95606132b92c08a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-364d5027675410e0d95606132b92c08a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;302&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-364d5027675410e0d95606132b92c08a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-364d5027675410e0d95606132b92c08a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当TCC调用执行过程中出现异常，调用服务所在的Omega会向Alpha协调器发送TccEnded事件来终止当前的TCC事务。Alpha协调器则会根据其记录的分布式事务的参与情况，向相关服务的Omega发送Coordinated事件，由Omega调用相关的取消方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ec9d22433705e622eebaa557c7fc2de0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-ec9d22433705e622eebaa557c7fc2de0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;302&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-ec9d22433705e622eebaa557c7fc2de0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ec9d22433705e622eebaa557c7fc2de0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果是参与服务在执行try方法时出错了，那Alpha协调器会收到一条标注try方法执行状态的ParticipationEnded事件，Alpha协调器会给自己发送一个包含Aborted信息的TccEnded事件来关闭正在执行的TCC事务，同时触发Omega相关恢复操作的调用。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5801022828147499c898e5556ecbfe68_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"289\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-5801022828147499c898e5556ecbfe68_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;289&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"289\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-5801022828147499c898e5556ecbfe68_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5801022828147499c898e5556ecbfe68_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>下面介绍事务执行超时的处理的设计，对于参与服务的try方法来说，Alpha协调器可以通过是否接收到ParticipationEnded事件来进行判断。如果在超时时间内没有收到ParticipationEnded事件，Alpha事件扫描器会向自己发送TccEnded，触发和之前提到过的一样的事务错误处理流程，进行分布式事务关闭以及调用Omega进行相关恢复的操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a45919ec3928eea21b6532492b339a5c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"289\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-a45919ec3928eea21b6532492b339a5c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;289&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"289\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-a45919ec3928eea21b6532492b339a5c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a45919ec3928eea21b6532492b339a5c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>同理当TCC分布式事务执行超时， Alpha事件扫描器会发送TccEnded触发相同的恢复操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-19f5e9789a3ea6c85bc4850282f20842_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"301\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-19f5e9789a3ea6c85bc4850282f20842_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;301&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"301\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-19f5e9789a3ea6c85bc4850282f20842_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-19f5e9789a3ea6c85bc4850282f20842_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>编写TCC应用代码</h2><p>下面我们会结合ServiceComb中的TCC示例，向大家详解如何编写与TCC应用代码。这个示例以我们常见的电商场景为例，用户通过Ordering应用进行下单，Odering会调用Inventory以及Payment两个服务进行相关的业务操作。和之前Saga的示例一样，我们可以通过@EnableOmega的方式在这几个应用中注入Omega。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42e4edc3c113f77382588a120d8d1bd7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"220\" class=\"origin_image zh-lightbox-thumb\" width=\"614\" data-original=\"https://pic4.zhimg.com/v2-42e4edc3c113f77382588a120d8d1bd7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;614&#39; height=&#39;220&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"220\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"614\" data-original=\"https://pic4.zhimg.com/v2-42e4edc3c113f77382588a120d8d1bd7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42e4edc3c113f77382588a120d8d1bd7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我们需要在OrderingController中通过加入@TccStart来定义这个TCC分布式事务的范围，这个分布式事务的范围就是order方法，order方法会调用Inventory的order服务接口，以及Payment的pay服务接口。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1e6b4dbe884d9a25cd7a9255ea3f5ea6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"612\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb\" width=\"612\" data-original=\"https://pic3.zhimg.com/v2-1e6b4dbe884d9a25cd7a9255ea3f5ea6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;612&#39; height=&#39;391&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"612\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"612\" data-original=\"https://pic3.zhimg.com/v2-1e6b4dbe884d9a25cd7a9255ea3f5ea6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1e6b4dbe884d9a25cd7a9255ea3f5ea6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Inventory会在try阶段先进行库存的扣减，在分布式业务执行成功之后进行设置库存订单状态；如果业务执行失败，Inventory服务会执行恢复操作。通过定义@Participate，ServiceComb Omega可以标注相关try方法，同时通过confirmMethod以及cancelMethod定义相关确认和取消方法名。需要注意的是，这里提到的confirm、cancel方法的参数必须和try方法的相同。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ec377a538c9330d0e99ce093c3db8e4e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"750\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic3.zhimg.com/v2-ec377a538c9330d0e99ce093c3db8e4e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;750&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"750\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic3.zhimg.com/v2-ec377a538c9330d0e99ce093c3db8e4e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ec377a538c9330d0e99ce093c3db8e4e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Payment会在try阶段先验证用户账户的信用值，在确认阶段执行扣减用户账户余额的操作，在恢复阶段恢复信用值。</p><h2>小结</h2><p>在本文中我们先从分布式事务场景入手，采用交互图的方式，向大家介绍分布式Saga以及TCC分布式事务协调协议交互，最后结合ServiceComb Pack所提供的示例向大家介绍如何编写Saga以及TCC的应用代码。</p>", 
            "topic": [
                {
                    "tag": "分布式存储", 
                    "tagLink": "https://api.zhihu.com/topics/19558640"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60990914", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "浅谈：基于服务的分布式事务", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ce9c7348c91e91271ba18a0baafb9bae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ce9c7348c91e91271ba18a0baafb9bae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ce9c7348c91e91271ba18a0baafb9bae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ce9c7348c91e91271ba18a0baafb9bae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>传统数据库事务</h2><p>在传统单体应用架构下，我们通常会将业务数据存储在一个数据库中，应用各模块直接对数据库进行操作业务数据。由数据库提供基于ACID的事务保证。</p><ul><li>A是Atomic 原子性：事务作为整体来执行，要么全部执行，要么都不执行。</li><li>C是Consistency 一致性：事务应确保数据从一个一致的状态转变为另一个一致的状态。</li><li>I是 Isolation 隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>D是Durability 持久性：已提交的事务修改数据会被持久保持。</li></ul><p>例如一个电商的下单操作，就涉及到用户系统、库存系统、支付系统以及配送系统等一系列的协同操作。我们在执行下单操作的过程中，如果出现库存短缺，或者用户账户余额不足的情况，这个下单操作就会涉及到一系列的相关业务系统调用。如果这些子系统连接同一个数据库，我们可以通过数据库提供的事务原子性机制将库存数量校验以及用户余额校验的工作，和执行具体的下单业务操作组合成为一个数据库事务操作。通过数据库事务原子性来保证系统各个模块的调用要么都成功，要么都失败（取消）。 同时，由于数据库提供一致性和持久性保证，保证了如果事务执行成功并提交，本次业务操作的数据在立即生效的同时不会产生异议。 同时数据库提供了不同级别的数据锁机制保证应用多个线程同时读取或者更新数据的过程中不会相互影响，从而来保证业务操作的隔离性。</p><h2><b>微服务的分布式事务</b></h2><p>随着微服务架构的流行，很多大型的业务流程被拆分成为了多个功能单一的基础服务，大家会根据业务的诉求在这些基础服务之上编写一些组合调用服务来满足业务诉求。为了保证微服务能够独立开发部署运行，通常我们会采用一个微服务对应一个数据库的架构，将内部数据经微服务封装之后，以服务的方式对外暴露。这样以往基于数据库来实现的数据操作，就变成了多个对外提供服务的微服务系统的协同完成操作。因为单个微服务只知道自己的服务执行情况，为了保证分布事务的一致性，参与分布式事务的微服务通常会依托协调器完成相关的一致性协调操作。</p><p>在十多年前分布式事务的实现方案有CORBA的 Object Transaction Service（OTS)、J2EE的 Java Transaction API 以及 Java Transaction Service。这些事务管理以及事务服务的技术都是建立在ACID事务的概念上的。协调器依托于底层的资源交互协议实现资源的占用以及提交的操作，通过两阶段提交的方式实现分布式事务的强一致操作。两阶段提交将分布式事务操作分为准备和提交两个阶段：系统在准备解决阶段完成资源操作， 如果准备阶段中出现问题，支持回滚操作，但是在提交阶段是不允许出错的。两阶段在保证事务原子性上做了很多工作，但是两阶段提交最大的问题是在分布式事务执行过程中， 所有参与事务的节点资源都是被锁定的，系统不允许其他节点访问锁定的资源，在这种执行下很难进一步提升系统的执行效率。</p><p>如上所述，在ACID的事务执行过程中，为了保证事务的隔离性，通常我们会采用读写加锁的方式，通过串行处理数据方式，保证多个事务在同时执行的过程中不会相互影响。也就是说只有当事务提交并且保存修改记录或者回退取消修改记录之后，其他的事务才能继续执行。然而对于由多个事务组成的长时间运行的事务来说，如果在整个事务的执行过程都采用这种机制来保证事务的隔离性是一种很低效的解决方案。</p><p><b>那我们有什么办法即提高系统运行效率，又能保证事务的数据一致性呢？</b></p><p>答案是采用补偿的方式来解决这一问题。</p><h2>基于补偿的事务实现</h2><p>补偿是指我们将一个事务分成一个本地执行的正常操作事务和一个逻辑上对之前的操作进行补偿的事务。这样采用补偿事务的方式，我们可以把一个长时间运行的事务分化成若干个可以立即提交的本地事务调用，而不是一个长时间占用锁资源的巨型事务。 这样做的最大好处就是极大降低锁占用的时间。作为代价，补偿方式的取消操作和以往的实现方式有很大的不同，我们需要执行一个单独的ACID事务来完成对之前已提交的事务的逻辑补偿。</p><p>下图展示了一个典型的分布式事务调用， 用户请求触发事务初始服务， 事务初始服务会顺序调用两个事务参与服务（服务A，服务B）。由于这两个事务参与服务之间没有联系，当事务参与服务执行出现了问题，需要一个协调器参与相关的恢复操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0add9d4c36952764d3500454aa01bed1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"305\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-0add9d4c36952764d3500454aa01bed1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;305&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"305\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-0add9d4c36952764d3500454aa01bed1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0add9d4c36952764d3500454aa01bed1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里我们可以根据补偿执行的不同将其分成两组不同的补偿方式：</p><p>不完美补偿 - 反向操作会留下之前原始事务操作的痕迹，一般来说我们是会在原始事务记录中设置取消状态。</p><p>完美补偿 - 反向逻辑会彻底清理之前的原始事务操作，一般来说是不会保留原始事务交易记录，用户是感知不到事务取消之前的状态信息的。</p><p>对于采用不完美的补偿方式的系统（Saga实现）来说：</p><p>我们的补偿事务逻辑和其他的事务逻辑相比没有什么不同， 系统只需要像执行其他业务逻辑一样执行相关的补偿操作即可，无需设置特殊的处理逻辑来恢复事务执行之前的状态。</p><p>以我们常见的银行ATM取款业务为例，银行账户预先进行扣减的操作，如果取款不成功，其逻辑恢复操作就是通过冲正的方式将预先扣减的款项打回到用户账户，我们可以通过查看账户的交易记录找到扣减和冲正的记录信息。</p><p>下图展示的内容就是当初始服务调用分别调用服务A和服务B，服务B执行出现错误，这个时候我们事务协调器会调用服务A的冲正方法将系统状态恢复到执行服务调用之前的状态。</p><p>对于采用完美补偿方式的系统（Try-Cancel/Confirm实现)来说：</p><p>为了让系统能够在补偿操作彻底清除事务执行的情况，我们会借助两阶段提交协议来完成这部分的功能。</p><p>在TCC方式下，cancel补偿显然是在第二阶段需要执行业务逻辑来取消第一阶段产生的后果。try是在第一阶段执行相关的业务操作，完成相关业务资源的占用，例如预先分配票务资源，或者检查并刷新用户的账户信用额度。在cancel阶段释放相关的业务资源，例如释放预先分配的票务资源或者恢复之前占用的用户信用额度。</p><p><b>那我们为什么还要加入confirm操作呢？</b></p><p>这需要从业务资源的使用生命周期来入手。在try过程中，我们只是占用的业务资源，相关的执行操作只是出于待定状态，只有在确认操作执行完毕之后，业务资源才能真正被确认。例如订票业务的try操作，我们只是占用了相关的票务资源。目的是防止票务资源被其他用户占用，但是业务还没有执行完毕，票务提供方还不能将被占用的票务资源统计为已售出票务。 只有相关票务资源被确认售出的之后，票务提供方才能将其统计为已售出票务资源。</p><h2>ServiceComb Pack架构介绍</h2><p>通过上面的分析我们可以发现一个有意思的现象，每一步事务的操作都有可能会根据业务的执行情况提供一个补偿操作，通过一个事务管理系统来协调这个补偿操作可以帮我们大大降低业务流程建模的复杂度。在分布式事务实现过程中， 协调器的作用非常重要， 各个事务的参与方需要跟协调器建立好良好的沟通， 由协调器统一调度完成相关事务的执行或者取消的操作。</p><p>ServiceComb Pack架构如下图所示，主要包含两个组件，即Alpha和Omega，其中：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-184b1e15993a94264871736b78a8bdce_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-184b1e15993a94264871736b78a8bdce_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;232&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-184b1e15993a94264871736b78a8bdce_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-184b1e15993a94264871736b78a8bdce_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Alpha充当协调者的角色，主要负责对事务的事件进行持久化存储以及协调子事务的状态，使其最终得以与全局事务的状态保持一致，即保证事务中的子事务要么全执行，要么全不执行。</p><p>Omega是微服务中内嵌的一个agent，负责对监控本地事务执行情况并向Alpha上报事务执行事件，并在异常情况下根据alpha下发的指令执行相应的补偿或重试操作。</p><p>Omega可以通过向Alpha发送消息的方式向Alpha实时传递事务执行的进展，但是Alpha怎么知道这些Omega上传的消息是相互关联的呢？我们通过在服务调用过程中插入唯一的全局事务ID，并在后续的调用其它服务过程中传递这个全局事务ID。通过全局事务ID可以从汇总到Alpha事件中找到事件与之相关联的所有事件，通过对这些事件信息进行分析，我们可以完整地追踪到与分布式事务执行情况。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a88d36f4a57e2b1173988b4119a032c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"862\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb\" width=\"862\" data-original=\"https://pic3.zhimg.com/v2-a88d36f4a57e2b1173988b4119a032c2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;862&#39; height=&#39;287&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"862\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"862\" data-original=\"https://pic3.zhimg.com/v2-a88d36f4a57e2b1173988b4119a032c2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a88d36f4a57e2b1173988b4119a032c2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Omega会以切面编程的方式向应用程序注入相关的处理模块，帮助我们构建分布式事务调用的上下文。Omega在事务处理初始阶段处理事务的相关准备的操作，并在事务执行完毕后做一些清理的操作，例如创建分布式事务起始事件，以及相关的子事件，根据事务执行的成功或者失败生成相关的事务终止或者失败事件。这样带来的好处是用户的代码只需要添加几个annotation来描述分布式事务执行范围，以及与本地的事务处理恢复的相关函数信息，Omega就能通过切面注入的代码追踪本地事务的执行情况。Omega会将本地事务执行的情况以事件的方式通知给Alpha。由于单个Omega不可能知晓一个分布式事务下其他参与服务的执行情况，如此一来，就需要Alpha扮演一个十分重要的协调者的角色。Alpha将收集到的分布式事务事件信息整理汇总，通过分析这些事件之间的关系可以了解到分布式事务的执行情况。Alpha通过向Omega下发相关的执行指令由Omega执行相关提交或恢复操作，实现分布式事务的最终一致性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-564008f69b42270f4348cc114006805f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"280\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-564008f69b42270f4348cc114006805f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;280&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"280\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-564008f69b42270f4348cc114006805f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-564008f69b42270f4348cc114006805f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在了解过Pack实现的部分细节之后， 我们可以从下图进一步了解ServiceComb Pack架构下，Alpha与Omega内部各模块之间的关系图。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1204b842306d2014436ba870fa1d6c6a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"305\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-1204b842306d2014436ba870fa1d6c6a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;305&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"305\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-1204b842306d2014436ba870fa1d6c6a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1204b842306d2014436ba870fa1d6c6a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>整个架构分为三个部分：</p><ol><li>一个是Alpha协调器（支持多个实例提供高可用支持）。</li><li>二是注入到微服务实例中的Omega。</li><li>三是Alpha与Omega之间的交互协议。</li></ol><p>目前ServiceComb Pack支持Saga 以及TCC两种分布式事务协调协议实现。</p><p>Omega包含了与分析用户分布式事务逻辑相关的模块：</p><ul><li>事务注解模块（Transaction Annotation）</li><li>事务拦截器（Transaction Interceptor）</li><li>分布式事务执行相关的事务上下文（Transaction Context）</li><li>事务回调（Transaction Callback）</li><li>事务执行器（Transaction Executor）</li><li>以及负责与Alpha进行通讯的事务传输（Transaction Transport）模块。</li></ul><p><b>事务注解模块</b>是分布式事务的用户界面，用户将这些标注添加到自己的业务代码之上用以描述与分布式事务相关的信息，这样Omega就可以按照分布式事务的协调要求进行相关的处理。如果大家扩展自己的分布式事务，也可以通过定义自己的事务标注来实现。</p><p><b>事务拦截器</b>这个模块我们可以借助AOP手段，在用户标注的代码基础上添加相关的拦截代码，获取到与分布式事务以及本地事务执行相关的信息，并借助事务传输模块与Alpha进行通讯传递事件。</p><p><b>事务上下文</b>为Omega内部提供了一个传递事务调用信息的一个手段，借助前面提到的全局事务ID以及本地事务ID的对应关系，Alpha可以很容易检索到与一个分布式事务相关的所有本地事务事件信息。</p><p><b>事务执行器</b>主要是为了处理事务调用超时设计的模块。由于Alpha与Omega之间的连接有可能不可靠，Alpha端很难判断Omega本地事务执行超时是由Alpha与Omega直接的网络引起的还是Omega自身调用的问题，因此设计了事务执行器来监控Omega的本地的执行情况，简化Omega的超时操作。目前Omega的缺省实现是直接调用事务方法，由Alpha的后台服务通过扫描事件表的方式来确定事务执行时间是否超时。</p><p><b>事务回调</b>在Omega与Alpha建立连接的时候就会向Alpha进行注册，当Alpha需要进行相关的协调操作的时候，会直接调用Omega注册的回调方法进行通信。 由于微服务实例在云化场景启停会很频繁，我们不能假设Alpha一直能找到原有注册上的事务回调， 因此我们建议微服务实例是无状态的，这样Alpha只需要根据服务名就能找到对应的Omega进行通信。</p><p><b>事务传输模块</b>负责Omega与Alpha之间的通讯，在具体的实现过程中，Pack通过定义相关的Grpc描述接口文件定义了TCC 以及Saga的事务交互方法， 同时也定义了与交互相关的事件。我们借助了Grpc所提供的双向流操作接口实现了Omega与Alpha之间的相互调用。 Omega和Alpha的传输建立在Grpc多语言支持的基础上，为实现多语言版本的Omega奠定了基础。</p><p>Alpha为了实现其事务协调的功能，首先需要通过事务传输（Transaction Transport）接收Omega上传的事件， 并将事件存在事件存储（Event Store）模块中，Alpha通过事件API（Event API）对外提供事件查询服务。Alpha会通过事件扫描器（Event Scanner）对分布式事务的执行事件信息进行扫描分析，识别超时的事务，并向Omega发送相关的指令来完成事务协调的工作。由于Alpha协调是采用多个实例的方式对外提供高可用架构， 这就需要Alpha集群管理器（Alpha Cluster Manger）来管理Alpha集群实例之前的协调。用户可以通过管理终端（Manage console）对分布式事务的执行情况进行监控。</p><p>目前Alpha的事件存储是构建在数据库基础之上的。为了降低系统实现的复杂程度，Alpha集群的高可用架构是建立在数据库集群基础之上的。 为了提高数据库的查询效率，我们会根据全局事务的执行情况将数据存储分成了在线库以及存档库，将未完成的分布式事务事件存储在在线库中， 将已经完成的分布式事务事件存储在存档库中。</p><p>事件API是Alpha对外暴露的Restful事件查询服务。 该模块功能首先应用在Pack的验收测试中，通过事件API验收测试代码可以很方便的了解Alpha内部接收的事件。验收测试通过模拟各种分布式事务执行异常情况（错误或者超时），比对Alpha接收到的事务事件来验证相关的其他事务协调功能是否正确。</p><p>管理终端是一个js的前端界面， 管理终端通过访问事件API提供的Rest服务，向用户提供分布式事务执行情况的统计分析，并且可以追踪单个全局事务的执行情况，找出事务的失败的根源。在Pack 0.3.0 中实现了一部分功能，后续还需要进一步完善，欢迎大家参与进来。</p><p>Alpha集群管理器负责Alpha实例注册工作，管理Alpha中单个服务的执行情况， 并且为Omega提供一个及时更新的服务列表。 通过集群管理器用户可以轻松实现Alpha服务实例的启停操作，以及Alpha服务实例的滚动升级功能。目前这部分的模块还在设计开发中，欢迎对此有兴趣的朋友加入到我们的开发队伍中来。</p><h2>小结</h2><p>本文从分布式事务需要解决的问题入手，向大家介绍了建立在补充基础之上的基于服务的分布式事务的解决思路。接下来我们结合具体的示例介绍了完美的补偿（TCC）和非完美补偿（Saga）两种分布式事务协调协议，最后结合ServiceComb Pack的实现原理详细介绍了ServiceComb Pack的架构实现。</p>", 
            "topic": [
                {
                    "tag": "分布式存储", 
                    "tagLink": "https://api.zhihu.com/topics/19558640"
                }, 
                {
                    "tag": "架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556226"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60990837", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 2, 
            "title": "使用Redis和Java进行数据库缓存", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-db4322125e7bd30c15baf08b1162860e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-db4322125e7bd30c15baf08b1162860e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;330&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-db4322125e7bd30c15baf08b1162860e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-db4322125e7bd30c15baf08b1162860e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>数据库缓存是处理这些性能问题的最常见策略之一。缓存涉及将数据库查询的结果保存在更快，更容易访问的位置。正确完成后，缓存将减少查询响应时间，减少数据库负载并降低成本。</p><p>但是，缓存也需要小心处理，因为它们实际上是在另一个位置创建另一个信息副本。保持数据库和缓存同步并保持最新可能比您预期的更棘手。在下一节中，我们将讨论一些最常见的数据库缓存策略。</p><p><b>什么是不同的缓存策略？</b></p><p>手动缓存（也称为缓存搁置策略）涉及直接管理数据库和缓存。您的应用程序在启动数据库查询之前检查缓存，并在对数据库进行任何更改后更新缓存。</p><p>虽然如果正确实现有效，但手动缓存可能非常繁琐，尤其是在您需要查询多个数据库时。出于这些原因，开发人员发明了许多替代性的缓存策略。</p><p><b>直读缓存策略</b></p><p>在读取缓存中，应用程序首先查询缓存以查看其所需的信息是否在内部。如果没有，它将从数据库中检索信息并使用它来更新缓存。缓存提供程序或缓存库负责查询和更新缓存的详细逻辑。</p><p>当应用程序重复请求相同的数据时，读取策略最适合读取繁重的工作负载：例如，一遍又一遍地加载相同文章的新闻网站。</p><p>读取策略的一个缺点是对缓存的第一次查询将始终导致未命中，因为保证所请求的信息不在内部。为了解决这个问题，开发人员通常会使用用户可能要求的信息提前“加热”缓存。</p><p><b>直写缓存策略</b></p><p>在直写式高速缓存中，首先对高速缓存进行更新，然后对数据库进行更新。从应用程序到缓存以及从缓存到数据库都有一条直接线。与直读式缓存结合使用时，直写式策略可确保您的数据保持一致，从而无需手动缓存失效。</p><p><b>后写缓存策略</b></p><p>在后写式缓存（也称为回写式高速缓存）中，应用程序首先将数据写入高速缓存。经过一段设定的延迟后，缓存也会将此信息写入数据库。后写缓存最适合写入繁重的工作负载，即使出现一些故障和停机也可以很好地执行。</p><p><b>基于Java的Redis缓存与Redisson​​​​​​​</b></p><p>Redis是NoSQL数据库最受欢迎的选项之一，它使用键值系统来存储数据。Redisson是Java编程语言中的Redis客户端库，可以使用所有熟悉的Java集合轻松访问Redis功能。</p><p>Redisson允许您将数据放在外部存储中的地图中。您可以使用此功能实现数据库，Web服务或任何其他数据源的缓存。</p><p><b>Redis中的直读缓存</b></p><p>下面是一个Java示例，说明如何在Redis和Redisson中使用直读缓存。</p><p>如果请求的条目在缓存中不存在，则它将由MapLoader对象加载：</p><div class=\"highlight\"><pre><code class=\"language-text\">MapLoader&lt;String, String&gt; mapLoader = new MapLoader&lt;String, String&gt;() {\n @Override\n public Iterable&lt;String&gt; loadAllKeys() {\n List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n Statement statement = conn.createStatement();\n try {\n ResultSet result = statement.executeQuery(&#34;SELECT id FROM student&#34;);\n while (result.next()) {\n list.add(result.getString(1));\n }\n } finally {\n statement.close();\n }\n return list;\n }\n @Override\n public String load(String key) {\n PreparedStatement preparedStatement = conn.prepareStatement(&#34;SELECT name FROM student where id = ?&#34;);\n try {\n preparedStatement.setString(1, key);\n ResultSet result = preparedStatement.executeQuery();\n if (result.next()) {\n return result.getString(1);\n }\n return null;\n } finally {\n preparedStatement.close();\n }\n }\n};\n</code></pre></div><p>配置使用案例：</p><div class=\"highlight\"><pre><code class=\"language-text\">MapOptions&lt;K, V&gt; options = MapOptions.&lt;K, V&gt;defaults()\n .loader(mapLoader);\nRMap&lt;K, V&gt; map = redisson.getMap(&#34;test&#34;, options);\n// or\nRMapCache&lt;K, V&gt; map = redisson.getMapCache(&#34;test&#34;, options);\n// or with boost up to 45x times \nRLocalCachedMap&lt;K, V&gt; map = redisson.getLocalCachedMap(&#34;test&#34;, options);\n// or with boost up to 45x times \nRLocalCachedMapCache&lt;K, V&gt; map = redisson.getLocalCachedMapCache(&#34;test&#34;, options);\n</code></pre></div><p><b>Redis中的直写缓存</b></p><p>下面是一个Java示例，说明如何在Redis中使用Redis中的Redis使用直写缓存。</p><p>在MapWriter对象更新缓存和数据库之前，缓存更新方法不会返回：</p><div class=\"highlight\"><pre><code class=\"language-text\">MapWriter&lt;String, String&gt; mapWriter = new MapWriter&lt;String, String&gt;() {\n @Override\n public void writeAll(Map&lt;String, String&gt; map) {\n PreparedStatement preparedStatement = conn.prepareStatement(&#34;INSERT INTO student (id, name) values (?, ?)&#34;);\n try {\n for (Entry&lt;String, String&gt; entry : map.entrySet()) {\n preparedStatement.setString(1, entry.getKey());\n preparedStatement.setString(2, entry.getValue());\n preparedStatement.addBatch();\n }\n preparedStatement.executeBatch();\n } finally {\n preparedStatement.close();\n }\n }\n @Override\n public void write(String key, String value) {\n PreparedStatement preparedStatement = conn.prepareStatement(&#34;INSERT INTO student (id, name) values (?, ?)&#34;);\n try {\n preparedStatement.setString(1, key);\n preparedStatement.setString(2, value);\n preparedStatement.executeUpdate();\n } finally {\n preparedStatement.close();\n }\n }\n @Override\n public void deleteAll(Collection&lt;String&gt; keys) {\n PreparedStatement preparedStatement = conn.prepareStatement(&#34;DELETE FROM student where id = ?&#34;);\n try {\n for (String key : keys) {\n preparedStatement.setString(1, key);\n preparedStatement.addBatch();\n }\n preparedStatement.executeBatch();\n } finally {\n preparedStatement.close();\n }\n }\n @Override\n public void delete(String key) {\n PreparedStatement preparedStatement = conn.prepareStatement(&#34;DELETE FROM student where id = ?&#34;);\n try {\n preparedStatement.setString(1, key);\n preparedStatement.executeUpdate();\n } finally {\n preparedStatement.close();\n }\n }\n};\n</code></pre></div><p>使用配置案例：</p><div class=\"highlight\"><pre><code class=\"language-text\">MapOptions&lt;K, V&gt; options = MapOptions.&lt;K, V&gt;defaults()\n .writer(mapWriter)\n .writeMode(WriteMode.WRITE_THROUGH);\nRMap&lt;K, V&gt; map = redisson.getMap(&#34;test&#34;, options);\n// or\nRMapCache&lt;K, V&gt; map = redisson.getMapCache(&#34;test&#34;, options);\n// or with boost up to 45x times \nRLocalCachedMap&lt;K, V&gt; map = redisson.getLocalCachedMap(&#34;test&#34;, options);\n// or with boost up to 45x times \nRLocalCachedMapCache&lt;K, V&gt; map = redisson.getLocalCachedMapCache(&#34;test&#34;, options);\n</code></pre></div><p><b>Redis中的后写缓存</b></p><p>MapWriter接口还用于异步提交对Map对象（缓存）和外部存储（数据库）的更新。后台写入操作执行中使用的线程数量通过 writeBehindThreads设置设置。</p><p>下面，我们看到Redisson中基于Redis的后写缓存实现的配置的Java示例：</p><div class=\"highlight\"><pre><code class=\"language-text\">MapOptions&lt;K, V&gt; options = MapOptions.&lt;K, V&gt;defaults()\n .writer(mapWriter)\n .writeMode(WriteMode.WRITE_BEHIND)\n .writeBehindThreads(8);\nRMap&lt;K, V&gt; map = redisson.getMap(&#34;test&#34;, options);\n// or\nRMapCache&lt;K, V&gt; map = redisson.getMapCache(&#34;test&#34;, options);\n// or with boost up to 45x times \nRLocalCachedMap&lt;K, V&gt; map = redisson.getLocalCachedMap(&#34;test&#34;, options);\n// or with boost up to 45x times \nRLocalCachedMapCache&lt;K, V&gt; map = redisson.getLocalCachedMapCache(&#34;test&#34;, options);\n</code></pre></div><p>上述所有讨论的策略可用于Redisson的RMap，RMapCache，RLocalCachedMap和RLocalCachedMapCache对象。使用后两个对象可以使Redis中的读取操作速度提高45倍。</p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60844190", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "afka权威指南，Kafka消费者", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-60db23c20844e8580f4ce39804a8268d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-60db23c20844e8580f4ce39804a8268d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-60db23c20844e8580f4ce39804a8268d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-60db23c20844e8580f4ce39804a8268d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>Kafka 消费者</h2><p>应用程序使用 KafkaConsumer 向 Kafka 订阅主题，并从订阅的主题上接收消息。</p><p>Kafka 消费者从属于消费者群组。一个群组里的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息。</p><p>1个消费者接收4个分区的消息：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d51a79b28a8251c1c6b79a5d00080918_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-d51a79b28a8251c1c6b79a5d00080918_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;226&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-d51a79b28a8251c1c6b79a5d00080918_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d51a79b28a8251c1c6b79a5d00080918_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>2个消费者接收4个分区的消息：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a140a4aa3eabdcbbd980c6b20b3df55d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-a140a4aa3eabdcbbd980c6b20b3df55d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;226&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"226\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-a140a4aa3eabdcbbd980c6b20b3df55d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a140a4aa3eabdcbbd980c6b20b3df55d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>4个消费者接收4个分区的消息：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d60208ade2055140a7c568db1a2db814_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"223\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-d60208ade2055140a7c568db1a2db814_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;223&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"223\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-d60208ade2055140a7c568db1a2db814_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d60208ade2055140a7c568db1a2db814_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>5个消费者接收4个分区的消息：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e73df26060e05daa36675ea92521d53b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-e73df26060e05daa36675ea92521d53b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;262&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-e73df26060e05daa36675ea92521d53b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e73df26060e05daa36675ea92521d53b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果消费者群组的消费者超过主题的分区数量，那么有一部分消费者就会被闲置，不会接收到任何消息。</p><p>两个消费者群组对应一个主题：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bd30e37826a5f47f7b40456bb9c6d573_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"356\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-bd30e37826a5f47f7b40456bb9c6d573_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;356&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"356\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-bd30e37826a5f47f7b40456bb9c6d573_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bd30e37826a5f47f7b40456bb9c6d573_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当一个消费者被关闭或发生崩溃时，它就离开群组，原本由它读取的分区将由群组里的其他消费者来读取。分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为再均衡。在再均衡期间，消费者无法读取消息，造成整个群组一小段时间的不可用。</p><p>消费者通过向被指派为群组协调器的 broker 发送心跳来维持它们和群组的从属关系以及它们对分区的所有权关系。消费者会在轮训消息或提交偏移量时发送心跳。如果消费者停止发送心跳的时间足够长，会话就会过期，群组协调器认为它已经死亡，就会触发一次再均衡。</p><p>如果一个消费者发生崩溃，并停止读取消息，群组协调器会等待几秒钟，确认它死亡了才会触发再均衡。</p><p>当消费者要加入群组时，它会向群组协调器发送一个 JoinGroup 请求。第一个加入群组的消费者将成为&#34;群主&#34;。群主从协调器那里获得群组的成员列表，并负责给每一个消费者分配分区。分配完毕之后，群主把分配情况列表发送给群组协调器，协调器再把这些信息发送给所有消费者。每个消费者只能看到自己的分配情况。这个过程会在每次再均衡时重复发生。</p><div class=\"highlight\"><pre><code class=\"language-text\">Propertites prop = new Propertites();\nprop.put(&#34;bootstrap.servers&#34;, &#34;broker1:9092,borker2:9092&#34;);\nprop.put(&#34;group.id&#34;, &#34;CountryCounter&#34;);\nprop.put(&#34;key.deserializer&#34;, &#34;org.apache.kafka.common.serialiation.StringDeserializer&#34;);\nprop.put(&#34;value.deserializer&#34;, &#34;org.apache.kafka.common.serialiation.StringDeserializer&#34;);\nKafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(prop);\n</code></pre></div><h2>轮询</h2><p>消息轮询是消费者 API 的核心。消费者必须持续对 Kafka 进行轮询，否则会被认为已经死亡。</p><div class=\"highlight\"><pre><code class=\"language-text\">try {\n while(true) {\n ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);\n for (ConsumerRecord&lt;String, String&gt; record : records) {\n log.debug(&#34;topic = %s, partition = %s, offset = %d, customer = %s, \n record.topic(), record.partition(), record.offset(), record.key());\n }\n }\n} finally {\n consumer.close();\n}\n</code></pre></div><p>在第一次调用新消费者的 poll() 方法时，它会负责查找 GroupCoordinator，然后加入群组，接受分配的分区。</p><h2>消费者的配置</h2><p><b>fetch.min.bytes</b></p><p>该属性指定了消费者从服务器获取记录的最小字节数。broker 在收到消费者的数据请求时，如果可用的数据量小于 fetch.min.bytes 指定的大小，那么它会等到有足够的可用数据时才把它返回给消费者。</p><p><b>fetch.max.wait.ms</b></p><p>用于指定 broker 的等待时间，默认是500s。</p><p><b>max.partition.fetch.bytes</b></p><p>该属性指定了服务器从每个分区里返回给消费者的最大字节数。它的默认值是1MB，也就是说，KafkaConsuer.poll() 方法从每个分区里返回的记录最多不超过 max.partition.fetch.bytes 指定的字节。</p><p><b>session.timeout.ms</b></p><p>该属性指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是3s。heartbeat.interval.ms 指定了 poll() 方法向协调器发送心跳的频率，一般是 session.timeout.ms 的三分之一。</p><p><b>auto.offset.reset</b></p><p>该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况该作何处理，它的默认值是 latest，意思是在偏移量无效的情况下，消费者从最新的记录开始读取数据。另一个值是 earliest，意思是，在偏移量无效的情况下，从起始位置读取分区的记录。</p><p><b>enable.auto.commit</b></p><p>该属性指定了消费者是否自动提交偏移量，默认值是 true。</p><p><b>partition.assignment.strategy</b></p><p>Kafka 有两个默认的分配策略：</p><ul><li>Range：该策略会把主题的若干个连续的分区分配给消费者。</li><li>RoundRobin：该策略把主题的所有分区逐个分配给消费者。</li></ul><p>默认使用 Range 策略。</p><p><b>max.poll.records</b></p><p>该属性用于控制单次调用 call() 方法能够返回的记录数量。</p><h2>提交和偏移量</h2><p>我们把更新分区当前位置的操作叫做提交。</p><p>消费者往一个叫做 _consumer_offset 的特殊主体发送消息，消息里包含每个分区的偏移量。</p><p>如果提交的偏移量小于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会被重复处理。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f968f078ecec2a143b4bc74cb5012e08_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1047\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb\" width=\"1047\" data-original=\"https://pic1.zhimg.com/v2-f968f078ecec2a143b4bc74cb5012e08_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1047&#39; height=&#39;321&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1047\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1047\" data-original=\"https://pic1.zhimg.com/v2-f968f078ecec2a143b4bc74cb5012e08_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f968f078ecec2a143b4bc74cb5012e08_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会丢失。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-905acadd0e2a62b0a9a31d1f05f5e210_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"221\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-905acadd0e2a62b0a9a31d1f05f5e210_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;221&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"221\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-905acadd0e2a62b0a9a31d1f05f5e210_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-905acadd0e2a62b0a9a31d1f05f5e210_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最简单的提交方式是让消费者自动提交偏移量。如果 enable.auto.commit 被设为 true，那么每过5s，消费者会自动把从 poll() 方法接收到的最大偏移量提交上去。提交时间间隔由 auto.commit.interval.ms 控制，默认值是5s。</p><p>把 auto.commit.offset 设为 false，让应用程序决定何时提交偏移量。使用 comitSync() 将会提交由 poll() 返回的最新偏移量。</p><div class=\"highlight\"><pre><code class=\"language-text\">while(true) {\n ConsumerRecords&lt;String, String&gt; records = consuer.poll(100);\n for (ConsumerRecord&lt;String, String&gt; record : records) {\n try {\n consumer.commitSync();\n } catch (CommitFailedException e) {\n log.error(&#34;commit failed&#34;, e);\n }\n }\n}\n</code></pre></div><p>在成功提交或碰到无法恢复的错误之前，comitSync() 会一直重试。</p>", 
            "topic": [
                {
                    "tag": "Kafka", 
                    "tagLink": "https://api.zhihu.com/topics/20012159"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60844072", 
            "userName": "Java架构", 
            "userLink": "https://www.zhihu.com/people/b8e435ec9606b88ca14f57785e74d26b", 
            "upvote": 1, 
            "title": "Kafka权威指南，Kafka生产者", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f1908dca2491e57bb4c84d9f913374c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f1908dca2491e57bb4c84d9f913374c8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f1908dca2491e57bb4c84d9f913374c8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f1908dca2491e57bb4c84d9f913374c8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>Kafka生产者</h2><p>Kafka 发送消息的主要步骤：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a901dc6635861be69d9044595e3deecf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-a901dc6635861be69d9044595e3deecf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;513&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-a901dc6635861be69d9044595e3deecf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a901dc6635861be69d9044595e3deecf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>ProducerRecord 对象包括目标主题和发送的内容，还可以制定键或分区。如果消息成功写入 Kafka，就返回一个 RecordMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，则会返回一个错误。</p><div class=\"highlight\"><pre><code class=\"language-text\">Propertites prop = new Propertites();\nprop.put(&#34;bootstrap.servers&#34;, &#34;broker1:9092,borker2:9092&#34;);\nprop.put(&#34;key.deserializer&#34;, &#34;org.apache.kafka.common.serialiation.StringDeserializer&#34;);\nprop.put(&#34;value.deserializer&#34;, &#34;org.apache.kafka.common.serialiation.StringDeserializer&#34;);\nKafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(prop);\n</code></pre></div><p>Kafka 发送消息主要有以下3种方式：</p><ul><li>发送并忘记：把消息发送给服务器，但并不关心它是否正常到达。</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">ProducerRecord&lt;String, String&gt; record \n = new ProducerRecord&lt;&gt;(&#34;CustoerContry&#34;, &#34;Precision Products&#34;, &#34;France&#34;);\n try {\n producer.send(record);\n } catch(Exception e) {\n e.printStackTrce();\n }\n}\n</code></pre></div><ul><li>同步发送：使用 send() 方法发送消息，它会返回一个 Future 对象，调用 get() 方法进行等待，就可以知道消息是否发送成功。</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">ProducerRecord&lt;String, String&gt; record \n = new ProducerRecord&lt;&gt;(&#34;CustoerContry&#34;, &#34;Precision Products&#34;, &#34;France&#34;);\n try {\n producer.send(record).get();\n } catch(Exception e) {\n e.printStackTrce();\n }\n}\n</code></pre></div><ul><li>异步发送：调用 send() 方法， 并指定一个回调函数，服务器在返回响应时调用该函数。</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">private class DemoProducerCallback impleents Callback {\n @Override\n public void onCopletion(Recordetadata recordMetadata, Exception e) {\n if (e != null) {\n e.printStackTrace();\n }\n }\n}\nProducerRecord&lt;String, String&gt; record \n = new ProducerRecord&lt;&gt;(&#34;CustoerContry&#34;, &#34;Precision Products&#34;, &#34;France&#34;);\n try {\n producer.send(record, new DemoProducerCallback());\n } catch(Exception e) {\n e.printStackTrce();\n }\n}\n</code></pre></div><h2>生产者的配置</h2><p>acks</p><p>acks 指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。</p><ul><li>acks = 0，生产者在成功写入消息之前不会等待任何来自服务器的响应。</li><li>acks = 1，只要集群的首领节点收到消息，生产者就会收到一个来自服务器的成功响应。</li><li>acks = all，只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的响应。</li></ul><p>buffer.memory</p><p>该参数用来设置生产者内存缓冲区的大小，生产者用它来缓冲发送到服务器的消息。如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足。这个时候，send() 方法调用要么被阻塞，要么抛出异常。</p><p>copression.type</p><p>默认情况下，消息发送时不会被压缩。该参数可以设置为 snappy、gzip 或 lz4 等。</p><p>retries</p><p>该参数决定了生产者可以重发消息的次数，如果达到这个次数，生产者会放弃重试并返回错误。默认情况下，生产者会在诶次重试之间等到100ms，不过可以通过 retry.backoff.ms 参数来改变这个时间间隔。</p><p>batch.size</p><p>当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。当批次被填满，批次里的所有消息会被发送处理。</p><p>linger.ms</p><p>该参数指定了生产者在发送批次之前等待更多消息加入批次的时间。KafkaProducer 会在批次被填满或 linger.ms 达到上限时把批次发送出去。</p><p>max.in.flight.requests.per.connection</p><p>该参数指定了生产者在接收到服务器响应之前可以发送多少个消息。</p><p>timeout.ms、request.timeout.ms 和 metadata.fetch.timeout.ms</p><p>request.timeout.ms 指定了生产者在发送数据时等待服务器响应的时间，metadata.fetch.timeout.ms 指定了生产者在获取元数据时等待服务器返回的响应时间。如果等待响应超时，要么重试发送数据，要么返回一个错误。timeout.ms 指定了 broker 等待同步副本返回消息确认的时间，与 asks 的配置相匹配。</p><p>max.block.ms</p><p>该参数指定了在调用 send() 方法或使用 partitionsFor() 方法获取元数据时生产者的阻塞时间。在阻塞时间达到 max.block.ms 时，生产者会抛出超时异常。</p><p>max.request.size</p><p>该参数用于控制生产者发送的请求大小。它可以指能发送的单个消息的最大值，也可以指单个请求里所有消息总的大小。</p><p>receive.buffer.bytes 和 send.buffer.bytes</p><p>这两个参数分别指定了 TCP socket 接收和发送数据包的缓冲区大小。</p><h2>序列化</h2><p>创建一个生产者对象必须指定序列化器。</p><h2>分区</h2><p>Kafka 的消息是一个个键值对。拥有相同键的消息将被写到统一分区。如果使用默认的分区器，那么记录将被随机地发送到主题内各个可用的分区上。分区器使用轮训（Round Robin）算法将消息均衡地分布到各个分区上。</p><p>只有在不改变主题分区数量的情况下，键与分区之间的映射才能保持不变。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Kafka", 
                    "tagLink": "https://api.zhihu.com/topics/20012159"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60796123", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 6, 
            "title": "JAVA 8 新特性", 
            "content": "<p>某天【二蛋】突然说他在学习 java8 得新特性，想让自己得代码变得更优雅，逼格更高，我这才发觉<a href=\"https://link.zhihu.com/?target=http%3A//www.oracle.com/technetwork/java/javase/8train-relnotes-latest-2153846.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 8</a>已经发布很长时间了，生命在于运动，任何时候都不能停止向前探索的勇气，是时候总结一下，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。</p><ul><li>Lambda 表达式</li><li>方法引用</li><li>函数式接口</li><li>默认方法</li><li>Stream</li><li>Optional 类</li><li>Nashorn, JavaScript 引擎</li><li>新的日期时间 API</li><li>Base64</li></ul><h2>1 Lambda 表达式</h2><p>C++的程序媛笑了，这不就是函数指针吗？ Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），语法包含参数与方法体，方法体只有一条不用写return;</p><div class=\"highlight\"><pre><code class=\"language-text\">(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</code></pre></div><p>举个栗子，实现一个MathOperation接口 :</p><div class=\"highlight\"><pre><code class=\"language-text\">MathOperation addition = (int a, int b) -&gt; a + b;</code></pre></div><h2>2 方法引用</h2><p><b>2.1 构造器引用</b></p><p>语法是Class::new，或者更一般的Class&lt; T &gt;::new，要求构造器方法是没有参数；Java编译器会自动根据Factory.create方法的签名来选择函数。</p><div class=\"highlight\"><pre><code class=\"language-text\">final Car car = Car.create( Car::new ); //相当于new了一个car</code></pre></div><p><b>2.2 静态方法引用：</b></p><p>它的语法是Class::<b>static</b>_method，实例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">cars.forEach( Car::collide );</code></pre></div><p><b>2.3 特定类的任意对象的方法引用：</b></p><p>它的语法是Class::method实例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">cars.forEach( Car::repair );</code></pre></div><p><b>2.4 特定对象的方法引用：</b></p><p>它的语法是instance::method实例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">final Car police = Car.create( Car::new );\ncars.forEach( police::follow );</code></pre></div><h2>3 函数式接口</h2><p>函数式接口就是<b>只有一个方法</b>的普通接口。java.lang.Runnable \\concurrent.Callable是函数式接口最典型的例子。采用@FunctionalInterface注解 ，函数式接口可被隐式转换为lambda 表达式。</p><p>如定义了一个函数式接口如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">@FunctionalInterface\ninterface GreetingService {\n void sayMessage(String message);\n}</code></pre></div><p>那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p><div class=\"highlight\"><pre><code class=\"language-text\">GreetingService greetService1 = message -&gt; System.out.println(&#34;Hello &#34; + message);</code></pre></div><h2>4 接口中可以写默认方法实现（接口定义公共方法）</h2><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个<b> default 关键字</b>即可实现默认方法。或者直接写静态 static方法实现也可。</p><p>对于实现类，处理接口中的方法：<b>可覆盖，或者可直接调用super.do()；</b></p><h2>5 Optional 类</h2><p>Optional 类解决空指针异常。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><div class=\"highlight\"><pre><code class=\"language-text\">//Optional.ofNullable - 允许传递为 null 参数 \nOptional&lt;Integer&gt; a = Optional.ofNullable(value1); \n\n// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException \nOptional&lt;Integer&gt; b = Optional.of(value2);\n\n// Optional.orElse - 如果值存在，返回它，否则返回默认值 \nInteger value1 = a.orElse(new Integer(0));</code></pre></div><p>常用栗子：</p><div class=\"highlight\"><pre><code class=\"language-text\">//user为null,value也为null，搁在以前，user为null,再判断时会报错的\nString value =Optional.ofNullable(user).map(User::getUserName); </code></pre></div><h2>6 Nashorn JavaScriptnue</h2><p>略；</p><h2>7 Stream</h2><p>Java 8 API添加了一个新的抽象称为流Stream，Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来<b>提供一种对 Java 集合运算和表达的高阶抽象.</b></p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。<b>4大管道技术：</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-280b3af3589cac6504f2842d86555f93_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"72\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-280b3af3589cac6504f2842d86555f93_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;72&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"72\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-280b3af3589cac6504f2842d86555f93_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-280b3af3589cac6504f2842d86555f93_b.png\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-50dbdc492ecfd208daff5ba26d409cdc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-50dbdc492ecfd208daff5ba26d409cdc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;154&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-50dbdc492ecfd208daff5ba26d409cdc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-50dbdc492ecfd208daff5ba26d409cdc_b.jpg\"/></figure><p><b>7.1 创建流</b></p><ul><li><b>stream()</b> − 为集合创建串行流。</li><li><b>parallelStream() </b>− 为集合创建并行流。</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;String&gt; strings = Arrays.asList(&#34;abc&#34;, &#34;&#34;, &#34;bc&#34;, &#34;efg&#34;, &#34;abcd&#34;,&#34;&#34;, &#34;jkl&#34;); \nList&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</code></pre></div><p><b>7.2 forEach</b></p><p>Stream 提供了新的方法 &#39;forEach&#39; 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><div class=\"highlight\"><pre><code class=\"language-text\">Random random = new Random();\nrandom.ints().limit(10).forEach(System.out::println);</code></pre></div><p><b>7.3 map</b></p><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); \nList&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</code></pre></div><p><b>7.4 filter</b></p><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;String&gt;strings = Arrays.asList(&#34;abc&#34;, &#34;&#34;, &#34;bc&#34;, &#34;efg&#34;, &#34;abcd&#34;,&#34;&#34;, &#34;jkl&#34;); \n// 获取空字符串的数量 \nint count = strings.stream().filter(string -&gt; string.isEmpty()).count();</code></pre></div><p><b>7.5 limit</b></p><p><b>limit 方法用于获取指定数量的流。</b> 以下代码片段使用 limit 方法打印出 10 条数据：</p><div class=\"highlight\"><pre><code class=\"language-text\">Random random = new Random(); \nrandom.ints().limit(10).forEach(System.out::println);</code></pre></div><p><b>7.6 sorted</b></p><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><div class=\"highlight\"><pre><code class=\"language-text\">Random random = new Random(); random.ints().limit(10).sorted().forEach(System.out::println);</code></pre></div><p><b>7.7 并行（parallel）程序</b></p><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;String&gt; strings = Arrays.asList(&#34;abc&#34;, &#34;&#34;, &#34;bc&#34;, &#34;efg&#34;, &#34;abcd&#34;,&#34;&#34;, &#34;jkl&#34;); \n// 获取空字符串的数量\nint count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</code></pre></div><p>我们可以很容易的在<b>顺序运行和并行</b>直接切换。</p><p><b>7.8 Collectors</b></p><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;String&gt;strings = Arrays.asList(&#34;abc&#34;, &#34;&#34;, &#34;bc&#34;, &#34;efg&#34;, &#34;abcd&#34;,&#34;&#34;, &#34;jkl&#34;);\nList&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); \nSystem.out.println(&#34;筛选列表: &#34; + filtered); \n\nString mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&#34;, &#34;)); \nSystem.out.println(&#34;合并字符串: &#34; + mergedString);</code></pre></div><p><b>7.9 统计summaryStatistics</b></p><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); \n\nIntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&#34;列表中最大的数 : &#34; + stats.getMax()); \nSystem.out.println(&#34;列表中最小的数 : &#34; + stats.getMin());\nSystem.out.println(&#34;所有数之和 : &#34; + stats.getSum()); \nSystem.out.println(&#34;平均数 : &#34; + stats.getAverage());\n </code></pre></div><h2>8 日期时间 API</h2><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。</p><p><b>旧版</b>的 Java 中，日期时间 API 存在诸多问题，其中有：</p><ul><li>· 非线程安全</li><li>· 设计很差 <a href=\"https://link.zhihu.com/?target=http%3A//java.util.Date\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">java.util.Date</a>、 <a href=\"https://link.zhihu.com/?target=http%3A//java.sql.Date\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">java.sql.Date</a> 都包含日期。</li><li>· 时区处理麻烦</li></ul><p><b>新版</b>Java 8 在 <b>java.time</b> 包下提供了很多新的 API。以下为两个比较重要的 API：</p><ul><li>· Local(本地) − 简化了日期时间的处理，没有时区的问题。</li><li>· Zoned(时区) − 通过制定的时区处理日期时间。</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">LocalDate，LocalTime，LocalDateTime ： 时间\nInstant ： 时间戳（以Unix元年：1970年1月一日 00:00:00到某个时间时间的毫秒值）\nDuration ： 计算两个“时间”之间的间隔\nPeriod ： 计算两个“日期”之间的间隔\nTemporalAdjust ：时间校正器\nDateTimeFormatter ：格式化时间/日期\nZonedDate，ZonedTime，ZonedDateTime ： 时区</code></pre></div><p>不考虑时区sample:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9099d2489bdf8faa278dbba8affb6e26_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"528\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-9099d2489bdf8faa278dbba8affb6e26_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;528&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"528\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-9099d2489bdf8faa278dbba8affb6e26_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9099d2489bdf8faa278dbba8affb6e26_b.jpg\"/></figure><p>考虑时区:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-af33b7b8dea70f9ea455c97e290d7412_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"183\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-af33b7b8dea70f9ea455c97e290d7412_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;183&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"183\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-af33b7b8dea70f9ea455c97e290d7412_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-af33b7b8dea70f9ea455c97e290d7412_b.jpg\"/></figure><h2>9 Base64</h2><p>编码解码等。</p>", 
            "topic": [
                {
                    "tag": "Java 8", 
                    "tagLink": "https://api.zhihu.com/topics/19936714"
                }, 
                {
                    "tag": "JDK8", 
                    "tagLink": "https://api.zhihu.com/topics/19969274"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59928269", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 2, 
            "title": "Java性能调优常用手段", 
            "content": "<p>性能调优，调一次，一时爽，一直调，一直爽。</p><p>在日常开发中开发人员可能会碰到跟内存管理相关的问题，但能够理解并解决这些问题是Java程序员进阶的必备要求。本文将对一些常用的Java性能调优常用手段，希望能起抛砖引玉之用。</p><h2><b>0 实用场景：</b></h2><ul><li>OutOfMemoryException，内存不足</li><li>内存泄露</li><li>线程死锁</li><li>锁争用（Lock Contention）</li><li>Java进程消耗CPU过高</li></ul><h2><b>1 如何定位问题源码</b></h2><p><b>1.1</b> 首先使用命令：<b>top</b>，定位到占用CPU高的进程PID</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3fbbdef65fe5ae0cbf8832cfd1690169_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-3fbbdef65fe5ae0cbf8832cfd1690169_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;224&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-3fbbdef65fe5ae0cbf8832cfd1690169_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3fbbdef65fe5ae0cbf8832cfd1690169_b.jpg\"/></figure><p><b>1.2</b> 使用命令：<b>top -Hp pid</b>  ，查看该进程下哪个线程CPU占有最高</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fddd035cd6910006613df6bae47d84e7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-fddd035cd6910006613df6bae47d84e7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;310&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-fddd035cd6910006613df6bae47d84e7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-fddd035cd6910006613df6bae47d84e7_b.jpg\"/></figure><p><b>1.3</b> 进制转换，线程pid转换为16进制命令：<b>printf &#34;%x\\n&#34;</b> <b>线程tid  。</b>这里做这一步是因为jstack 进程ID的内容显示的线程信息中线程ID nid是16进制的，方便grep 查找。</p><p><b>1.4</b> 使用命令：<b> jstack 21711 | grep pid -A 20</b>  查看线程信息，定位代码，可以看到CPU消耗在PollIntervalRetrySchedulerThread这个类的Object.wait()；</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-544ae741b13b440526442b637e7ca4a7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"93\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-544ae741b13b440526442b637e7ca4a7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;93&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"93\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-544ae741b13b440526442b637e7ca4a7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-544ae741b13b440526442b637e7ca4a7_b.jpg\"/></figure><h2><b>2 使用jmap堆内存分析</b></h2><p><b>2.1 jmap介绍</b></p><p>jmap（Memory Map）和jhat（Java Heap Analysis Tool）jmap用来查看<b>堆内存使用状况</b>，一般结合jhat使用。jmap语法格式如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">jmap [option] pid\njmap [option] executable core\njmap [option] [server-id@]remote-hostname-or-ip</code></pre></div><p>如果运行在64位JVM上，可能需要指定-J-d64命令选项参数：<b>jmap -permstat pid。</b></p><p>jmap打印进程的类加载器和类加载器加载的持久代对象信息，输出：类加载器名称、对象是否存活（不可靠）、对象地址、父类加载器、已加载的类大小等信息。</p><p><b>2.2 jmap进程内存使用情况dump</b></p><p>jmap进行dump命令格式如下：</p><p><b><code>jmap -dump:format=b,file=dumpFileName pid</code> </b></p><p> 举个栗子，对进程ID为21711进行Dump：</p><div class=\"highlight\"><pre><code class=\"language-text\">root@ubuntu:/# jmap -dump:format=b,file=/tmp/dump.dat 21711     \nDumping heap to /tmp/dump.dat ...\nHeap dump file created</code></pre></div><p>dump出来的文件可以用MAT、VisualVM等工具查看，这里用jhat查看：</p><p><b><code>jhat -port 9998 /tmp/dump.dat</code> </b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-024a28376c3af0ef047a99330b678535_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"565\" data-original=\"https://pic2.zhimg.com/v2-024a28376c3af0ef047a99330b678535_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;565&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"565\" data-original=\"https://pic2.zhimg.com/v2-024a28376c3af0ef047a99330b678535_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-024a28376c3af0ef047a99330b678535_b.jpg\"/></figure><p>注意如果Dump文件太大，可能需要加上-J-Xmx512m这种参数指定最大堆内存，即：</p><p><b>jhat -J-Xmx512m -port 9998 /tmp/dump.dat</b></p><p>然后就可以在浏览器中输入主机地址:9998查看了：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fae12f835c94713ceb188ca4e2596f49_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb\" width=\"654\" data-original=\"https://pic2.zhimg.com/v2-fae12f835c94713ceb188ca4e2596f49_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;654&#39; height=&#39;249&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"654\" data-original=\"https://pic2.zhimg.com/v2-fae12f835c94713ceb188ca4e2596f49_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fae12f835c94713ceb188ca4e2596f49_b.jpg\"/></figure><h2><b>3 jstat 查看GC情况</b></h2><p>找到应用程序的PID，查看GC情况。interval是采样时间间隔。count是采样数目。比如下面输出的是GC信息，采样时间间隔为250ms，采样数为4：</p><p><b> jstat -gc 21711 250 4</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6e5a5820b3f1f745f091c30bcd8b5c85_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-6e5a5820b3f1f745f091c30bcd8b5c85_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-6e5a5820b3f1f745f091c30bcd8b5c85_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6e5a5820b3f1f745f091c30bcd8b5c85_b.jpg\"/></figure><p>java内存管理就不多解释，一张图以蔽之：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3025c971e6d43fab9cc596c5e0eb7a0d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"339\" data-rawheight=\"189\" class=\"content_image\" width=\"339\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;339&#39; height=&#39;189&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"339\" data-rawheight=\"189\" class=\"content_image lazy\" width=\"339\" data-actualsrc=\"https://pic2.zhimg.com/v2-3025c971e6d43fab9cc596c5e0eb7a0d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "性能", 
                    "tagLink": "https://api.zhihu.com/topics/19576984"
                }, 
                {
                    "tag": "内存管理", 
                    "tagLink": "https://api.zhihu.com/topics/19579205"
                }
            ], 
            "comments": [
                {
                    "userName": "强sir", 
                    "userLink": "https://www.zhihu.com/people/a21a380b74eef90d6c684290f52e4e28", 
                    "content": "讲解的很透彻，学习了", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58564841", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 3, 
            "title": "消息实时预警设计与实现", 
            "content": "<p>场景：企业微信作为一个消息渠道，在业务量达到一个稳定运行的时间段，数据也基本趋于周期性变化，局部小波段也属正常，为了更好对系统进行监控，从【数据访问量】的角度对消息通道进行预警。一般而言，监控预警主要体现在两方面：</p><ul><li>一是异常前的预防预警。根据业务量定制预警规则，规则的定制具备灵活性，可根据实时调整参数，且代码结构具备拓展性，方便规则的增删。</li><li>二是异常出现后的告警，属于补救措施。本文着重讨论第一种。</li></ul><p><b>1 对预警流程的抽象</b></p><p>预警主流程分四步走，主流程如图：</p><ul><li>读取预警配置，预警类型，预警规则，预警描述等；</li><li>校验预警规则中的阈值是否超标，不同规则有不同校验方法；</li><li>生产缓存数据：预警消息详情页的内容，方便快速访问；</li><li>推送预警信息，消息接收人为空，该条规则不做预警校验；</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7498d4b0e5ce90aece3a13903731b137_b.jpg\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb\" width=\"514\" data-original=\"https://pic4.zhimg.com/v2-7498d4b0e5ce90aece3a13903731b137_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;514&#39; height=&#39;454&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"514\" data-original=\"https://pic4.zhimg.com/v2-7498d4b0e5ce90aece3a13903731b137_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7498d4b0e5ce90aece3a13903731b137_b.jpg\"/><figcaption>预警数据监控及消息推送主流程</figcaption></figure><p>代码实现采用模板设计方法，固定主流程，规则校验子类各自实现：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e8d7aea974d2b8ed29f291fe1a4aab69_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb\" width=\"541\" data-original=\"https://pic2.zhimg.com/v2-e8d7aea974d2b8ed29f291fe1a4aab69_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;541&#39; height=&#39;286&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"541\" data-original=\"https://pic2.zhimg.com/v2-e8d7aea974d2b8ed29f291fe1a4aab69_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e8d7aea974d2b8ed29f291fe1a4aab69_b.jpg\"/></figure><p>各种规则配置作为模板子类，子类覆盖以下三大步骤：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-305fdb751372d934946286a3e53802cc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"551\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb\" width=\"551\" data-original=\"https://pic1.zhimg.com/v2-305fdb751372d934946286a3e53802cc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;551&#39; height=&#39;309&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"551\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"551\" data-original=\"https://pic1.zhimg.com/v2-305fdb751372d934946286a3e53802cc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-305fdb751372d934946286a3e53802cc_b.jpg\"/></figure><p><b>2 预警规则统计数据模型</b></p><p>统计指标采用redis 中key原子+操作，高效便捷；统计涉及两个维度：统计内容CONTENT，统计时间粒度TIME，因此可作key 数据模型为：</p><div class=\"highlight\"><pre><code class=\"language-text\">String STAT_PERIOD_KEY =&#34;stat:realtime:CONTENT:TIME&#34;;</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9bdb78f605f0d4313d19bb0f189e3fcd_b.jpg\" data-size=\"normal\" data-rawwidth=\"604\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb\" width=\"604\" data-original=\"https://pic2.zhimg.com/v2-9bdb78f605f0d4313d19bb0f189e3fcd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;604&#39; height=&#39;336&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"604\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"604\" data-original=\"https://pic2.zhimg.com/v2-9bdb78f605f0d4313d19bb0f189e3fcd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9bdb78f605f0d4313d19bb0f189e3fcd_b.jpg\"/><figcaption> 预警规则设计抽象</figcaption></figure><p>利用redis作数值统计，统计函数如下，在指定时刻Date获取过去count单位时间内的统计数据：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3937c764ede3df104955c95c5d27b539_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"534\" class=\"origin_image zh-lightbox-thumb\" width=\"632\" data-original=\"https://pic2.zhimg.com/v2-3937c764ede3df104955c95c5d27b539_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;632&#39; height=&#39;534&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"534\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"632\" data-original=\"https://pic2.zhimg.com/v2-3937c764ede3df104955c95c5d27b539_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3937c764ede3df104955c95c5d27b539_b.jpg\"/></figure><p><b>3 监控数据缓存生成</b></p><p>对需要预警的消息，可异步拉取相应时刻的数据，生产缓存，以便后续消息内容中访问 ，数据key可采用【<b>预警类型+当前时刻</b>】作为唯一标识。</p><p><i>注：原则上数据的拉取与数据内容解析均在模板子类实现，但看实际业务，若规则具备一定统一性，数据解析部分，可放在模板主流程中；</i></p><p><b>4 实际案例</b></p><p><b>4.1业务规则定制</b></p><p>本项目每3分钟扫描消息数据，定义3种预警类型，分别拦截统计：</p><div class=\"highlight\"><pre><code class=\"language-text\">（1） 3min预警：当前这3分钟MSG发送总量 ：&gt;3000 （是每分钟 or 总数）\n     【返回预警时刻，各业务消息发送量列表】 \n      code: MSG_ALERT_COUNT_THREE_MIN\n\n（2） 1h总数预警 ：当前所在这一小时消息累计: &gt;5000\n     【返回预警时刻，返回各业务消息发送量列表】 \n      code: MSG_ALERT_COUNT_ONE_HOUR\n\n（3）1h参照预警：当前所在这一小时消息累计数量 与 上三周同等时刻的均值超过预警\n     【返回预警时刻，返回各业务消息发送量列表】\n      code: MSG_ALERT_TOLERANCE_BEYOUND_AVER</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ce6c0af20bc6afe9061472ee6bcc9d5b_b.jpg\" data-size=\"normal\" data-rawwidth=\"359\" data-rawheight=\"121\" class=\"content_image\" width=\"359\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;359&#39; height=&#39;121&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"359\" data-rawheight=\"121\" class=\"content_image lazy\" width=\"359\" data-actualsrc=\"https://pic4.zhimg.com/v2-ce6c0af20bc6afe9061472ee6bcc9d5b_b.jpg\"/><figcaption>推送消息：消息显示预警类型+预警时刻+内容详情</figcaption></figure><p><b>4.2 后台展示：</b></p><p>当天24小时，每个小时内消息累计量，前3周当前时刻均值比较后台展示：在24小时消息轴线上显示【预警时刻，预警值】；</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-af93133190a12b703ecdd3d1315f6f9c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1649\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb\" width=\"1649\" data-original=\"https://pic1.zhimg.com/v2-af93133190a12b703ecdd3d1315f6f9c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1649&#39; height=&#39;365&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1649\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1649\" data-original=\"https://pic1.zhimg.com/v2-af93133190a12b703ecdd3d1315f6f9c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-af93133190a12b703ecdd3d1315f6f9c_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "消息", 
                    "tagLink": "https://api.zhihu.com/topics/19652134"
                }, 
                {
                    "tag": "预警", 
                    "tagLink": "https://api.zhihu.com/topics/19724909"
                }, 
                {
                    "tag": "监控", 
                    "tagLink": "https://api.zhihu.com/topics/19563297"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57474562", 
            "userName": "一颗白菜菜", 
            "userLink": "https://www.zhihu.com/people/20603d6675443732bfe26faafdb0caab", 
            "upvote": 6, 
            "title": "推荐 10 个好用的 CI/CD 工具", 
            "content": "<p>虽然云平台的到来让开发者免于安装和维护物理服务器，但测试和部署代码过程依旧需要人为完成，持续集成可以自动消除构建、测试和部署代码的大部分痛苦。如果希望最大限度提高效率，持续集成和交付工具是最好的选择。</p><p>实际上，所有开发者都可在软件开发中使用 CI/CD，但团队使用可以获得更大优势，尤其是大型团队，因为他们通常在处理相同的互锁代码块。持续集成最全面的实现是在测试之前构建代码，寻找未被发现的错误和不兼容问题，这些可能是由不同的团队成员写入代码时创建的，持续集成服务器可以同步所有程序员的工作，并帮助团队检测所有问题。</p><p>虽然 CI/CD 热度不退，但完全自动化的部署方式会让团队管理者感到不踏实，因此很多团队习惯在此过程中添加一些手动暂停，并增加问责制和其他保证代码在可控范围内的规则，这种混合方法被称为持续交付，因为它将代码提供给某一阶段或测试集群，并等待开发者最终推向生产。</p><p>如果在服务器机房中持续集成非常好，那么在云中可以实现更快交付和更高效率。在最好的情况下，云可以拆分任务并行运行。服务从大量硬件开始，然后在许多团队之间共享，只要所有人不同时推送代码，构建和测试将运行得很快。</p><p>或许，唯一令团队担心的问题就是失去控制。所有云服务都需要将代码交给第三方，这种选择可能让某些人感到不自由。即便所有的云服务都在努力强调安全性，但依旧让人担心。以下是在云中进行持续集成的 10 种不同选项，可以帮助开发者更好得适应这一过程。</p><p>CloudBees</p><p>CloudBees 核心源自 Jenkins，这是著名的持续集成开源项目，添加了测试支持以及代码运行保证。该公司将所有实验插件清理干净，添加了一些自研实验插件，然后打磨正确以便在需要时如期工作。</p><p>CloudBees 雇用了 80％的 Jenkins 开发团队，为开源项目贡献代码，因此可以确信他们对这个平台有很好的理解。为了加快速度，CloudBees 还添加了大量并行化工具跟踪开发过程。</p><p>CloudBees 提供各种价位，从免费到入门套件和全年服务，并为需要该工具但不需要云计算的开发者提供 Jenkins 支持。</p><p>AWS CodePipeline</p><p>亚马逊用于持续集成和部署的工具 AWS CodePipeline 经过优化，可以将代码交付给 AWS 服务器，同时为代码和数据提供更复杂的路径。基本工具为主要编程语言（Java，Python，Node.js，Ruby，Go，Android，.Net Core for Linux）提供了一个很好的预配置构建环境，发送之前将结果转储到 S3 中并关闭服务器就可以开始运行。</p><p>CodeBuild 在 CodePipe 由 CodePipeline 触发时从 CodeCommit 中获取最新结果，并将其交给 CodeDeploy。如果需要配置大量 Code 代码，可以直接跳到 CodeStar，这提供了另一层面的自动化。在技术上并不需要支付任何代码层费用，亚马逊收取的费用主要是沿途使用的计算和存储资源。</p><p>Bitbucket Pipelines</p><p>Atlassian 是流行的 Jira 和代码库 Bitbucket 背后的公司，决定创建 Bitbucket Pipelines（Bitbucket 云中的持续集成工具）以包括更多集成。构建机制和 Atlassian 其他工具之间的连接形式成为重点，因此这只作为 Bitbucket 中项目的一个选项，另一个选项指向部署。</p><p>如果开发者选择为主要语言（Java，JavaScript，Python，PHP，.Net 等）定义的模板，则只需单击几下即可构建和部署代码，除此之外的选项不存在。Atlassian 确实鼓励一个似乎是图表和 webhook 混合到其他服务的应用程序市场。在我写这篇文章时，图表上的顶级应用程序会将 Bitbucket 与 Jenkins 连接起来，大概是为了做一些无法在墙内快速完成的事情。</p><p>Pipelines 的主要优点是速度，Atlassian 已预先设计从代码到运行部署的大多数主要途径，只需花费几美元就可以使用。很难比较使用 Bitbucket 的成本，因为构建只需几分钟，就像大多数无服务器模型一样，团队通常会使用一组实例来处理 Jenkins 构建。</p><p>GitLab CI / CD</p><p>Atlassian 最大的竞争对手之一是 GitLab。GitLab 的构建，测试和部署机制同样直接连接到其 Git 存储库，因此可以根据规则触发。该过程主要围绕 Docker 容器构建，可以大大简化围绕 Jenkins 构建必须完成的一些配置工作。</p><p>构建任务可以针对任何语言，但必须由 GitLab Runner 触发，GitLab Runner 是一个用 Go 编写的自动缩放工具，适用于大多数平台。这种灵活性意味着可以在其他计算机上触发任何任务，这对于精心设计的架构而言可能非常有用，这些架构不仅仅提供微服务。</p><p>定价与级别捆绑在一起以满足需求，最高级别可以获得最佳功能，比如安全仪表板和在共享机器集群上构建 50,000 分钟，部分流程中使用自己的计算机或在其他云中使用单独的实例是免费的。</p><p>CircleCI</p><p>许多持续集成工具专注于在 Linux 环境中构建代码。CircleCI 既可在 Linux 环境中构建和提供，也可以构建 Android 应用程序以及 Xcode（适用于 iOS，MacOS，tvOS 或 watchOS）。</p><p>CircleCI 使用 Docker，在其所有层次中为代码配置测试环境。构建从新容器开始，所有测试也是如此，Mac 工作在类似的虚拟机中，避免了配置中的一些问题。</p><p>定价主要集中在构建的 CPU 数量上。用户数和存储库数量上限为无穷大，但构建分钟数和容器数是计量的。第一个容器是免费的，可以在其中运行一个构建，如果想要更多并行性或更高吞吐量，需要收费。</p><p>Travis CI</p><p>如果构建需要在 Windows 机器上测试的代码，那么 Travis CI 可以提供一站式服务。该公司已经提供了一段时间的 MacOS 和 Linux 选项，刚刚推出 Windows 选项，让生成更多代码变得更加简单。</p><p>目前，Linux 代码支持 Ubuntu 基本版本，Mac 代码以 OS X，Xcode 和 JDK 的十几种组合之一运行。Windows 代码只支持一个版本的 Windows Server（1803）。Travis CI 提供 30 多种语言支持列表，并构建预先配置且可以运行的规则。</p><p>定价基于一次执行的并发任务数，但这些构建可以占用的分钟数没有正式限制。定制化工作没有免费选项，但开源项目永远免费，这可能是尝试 Travis CI 最简单的方法。</p><p>Azure Pipelines</p><p>虽然，Azure 可能没有太多提供 ENIAC 程序员，但确实为代码提供 Microsoft、Linux 和 MacOS 路径。该堆栈包含 Docker 容器和 Azure 硬件。如果更喜欢命令行，则可以使用 YAML 指定。</p><p>有免费并行任务试用，1800 分钟的构建时间。如果想要更多的并行性或更多构建时间则需要付费。</p><p>CodeShip</p><p>使用持续集成工具时，配置任务列表通常是最大的挑战。CodeShip 在两个服务级别采用两种不同的方法。基础版本计划包括大量自动化和预配置以及图形用户界面，用于设置任务的大致轮廓。高级版本允许配置和用于定义构建环境的 Docker 容器，可以选择将多少个构建专用于任务以及可能的配置。</p><p>基础版本提供免费套餐，包括一台构建机器，无限制项目和人员，但每月只有 100 个构建。如果超过 100 个项目，并希望在一个月内完成所有项目，则需要付费。一旦付费，就没有构建数量或者花费多少时间的上限，只需选择构建和测试即可处理任务。</p><p>Sauce Labs</p><p>以上大多数工具集中在编排从存储库到部署的代码流，Sauce Labs 则专注于测试。基于云的服务提供了各种各样的组合，以确保一切正常。如果想在 Windows 10 上运行的 Firefox 58 上进行测试，或者在 MacOS 上的 Firefox 56，只要选择 Java，Node，Ruby 或 PHP 等其中之一，测试脚本就可以用选择的语言编写，云将并行定位每个处理器。 Sauce Labs 专门将测试与其他 CI 工具或管道集成，因此可以在本地运行 Jenkins，然后将测试委托给 Sauce Labs。</p><p>Jenkins and Hudson</p><p>在云中启动持续集成最简单的方法之一是租用服务器实例并启动 Jenkins 或 Hudson。二者很久以前就开始用作测试 Java 代码的程序，当开发人员和 Oracle 之间出现争议时，其分成了两个阵营，开发人员需要认真查看开源许可。</p><p>虽然 Jenkins 和 Hudson 可能已经开始作为构建 Java 项目的工具，但其早已超越这个利基市场，并可处理几乎所有语言，有数千个插件来处理构建、打包、测试和部署。代码是开源的，因此使用时不需要额外付费，只需支付服务器费用和配置时间。</p><p>欢迎工作一到五年的Java工程师朋友们加入Java程序员开发： 854393687</p><p>群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用&#34;没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！</p><p></p>", 
            "topic": [
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57606694", 
            "userName": "一颗白菜菜", 
            "userLink": "https://www.zhihu.com/people/20603d6675443732bfe26faafdb0caab", 
            "upvote": 3, 
            "title": "从架构特点到功能缺陷，重新认识分析型分布式数据库", 
            "content": "<h2><b>正文</b></h2><p>随着大规模互联网应用的广泛出现，分布式数据库成为近两年的一个热门话题。同样，在银行业主推X86限制主机与小型机的背景下，传统的单机数据库逐渐出现了一些瓶颈，马上会面临是否引入分布式数据库的问题。</p><p>近期，Ivan在个人公众号就“银行引入分布式数据库的必要性”做过一些展望，并收到了一些朋友的反馈，除了对分布式数据库具体技术探讨外，还有一类很有趣的建议，“能不能也讲讲Teradata、Greenplum这类MPP，这些也是分布式数据库，但老板总是认为OLTP场景下的才算数”。</p><p>的确，为了解决OLAP场景需求，其实很早就出现了分布式架构的产品和解决方案，其与目前的OLTP方案有很多共通的地方。而且Ivan相信，今后OLAP和OLTP两个分支技术的发展也必然是交错前行，可以相互借鉴的。</p><p>鉴于此，本文会将OLAP类场景的分布式数据也纳入进来，从两个维度对“分布式数据库”进行拆解，第一部分会横向谈谈不同的“分布式数据库”，把它们分为五类并对其中OLAP场景的三类做概要分析；第二部分结合NoSQL与NewSQL的差异，纵向来谈谈OLTP场景“分布式数据库”实现方案的关键技术要点，是前文的延伸，也是分布式数据库专题文章的一个总纲，其中的要点也都会单独撰文阐述。</p><p>首先，Ivan们从横向谈谈不同的“分布式数据库”：</p><h2><b>一、万法同宗RDBMS</b></h2><p>1990年代开始，关系型数据库（RDBMS）成为主流，典型的产品包括Sybase、Oracle、DB2等，同期大约也是国内IT产业的起步阶段。RDBMS的基本特征已有学术上的定义，这里不再赘述。</p><p>但从实际应用的角度看，Ivan认为有两点最受关注：</p><ol><li>内部以关系模型存储数据，对外支持ANSI SQL接口；</li><li>支持事务管理ACID特性，尤其是强一致性（指事务内的修改要么全部失败要么全部成功，不会出现中间状态）。</li></ol><p>而后出现的各种“分布式数据库”，大多都是在这两点上做权衡以交换其他方面的能力。</p><p>“数据库”虽然有经典定义，但很多大数据产品或许是为了标榜对传统数据库部分功能的替代作用，也借用了“数据库”的名号，导致在实践中这个概念被不断放大，边界越来越模糊。本文一个目标是要厘清这些产品与经典数据库的差异与传承，所以不妨先弱化“数据库”，将其放大为“数据存储”。</p><p>那么怎样才算是“分布式数据存储”系统？</p><p>“分布式”是一种架构风格，用其实现“数据存储”，最现实的目的是为了打开数据库产品的性能天花板，并保证系统的高可靠，进一步展开，“分布式数据库”的必要条件有两点：</p><ul><li>支持水平扩展，保证高性能</li></ul><p>通过增加机器节点的方式提升系统整体处理能力，摆脱对专用设备的依赖，并且突破专用设备方案的性能上限。这里的机器节点，通常是要支持X86服务器。</p><ul><li>廉价设备+软件，保证高可靠</li></ul><p>在单机可靠性较低的前提下，依靠软件保证系统整体的高可靠，又可以细分为“数据存储的高可靠”和“服务的高可靠”。总之，任何单点的故障，可能会带来短时间、局部的服务水平下降，但不会影响系统整体的正常运转。</p><p>将这两点作为“分布式数据库”的必要条件，Ivan大致归纳了一下，至少有五种不同的“分布式数据库”：</p><ul><li>NoSQL</li><li>NewSQL</li><li>MPP</li><li>Hadoop技术生态</li><li>Like-Mesa</li></ul><blockquote>注：也许有些同学会提到Kafka、Zookeeper等，这些虽然也是分布式数据存储，但因为具有鲜明的特点和适用场景，无需再纳入“数据库”概念进行探讨。</blockquote><p>这五类中，前两类以支持OLTP场景为主，后三类则以OLAP场景为主。Ivan将按照时间线，主要对OLAP场景下的三类进行概要分析。</p><h2><b>二、OLAP场景下的分布式数据库</b></h2><p>1990-2000年代，随着应用系统广泛建设与深入使用，数据规模越来越大，国内银行业的“全国大集中”基本都是在这个阶段完成。这期间，RDBMS得到了广泛运用，Oracle也击败Sybase成为数据库领域的王者。</p><p>在满足了基本的交易场景后，数据得到了累积，进一步的分析性需求自然就涌现了出来。单一数据库内同时支持联机交易和分析需求存在很多问题，往往会造成对联机交易的干扰，因此需要新的解决方案。这就为MPP崛起提供了机会。</p><h2><b>1. MPP</b></h2><p>MPP（Massively Parallel Processing）是指多个处理器（或独立的计算机）并行处理一组协同计算[1]。</p><p>为了保证各节点的独立计算能力，MPP数据库通常采用ShareNothing架构，最为典型的产品是Teradata（简称TD），后来也出现Greenplum（简称GPDB）、Vertica、Netezza等竞争者。</p><p><b>架构特点：</b></p><p>MPP是多机可水平扩展的架构，符合“分布式”的基本要求，其中TD采用外置集中存储而GPDB直接使用本地磁盘，从这点来说GPDB是更彻底的Share Nothing架构。</p><p>考虑到TD商业策略上采用一体机方案，不具有开放性，而GPDB具有较高的开源程度，下文中通过分析后者架构特点来分析MPP工作机制。</p><p>GPDB属于主从架构[2]，Slave称为Segment是主要的数据加工节点，是在PostgreSQL基础上的封装和修改，天然具备事务处理的能力，可进行水平扩展；集群内有唯一Active状态的Master节点，除了元数据存储和调度功能外，同时承担一定的工作负载，即所有外部对集群的数据联机访问都要经过Master节点。</p><p>在高可靠设计方面，首先设置了Standby Master节点，在Master节点宕机时接管其任务，其次将Segment节点则细分为两类不同角色Primary和Mirror，后者是前者的备节点，数据提交时在两者间进行强同步，以此保证Primary宕机时，Mirror可以被调度起来接替前者的任务。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3ffca276030821b0143bf2b9e93ff7c3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"392\" data-rawheight=\"431\" class=\"content_image\" width=\"392\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;392&#39; height=&#39;431&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"392\" data-rawheight=\"431\" class=\"content_image lazy\" width=\"392\" data-actualsrc=\"https://pic4.zhimg.com/v2-3ffca276030821b0143bf2b9e93ff7c3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>数据分析性需求对IT能力的要求包括：</p><ul><li>复杂查询能力；</li><li>批量数据处理；</li><li>一定的并发访问能力。</li></ul><p>MPP较好的实现了对上述能力的支撑，在前大数据时代得到了广泛的应用，但这个时期的数据总量相对仍然有限，普遍在TB级别，对应的集群规模也通常在单集群百节点以下。</p><p>随着数据价值关注度的不断提升，越来越多的数据被纳入企业分析范围；同时实际应用中考虑到数据存储和传输成本，往往倾向于将数据集中在一个或少数几个集群中，这样推动了集群规模的快速增长。</p><p>在大规模集群（几百至上千）的使用上，MPP从批处理和联机访问两个方面都显现了一些不足。以下内容主要借鉴了Pivotal（GPDB原厂）的一篇官方博客[3]。</p><p>注：有位同学给出的译文也具有较好的质量，推荐阅读[4]。</p><p><b>缺陷：</b></p><ul><li>批处理</li></ul><p>MPP架构下，工作负载节点（对GPDB而言是Segment节点）是完全对称的，数据均匀的存储在这些节点，处理过程中每个节点（即该节点上的Executor）使用本地的CPU、内存和磁盘等资源完成本地的数据加工。这个架构虽然提供了较好的扩展性，但隐藏了极大的问题——Straggler，即当某个节点出现问题导致速度比其他节点慢时，该节点会成为Straggler。</p><p>此时，无论集群规模多大，批处理的整体执行速度都由Straggler决定，其他节点上的任务执行完毕后则进入空闲状态等待Straggler，而无法分担其工作。导致节点处理速度降低的原因多数是磁盘等硬件损坏，考虑到磁盘本身的一定故障率（根据Google统计前三个月内2%损坏率，第二年时达到8%）当集群规模达到一定程度时，故障会频繁出现使straggler成为一个常规问题。</p><ul><li>并发</li></ul><p>由于MPP的“完全对称性”，即当查询开始执行时，每个节点都在并行的执行完全相同的任务，这意味着MPP支持的并发数和集群的节点数完全无关。根据该文中的测试数据，4个节点的集群和400个节点的集群支持的并发查询数是相同的，随着并发数增加，这二者几乎在相同的时点出现性能骤降。</p><p>传统MPP的联机查询主要面向企业管理层的少数用户，对并发能力的要求较低。而在大数据时代，数据的使用者从战略管理层转向战术执行层乃至一线人员，从孤立的分析场景转向与业务交易场景的融合。对于联机查询的并发能力已经远超MPP时代，成为OLAP场景分布式数据库要考虑的一个重要问题。</p><p>除上述两点以外，GPDB架构中的Master节点承担了一定的工作负载，所有联机查询的数据流都要经过该节点，这样Master也存在一定的性能瓶颈。同时，在实践中GPDB对数据库连接数量的管理也是非常谨慎的。在Ivan曾参与的项目中，Pivotal专家给出了一个建议的最大值且不会随着集群规模扩大而增大。</p><p>综上，大致可以得出结论，MPP（至少是GPDB）在集群规模上是存在一定限制的。</p><p>2000-2010年代，大多数股份制以上银行和少部分城商行都建立了数据仓库或ODS系统，主要采用了MPP产品。可以说，这十余年是MPP产品最辉煌的时代。到目前为止，MPP仍然是银行业建设数据仓库和数据集市类系统的主要技术选择。为了规避MPP并发访问上的缺陷以及批量任务对联机查询的影响，通常会将数据按照应用粒度拆分到不同的单体OLTP数据库中以支持联机查询。</p><h2><b>2. Hadoop生态体系</b></h2><p>MPP在相当长的一段时期内等同于一体机方案（以TD为代表），其价格高昂到普通企业无法承受，多数在银行、电信等行业的头部企业中使用。2010年代，随着大数据时代的开启，Hadoop生态体系以开源优势，获得了蓬勃发展和快速普及。</p><p>Hadoop技术体系大大降低了数据分析类系统的建设成本，数据分析挖掘等工作由此步入“数据民主化”时代。在Hadoop生态体系中，分析需求所需要的能力被拆分为批量加工和联机访问，通过不同的组件搭配实现。批量加工以MapReduce、Tez、Spark等为执行引擎，为了获得友好的语义支持，又增加了Hive、SparkSQL等组件提供SQL访问接口。</p><p>联机访问部分，则从早期Hive过渡到Impala、Hawk以及Kylin、Presto等方案逐渐降低了访问延时。</p><ul><li>架构特点：</li></ul><p>Hadoop生态体系下HDFS、Spark、Hive等组件已经有很多文章介绍，本文不再赘述。总的来说，其架构的着力点在于数据高吞吐处理能力，在事务方面相较MPP更简化，仅提供粗粒度的事务管理。</p><ul><li>缺陷：</li></ul><p>Hadoop也有其明显的缺陷，主要是三点：</p><ul><li>批量加工效率较低</li></ul><p>MPP的拥护者往往会诟病Hadoop计算引擎执行效率低。的确，在同等规模的集群执行相同的数据加工逻辑，即使与Spark对比，MPP所耗费的时间也会明显更少些[3]，其主要的原因在于两者对于数据在磁盘和内存中的组织形式不同。</p><p>MPP从RDBMS而来（例如Vertica和GPDB都是基于PostgreSQL开发），对数据的组织形式更贴近传统方式，按区、段、块等单位组织，对数据进行了预处理工作以提升使用时的效率；Hadoop生态体系以HDFS文件存储为基础，HDFS并不像传统数据库那样独立管理一块连续的磁盘空间，而是将数据表直接映射成不同的数据文件，甚至表分区也以目录、文件等方式体现。</p><p>HDFS最简单的txt格式干脆就是平铺的数据文件，处理过程难免要简单粗暴一些，但随着Avro、ORCFile、Parquet等很多新的存储格式相继被引入，基于HDFS的批处理也更加精细。从整体架构来看，Hadoop更加看重大数据量批量处理的吞吐能力。</p><p>同时，Hadoop具备MPP所缺失的批量任务调整能力，数据的多副本存储使其具有更多“本地化”数据加工的备选节点，而且数据加工处理与数据存储并不绑定，可以根据节点的运行效率动态调整任务分布，从而在大规模部署的情况下具有整体上更稳定的效率。相比之下，MPP在相对较小的数据量下具有更好的执行效率。</p><ul><li>不能无缝衔接EDW实施方法论</li></ul><p>在长期的实践中，企业级市场的主流集成商针对EDW项目沉淀了一套固定的实施方法，与MPP特性相匹配，但Hadoop并不能与之无缝对接。一个最典型的例子是历史数据的存储，传统方法是采用“拉链表”的形式，即对于当前有效的数据会记录其生效的起始时间，在数据被更改或删除后，在该行记录的另外一列记录失效时间。这样，当前数据即变更为历史数据，通过这种增量的表述方式，节省了大量的存储空间和磁盘IO。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c3cfe464e03ddfd9b6d7b3b2e5b7a7d4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic1.zhimg.com/v2-c3cfe464e03ddfd9b6d7b3b2e5b7a7d4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;652&#39; height=&#39;268&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"652\" data-original=\"https://pic1.zhimg.com/v2-c3cfe464e03ddfd9b6d7b3b2e5b7a7d4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c3cfe464e03ddfd9b6d7b3b2e5b7a7d4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>可以看出，拉链表的设计思想其实与基于时间戳的MVCC机制是相同的。</p><p>HDFS作为Hadoop的存储基础，其本身不提供Update操作，这样所有在数据操作层面的Update最终会被转换为文件层面的Delete和Insert操作，效率上显著降低。据Ivan所知，在很多企业实践中会将这种增量存储转换为全量存储，带来大量数据冗余的同时，也造成实施方法上的变更。</p><ul><li>联机查询并发能力不足</li></ul><p>对于联机查询场景，最常见的是SQL on Hadoop方案，将Impala、HAWQ等MPP引擎架设在HDFS基础上，批量数据与联机查询共用一份数据。MPP引擎借鉴了MPP数据库的设计经验，相对Hive等组件提供了更低的延迟。但存在一个与MPP相同的问题，即并发能力不足。</p><p>通过一些项目测试中，Ivan发现在大体相同的数据量和查询逻辑情况下， Impala并发会低于GPDB。其原因可能是多方面的，不排除存在一些调优空间，但在系统架构层面也有值得探讨的内容。例如在元数据读取上，Impala复用了Hive MetaStore，但后者提供的访问服务延时相对较长，这也限制了Impala的并发能力[7]。</p><h2><b>3. Like-Mesa</b></h2><p>Mesa是Google开发的近实时分析型数据仓库，2014年发布了论文披露其设计思想[5]，其通过预聚合合并Delta文件等方式减少查询的计算量，提升了并发能力。</p><p>Mesa充分利用了现有的Google技术组件，使用BigTable来存储所有持久化的元数据，使用了Colossus (Google的分布式文件系统)来存储数据文件，使用MapReduce来处理连续的数据。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f0a490408c19bfb8b14cec1af9a5c602_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"533\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb\" width=\"533\" data-original=\"https://pic3.zhimg.com/v2-f0a490408c19bfb8b14cec1af9a5c602_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;533&#39; height=&#39;232&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"533\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"533\" data-original=\"https://pic3.zhimg.com/v2-f0a490408c19bfb8b14cec1af9a5c602_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f0a490408c19bfb8b14cec1af9a5c602_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Mesa相关的开源产品为Clickhouse[6]（2016年Yandex开源）和Palo[7]（2017年百度开源）。</p><p><b>架构特点：</b></p><p>目前ClickHouse的资料仍以俄语社区为主，为便于大家理解和进一步研究，下面主要以Palo为例进行说明。</p><p>Palo没有完全照搬Mesa的架构设计的思路，其借助了Hadoop的批量处理能力，但将加工结果导入到了Palo自身存储，专注于联机查询场景，在联机查询部分主要借鉴了Impala技术。同时Palo没有复用已有的分布式文件系统和类BigTable系统，而是设计了独立的分布式存储引擎。虽然数据存储上付出了一定的冗余，但在联机查询的低延迟、高并发两方面都得到了很大的改善。</p><p>Palo在事务管理上与Hadoop体系类似，数据更新的原子粒度最小为一个数据加载批次，可以保证多表数据更新的一致性。</p><p>整体架构由Frontend和Backend两部分组成，查询编译、查询执行协调器和存储引擎目录管理被集成到Frontend；查询执行器和数据存储被集成到Backend。Frontend负载较轻，通常配置下，几个节点即可满足要求；而Backend作为工作负载节点会大幅扩展到几十至上百节点。数据处理部分与Mesa相同采用了物化Rollup（上卷表）的方式实现预计算。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fe70cdfadc63e33e29386338fb132ac0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1494\" data-rawheight=\"780\" class=\"origin_image zh-lightbox-thumb\" width=\"1494\" data-original=\"https://pic1.zhimg.com/v2-fe70cdfadc63e33e29386338fb132ac0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1494&#39; height=&#39;780&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1494\" data-rawheight=\"780\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1494\" data-original=\"https://pic1.zhimg.com/v2-fe70cdfadc63e33e29386338fb132ac0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fe70cdfadc63e33e29386338fb132ac0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Palo和ClickHouse都宣称实现了MPP Data Warehouse，但从架构上看已经与传统的MPP发生很大的变化，几乎完全舍弃了批量处理，专注于联机部分。</p><p>ClickHouse和Palo作为较晚出现的开源项目，还在进一步发展过程中，设定的使用场景以广告业务时序数据分析为主，存在一定局限性，但值得持续关注。</p><p>欢迎工作一到五年的Java工程师朋友们加入Java程序员开发： 854393687</p><p>群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用&#34;没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！</p><p></p>", 
            "topic": [
                {
                    "tag": "分布式数据库", 
                    "tagLink": "https://api.zhihu.com/topics/20034041"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57385234", 
            "userName": "一颗白菜菜", 
            "userLink": "https://www.zhihu.com/people/20603d6675443732bfe26faafdb0caab", 
            "upvote": 9, 
            "title": "传统行业转型微服务的挖坑与填坑", 
            "content": "<h2><b>一、微服务落地是一个复杂问题，牵扯到IT架构，应用架构，组织架构多个方面</b></h2><p>在多家传统行业的企业走访和落地了微服务之后，发现落地微服务是一个非常复杂的问题，甚至都不完全是技术问题。</p><p>当时想微服务既然是改造应用，做微服务治理，类似注册，发现，熔断，限流，降级等，当然应该从应用开发组切入，一般一开始聊的会比较开心，从单体架构，到SOA，再到微服务架构，从Dubbo聊到SpringCloud，但是必然会涉及到微服务的发布和运维问题，涉及到DevOps和容器层，这些都不在开发组的控制范围内，一旦拉进运维组，对于容器的接受程度就成了一个问题，和传统物理机，虚拟机的差别，会带来什么风险等等等等，尤其是容器绝对不是轻量级的虚拟化这件事情，就不是一时半会儿能说的明白的。更何况就算说明白了，还有线上应用容器，一旦出了事情，谁背锅的问题，容器往往会导致应用层和基础设施层界限模糊，这使得背锅双方都会犹豫不决。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-16de609f6ec43f8244e8bacc99538d09_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-16de609f6ec43f8244e8bacc99538d09_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-16de609f6ec43f8244e8bacc99538d09_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-16de609f6ec43f8244e8bacc99538d09_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>有的企业的微服务化是运维部门发起的，运维部门已经意识到了各种各样不统一的应用给运维带来的苦，也乐意接受容器的运维模式，这就涉及到容器直接的服务发现是否应该运维在容器层搞定，还是应用应该自己搞定的问题，还涉及Dockerfile到底是开发写还是运维写的问题。一旦容器化的过程中，开发不配合，运维单方面去做这个事情，是徒增烦恼却收益有限的。</p><p>欢迎工作一到五年的Java工程师朋友们加入Java程序员开发： 854393687</p><p>群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用&#34;没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下图是微服务实施的过程中涉及到的层次，具体的描述参考文章<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NzYzODk4OQ%3D%3D%26mid%3D2247484962%26idx%3D1%26sn%3Daf630988628021e0016c8764293ed48a%26chksm%3Dea151100dd62981645198dc7624004008c0babf6da195e2c374e3da276604c401946851db3f0%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">云架构师进阶攻略</a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7631ceab84ea472078c223172a2d426c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"552\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic1.zhimg.com/v2-7631ceab84ea472078c223172a2d426c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;552&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"552\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic1.zhimg.com/v2-7631ceab84ea472078c223172a2d426c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7631ceab84ea472078c223172a2d426c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在一些相对先进的企业，会在运维组和开发组之间，有个中间件组，或者叫做架构组，来负责推动微服务化改造的事情，架构组就既需要负责劝说业务开发实施微服务化，也要劝说运维组实施容器化，如果架构组的权威性不足，推动往往也会比较困难。</p><p>所以微服务，容器，DevOps的推动，不单单是一个技术问题，更是一个组织问题，在推动微服务的过程中，更加能够感觉到康威定律的作用，需要更高层次技术总监或者CIO的介入，方能够推动微服务的落地。</p><p>然而到了CIO层，在很多企业又体会不到技术层面的痛点了，而更加关注业务的层面了，只要业务能赚钱，架构的痛，中间件的痛，运维的痛，高层不是非常能够感知，也就体会不到微服务，容器化的技术优势了，而微服务和容器化对于业务的优势，很多厂家在说，能够说到表面，说不到心里。</p><p>因而微服务和容器化的改造，更加容易发生在一个扁平化的组织里面，由一个能够体会到基层技术细节的痛的CIO，高瞻远瞩的推动这件事情。这也是为什么微服务的落地一般率先落地在互联网公司，因为互联网公司的组织架构实在太平台，哪怕是高层，也离一线非常的近，了解一线的痛。</p><p>然而在传统行业就没有那么幸运了，层级往往会比较多，这个时候就需要技术上的痛足够痛，能够痛到影响业务，能够痛到影响收入，能够痛到被竞争对手甩在后面，才能上达天听。</p><p>我们接下来就梳理一下，在这个过程中的那些痛。</p><h2><b>二、阶段一：单体架构群，多个开发组，统一运维组</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0bc12b73ef87b04ec4721e5cc96987e3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1017\" data-rawheight=\"566\" class=\"origin_image zh-lightbox-thumb\" width=\"1017\" data-original=\"https://pic4.zhimg.com/v2-0bc12b73ef87b04ec4721e5cc96987e3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1017&#39; height=&#39;566&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1017\" data-rawheight=\"566\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1017\" data-original=\"https://pic4.zhimg.com/v2-0bc12b73ef87b04ec4721e5cc96987e3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0bc12b73ef87b04ec4721e5cc96987e3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.1. 阶段一的组织状态</b></h2><p>组织状态相对简单。</p><p>统一的运维组，管理物理机，物理网络，Vmware虚拟化等资源，同时部署上线由运维部负责。</p><p>开发组每个业务都是独立的，负责写代码，不同的业务沟通不多，开发除了做自己的系统外，还需要维护外包公司开发的系统，由于不同的外包公司技术选型差异较大，因而处于烟囱式的架构状态。</p><p>传统烟囱式架构如下图所示</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4c14fc3950581d07b1e4fc895393ac35_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"386\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-4c14fc3950581d07b1e4fc895393ac35_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;386&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"386\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-4c14fc3950581d07b1e4fc895393ac35_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4c14fc3950581d07b1e4fc895393ac35_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.2. 阶段一的运维模式</b></h2><p>在传统架构下，基础设施层往往采取物理机或者虚拟化进行部署，为了不同的应用之间方便相互访问，多采取桥接扁平二层机房网络，也即所有的机器的IP地址都是可以相互访问的，不想互相访问的，多采用防火墙进行隔离。</p><p>无论是使用物理机，还是虚拟化，配置是相对复杂的，不是做过多年运维的人员，难以独立的创建一台机器，而且网络规划也需要非常小心，分配给不同业务部门的机器，网段不能冲突。所有这一切，都需要运维部门统一进行管理，一般的IT人员或者开发人员既没有专业性，也不可能给他们权限进行操作，要申请机器怎么办，走个工单，审批一下，过一段时间，机器就能创建出来。</p><h2><b>2.3. 阶段一的应用架构</b></h2><p>传统架构数据库层，由于外包公司独立开发，或者不同开发部门独立开发，不同业务使用不同的数据库，有用Oracle的，有用SQL Server的，有用Mysql的，有用MongoDB的，各不相同。</p><p>传统架构的中间件层，每个团队独立选型中间件：</p><ul><li>文件：NFS，FTP，Ceph，S3</li><li>缓存：Redis Cluster，主备，Sentinel, Memcached</li><li>分布式框架：Spring Cloud，Dubbo，Restful or RPC不同的部门自己选型</li><li>分库分表：Sharding-jdbc，Mycat</li><li>消息队列：RabbitMQ, Kafka</li><li>注册中心：Zk，Euraka，consul</li></ul><p>传统架构的服务层，系统或者由外包公司开发，或者由独立团队开发。</p><p>传统架构前端，各自开发各自的前端。</p><h2><b>2.4. 阶段一有什么问题吗？</b></h2><p>其实阶段一没有任何问题，我们甚至能找出一万个理由说明这种模式的好处。</p><p>运维部和开放部是天然分开的，谁也不想管对方，两边的老大也是评级的，本相安无事。</p><p>机房当然只能运维人员能碰，这里面有安全的问题，专业性的问题，线上系统严肃的问题。如果交给没有那么专业的开发去部署环境，一旦系统由漏洞，谁能担责任，一旦线上系统挂了，又是谁的责任，这个问题问出来，能够让任何争论鸦雀无声。</p><p>数据库无论使用Oracle, DB2，还是SQL Server都没有问题，只要公司有足够的预算，而且性能也的确杠杠的，里面存储了大量存储过程，会使得应用开发简单很多，而且有专业的乙方帮忙运维，数据库如此关键，如果替换称为Mysql，一旦抗不出挂了，或者开源的没人维护，线上出了事情，谁来负责？</p><p>中间件，服务层，前端，全部由外包商或者乙方搞定，端到端维护，要改什么招手即来，而且每个系统都是完整的一套，部署方便，运维方便。</p><p>其实没有任何问题，这个时候上容器或者上微服务，的确自找麻烦。</p><h2><b>2.5. 什么情况下才会觉得阶段一有问题？</b></h2><p>当然最初的痛点应该在业务层面，当用户的需求开始变的多种多样，业务方时不时的就要上一个新功能，做一个新系统的时候，你会发现外包公司不是能完全搞定所有的事情，他们是瀑布模型的开发，而且开发出来的系统很难变更，至少很难快速变更。</p><p>于是你开始想自己招聘一些开发，开发自己能够把控的系统，至少能够将外包公司开发的系统接管过来，这个时候，应对业务部门的需求，就会灵活的多。</p><p>但是自己开发和维护就带来了新的问题，多种多样的数据库，根本不可能招聘到如此多样的DBA，人都非常的贵，而且随着系统的增多，这些数据库的lisense也非常的贵。</p><p>多种多样的中间件，每个团队独立选型中间件，没有统一的维护，没有统一的知识积累，无法统一保障SLA。一旦使用的消息队列，缓存，框架出了问题，整个团队没有人能够搞定这个事情，因为大家都忙于业务开发，没人有时间深入的去研究这些中间件的背后原理，常见的问题，如何调优等等。</p><p>前端框架也有相同的问题，技术栈不一致，界面风格不一致，根本无法自动做UI测试。</p><p>当维护了多套系统之后，你会发现，这些系统各个层次都有很多的共同点，很多能力是可以复用的，很多数据是可以打通的。同样一套逻辑，这里也有，那里也有，同样类型的数据，这里一份，那里一份，但是信息是隔离的，数据模型不统一，根本无法打通。</p><p>当出现这些问题的时候，才是您考虑进入第二个阶段。</p><h2><b>三、阶段二：组织服务化，架构SOA化，基础设施云化</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-35ecb8515772781cd0837969056e2a37_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"781\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb\" width=\"781\" data-original=\"https://pic4.zhimg.com/v2-35ecb8515772781cd0837969056e2a37_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;781&#39; height=&#39;476&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"781\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"781\" data-original=\"https://pic4.zhimg.com/v2-35ecb8515772781cd0837969056e2a37_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-35ecb8515772781cd0837969056e2a37_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.1. 阶段二的组织形态</b></h2><p>怎么解决上面的问题呢？</p><p>根据康威定理，组织方面就需要有一定的调整，整个公司还是分运维组和开发组。</p><p>由于痛点是从业务层面发生的，开始调整的应该是开发组。</p><p>应该建立独立的前端组，统一前端框架，界面一致，所有人掌握统一的前端开发能力，积累前端代码，在有新的需求的时候，能够快速的进行开发。</p><p>建立中间件组，或者架构师组，这部分人不用贴近业务开发，每天的任务就是研究如何使用这些中间件，如何调优，遇到问题如何Debug，形成知识积累。如果有统一的一帮人专注中间件，就可以根据自身的情况，选择有限几个中间件集中研究，限定业务组只使用这些中间件，可保证选型的一致性，如果中间件被这个组统一维护，也可以提供可靠的SLA给业务方。</p><p>将业务开发组分出一部分来，建立中台组，将可以复用的能力和代码，交由这几个组开发出服务来，给业务组使用，这样数据模型会统一，业务开发的时候，首先先看看有哪些现成的服务可以使用，不用全部从零开发，也会提高开发效率。</p><h2><b>3.2. 阶段二的应用架构</b></h2><p>要建立中台，变成服务为其他业务使用，就需要使用SOA架构，将可以复用的组件服务化，注册到服务的注册中心。</p><p>对于有钱的企业，可能会采购商用的ESB总线，也有使用Dubbo自己封装称为服务注册中心。</p><p>接下来就是要考虑，哪些应该拆出来？ 最后考虑的是如何拆出来？</p><p>这两个题目的答案，不同的企业不同，其实分为两个阶段，第一个阶段是尝试阶段，也即整个公司对于服务化拆分没有任何经验，当然不敢拿核心业务上手，往往选取一个边角的业务，先拆拆看，这个时候拆本身是重要的，其实是为了拆而拆，拆的比较理想化，符合领域驱动设计的最好，如何拆呢？当然是弄一个两个月，核心员工大家闭门开发，进行拆分和组合，来积累经验。很多企业目前处于这个阶段。</p><p>但是其实这个阶段的拆法也只能用来积累经验，因为咱们最初要拆分，是为了快速响应业务请求，而这个边角的模块，往往不是最痛的核心业务。本来业务就边角，拆不拆收益不大，而且也没办法很好的做能力复用。复用当然都想复用核心能力。</p><p>所以其实最重要的是第二个阶段，业务真正的服务化的阶段。当然要拿业务需求最多的核心业务逻辑下手，才能起到快速响应业务请求，复用能力的作用。</p><p>例如考拉最初也是一个使用Oracle，对外只有一个online业务的单体应用，而真正的拆分，就是围绕核心的下单业务逻辑进行的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e4c39a6f44ae66fcb2a1a26227f71e28_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"877\" data-rawheight=\"514\" class=\"origin_image zh-lightbox-thumb\" width=\"877\" data-original=\"https://pic1.zhimg.com/v2-e4c39a6f44ae66fcb2a1a26227f71e28_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;877&#39; height=&#39;514&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"877\" data-rawheight=\"514\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"877\" data-original=\"https://pic1.zhimg.com/v2-e4c39a6f44ae66fcb2a1a26227f71e28_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e4c39a6f44ae66fcb2a1a26227f71e28_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>那核心业务逻辑中，哪些应该拆出来呢？很多企业会问我们，其实企业自己的开发最清楚。</p><p>这个时候经常犯的错误是，先将核心业务逻辑从单体应用中拆分出来。例如将下单逻辑形成下单服务，从online服务中拆分出来。</p><p>当然不应该这样，例如两军打仗，当炊事班的烟熏着战士了，是将中军大营搬出去，还是讲炊事班搬出去呢？当然是炊事班了。</p><p>另外一点是，能够形成复用的组件，往往不是核心业务逻辑。这个很好理解，两个不同的业务，当然是核心业务逻辑不同(要不就成一种业务了)，核心业务逻辑往往是组合逻辑，虽然复杂，但是往往不具备复用性，就算是下单，不同的电商也是不一样的，这家推出了什么什么豆，那家推出了什么什么券，另一家有个什么什么活动，都是核心业务逻辑的不同，会经常变。能够复用的，往往是用户中心，支付中心，仓储中心，库存中心等等核心业务的周边逻辑。</p><p>所以拆分，应该将这些核心业务的周边逻辑，从核心业务里面拆出来，最终Online就剩下下单的核心路径了，就可以改成下单服务了。当业务方突然有了需求推出一个抢购活动，就可以复用刚才的周边逻辑了。抢购就成了另一个应用的核心逻辑，其实核心逻辑是传真引线的，周边逻辑是保存数据，提供原子化接口的。</p><p>那哪些周边逻辑应该先拆出来呢？问自己的开发吧，那些战战兢兢，自己修改后生怕把核心逻辑搞挂了的组，是自己有动力从核心逻辑中拆分出来的，这个不需要技术总监和架构师去督促，他们有自己的原有动力，是一个很自然的过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-722a213cefee69599f79e7147d293709_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"889\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb\" width=\"889\" data-original=\"https://pic2.zhimg.com/v2-722a213cefee69599f79e7147d293709_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;889&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"889\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"889\" data-original=\"https://pic2.zhimg.com/v2-722a213cefee69599f79e7147d293709_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-722a213cefee69599f79e7147d293709_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里的原有动力，一个是开发独立，一个是上线独立，就像考拉的online系统里面，仓库组就想自己独立出去，因为他们要对接各种各样的仓储系统，全球这么多的仓库，系统都很传统，接口不一样，没新对接一个，开发的时候，都担心把下单核心逻辑搞挂了，造成线上事故，其实仓储系统可以定义自己的重试和容灾机制，没有下单那么严重。物流组也想独立出去，因为对接的物流公司太多了，也要经常上线，也不想把下单搞挂。</p><p>您也可以梳理一下贵公司的业务逻辑，也会有自行愿意拆分的业务，形成中台服务。</p><p>当周边的逻辑拆分之后，一些核心的逻辑，互相怕影响，也可以拆分出去，例如下单和支付，支付对接多个支付方的时候，也不想影响下单，也可以独立出去。</p><p>然后我们再看，如何拆分的问题？</p><p>关于拆分的前提，时机，方法，规范等，参考文章<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NzYzODk4OQ%3D%3D%26mid%3D2247484925%26idx%3D1%26sn%3D5c15ba98fb03a2a0d9c823136f34e162%26chksm%3Dea1512dfdd629bc9971b4ec7ccc6d2c844fee66a7b7fc1a25a7cf78467996d76b5ef33e56190%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">微服务化之服务拆分与服务发现</a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3c2da9677bb5a08f2de16b8212d36d12_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-3c2da9677bb5a08f2de16b8212d36d12_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;811&#39; height=&#39;235&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-3c2da9677bb5a08f2de16b8212d36d12_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3c2da9677bb5a08f2de16b8212d36d12_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>首先要做的，就是原有工程代码的标准化，我们常称为“任何人接手任何一个模块都能看到熟悉的面孔”</p><p>例如打开一个java工程，应该有以下的package：</p><ul><li>API接口包：所有的接口定义都在这里，对于内部的调用，也要实现接口，这样一旦要拆分出去，对于本地的接口调用，就可以变为远程的接口调用</li><li>访问外部服务包：如果这个进程要访问其他进程，对于外部访问的封装都在这里，对于单元测试来讲，对于这部分的Mock，可以使得不用依赖第三方，就能进行功能测试。对于服务拆分，调用其他的服务，也是在这里。</li><li>数据库DTO：如果要访问数据库，在这里定义原子的数据结构</li><li>访问数据库包：访问数据库的逻辑全部在这个包里面</li><li>服务与商务逻辑：这里实现主要的商业逻辑，拆分也是从这里拆分出来。</li><li>外部服务：对外提供服务的逻辑在这里，对于接口的提供方，要实现在这里。</li></ul><p>另外是测试文件夹，每个类都应该有单元测试，要审核单元测试覆盖率，模块内部应该通过Mock的方法实现集成测试。</p><p>接下来是配置文件夹，配置profile，配置分为几类：</p><ul><li>内部配置项(启动后不变，改变需要重启)</li><li>集中配置项(配置中心，可动态下发)</li><li>外部配置项(外部依赖，和环境相关)</li></ul><p>当一个工程的结构非常标准化之后，接下来在原有服务中，先独立功能模块 ，规范输入输出，形成服务内部的分离。在分离出新的进程之前，先分离出新的jar，只要能够分离出新的jar，基本也就实现了松耦合。</p><p>接下来，应该新建工程，新启动一个进程，尽早的注册到注册中心，开始提供服务，这个时候，新的工程中的代码逻辑可以先没有，只是转调用原来的进程接口。</p><p>为什么要越早独立越好呢？哪怕还没实现逻辑先独立呢？因为服务拆分的过程是渐进的，伴随着新功能的开发，新需求的引入，这个时候，对于原来的接口，也会有新的需求进行修改，如果你想把业务逻辑独立出来，独立了一半，新需求来了，改旧的，改新的都不合适，新的还没独立提供服务，旧的如果改了，会造成从旧工程迁移到新工程，边迁移边改变，合并更加困难。如果尽早独立，所有的新需求都进入新的工程，所有调用方更新的时候，都改为调用新的进程，对于老进程的调用会越来越少，最终新进程将老进程全部代理。</p><p>接下来就可以将老工程中的逻辑逐渐迁移到新工程，由于代码迁移不能保证逻辑的完全正确，因而需要持续集成，灰度发布，微服务框架能够在新老接口之间切换。</p><p>最终当新工程稳定运行，并且在调用监控中，已经没有对于老工程的调用的时候，就可以将老工程下线了。</p><h2><b>3.3. 阶段二的运维模式</b></h2><p>经过业务层的的服务化，也对运维组造成了压力。</p><p>应用逐渐拆分，服务数量增多。</p><p>在服务拆分的最佳实践中，有一条就是，拆分过程需要进行持续集成，保证功能一致。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b9dc182e3453c8e14dd76cc8b10ab524_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"712\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb\" width=\"712\" data-original=\"https://pic1.zhimg.com/v2-b9dc182e3453c8e14dd76cc8b10ab524_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;712&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"712\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"712\" data-original=\"https://pic1.zhimg.com/v2-b9dc182e3453c8e14dd76cc8b10ab524_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b9dc182e3453c8e14dd76cc8b10ab524_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>而持续集成的流程，往往需要频繁的部署测试环境。</p><p>随着服务的拆分，不同的业务开发组会接到不同的需求，并行开发功能增多，发布频繁，会造成测试环境，生产环境更加频繁的部署。</p><p>而频繁的部署，就需要频繁创建和删除虚拟机。</p><p>如果还是采用上面审批的模式，运维部就会成为瓶颈，要不就是影响开发进度，要不就是被各种部署累死。</p><p>这就需要进行运维模式的改变，也即基础设施层云化。</p><p>虚拟化到云化有什么不一样呢？</p><p>首先要有良好的租户管理，从运维集中管理到租户自助使用模式的转换。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9a75c518c8980d9d8829e49cc55843ff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"871\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb\" width=\"871\" data-original=\"https://pic4.zhimg.com/v2-9a75c518c8980d9d8829e49cc55843ff_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;871&#39; height=&#39;496&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"871\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"871\" data-original=\"https://pic4.zhimg.com/v2-9a75c518c8980d9d8829e49cc55843ff_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9a75c518c8980d9d8829e49cc55843ff_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>也即人工创建，人工调度，人工配置的集中管理模式已经成为瓶颈，应该变为租户自助的管理，机器自动的调度，自动的配置。</p><p>其次，要实现基于Quota和QoS的资源控制。</p><p>也即对于租户创建的资源的控制，不用精细化到运维手动管理一切，只要给这个客户分配了租户，分配了Quota，设置了Qos，租户就可以在运维限定的范围内，自由随意的创建，使用，删除虚拟机，无需通知运维，这样迭代速度就会加快。</p><p>再次，要实现基于虚拟网络，VPC，SDN的网络规划。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c92f3b2479eb68c4041b9ef92eff254f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic4.zhimg.com/v2-c92f3b2479eb68c4041b9ef92eff254f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;376&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic4.zhimg.com/v2-c92f3b2479eb68c4041b9ef92eff254f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c92f3b2479eb68c4041b9ef92eff254f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d28fa7b1521dae9312a3ab22eda4bd42_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"571\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb\" width=\"571\" data-original=\"https://pic3.zhimg.com/v2-d28fa7b1521dae9312a3ab22eda4bd42_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;571&#39; height=&#39;194&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"571\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"571\" data-original=\"https://pic3.zhimg.com/v2-d28fa7b1521dae9312a3ab22eda4bd42_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d28fa7b1521dae9312a3ab22eda4bd42_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>原来的网络使用的都是物理网络，问题在于物理网络是所有部门共享的，没办法交给一个业务部门自由的配置和使用。因而要有VPC虚拟网络的概念，每个租户可以随意配置自己的子网，路由表，和外网的连接等，不同的租户的网段可以冲突，互不影响，租户可以根据自己的需要，随意的在界面上，用软件的方式做网络规划。</p><p>除了基础设施云化之外，运维部门还应该将应用的部署自动化。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1bc48930f5da7d65d25bc6d1f541da57_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1011\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb\" width=\"1011\" data-original=\"https://pic4.zhimg.com/v2-1bc48930f5da7d65d25bc6d1f541da57_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1011&#39; height=&#39;452&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1011\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1011\" data-original=\"https://pic4.zhimg.com/v2-1bc48930f5da7d65d25bc6d1f541da57_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1bc48930f5da7d65d25bc6d1f541da57_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>因为如果云计算不管应用，一旦出现扩容，或者自动部署的需求，云平台创建出来的虚拟机还是空的，需要运维手动上去部署，根本忙不过来。因而云平台，也一定要管理应用。</p><p>云计算如何管理应用呢？我们将应用分成两种，一种称为通用的应用，一般指一些复杂性比较高，但大家都在用的，例如数据库。几乎所有的应用都会用数据库，但数据库软件是标准的，虽然安装和维护比较复杂，但无论谁安装都是一样。这样的应用可以变成标准的PaaS层的应用放在云平台的界面上。当用户需要一个数据库时，一点就出来了，用户就可以直接用了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9fe73176f524ad4e3d171eee60ceb532_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"493\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-9fe73176f524ad4e3d171eee60ceb532_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;493&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"493\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-9fe73176f524ad4e3d171eee60ceb532_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9fe73176f524ad4e3d171eee60ceb532_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以对于运维模式的第二个改变是，通用软件PaaS化。</p><p>前面说过了，在开发部门有中间件组负责这些通用的应用，运维也自动部署这些应用，两个组的界限是什么样的呢？</p><p>一般的实践方式是，云平台的PaaS负责创建的中间件的稳定，保证SLA，当出现问题的时候，会自动修复。</p><p>而开发部门的中间件组，主要研究如何正确的使用这些PaaS，配置什么样的参数，使用的正确姿势等等，这个和业务相关。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-08447e2463a3d6b040ea261f3b9d33aa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-08447e2463a3d6b040ea261f3b9d33aa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;522&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-08447e2463a3d6b040ea261f3b9d33aa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-08447e2463a3d6b040ea261f3b9d33aa_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>除了通用的应用，还有个性化的应用，应该通过脚本进行部署，例如工具Puppet, Chef, Ansible, SaltStack等。</p><p>这里有一个实践是，不建议使用裸机部署，因为这样部署非常的慢，推荐基于虚拟机镜像的自动部署。在云平台上，任何虚拟机的创建都是基于镜像的，我们可以在镜像里面，将要部署的环境大部分部署好，只需要做少量的定制化，这些由部署工具完成。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-99c198bce8ab2d57e6cc4dc1810bc215_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"436\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb\" width=\"436\" data-original=\"https://pic2.zhimg.com/v2-99c198bce8ab2d57e6cc4dc1810bc215_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;436&#39; height=&#39;359&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"436\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"436\" data-original=\"https://pic2.zhimg.com/v2-99c198bce8ab2d57e6cc4dc1810bc215_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-99c198bce8ab2d57e6cc4dc1810bc215_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>下图是OpenStack基于Heat的虚拟机编排，除了调用OpenStack API基于镜像创建虚拟机之外，还要调用SaltStack的master，将定制化的指令下发给虚拟机里面的agent。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f45a5bafd5a0d0a03bc2fbc096278b3d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb\" width=\"678\" data-original=\"https://pic2.zhimg.com/v2-f45a5bafd5a0d0a03bc2fbc096278b3d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;678&#39; height=&#39;212&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"678\" data-original=\"https://pic2.zhimg.com/v2-f45a5bafd5a0d0a03bc2fbc096278b3d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f45a5bafd5a0d0a03bc2fbc096278b3d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>基于虚拟机镜像和脚本下发，可以构建自动化部署平台NDP</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3653aeef559a7b2ffceb5792810a35a9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb\" width=\"553\" data-original=\"https://pic2.zhimg.com/v2-3653aeef559a7b2ffceb5792810a35a9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;553&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"553\" data-original=\"https://pic2.zhimg.com/v2-3653aeef559a7b2ffceb5792810a35a9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3653aeef559a7b2ffceb5792810a35a9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样可以基于虚拟机镜像，做完整的应用的部署和上线，称为编排。基于编排，就可以进行很好的持续集成，例如每天晚上，自动部署一套环境，进行回归测试，从而保证修改的正确性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3305a9e06f635cb17062bc06e9b38fb6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"509\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-3305a9e06f635cb17062bc06e9b38fb6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;509&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"509\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-3305a9e06f635cb17062bc06e9b38fb6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3305a9e06f635cb17062bc06e9b38fb6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>进行完第二阶段之后，整个状态如上图所示。</p><p>这里运维部门的职能有了一定的改变，除了最基本的资源创建，还要提供自助的操作平台，PaaS化的中间件，基于镜像和脚本的自动部署。</p><p>开发部门的职能也有了一定的改变，拆分称为前端组，业务开发组，中台组，中间件组，其中中间件组合运维部门的联系最紧密。</p><h2><b>3.4. 阶段二有什么问题吗？</b></h2><p>其实大部分的企业，到了这个阶段，已经可以解决大部分的问题了。</p><p>能够做到架构SOA化，基础设施云化的公司已经是传统行业在信息化领域的佼佼者了。</p><p>中台开发组基本能够解决中台的能力复用问题，持续集成也基本跑起来了，使得业务开发组的迭代速度明显加快。</p><p>集中的中间件组或者架构组，可以集中选型，维护，研究消息队列，缓存等中间件。</p><p>在这个阶段，由于业务的稳定性要求，很多公司还是会采用Oracle商用数据库，也没有什么问题。</p><p>实现到了阶段二，在同行业内，已经有一定的竞争优势了。</p><h2><b>3.5. 什么情况下才会觉得阶段二有问题？</b></h2><p>我们发现，当传统行业不再满足于在本行业的领先地位，希望能够对接到互联网业务的时候，上面的模式才出现新的痛点。</p><p>对接互联网所面临的最大的问题，就是巨大的用户量所带来的请求量和数据量，会是原来的N倍，能不能撑得住，大家都心里没底。</p><p>例如有的客户推出互联网理财秒杀抢购，原来的架构无法承载近百倍的瞬间流量。</p><p>有的客户对接了互联网支付，甚至对接了国内最大的外卖平台，而原来的ESB总线，就算扩容到最大规模(13个节点)，也可能撑不住。</p><p>有的客户虽然已经用了Dubbo实现了服务化，但是没有熔断，限流，降级的服务治理策略，有可能一个请求慢，高峰期波及一大片，或者请求全部接进来，最后都撑不住而挂一片。</p><p>有的客户希望实现工业互连网平台，可是接入的数据量动辄PB级别，如果扛的住是一个很大的问题。</p><p>有的客户起初使用开源的缓存和消息队列，分布式数据库，但是读写频率到了一定的程度，就会出现各种奇奇怪怪的问题，不知道应该如何调优。</p><p>有的客户发现，一旦到了互联网大促级别，Oracle数据库是肯定扛不住的，需要从Oracle迁移到DDB分布式数据库，可是怎么个迁移法，如何平滑过渡，心里没底。</p><p>有的客户服务拆分之后，原来原子化的操作分成了两个服务调用，如何仍然保持原子化，要不全部成功，要不全部失败，需要分布式事务，虽然业内有大量的分布式方案，但是能够承载高并发支付的框架还没有。</p><p>当出现这些问题的时候，才应该考虑进入第三个阶段，微服务化</p><h2><b>四、阶段三：组织DevOps化，架构微服务化，基础设施容器化</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2e237597edc299e148647130baa69da8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"781\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb\" width=\"781\" data-original=\"https://pic1.zhimg.com/v2-2e237597edc299e148647130baa69da8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;781&#39; height=&#39;476&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"781\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"781\" data-original=\"https://pic1.zhimg.com/v2-2e237597edc299e148647130baa69da8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2e237597edc299e148647130baa69da8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4.1. 阶段三的应用架构</b></h2><p>从SOA到微服务化这一步非常关键，复杂度也比较高，上手需要谨慎。</p><p>为了能够承载互联网高并发，业务往往需要拆分的粒度非常的细，细到什么程度呢？我们来看下面的图。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ae76e26108f258c862bdf0e6f05275dd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-ae76e26108f258c862bdf0e6f05275dd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;294&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-ae76e26108f258c862bdf0e6f05275dd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ae76e26108f258c862bdf0e6f05275dd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在这些知名的使用微服务的互联网公司中，微服务之间的相互调用已经密密麻麻相互关联成为一个网状，几乎都看不出条理来。</p><p>为什么要拆分到这个粒度呢？主要是高并发的需求。</p><p>但是高并发不是没有成本的，拆分成这个粒度会有什么问题呢？你会发现等拆完了，下面的这些措施一个都不能少。</p><ul><li>拆分如何保证功能不变，不引入Bug——持续集成，参考<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NzYzODk4OQ%3D%3D%26mid%3D2247484778%26idx%3D1%26sn%3Df3a29677d7030370fdd9b8931a0449d0%26chksm%3Dea151248dd629b5e1439bc4fa84411cdb5444d0bf0e8c09267a868fcb18f78602482dea51107%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">微服务化的基石——持续集成</a></li><li>静态资源要拆分出来，缓存到接入层或者CDN，将大部分流量拦截在离用户近的边缘节点或者接入层缓存，参考<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NzYzODk4OQ%3D%3D%26mid%3D2247484791%26idx%3D1%26sn%3D4cb4fb04b481c3aee8a882934c8d925f%26chksm%3Dea151255dd629b43c6383d912234ae0d53fad34e354fdf985a6461aa2774deaf313a234d64fb%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">微服务的接入层设计与动静资源隔离</a></li><li>应用的状态要从业务逻辑中拆分出来，使得业务无状态，可以基于容器进行横向扩展，参考<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NzYzODk4OQ%3D%3D%26mid%3D2247484852%26idx%3D1%26sn%3Dbf08e717f6d0b4dde432109753c00f36%26chksm%3Dea151296dd629b80fbf9d623b7fa7c8c063b9bfab74913ca3e7e7eb3daf0bfa331e7125678de%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">微服务化之无状态化与容器化</a></li><li>核心业务和非核心业务要拆分，方便核心业务的扩展以及非核心业务的降级，参考<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NzYzODk4OQ%3D%3D%26mid%3D2247484925%26idx%3D1%26sn%3D5c15ba98fb03a2a0d9c823136f34e162%26chksm%3Dea1512dfdd629bc9971b4ec7ccc6d2c844fee66a7b7fc1a25a7cf78467996d76b5ef33e56190%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">微服务化之服务拆分与服务发现</a></li><li>数据库要读写分离，要分库分表，才能在超大数据量的情况下，数据库具有横向扩展的能力，不成为瓶颈，参考<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NzYzODk4OQ%3D%3D%26mid%3D2247484821%26idx%3D1%26sn%3D1d73b718ddb6bcbdd28a7fa98d7dcda0%26chksm%3Dea1512b7dd629ba12412b22a213f281638b2e21161938fbb82c176a2b8a869753afa46a841f6%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">微服务化的数据库设计与读写分离</a></li><li>要层层缓存，只有少数的流量到达中军大营数据库，参考<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NzYzODk4OQ%3D%3D%26mid%3D2247484868%26idx%3D1%26sn%3D5e6a6960557e373b4e21afa05f9a49ab%26chksm%3Dea1512e6dd629bf0e53545da90b761965033ed1447db0a4d22d5c6a70b4c4364ef443c5aa3e7%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">微服务化之缓存的设计</a></li><li>要使用消息队列，将原来连续调用的多个服务异步化为监听消息队列，从而缩短核心逻辑</li><li>服务之间要设定熔断，限流，降级策略，一旦调用阻塞应该快速失败，而不应该卡在那里，处于亚健康状态的服务要被及时熔断，不产生连锁反应。非核心业务要进行降级，不再调用，将资源留给核心业务。要在压测到的容量范围内对调用限流，宁可慢慢处理，也不用一下子都放进来，把整个系统冲垮。</li><li>拆分成的服务太多了，没办法一个个配置，需要统一的一个配置中心，将配置下发</li><li>拆分成的服务太多了，没办法一个个看日志，需要统一的日志中心，将日志汇总</li><li>拆分成的服务太多了，很难定位性能瓶颈，需要通过APM全链路应用监控，发现性能瓶颈，及时修改</li><li>拆分成的服务太多了，不压测一下，谁也不知道到底能够抗住多大的量，因而需要全链路的压测系统。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-702fa4d4962bbc82e1e3669253082775_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"406\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-702fa4d4962bbc82e1e3669253082775_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;406&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"406\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-702fa4d4962bbc82e1e3669253082775_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-702fa4d4962bbc82e1e3669253082775_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>应用层需要处理这十二个问题，最后一个都不能少，实施微服务，你做好准备了吗？你真觉得攒一攒springcloud，就能够做好这些吗？</p><h2><b>4.2. 阶段三的运维模式</b></h2><p>业务的微服务化改造之后，对于运维的模式是有冲击的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fbab31b0bae285bd481f960937e67a60_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1077\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb\" width=\"1077\" data-original=\"https://pic1.zhimg.com/v2-fbab31b0bae285bd481f960937e67a60_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1077&#39; height=&#39;194&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1077\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1077\" data-original=\"https://pic1.zhimg.com/v2-fbab31b0bae285bd481f960937e67a60_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fbab31b0bae285bd481f960937e67a60_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果业务拆成了如此网状的细粒度，服务的数目就会非常的多，每个服务都会独立发布，独立上线，因而版本也非常多。</p><p>这样环境就会非常的多，手工部署已经不可能，必须实施自动部署。好在在上一个阶段，我们已经实施了自动部署，或者基于脚本的，或者基于镜像的，但是到了微服务阶段都有问题。</p><p>如果基于脚本的部署，脚本原来多由运维写，由于服务太多，变化也多，脚本肯定要不断的更新，而每家公司的开发人员都远远多于运维人员，运维根本来不及维护自动部署的脚本。那脚本能不能由开发写呢？一般是不可行的，开发对于运行环境了解有限，而且脚本没有一个标准，运维无法把控开发写的脚本的质量。</p><p>基于虚拟机镜像的就会好很多，因为需要脚本做的事情比较少，大部分对于应用的配置都打在镜像里面了。如果基于虚拟机镜像进行交付，也能起到标准交付的效果。而且一旦上线有问题，也可以基于虚拟机镜像的版本进行回滚。</p><p>但是虚拟机镜像实在是太大了，动不动几百个G，如果一共一百个服务，每个服务每天一个版本，一天就是10000G，这个存储容量，谁也受不了。</p><p>这个时候，容器就有作用了。镜像是容器的根本性发明，是封装和运行的标准，其他什么namespace，cgroup，早就有了。</p><p>原来开发交付给运维的，是一个war包，一系列配置文件，一个部署文档，但是由于部署文档更新不及时，常常出现运维部署出来出错的情况。有了容器镜像，开发交付给运维的，是一个容器镜像，容器内部的运行环境，应该体现在Dockerfile文件中，这个文件是应该开发写的。</p><p>这个时候，从流程角度，将环境配置这件事情，往前推了，推到了开发这里，要求开发完毕之后，就需要考虑环境部署的问题，而不能当甩手掌柜。由于容器镜像是标准的，就不存在脚本无法标准化的问题，一旦单个容器运行不起来，肯定是Dockerfile的问题。</p><p>而运维组只要维护容器平台就可以，单个容器内的环境，交给开发来维护。这样做的好处就是，虽然进程多，配置变化多，更新频繁，但是对于某个模块的开发团队来讲，这个量是很小的，因为5-10个人专门维护这个模块的配置和更新，不容易出错。自己改的东西自己知道。</p><p>如果这些工作量全交给少数的运维团队，不但信息传递会使得环境配置不一致，部署量会大非常多。</p><p>容器作用之一就是环境交付提前，让每个开发仅仅多做5%的工作，就能够节约运维200%的工作，并且不容易出错。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bfe42012bdcecafc6ebf56c1ba8a0761_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"649\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-bfe42012bdcecafc6ebf56c1ba8a0761_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;649&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"649\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-bfe42012bdcecafc6ebf56c1ba8a0761_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bfe42012bdcecafc6ebf56c1ba8a0761_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>容器的另外一个作用，就是不可改变基础设施。</p><p>容器镜像有个特点，就是ssh到里面做的任何修改，重启都不见了，恢复到镜像原来的样子，也就杜绝了原来我们部署环境，这改改，那修修最后部署成功的坏毛病。</p><p>因为如果机器数目比较少，还可以登录到每台机器上改改东西，一旦出了错误，比较好排查，但是微服务状态下，环境如此复杂，规模如此大，一旦有个节点，因为人为修改配置导致错误，非常难排查，所以应该贯彻不可改变基础设施，一旦部署了，就不要手动调整了，想调整从头走发布流程。</p><p>这里面还有一个概念叫做一切即代码，单个容器的运行环境Dockerfile是代码，容器之间的关系编排文件是代码，配置文件是代码，所有的都是代码，代码的好处就是谁改了什么，Git里面一清二楚，都可以track，有的配置错了，可以统一发现谁改的。</p><h2><b>4.3. 阶段三的组织形态</b></h2><p>到了微服务阶段，实施容器化之后，你会发现，然而本来原来运维该做的事情开发做了，开发的老大愿意么？开发的老大会投诉运维的老大么？</p><p>这就不是技术问题了，其实这就是DevOps，DevOps不是不区分开发和运维，而是公司从组织到流程，能够打通，看如何合作，边界如何划分，对系统的稳定性更有好处。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6ed5dbffc1da0e59b15148fe383da35f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"518\" data-rawheight=\"520\" class=\"origin_image zh-lightbox-thumb\" width=\"518\" data-original=\"https://pic4.zhimg.com/v2-6ed5dbffc1da0e59b15148fe383da35f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;518&#39; height=&#39;520&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"518\" data-rawheight=\"520\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"518\" data-original=\"https://pic4.zhimg.com/v2-6ed5dbffc1da0e59b15148fe383da35f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6ed5dbffc1da0e59b15148fe383da35f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>其实开发和运维变成了一个融合的过程，开发会帮运维做一些事情，例如环境交付的提前，Dockerfile的书写。</p><p>运维也可以帮助研发做一些事情，例如微服务之间的注册发现，治理，配置等，不可能公司的每一个业务都单独的一套框架，可以下沉到运维组来变成统一的基础设施，提供统一的管理。</p><p>实施容器，微服务，DevOps后，整个分工界面就变成了下面的样子。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9e3bdebd96790a4e1d1c61261e48fbb0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"512\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-9e3bdebd96790a4e1d1c61261e48fbb0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;512&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"512\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-9e3bdebd96790a4e1d1c61261e48fbb0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9e3bdebd96790a4e1d1c61261e48fbb0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在网易就是这个模式，杭州研究院作为公共技术服务部门，有运维部门管理机房，上面是云平台组，基于OpenStack开发了租户可自助操作的云平台。PaaS组件也是云平台的一部分，点击可得，提供SLA保障。容器平台也是云平台的一部分，并且基于容器提供持续集成，持续部署的工具链。</p><p>微服务的管理和治理也是云平台的一部分，业务部门可以使用这个平台进行微服务的开发。</p><p>业务部门的中间件组或者架构组合云平台组沟通密切，主要是如何以正确的姿势使用云平台组件。</p><p>业务部门分前端组，业务开发组，中台开发组。</p><h2><b>五、如何实施微服务，容器化，DevOps</b></h2><p>实施微服务，容器化，DevOps有很多的技术选型。</p><p>其中容器化的部分，Kubernetes当之无愧的选择。但是Kubernetes可不仅仅志在容器，他是为微服务而设计的。对于实施微服务各方面都有涉及。</p><p>详细分析参加<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NzYzODk4OQ%3D%3D%26mid%3D2247484871%26idx%3D1%26sn%3D4c40df039911e7ef7d355c1435271eb0%26chksm%3Dea1512e5dd629bf368bae145c6c42ad89f260c529d0eb006779768c6f124e0318b653d2d1821%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">为什么 kubernetes 天然适合微服务</a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-01e8618e001dba255720b10564725ee5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1059\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb\" width=\"1059\" data-original=\"https://pic2.zhimg.com/v2-01e8618e001dba255720b10564725ee5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1059&#39; height=&#39;411&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1059\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1059\" data-original=\"https://pic2.zhimg.com/v2-01e8618e001dba255720b10564725ee5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-01e8618e001dba255720b10564725ee5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是Kubernetes对于容器的运行时生命周期管理比较完善，但是对于服务治理方面还不够强大。</p><p>因而对于微服务的治理方面，多选择使用Dubbo或者SpringCloud。使用Dubbo的存量应用比较多，相对于Dubbo来讲，SpringCloud比较新，组件也比较丰富。但是SpringCloud的组件都不到开箱即用的程度，需要比较高的学习曲线。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3f5d7373985e39b99acbbac971cbdf90_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"714\" data-rawheight=\"516\" class=\"origin_image zh-lightbox-thumb\" width=\"714\" data-original=\"https://pic1.zhimg.com/v2-3f5d7373985e39b99acbbac971cbdf90_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;714&#39; height=&#39;516&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"714\" data-rawheight=\"516\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"714\" data-original=\"https://pic1.zhimg.com/v2-3f5d7373985e39b99acbbac971cbdf90_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3f5d7373985e39b99acbbac971cbdf90_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>因而基于Kubernetes和SpringCloud，就有了下面这个微服务，容器，DevOps的综合管理平台。包含基于Kubernetes的容器平台，持续集成平台，测试平台，API网关，微服务框架，APM应用性能管理。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-52877b8d85f3e1b0c261ec4775aa7042_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-52877b8d85f3e1b0c261ec4775aa7042_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;496&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-52877b8d85f3e1b0c261ec4775aa7042_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-52877b8d85f3e1b0c261ec4775aa7042_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>主要为了解决从阶段一到阶段二，或者阶段二到阶段三的改进中的痛点。</p><p>下面我们列举几个场景。</p><h2><b>场景一：架构SOA拆分时，如何保证回归测试功能集不变</b></h2><p>前面说过，服务拆分后，最怕的是拆完了引入一大堆的bug，通过理智肯定不能保证拆分后功能集是不变的，因而需要有回归测试集合保证，只要测试集合通过了，功能就没有太大的问题。</p><p>回归测试最好是基于接口的，因为基于UI的很危险，有的接口是有的，但是UI上不能点，这个接口如果有Bug，就被暂时隐藏掉了，当后面有了新的需求，当开发发现有个接口能够调用的时候，一调用就挂了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c6776bf7effb3519c3d35f8ae391be35_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-c6776bf7effb3519c3d35f8ae391be35_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;468&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-c6776bf7effb3519c3d35f8ae391be35_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c6776bf7effb3519c3d35f8ae391be35_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>有了基于Restful API的接口测试之后，可以组成场景测试，将多个API调用组合成为一个场景，例如下单，扣优惠券，减库存，就是一个组合场景。</p><p>另外可以形成测试集合，例如冒烟测试集合，当开发将功能交付给测试的时候，执行一下。再如日常测试集合，每天晚上跑一遍，看看当天提交的代码有没有引入新的bug。再如回归测试集合，上线之前跑一遍，保证大部分的功能是正确的。</p><h2><b>场景二：架构SOA化的时候，如何统一管理并提供中台服务</b></h2><p>当业务要提供中台服务的时候，中台服务首先希望能够注册到一个地方，当业务组开发业务逻辑的时候，能够在这个地方找到中台的接口如何调用的文档，当业务组的业务注册上来的时候，可以进行调用。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-341145a076b5ca585c97ab32abf0992d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"718\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"718\" data-original=\"https://pic2.zhimg.com/v2-341145a076b5ca585c97ab32abf0992d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;718&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"718\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"718\" data-original=\"https://pic2.zhimg.com/v2-341145a076b5ca585c97ab32abf0992d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-341145a076b5ca585c97ab32abf0992d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在微服务框架普通的注册发现功能之外，还提供知识库的功能，使得接口和文档统一维护，文档和运行时一致，从而调用方看着文档就可以进行调用。</p><p>另外提供注册，发现，调用期间的鉴权功能，不是谁看到中台服务都能调用，需要中台管理员授权才可以。</p><p>为了防止中台服务被恶意调用，提供账户审计功能，记录操作。</p><h2><b>场景三：服务SOA化的时候，如何保证关键服务的调用安全</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8a5ce635134389ebd586be09be5265c5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-8a5ce635134389ebd586be09be5265c5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;321&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-8a5ce635134389ebd586be09be5265c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8a5ce635134389ebd586be09be5265c5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>有的服务非常关键，例如支付服务，和资金相关，不是谁想调用就能调用的，一旦被非法调用了，后果严重。</p><p>在服务治理里面有路由功能，除了能够配置灵活的路由功能之外，还可以配置黑白名单，可以基于IP地址，也可以基于服务名称，配置只有哪些应用可以调用，可以配合云平台的VPC功能，限制调用方。</p><h2><b>场景四：架构SOA化后，对外提供API服务，构建开放平台</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-78dea79d9736b76eb03ae90cc61c29f3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"893\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb\" width=\"893\" data-original=\"https://pic4.zhimg.com/v2-78dea79d9736b76eb03ae90cc61c29f3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;893&#39; height=&#39;330&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"893\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"893\" data-original=\"https://pic4.zhimg.com/v2-78dea79d9736b76eb03ae90cc61c29f3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-78dea79d9736b76eb03ae90cc61c29f3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>架构SOA化之后，除了对内提供中台服务，很多能力也可以开放给外部的合作伙伴，形成开放平台。例如你是一家物流企业，除了在你的页面上下单寄快递之外，其他的电商也可以调用你的API来寄快递，这就需要有一个API网关来管理API，对接你的电商只要登录到这个API网关，就能看到API以及如何调用，API网关上面的文档管理就是这个作用。</p><p>另外API网关提供接口的统一认证鉴权，也提供API接口的定时开关功能，灵活控制API的生命周期。</p><h2><b>场景五：互联网场景下的灰度发布和A/B测试</b></h2><p>接下来我们切换到互联网业务场景，经常会做A/B测试，这就需要API网关的流量分发功能。</p><p>例如我们做互联网业务，当上一个新功能的 时候，不清楚客户是否喜欢，于是可以先开放给山东的客户，当HTTP头里面有来自山东的字段，则访问B系统，其他客户还是访问A系统，这个时候可以看山东的客户是否都喜欢，如果都喜欢，就推向全国，如果不喜欢，就撤下来。</p><h2><b>场景六：互联网场景下的预发测试</b></h2><p>这个也是互联网场景下经常遇到的预发测试，虽然我们在测试环境里面测试了很多轮，但是由于线上场景更加复杂，有时候需要使用线上真实数据进行测试，这个时候可以在线上的正式环境旁边部署一套预发环境，使用API网关将真实的请求流量，镜像一部分到预发环境，如果预发环境能够正确处理真实流量，再上线就放心多了。</p><h2><b>场景七：互联网场景下的性能压测</b></h2><p>互联网场景下要做线上真实的性能压测，才能知道整个系统真正的瓶颈点。但是性能压测的数据不能进真实的数据库，因而需要进入影子库，性能压测的流量，也需要有特殊的标记放在HTTP头里面，让经过的业务系统知道这是压测数据，不进入真实的数据库。</p><p>这个特殊的标记要在API网关上添加，但是由于不同的压测系统要求不一样，因而需要API网关有定制路由插件功能，可以随意添加自己的字段到HTTP头里面，和压测系统配合。</p><h2><b>场景八：微服务场景下的熔断，限流，降级</b></h2><p>微服务场景下，大促的时候，需要进行熔断，限流，降级。这个在API网关上可以做，将超过压测值的流量，通过限流，拦在系统外面，从而保证尽量的流量，能够下单成功。</p><p>在服务之间，也可以通过微服务框架，进行熔断，限流，降级。Dubbo对于服务的控制在接口层面，SpringCloud对于服务的管理在实例层面，这两个粒度不同的客户选择不一样，都用Dubbo粒度太细，都用SpringCloud粒度太粗，所以需要可以灵活配置。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bda5825165dcdee82381d0cc907a0cab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1078\" data-rawheight=\"433\" class=\"origin_image zh-lightbox-thumb\" width=\"1078\" data-original=\"https://pic4.zhimg.com/v2-bda5825165dcdee82381d0cc907a0cab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1078&#39; height=&#39;433&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1078\" data-rawheight=\"433\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1078\" data-original=\"https://pic4.zhimg.com/v2-bda5825165dcdee82381d0cc907a0cab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bda5825165dcdee82381d0cc907a0cab_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>场景九：微服务场景下的精细化流量管理。</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e7773a2475273f4ec1f70f694b82e489_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1061\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb\" width=\"1061\" data-original=\"https://pic2.zhimg.com/v2-e7773a2475273f4ec1f70f694b82e489_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1061&#39; height=&#39;388&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1061\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1061\" data-original=\"https://pic2.zhimg.com/v2-e7773a2475273f4ec1f70f694b82e489_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e7773a2475273f4ec1f70f694b82e489_b.jpg\"/></figure><p>欢迎工作一到五年的Java工程师朋友们加入Java程序员开发： 854393687</p><p>群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用&#34;没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！</p><p></p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55777290", 
            "userName": "一颗白菜菜", 
            "userLink": "https://www.zhihu.com/people/20603d6675443732bfe26faafdb0caab", 
            "upvote": 149, 
            "title": "面试被问烂的 Spring IOC(求求你别再问了)", 
            "content": "<h2><b>广义的 IOC</b></h2><ol><li>IoC(Inversion of Control) 控制反转，即“不用打电话过来，我们会打给你”。</li></ol><p>两种实现： 依赖查找（DL）和依赖注入（DI）。</p><p>IOC 和 DI 、DL 的关系（这个 DL，Avalon 和 EJB 就是使用的这种方式实现的 IoC）：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b26567fd166d55063f9ce18d5ec44c57_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"715\" data-rawheight=\"308\" class=\"origin_image zh-lightbox-thumb\" width=\"715\" data-original=\"https://pic4.zhimg.com/v2-b26567fd166d55063f9ce18d5ec44c57_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;715&#39; height=&#39;308&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"715\" data-rawheight=\"308\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"715\" data-original=\"https://pic4.zhimg.com/v2-b26567fd166d55063f9ce18d5ec44c57_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b26567fd166d55063f9ce18d5ec44c57_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>DL 已经被抛弃，因为他需要用户自己去是使用 API 进行查找资源和组装对象。即有侵入性。</li><li>DI 是 Spring 使用的方式，容器负责组件的装配。</li></ol><blockquote>注意：Java 使用 DI 方式实现 IoC 的不止 Spring，包括 Google 的 Guice，还有一个冷门的 PicoContainer（极度轻量，但只提供 IoC）。</blockquote><h2><b>Spring 的 IoC</b></h2><p>Spring 的 IoC 设计支持以下功能：</p><ol><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li></ol><p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><h2><b>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</b></h2><p>那么， Spring 如何设计容器的呢？</p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p><ol><li>BeanFactory</li><li>ApplicationContext</li></ol><p>BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。</p><blockquote>例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。</blockquote><p>该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，但我今天不会花太多篇幅介绍他们。</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类，来展示整个容器的层级 UML 关系。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d7a3c85c21231c733e586c302416f405_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"649\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-d7a3c85c21231c733e586c302416f405_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;649&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"649\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-d7a3c85c21231c733e586c302416f405_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d7a3c85c21231c733e586c302416f405_b.jpg\"/></figure><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的 BeanFactory 知道吧？我就不讲了。</p><p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><blockquote>好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。（由于我这是 interface21 的代码，肯定和你的 Spring 4.x 系列不同）。</blockquote><p>下图是 ClassPathXmlApplicationContext 的构造过程，实际就是 Spring IoC 的初始化过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3492d97f4467c8aaa3a9d41eeffe2d28_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"618\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-3492d97f4467c8aaa3a9d41eeffe2d28_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;618&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"618\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-3492d97f4467c8aaa3a9d41eeffe2d28_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3492d97f4467c8aaa3a9d41eeffe2d28_b.jpg\"/></figure><p>注意，这里为了理解方便，有所简化。</p><p>这里再用文字来描述这个过程：</p><ol><li>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</li><li>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和 Properties 到容器中。</li><li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向 ：）。</li></ol><p>简单说就是：</p><ol><li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li><li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li></ol><h2><b>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</b></h2><p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-835833f71e99b35e1f3963548aa7dc34_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"530\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb\" width=\"530\" data-original=\"https://pic1.zhimg.com/v2-835833f71e99b35e1f3963548aa7dc34_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;530&#39; height=&#39;495&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"530\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"530\" data-original=\"https://pic1.zhimg.com/v2-835833f71e99b35e1f3963548aa7dc34_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-835833f71e99b35e1f3963548aa7dc34_b.jpg\"/></figure><p>从图中可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p><blockquote>假设：当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。</blockquote><p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p><p>所以，Spring 将其分为了 2 个步骤：</p><ol><li>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</li><li>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。<br/>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。</li></ol><p>这就是 IoC。</p><p>所以 ApplicationContext refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p><h2><b>总结</b></h2><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li><li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li></ol><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><p>可以预见，随着 Spring 的不断发展，高级容器的功能会越来越多。</p><blockquote>诚然，了解 IoC 的过程，实际上为了了解 Spring 初始化时，各个接口的回调时机。例如 InitializingBean，BeanFactoryAware，ApplicationListener 等等接口，这些接口的作用，笔者之前写过一篇文章进行介绍，有兴趣可以看一下，关键字：Spring 必知必会 扩展接口。</blockquote><p>但是请注意，实现 Spring 接口代表着你这个应用就绑定死 Spring 了！代表 Spring 具有侵入性！要知道，Spring 发布时，无侵入性就是他最大的宣传点之一 —— 即 IoC 容器可以随便更换，代码无需变动。而现如今，Spring 已然成为 J2EE 社区准官方解决方案，也没有了所谓的侵入性这个说法。因为他就是标准，和 Servlet 一样，你能不实现 Servlet 的接口吗？: -)</p><p>好了，下次如果再有面试官问 Spring IoC 初始化过程，就再也不会含糊其词、支支吾吾了！！！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>欢迎工作一到五年的Java工程师朋友们加入Java程序员开发： 854393687</p><p>群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用&#34;没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！</p><p></p>", 
            "topic": [
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }
            ], 
            "comments": [
                {
                    "userName": "点燃你的腿毛", 
                    "userLink": "https://www.zhihu.com/people/d8a02293706d1f109400072fc4c33544", 
                    "content": "工作两年时看Spring的源码已经没有难度，当时看Spring data的Repository的实现知道了动态代理，看Spring mvc的源码扩展了返回xml格式报文的方式。但是对于一些概念比如Ioc这些，我不太看重深入了解，面试时被问起就不一定答得上。", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "吃吃吃", 
                    "userLink": "https://www.zhihu.com/people/c9a906e294ba9be3bc74adfa5bd0f634", 
                    "content": "<p>说句不好听的 你说的这些都是没用的玩意  IOC这个东西就是伪概念  它并不是什么新的玩意  这玩意的本质就是一个非图灵完备的解释语言   其他一切都是瞎几把扯</p>", 
                    "likes": 6, 
                    "childComments": []
                }, 
                {
                    "userName": "值得推敲的人生", 
                    "userLink": "https://www.zhihu.com/people/696f1bb40827ba97f65f95d406ffb0c3", 
                    "content": "讲解非常不错[赞同]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "满目荒唐", 
                    "userLink": "https://www.zhihu.com/people/d8d1787c702cc795672ac04272ef46fc", 
                    "content": "鞭辟入里，发人深省", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "心DE觉悟", 
                    "userLink": "https://www.zhihu.com/people/b602c0e467534e0f87c423501c71e135", 
                    "content": "面试问的太多愚蠢的问题，比如单例模式/IOC，很少看到问使用场景和原因，要你解释一些有的没的。恕我直言，代码就那几句，搞出一大堆的名词堆起来，解释起来特费劲，使用过程无非就是几句代码而已。这堆名字仅仅是方便沟通的道具，却变成了考核用的东西", 
                    "likes": 7, 
                    "childComments": [
                        {
                            "userName": "Buu.G", 
                            "userLink": "https://www.zhihu.com/people/9cafd793e4a509512e930d1ad8d651a3", 
                            "content": "<p>其实就像高考中的数学，无用但是还考</p>", 
                            "likes": 0, 
                            "replyToAuthor": "心DE觉悟"
                        }, 
                        {
                            "userName": "不知道起什么名字好呀", 
                            "userLink": "https://www.zhihu.com/people/702eb95a51afbed491c4df6d98b23402", 
                            "content": "数学没用。。哈哈哈哈。IT只是数学的一小个分支，属于对数学的应用。", 
                            "likes": 1, 
                            "replyToAuthor": "Buu.G"
                        }
                    ]
                }, 
                {
                    "userName": "几万天的旅行", 
                    "userLink": "https://www.zhihu.com/people/3691411a2a231148322e7f2fb22caa9d", 
                    "content": "hk2也支持依赖注入", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "一米阳光", 
                    "userLink": "https://www.zhihu.com/people/469ccb184b75f7c942bd65d92d68e71d", 
                    "content": "真扯淡，这都是皮毛，spring ioc源码能看到你吐血！！！很多大牛，包括spring深度源码解析那本书，很多地方都没讲通，就这点东西你认为你就懂了？差的太远了", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56145125", 
            "userName": "一颗白菜菜", 
            "userLink": "https://www.zhihu.com/people/20603d6675443732bfe26faafdb0caab", 
            "upvote": 12, 
            "title": "Java中15种锁的介绍", 
            "content": "<p>在读很多并发文章中，会提及各种各样锁如公平锁，乐观锁等等，这篇文章介绍各种锁的分类。介绍的内容如下：</p><p>1.公平锁 / 非公平锁</p><p>2.可重入锁 / 不可重入锁</p><p>3.独享锁 / 共享锁</p><p>4.互斥锁 / 读写锁</p><p>5.乐观锁 / 悲观锁</p><p>6.分段锁</p><p>7.偏向锁 / 轻量级锁 / 重量级锁</p><p>8.自旋锁</p><p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><h2><b>公平锁 / 非公平锁</b></h2><p><b>公平锁</b></p><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p><p><b>非公平锁</b></p><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p><p>对于<code>Java ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br/>对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过<code>AQS</code>的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2><b>可重入锁 / 不可重入锁</b></h2><p><b>可重入锁</b></p><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁</p><div class=\"highlight\"><pre><code class=\"language-text\">synchronized void setA() throws Exception{\n   Thread.sleep(1000);\n   setB();\n}\nsynchronized void setB() throws Exception{\n   Thread.sleep(1000);\n}</code></pre></div><p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</p><p><b>不可重入锁</b></p><p>不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。看到一个经典的讲解，使用自旋锁来模拟一个不可重入锁，代码如下</p><div class=\"highlight\"><pre><code class=\"language-text\">import java.util.concurrent.atomic.AtomicReference;\n\npublic class UnreentrantLock {\n\n   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();\n\n   public void lock() {\n       Thread current = Thread.currentThread();\n       //这句是很经典的“自旋”语法，AtomicInteger中也有\n       for (;;) {\n           if (!owner.compareAndSet(null, current)) {\n               return;\n           }\n       }\n   }\n\n   public void unlock() {\n       Thread current = Thread.currentThread();\n       owner.compareAndSet(current, null);\n   }\n}</code></pre></div><p>代码也比较简单，使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁，这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。</p><p><b>把它变成一个可重入锁</b>：</p><div class=\"highlight\"><pre><code class=\"language-text\">import java.util.concurrent.atomic.AtomicReference;\n\npublic class UnreentrantLock {\n\n   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();\n   private int state = 0;\n\n   public void lock() {\n       Thread current = Thread.currentThread();\n       if (current == owner.get()) {\n           state++;\n           return;\n       }\n       //这句是很经典的“自旋”式语法，AtomicInteger中也有\n       for (;;) {\n           if (!owner.compareAndSet(null, current)) {\n               return;\n           }\n       }\n   }\n\n   public void unlock() {\n       Thread current = Thread.currentThread();\n       if (current == owner.get()) {\n           if (state != 0) {\n               state--;\n           } else {\n               owner.compareAndSet(current, null);\n           }\n       }\n   }\n}</code></pre></div><p>在执行每次操作之前，判断当前锁持有者是否是当前对象，采用state计数，不用每次去释放锁。</p><p><b>ReentrantLock中可重入锁实现</b></p><p>这里看非公平锁的锁获取方法：</p><div class=\"highlight\"><pre><code class=\"language-text\">final boolean nonfairTryAcquire(int acquires) {\n   final Thread current = Thread.currentThread();\n   int c = getState();\n   if (c == 0) {\n       if (compareAndSetState(0, acquires)) {\n           setExclusiveOwnerThread(current);\n           return true;\n       }\n   }\n   //就是这里\n   else if (current == getExclusiveOwnerThread()) {\n       int nextc = c + acquires;\n       if (nextc &lt; 0) // overflow\n           throw new Error(&#34;Maximum lock count exceeded&#34;);\n       setState(nextc);\n       return true;\n   }\n   return false;\n}</code></pre></div><p>在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p><h2><b>独享锁 / 共享锁</b></h2><p>独享锁和共享锁在你去读C.U.T包下的ReeReentrantLock和ReentrantReadWriteLock你就会发现，它俩一个是独享一个是共享锁。</p><p><b>独享锁</b>：该锁每一次只能被一个线程所持有。</p><p><b>共享锁</b>：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。</p><p>另外读锁的共享可保证并发读是非常高效的，但是读写和写写，写读都是互斥的。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br/>对于Synchronized而言，当然是独享锁。</p><h2><b>互斥锁 / 读写锁</b></h2><p><b>互斥锁</b></p><p>在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。</p><p>如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源</p><p><b>读写锁</b></p><p>读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。</p><p><b>读写锁有三种状态</b>：读加锁状态、写加锁状态和不加锁状态</p><p><b>读写锁在Java中的具体实现就是</b><code>ReadWriteLock</code></p><p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。<br/>只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，直到所有线程的读状态锁被释放；为了避免想要尝试写操作的线程一直得不到写状态锁，当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。所以读写锁非常适合资源的读操作远多于写操作的情况。</p><h2><b>乐观锁 / 悲观锁</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p><b>悲观锁</b></p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<b>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</b>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<code>Java</code>中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p><b>乐观锁</b></p><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐<b>观锁适用于多读的应用类型，这样可以提高吞吐量</b>，像数据库提供的类似于<code>write_condition</code>机制，其实都是提供的乐观锁。在<code>Java</code>中<code>java.util.concurrent.atomic</code>包下面的<b>原子变量类就是使用了乐观锁的一种实现方式CAS实现的</b>。</p><h2><b>分段锁</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>并发容器类的加锁机制是基于粒度更小的分段锁，分段锁也是提升多并发程序性能的重要手段之一。</p><p>在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将通水导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。</p><p><b>我们一般有三种方式降低锁的竞争程度</b>： <br/>1、减少锁的持有时间 <br/>2、降低锁的请求频率 <br/>3、使用带有协调机制的独占锁，这些机制允许更高的并发性。</p><p>在某些情况下我们可以将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这成为分段锁。</p><p><b>其实说的简单一点就是</b>：</p><p>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是<code>ConcurrentHashMap</code>所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>比如：在ConcurrentHashMap中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护。假设使用合理的散列算法使关键字能够均匀的分部，那么这大约能使对锁的请求减少到越来的1/16。也正是这项技术使得ConcurrentHashMap支持多达16个并发的写入线程。</p><h2><b>偏向锁 / 轻量级锁 / 重量级锁</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p><b>锁的状态</b>：</p><p>1.无锁状态</p><p>2.偏向锁状态</p><p>3.轻量级锁状态</p><p>4.重量级锁状态</p><p>锁的状态是通过对象监视器在对象头中的字段来表明的。<br/>四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。<br/><b>这四种状态都不是Java语言中的锁</b>，而是Jvm为了提高锁的获取与释放效率而做的优化(<b>使用synchronized时</b>)。</p><p><b>偏向锁</b></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p><p><b>轻量级</b></p><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><p><b>重量级锁</b></p><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h2><br/></h2><h2><b>自旋锁</b></h2><p>我们知道CAS算法是乐观锁的一种实现方式，CAS算法中又涉及到自旋锁，所以这里给大家讲一下什么是自旋锁。</p><h2><b>简单回顾一下CAS算法</b></h2><p><code>CAS</code>是英文单词<code>Compare and Swap</code>（比较并交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（<code>Non-blocking Synchronization</code>）。CAS算法涉及到三个操作数</p><p>1.需要读写的内存值 V</p><p>2.进行比较的值 A</p><p>3.拟写入的新值 B</p><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。</p><h2><b>什么是自旋锁？</b></h2><p><b>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环</b>。</p><p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。<b>无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁</b>。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p><h2><b>Java如何实现自旋锁？</b></h2><p>下面是个简单的例子：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class SpinLock {\n   private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;();\n   public void lock() {\n       Thread current = Thread.currentThread();\n       // 利用CAS\n       while (!cas.compareAndSet(null, current)) {\n           // DO nothing\n       }\n   }\n   public void unlock() {\n       Thread current = Thread.currentThread();\n       cas.compareAndSet(current, null);\n   }\n}</code></pre></div><p>lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p><h2><b>自旋锁存在的问题</b></h2><p>1、如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。<br/>2、上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</p><h2><b>自旋锁的优点</b></h2><p>1、自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快<br/>2、非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p><h2><b>可重入的自旋锁和不可重入的自旋锁</b></h2><p>文章开始的时候的那段代码，仔细分析一下就可以看出，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。</p><p>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。</p><p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class ReentrantSpinLock {\n   private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;();\n   private int count;\n   public void lock() {\n       Thread current = Thread.currentThread();\n       if (current == cas.get()) { // 如果当前线程已经获取到了锁，线程数增加一，然后返回\n           count++;\n           return;\n       }\n       // 如果没获取到锁，则通过CAS自旋\n       while (!cas.compareAndSet(null, current)) {\n           // DO nothing\n       }\n   }\n   public void unlock() {\n       Thread cur = Thread.currentThread();\n       if (cur == cas.get()) {\n           if (count &gt; 0) {// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟\n               count--;\n           } else {// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。\n               cas.compareAndSet(cur, null);\n           }\n       }\n   }\n}</code></pre></div><h2><b>自旋锁与互斥锁</b></h2><p>1.自旋锁与互斥锁都是为了实现保护资源共享的机制。</p><p>2.无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</p><p>3获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</p><h2><b>自旋锁总结</b></h2><p>1.自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。</p><p>2.自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。</p><p>3.自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。</p><p>4.自旋锁本身无法保证公平性，同时也无法保证可重入性。</p><p>5.基于自旋锁，可以实现具备公平性和可重入性质的锁。</p><p>欢迎工作一到五年的Java工程师朋友们加入Java程序员开发： 854393687</p><p>群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用&#34;没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！</p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55202352", 
            "userName": "miss Lee", 
            "userLink": "https://www.zhihu.com/people/1b6166cf40693f6b0177b11767f0cb27", 
            "upvote": 1, 
            "title": "微信上怎么用企业邮箱？", 
            "content": "<p>  随着微信越来越多的应用到我们的生活中，之前很多需要下载APP才能做的事，现在直接用微信就能完成，比如打车、购物。今天小编教大家怎么把企业邮箱绑到微信上使用，直接在微信里收发邮件有很多的便利，不用单独再下载一个APP，有网就能用，也符合大家经常使用微信的习惯。下面以小编工作用的TOM企业邮箱为例</p><p>第一步，微信搜索公众号“随心邮”并关注</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a473e5258b6fb417391a78b5fdc77b5b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"391\" data-rawheight=\"670\" class=\"content_image\" width=\"391\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;391&#39; height=&#39;670&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"391\" data-rawheight=\"670\" class=\"content_image lazy\" width=\"391\" data-actualsrc=\"https://pic4.zhimg.com/v2-a473e5258b6fb417391a78b5fdc77b5b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>第二步，点击推送消息，或者下方任意按钮，可以进入登录页面</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-bd9d90a4dc90781ce17afbcc3ff59598_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"392\" data-rawheight=\"685\" class=\"content_image\" width=\"392\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;392&#39; height=&#39;685&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"392\" data-rawheight=\"685\" class=\"content_image lazy\" width=\"392\" data-actualsrc=\"https://pic1.zhimg.com/v2-bd9d90a4dc90781ce17afbcc3ff59598_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>第三步，输入你的账号密码点绑定</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8e53ca27846f41398a8e1365905dac73_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"659\" class=\"content_image\" width=\"380\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;380&#39; height=&#39;659&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"659\" class=\"content_image lazy\" width=\"380\" data-actualsrc=\"https://pic4.zhimg.com/v2-8e53ca27846f41398a8e1365905dac73_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>你的邮箱与微信绑定成功后，就可以在微信上收发邮件了，收到邮件，随心邮会有个提醒弹出来，提醒显示发件人、主题、部分邮件内容</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-aa00e8ab78b705d34033b331b993c908_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"396\" data-rawheight=\"682\" class=\"content_image\" width=\"396\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;396&#39; height=&#39;682&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"396\" data-rawheight=\"682\" class=\"content_image lazy\" width=\"396\" data-actualsrc=\"https://pic1.zhimg.com/v2-aa00e8ab78b705d34033b331b993c908_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>点击这个提醒后，可以打开这封邮件，查看具体邮件内容，点击右下角的按钮，可以转发、回复、收藏、分享邮件</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d14c3049026f93fad436ed20a9a5d8c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"390\" data-rawheight=\"671\" class=\"content_image\" width=\"390\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;390&#39; height=&#39;671&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"390\" data-rawheight=\"671\" class=\"content_image lazy\" width=\"390\" data-actualsrc=\"https://pic1.zhimg.com/v2-d14c3049026f93fad436ed20a9a5d8c8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e1f636e8ecf7f17346d483e24cd90de1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"669\" class=\"content_image\" width=\"398\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;398&#39; height=&#39;669&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"669\" class=\"content_image lazy\" width=\"398\" data-actualsrc=\"https://pic2.zhimg.com/v2-e1f636e8ecf7f17346d483e24cd90de1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在微信里收发邮件的功能让企业邮箱用户随时可以处理工作邮件，不需要手机中下载新APP，门槛低又方便，赶快用起来吧~</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c9a7f39bcf076b7a6abda059c6a929bc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"362\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-c9a7f39bcf076b7a6abda059c6a929bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;362&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"362\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-c9a7f39bcf076b7a6abda059c6a929bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c9a7f39bcf076b7a6abda059c6a929bc_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "邮箱", 
                    "tagLink": "https://api.zhihu.com/topics/19563612"
                }, 
                {
                    "tag": "企业邮箱", 
                    "tagLink": "https://api.zhihu.com/topics/19570076"
                }, 
                {
                    "tag": "微信", 
                    "tagLink": "https://api.zhihu.com/topics/19554470"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54953927", 
            "userName": "面向Google编程", 
            "userLink": "https://www.zhihu.com/people/19f166c4e6e2ce95a0adee9e3e7dd66c", 
            "upvote": 12, 
            "title": "走近源码：Redis如何执行命令", 
            "content": "<p><a href=\"https://link.zhihu.com/?target=https%3A//jackeyzhe.github.io/2019/01/04/%25E8%25B5%25B0%25E8%25BF%2591%25E6%25BA%2590%25E7%25A0%2581%25EF%25BC%259ARedis%25E7%259A%2584%25E5%2590%25AF%25E5%258A%25A8%25E8%25BF%2587%25E7%25A8%258B/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">前文</a>我们了解了Redis的启动过程。在initServer()函数中创建了一些循环事件来监听TCP端口和Unix的Sockets，从而使Redis服务器可以接收新的连接。今天我们再一起来看一下Redis究竟是如何处理命令并返回结果的。</p><h2>处理新连接</h2><p>Redis在initServer()函数中创建循环事件调用了acceptTcpHandler和acceptUnixHandler函数（都在networking.c文件中）来处理接收到的TCP连接和Unix的Sockets连接。这两个函数又调用了acceptCommonHandler()函数，在这个函数中调用了createClient()函数创建一个新的client对象，用来表示一个新的客户端连接。</p><p>createClient()函数具体做了哪些事情呢？</p><p>首先为变量c分配了内存，接着将Socket连接置为非阻塞状态，并且设置了TCP无延迟。然后创建了File循环事件（aeCreateFileEvent）来调用readQueryFromClient函数。新建的客户端默认连接的是服务器的第一个数据库（编码为0），最后需要设置好客户端的各种属性和状态。</p><h2>读一个客户端的命令</h2><p>刚刚我们提到了readQueryFromClient函数，从名称上就能看出来这个函数是用来从客户端读取命令的。下面来看看函数的具体实现。</p><p>Redis会先将命令读入缓冲区，一次最多读取的大小是PROTO_IOBUF_LEN（1024*16）bit。然后调用processInputBufferAndReplicate()函数，来处理缓冲区中的数据，如果客户端是master（主从同步过程），那么Redis会计算处理前后缓冲区的不同部分，以确定从节点接收了多少数据。processInputBufferAndReplicate()函数会处理客户端向服务器发送命令和主节点向从节点发送命令这两种情况，不过最后都需要调用processInputBuffer()函数。</p><p>processInputBuffer()函数会先判断客户端是否正常，如果出现连接中断或者客户端阻塞等情况，就会立即停止处理命令，不做无用功。然后根据读取的请求生成相应的Redis可以执行的命令（包括参数）。不同的请求类型分别调用processInlineBuffer()和processMultibulkBuffer()函数。生成好命令之后，交给processCommand()（server.c文件中）函数执行，如果返回C_OK则重置客户端，等待下一个命令。如果返回的是C_ERR，则客户端会被销毁（比如执行QUIT命令）。</p><p>processCommand()函数会从Redis启动时加载的命令表中查找命令，然后检查命令的执行权限。</p><p>如果是cluster，这时会判断key是否属于当前的master，不属于需要返回重定向信息。</p><p>如果内存不够用，这里也需要判断一下是否有可以释放的内存，如果没有，就不能执行命令，返回错误信息。</p><p>接下来会判断一些不能接收写命令的情况：</p><ul><li>服务器不能进行持久化</li><li>作为master，没有足够的可用的slave</li><li>此服务器为只读的slave，只有它的master可以接收写命令</li></ul><p>在订阅模式中，只能接收指定的命令：(P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT。</p><p>当slave和master失联时，只能接收有flag &#34;t&#34;的命令，例如，INFO，SLAVEOF等。</p><p>如果命令没有CMD_LOADING标志，并且当前服务器正在加载数据，则不能接收此命令。</p><p>对lua脚本的长度进行限制。</p><p>进行完上面的各种条件判断之后，才可以真正开始调用call()函数执行命令。</p><h2>执行命令并返回</h2><p>call()函数的参数是client类型的，取出cmd成员进行执行。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cm\">/* Call the command. */</span>\n<span class=\"n\">dirty</span> <span class=\"o\">=</span> <span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">dirty</span><span class=\"p\">;</span>\n<span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">ustime</span><span class=\"p\">();</span>\n<span class=\"n\">c</span><span class=\"o\">-&gt;</span><span class=\"n\">cmd</span><span class=\"o\">-&gt;</span><span class=\"n\">proc</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">);</span>\n<span class=\"n\">duration</span> <span class=\"o\">=</span> <span class=\"n\">ustime</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"n\">start</span><span class=\"p\">;</span>\n<span class=\"n\">dirty</span> <span class=\"o\">=</span> <span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">dirty</span><span class=\"o\">-</span><span class=\"n\">dirty</span><span class=\"p\">;</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">dirty</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">dirty</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span></code></pre></div><p>如果是写命令，就会使服务器变“脏”，也就是服务器需要标记一下内存中的某些页有了改变。这对于Redis的持久化来说非常重要，它可以知道这个命令影响了多少个key。命令执行完之后并没有结束，call函数还会做一些其他操作。例如记录日志，写AOF文件，向从节点同步命令等。</p><p>至于返回值，每个命令有各自的处理方法，我们后面在介绍。</p><p>到这里，Redis处理命令的过程也就完成了。</p><p>后面我们会再通过具体的命令来对这个过程做一个更清晰的介绍。</p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "源码阅读", 
                    "tagLink": "https://api.zhihu.com/topics/19593602"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54659432", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 1, 
            "title": "邮件提醒系统：新邮件识别", 
            "content": "<p>最近在做邮件提醒抄送企业微信消息系统，就目前而言，无论是pop3还是imap都没有一个好的方法只接收新邮件，基本只能依靠收件箱列表message自行判断，下面给出几种思路并作对比。</p><div class=\"highlight\"><pre><code class=\"language-text\">//收件箱\nfolder = store.getFolder(&#34;INBOX&#34;);\n//权限\nfolder.open(Folder.READ_ONLY);</code></pre></div><h2><b>1 缓存（redis）计数方案</b></h2><p>这是最为直观的一种方式，基本思想是，在redis中对处理过新邮件的数目作原子加标记cacheTotal，定时扫描收件箱中所有邮件数目total, total与cacheTotal的差值即为新邮件数目，当然也很容易获取到新邮件的数组下标。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-22d82ea6c8f408c8f18a9c2236dc6332_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"181\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-22d82ea6c8f408c8f18a9c2236dc6332_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;181&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"181\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-22d82ea6c8f408c8f18a9c2236dc6332_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-22d82ea6c8f408c8f18a9c2236dc6332_b.jpg\"/></figure><ul><li><b>优点：</b>直观，简单</li><li><b>缺点：</b>粗暴，可能因为邮件归档，redis异常等原因，造成误读，风险较大</li></ul><h2><b>2 采用flag判断是否是新邮件</b></h2><p>flag是邮件对象message的一种标识，需要设置：</p><ul><li> 需要使用imap协议，Store store = session.getStore(&#34;imap&#34;); </li><li> 设置folder需要读写权限， folder.open(Folder.READ_WRITE); </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-318659f18e58b41e4f39b68067f0e017_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"136\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-318659f18e58b41e4f39b68067f0e017_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;136&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"136\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic4.zhimg.com/v2-318659f18e58b41e4f39b68067f0e017_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-318659f18e58b41e4f39b68067f0e017_b.jpg\"/></figure><p>但获取flag注意一点：在第一行，如果你调用了getMessages(),在第二次运行程序时就不会出现新邮件！因为调用了getMessages()，它就把新邮件读成了旧邮件。 运行结果：第一次运行，输出的flag：javax.mail.Flags@10，再次运行就全是0了。</p><ul><li><b>优点：</b>flag在能获取有效值的情况下，可精确判定是新邮件唯一标识</li><li><b>缺点：</b>（1）限定是imap协议，pop3不可行（2）flag不能稳定获取，对于需要分批次拉取新邮件的需求不能满足</li></ul><h2><b>3 采用【邮箱名+UID】方式接收新邮件</b></h2><p>UID是账户的每一封邮件的标识，不同于MessageID，MessageID是发送邮件的时候生成的唯一ID，也有可能发送没有你的接收邮箱自己生成，或者是javamail生成的，取messageid需要下载邮件的头造成效率缓慢，所以只需要存储uid；以POP3为例：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7445a8276d8d8ce3e3042a443f1457e9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"313\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-7445a8276d8d8ce3e3042a443f1457e9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;313&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"313\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-7445a8276d8d8ce3e3042a443f1457e9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7445a8276d8d8ce3e3042a443f1457e9_b.jpg\"/></figure><p>UID唯一性的前提是在同一个账户里，也就是说在不同账户下UID还是可能又相同的，这在数据库持久化时得注意，故采用【邮箱名+UID】得方式存储。还有就是session如果不带有用户和服务器信息， 就这样生成一个公用的就可以了 ：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8a3cc642156c7b588e9f18a51fa8d0ab_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"537\" data-rawheight=\"39\" class=\"origin_image zh-lightbox-thumb\" width=\"537\" data-original=\"https://pic4.zhimg.com/v2-8a3cc642156c7b588e9f18a51fa8d0ab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;537&#39; height=&#39;39&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"537\" data-rawheight=\"39\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"537\" data-original=\"https://pic4.zhimg.com/v2-8a3cc642156c7b588e9f18a51fa8d0ab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8a3cc642156c7b588e9f18a51fa8d0ab_b.png\"/></figure><ul><li><b>优点：</b>（1）能精准识别新邮件（2）pop3,imap均可支持</li><li><b>缺点：</b>（1）还行吧</li></ul>", 
            "topic": [
                {
                    "tag": "Mail", 
                    "tagLink": "https://api.zhihu.com/topics/19569465"
                }, 
                {
                    "tag": "电子邮件", 
                    "tagLink": "https://api.zhihu.com/topics/19570205"
                }, 
                {
                    "tag": "邮件提醒", 
                    "tagLink": "https://api.zhihu.com/topics/19573065"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52594053", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 1, 
            "title": "Sharding-jdbc与jdbc的性能比较", 
            "content": "<h2><b>0 引言</b></h2><p>关系型数据库凭借灵活查询的SQL和稳定的存储及事务引擎，一直以来是业务存储领域的首选。而在规模越来越大的互联网年代，单一的关系型数据库却已难满足需求。开发人员不愿放弃SQL查询的灵活度及对之前代码的兼容性，而又无法承受数据量过大时所带来的性能瓶颈。因此大多数互联网公司趋向使用关系型数据库中间件采用单体向分布式透明转化的方案来解决数据量和访问量巨大这两个互联网场景的核心问题。sharding-jdbc是一款最为常用的轻量级分库分表的“中间件”，其架构图如下，本文就其性能作探讨。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c4da88e9247d890c20691b089267d06a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"405\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-c4da88e9247d890c20691b089267d06a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;405&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"405\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-c4da88e9247d890c20691b089267d06a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c4da88e9247d890c20691b089267d06a_b.jpg\"/></figure><h2><b>1 测试目的</b></h2><p>在同等数据读写量环境下，检验sharding-jdbc与单库单表jdbc的性能比较。</p><h2><b>2 测试场景</b></h2><p><b>数据批量写入：</b></p><p>批量写入10000条数据，测试结果如下表</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8282e7943ffeb406a390230ab0e87fa5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"583\" data-rawheight=\"51\" class=\"origin_image zh-lightbox-thumb\" width=\"583\" data-original=\"https://pic2.zhimg.com/v2-8282e7943ffeb406a390230ab0e87fa5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;583&#39; height=&#39;51&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"583\" data-rawheight=\"51\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"583\" data-original=\"https://pic2.zhimg.com/v2-8282e7943ffeb406a390230ab0e87fa5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8282e7943ffeb406a390230ab0e87fa5_b.jpg\"/></figure><p><b>数据查询:</b></p><p>查询约15万条数据所用时长，测试结果如下表</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2fceb0d84d83da164c7ddb70e01a6dc1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"578\" data-rawheight=\"95\" class=\"origin_image zh-lightbox-thumb\" width=\"578\" data-original=\"https://pic2.zhimg.com/v2-2fceb0d84d83da164c7ddb70e01a6dc1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;578&#39; height=&#39;95&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"578\" data-rawheight=\"95\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"578\" data-original=\"https://pic2.zhimg.com/v2-2fceb0d84d83da164c7ddb70e01a6dc1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2fceb0d84d83da164c7ddb70e01a6dc1_b.jpg\"/></figure><p>以上数据均为平均时长。</p><h2><b>3 测试结论</b></h2><p>在单服务器下，相比jdbc，使用sharding-jdbc进行分库分表后，Sharding-JDBC在查询中的性能损失非常低，插入和更新略高，并不会对程序性能造成负面影响，并且在批量写入、带分页要求的数据查询方面会有很大的性能提升。</p><h2><b>4 附录：</b></h2><h2><b>测试环境</b></h2><p>服务端为单机部署，机器配置如下：</p><ul><li>Jdbc：单库test，单表user。</li><li>Sharding-jdbc：分三个库test_0,test_1,test_2，水平分库分表，每个库两张表user_0,user_1。</li></ul><h2><b>测试脚本</b></h2><ul><li>建表sql</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">CREATE TABLE `user` (\n `id` int(12) unsigned zerofill NOT NULL AUTO_INCREMENT,\n `user_name` varchar(50) DEFAULT NULL,\n `user_id` int(20) NOT NULL,\n `c_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=28204 DEFAULT CHARSET=utf8;</code></pre></div><ul><li>插入sql</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">insert into user(user_name,user_id,c_time) values(?,?,?)</code></pre></div><ul><li>查询sql</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">select id,user_id,user_name,c_time from user where user_id &gt;= ? and user_id &lt;= ? ORDER BY c_time DESC\nselect id,user_id,user_name,c_time from user where c_time &gt;= ? and c_time &lt;= ? ORDER BY c_time DESC\nselect id,user_id,user_name,c_time from user where user_id &gt;= ? and user_id &lt;= ? ORDER BY c_time DESC limit ?,?\nselect id,user_id,user_name,c_time from user where c_time &gt;= ? and c_time &lt;= ? ORDER BY c_time DESC limit ?,?</code></pre></div><h2><b>未完待续</b></h2><p>作为目前最受欢迎的分库分表插件，在互联网应用场景中更有它优越的一面，而且以后市场肯定也会有其他的插件流行起来，敬请期待后续报告!</p><p>（1）作者个人技术专栏，有趣的互联网应用，全新的技术实践与总结：</p><a href=\"https://zhuanlan.zhihu.com/frankyho\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-af80b286ddc840cabe8cb65de37ae1ba_ipico.jpg\" data-image-width=\"638\" data-image-height=\"638\" class=\"internal\">风中饮酒的程序员</a><p>（2）个人开源缓存系统：</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/dickyPro/fast-cache-starter\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-25db3204d1733686385852a711e54722_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">dickyPro/fast-cache-starter</a><p></p>", 
            "topic": [
                {
                    "tag": "JDBC", 
                    "tagLink": "https://api.zhihu.com/topics/19574323"
                }, 
                {
                    "tag": "Sharding", 
                    "tagLink": "https://api.zhihu.com/topics/19608429"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }
            ], 
            "comments": [
                {
                    "userName": "李开心", 
                    "userLink": "https://www.zhihu.com/people/aa80533967c7ec0944342a0e21fa1777", 
                    "content": "<p>您好，您是在分库分表的条件下，批量插入的吗？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "愤怒的小吹球", 
                            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
                            "content": "<p>是哒</p>", 
                            "likes": 0, 
                            "replyToAuthor": "李开心"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51104501", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 2, 
            "title": "Mybatis超量查询解决方案", 
            "content": "<p>最近碰到sql查询出错的问题，原因即是OOM（out of memory 内存溢出），GC回收内存查询GC limited expeed问题，为此给出几种方案比较；</p><h2><b>1 普通查询</b></h2><p>原始mybatis语句:</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;select id=&#34;getAllUsers&#34; resultMap=&#34;BaseResultMap&#34; parameterType=&#34;java.util.Map&#34; &gt;\n  select &lt;include refid=&#34;Base_Column_List&#34; /&gt;  from user_messages\n  where created_time between &#39;2018-01-01&#39; and &#39;${currentYear}-12-31&#39;\n  and DATEDIFF(#{date,jdbcType=VARCHAR},created_time)=0\n&lt;/select&gt;</code></pre></div><p>对于普通sql查询，上面写法足以满足需求，Mybatis作为一个优秀的ORM框架极大方便了我们对数据库CUID的操作，但是Mybatis对底层JDBC的封装同时也给我们底层调优带来了一些问题。当一次查询数据过多，比如1000W条数据得场景，就会出现OOM，这个时候JDBC可能采用返回游标的方式就可以完成。Oracle和MySQL在服务器端已经帮我们完成游标偏移，这样也使得客户端可以用较少内存来处理数据库返回的数据，下面介绍流式查询。</p><h2><b>2 流式查询</b></h2><p>将普通查询改为流式查询，本质是Mybatis提供了回调ResultHandler方式可以完成数据逐条访问，这种方式在大数据量场景非常有用，可以均衡系统复杂性和系统资源占用两个因素。</p><p>改造前：</p><p>//DAO层</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface DataMapper {\n\tList&lt;HsUser&gt; getAllUsers();\n}</code></pre></div><p>//mapper xml ：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;mapper namespace=&#34;ems.rm.datasourceservice1.DataMapper&#34; &gt;\t\n\t&lt;select id=&#34;getAllUsers&#34; resultMap=&#34;BaseResultMap&#34;&gt;\t\t\n\t\tselect FUND_ACCOUNT from fundaccount\t\t\n\t&lt;/select&gt;\t\n&lt;/mapper&gt;</code></pre></div><p>改造后：</p><p>//先注入数据库配置</p><div class=\"highlight\"><pre><code class=\"language-text\">@MapperScan(basePackages = &#34;ems.rm.datasourceservice&#34;, sqlSessionFactoryRef = &#34;hsdataSqlSessionFactory&#34;)\npublic class DataConfig {\n\n\t\t@Bean(name = &#34;HSDataSource&#34;)\n\t\t@ConfigurationProperties(prefix = &#34;spring.datasource.hsdata&#34;)\n\t\t@Primary\n\t\tpublic DataSource dataSource() {\n\t\t\treturn DataSourceBuilder.create().build();\n\t\t}\n\n\t\t@Bean(name = &#34;hsdataSqlSessionFactory&#34;)\n\t\t@Primary\n\t\tpublic SqlSessionFactory  sqlSessionFactory(@Qualifier(&#34;HSDataSource&#34;) DataSource dataSource)\n\t\t\t\tthrows Exception {\n\t\t\tSqlSessionFactoryBean bean = new SqlSessionFactoryBean();\n\t\t\tbean.setDataSource(dataSource);\n\t\t\tbean.setMapperLocations(\n\t\t\t\t\tnew PathMatchingResourcePatternResolver().getResources(&#34;classpath:mybatis/hsMapper.xml&#34;));\n\t\t\treturn bean.getObject();\n\t\t}\n\n\t\t@Bean(name = &#34;hsdataTransactionManager&#34;)\n\t\t@Primary\n\t\tpublic DataSourceTransactionManager transactionManager(@Qualifier(&#34;HSDataSource&#34;) DataSource dataSource) {\n\t\t\treturn new DataSourceTransactionManager(dataSource);\n\t\t}\n\n\t\t@Bean(name = &#34;hsdataSqlSessionTemplate&#34;)\n\t\t@Primary\n\t\tpublic SqlSessionTemplate sqlSessionTemplate(\n\t\t\t\t@Qualifier(&#34;hsdataSqlSessionFactory&#34;) SqlSessionFactory sqlSessionFactory) throws Exception {\n\t\t\treturn new SqlSessionTemplate(sqlSessionFactory);\n\t\t}\n}</code></pre></div><p>//dao 层</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface DataMapper {\n\tvoid getHSUser();\n}</code></pre></div><p>//mapper xml:</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;mapper namespace=&#34;ems.rm.datasourceservice.HSDataMapper&#34; &gt;\t\n\t&lt;resultMap id=&#34;HSUserAccountMap&#34; type=&#34;ems.rm.datasourceservice.HsUser&#34;&gt;\n\t\t &lt;id  column=&#34;FUND_ACCOUNT&#34; property=&#34;userAccount&#34; jdbcType=&#34;VARCHAR&#34;/&gt;\n\t&lt;/resultMap&gt;\n \n\t&lt;select id=&#34;getHSUser&#34; fetchSize=&#34;100&#34; resultMap=&#34;HSUserAccountMap&#34;&gt;\t\t\n\t\tselect FUND_ACCOUNT from hs_fund.fundaccount\t\t\n\t&lt;/select&gt;\t\n&lt;/mapper&gt;</code></pre></div><p>//服务层调用:</p><div class=\"highlight\"><pre><code class=\"language-text\">public class DataService {\n\t@Autowired\n\tSqlSessionTemplate template;\n\n\t@SuppressWarnings(&#34;rawtypes&#34;)\n\t@Scheduled(fixedRateString =&#34;${ems.rm.cpyalgorithm.alarmCheck}&#34;)\n\tvoid TestFunc()\n\t{\n\t   template.select(&#34;ems.rm.datasourceservice.HSDataMapper.getHSUser&#34;,\n\t\t\t\tnew ResultHandler() {\n \n            @Override\n            public void handleResult(ResultContext resultContext) {\n            \tHsUser hsUser = (HsUser) resultContext.getResultObject();\n                //System.out.println(resultContext.getResultCount());\n                System.out.println(hsUser);\n            }\n\t\t});\n\t}\n}</code></pre></div><h2><b>3 分页查询</b></h2><p>上述方案理论可行，然而实际情况中，当数据超量，<a href=\"https://link.zhihu.com/?target=http%3A//template.select/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">template.select</a>初始化照样会溢出，采用mybatis得分页插件查询是比较实用折中得方案。</p><p>分页查询本质上是采用limit语句，限定paigesize，再舍弃前page-1页，分页插件只需查询一次，就可以返回记录数 messagePager.getCount();</p><div class=\"highlight\"><pre><code class=\"language-text\">public List&lt;UserMessage&gt; selectByDate(String date) {\n    List&lt;UserMessage&gt; userMessageSum = new ArrayList&lt;&gt;();\n    Pager messagePager = new Pager();\n    messagePager.setPageIndex(1);\n    messagePager.setPageSize(PAGE_SIZE);\n    try {\n        Date toDate = DateUtil.strToDate2(date);\n        String current = DateUtil.date2shortStr(toDate);\n        messagePager.addParameter(&#34;createdStartDate&#34;, current + &#34; 00:00:00&#34;);\n        messagePager.addParameter(&#34;createdEndDate&#34;, current + &#34; 23:59:59&#34;);\n    } catch (Exception ignore) {\n        logger.error(&#34;selectByDate|按日期选择消息|解析日期异常&#34;, ignore.getMessage());\n        return userMessageSum;\n    }\n    List&lt;UserMessage&gt; firstPage = userMessageMapper.selectPager(messagePager);\n    int count = messagePager.getCount();\n    logger.error(&#34;selectByDate|按日期选择消息|COUNT:{}&#34;, count);\n    if (count &lt;= 0) {\n        return userMessageSum;\n    } else if (count &lt;= PAGE_SIZE) {\n        return firstPage;\n    } else if (count &gt; PAGE_SIZE) {\n        userMessageSum.addAll(firstPage);\n        //分页添加\n        int totalPage = 0;\n        if (count % PAGE_SIZE == 0) {\n            totalPage = count / PAGE_SIZE;\n        } else {\n            totalPage = (count - count % PAGE_SIZE) / PAGE_SIZE + 1;\n        }\n        for (int i = 2; i &lt;= totalPage; i++) {\n            messagePager.setPageIndex(i);\n            List&lt;UserMessage&gt; messages = userMessageMapper.selectPager(messagePager);\n            userMessageSum.addAll(messages);\n        }\n    }\n    return userMessageSum;\n}</code></pre></div><p></p><p></p>", 
            "topic": [
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }, 
                {
                    "tag": "MyBatis", 
                    "tagLink": "https://api.zhihu.com/topics/19680218"
                }, 
                {
                    "tag": "查询", 
                    "tagLink": "https://api.zhihu.com/topics/19572287"
                }
            ], 
            "comments": [
                {
                    "userName": "Bouger", 
                    "userLink": "https://www.zhihu.com/people/4eba31fdd73ebc44e4c8ec2259c9d671", 
                    "content": "<p>大神 有源码吗？</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Bouger", 
                    "userLink": "https://www.zhihu.com/people/4eba31fdd73ebc44e4c8ec2259c9d671", 
                    "content": "<p>分页查询 都放到userMessageSum中，客户端也会存在内存溢出的情况啊</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "愤怒的小吹球", 
                            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
                            "content": "<p>上面就是源码啊，userMessageSum是个list，会自动拓容不会溢出</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Bouger"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/50389059", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 0, 
            "title": "代码整洁之道随想", 
            "content": "<p>最近偶尔翻阅<b>《code clean》,</b>温故而知新，别用一番风味。以前没想过做笔记，以前没想过会喜欢吃苹果，现在喜欢了，人生就是这么滑稽。</p><h2><b>1 整洁代码不是一蹴而就</b></h2><p>别看这本书列出这么多规范，头头是道，但让本书作者来写代码，第一次也不会达到如此精准的境界，就如书中坦言：</p><blockquote><i>“我并不从一开始就按规则写函数，我想没人做得到“</i></blockquote><p>所以我们看的那些成熟的源码，在心生敬畏的同时，不要望而却步，心想一辈子都达不到这个境界，实际上，你能有机会达到，前提是在万般打磨自己代码的基础上，认识不努力一把，如何感知什么叫绝望。。。。哈哈</p><h2><b>2 有意义的命名</b></h2><ul><li>名副其实，避免误导：在给变量、函数等取个合适名字其实是很花时间的事，对于已有的变量等，如果想到更合适的名字则请记得马上换掉，必免误导其他开发人员。</li><li>遵守编码规范中的命名相关部分。</li></ul><h2><b>3 函数只做一件事</b></h2><ul><li>问题分解、模块职责划分</li><li>编码前需要有最基本的设计思路，不管是何种设计粒度（系统、模块、类），其核心骨架、流程都必须成竹于胸。</li><li>函数尽量精简，精简的函数不代表行数就一定是很少；只要保证一个函数只做一件事，这里的“一件事“比较抽象，不同人有不同的解读；我的区分原则为：有利于函数复用与阅读。</li><li>函数参数越少越好，这样能省很多测试用例；参数尽量只用于输入，通过返回值进行函数结果输出，参数尽量不同时承载输入与输出信息（多线程开发时除外）</li><li>函数要么做查询操作，要么做设置操作，不要同时都做。</li></ul><p><i><b>“函数只做一件事”</b></i>这句话摘选自函数这一章节。这句话很重要，我总会在函数中看到比函数名描述的更多的事情，有的时候我不得不花时间去阅读一些我不想了解的实现细节才能明白这个函数到底做了一件什么事。所以一个函数只做一件事，这是我认为很容易达到却又很容易被忽略的非常重要的事情。同时，函数还应该尽可能的短小，一个函数就算写的再清晰，如果一下子展示出100多行，那种庞大的行数也会让读者瞬间放弃。</p><h2><b>4 注释</b></h2><ul><li>个人觉得JavaBean的Getter/Setter方法是不需要注释的</li><li>对代码的修改不需要写一些日志式的注释、不写废话式注释</li><li>能用函数名或变量名自解释的，尽量不写注释</li><li>不需要在控制语句的花括号结尾加代表语句结束的注释，类似} // while</li><li>也不需要写一大段的注释，如果出现这种情况，肯定是功能函数拆解不合理导致。</li></ul><h2><b>5 错误处理</b></h2><ul><li>面向对象设计中，严格实行快速抛异常原则，而不是返回错误代码，而不应该吃掉异常。</li><li>对于外部复杂的异常层次结构可做必要的封装以减少重复代码</li><li>尽量不使用null作为返回值、参数等，因为null可能引起歧义<b> ，</b>涉及<b>特例模式与NULL值处理</b>，利用天然的空集合：</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">返回 Collections.emptyList() 代替null</code></pre></div><h2><b>6 第三方API调用处理</b></h2><ul><li>建议对第三方接口进行包装，便于后续适配多个提供方</li><li>团队协作中，如果依赖的其他子系统的接口未定义，但我们已明确我方的需求，我们可以先定义接口并提供一个Mock类，这样可以保证我们的模块稳定性及可测试性</li><li>如果依赖的第三方接口在本系统中使用得比较多，也建议统一再包装一层以适应外部接口变化</li><li>包装的目的是屏蔽外部不确定性、增加鲁棒性</li></ul><h2><b>7从哪儿入手</b></h2><p>如果不知道如何重构改动的时候，我自己的经验是，可以先从最基本的入手，看懂一段代码并且明确这是做了一件事之后，提取出来，取一个具有描述意义的名字。当将代码这样拆解成一个一个的方法之后，结构就清晰了很多。之后我们就会闻到很多的code smell，发现很多的重复。关于如何发现和解决code smell，可以参考《重构》这本书，这本书列举了很多code smell，并且给出了很好的解决方案。</p><p>小幅的、迭代式的进行代码的改动可以帮助我们一点一点的梳理结构，朝着更清晰的方向行走。同时千万不要忘记每一次的改动都需要运行测试来保证我们做的是对的事情。</p><p>下面推荐一个非常不错的有关设计模式与重构的英文站点：<br/></p><a href=\"https://link.zhihu.com/?target=https%3A//refactoring.guru/refactoring/course\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-c1e480785b998bfbdc18c9a0e555ac51_180x120.jpg\" data-image-width=\"476\" data-image-height=\"249\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Refactoring Course</a><p></p>", 
            "topic": [
                {
                    "tag": "代码整洁之道（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20117910"
                }, 
                {
                    "tag": "代码质量", 
                    "tagLink": "https://api.zhihu.com/topics/19585332"
                }, 
                {
                    "tag": "源代码", 
                    "tagLink": "https://api.zhihu.com/topics/19569491"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/49612203", 
            "userName": "一颗白菜菜", 
            "userLink": "https://www.zhihu.com/people/20603d6675443732bfe26faafdb0caab", 
            "upvote": 1, 
            "title": "五种方式让你在java中读取properties文件内容不再是难题", 
            "content": "<h2>一、背景</h2><p>　　最近，在项目开发的过程中，遇到需要在properties文件中定义一些自定义的变量，以供java程序动态的读取，修改变量，不再需要修改代码的问题。就借此机会把Spring+SpringMVC+Mybatis整合开发的项目中通过java程序读取properties文件内容的方式进行了梳理和分析，现和大家共享。</p><h2>二、项目环境介绍</h2><p>    Spring 4.2.6.RELEASE</p><p>    SpringMvc 4.2.6.RELEASE</p><p>    Mybatis 3.2.8</p><p>    Maven 3.3.9</p><p>    Jdk 1.7</p><p>    Idea 15.04</p><h2>三、五种实现方式</h2><p><b>方式1.通过context:property-placeholder加载配置文件jdbc.properties中的内容</b></p><p>&lt;context:property-placeholder location=&#34;classpath:jdbc.properties&#34; ignore-unresolvable=&#34;true&#34;/&gt;</p><p>　　上面的配置和下面配置等价，是对下面配置的简化</p><p>&lt;bean id=&#34;propertyConfigurer&#34; class=&#34;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&#34;&gt; &lt;property name=&#34;ignoreUnresolvablePlaceholders&#34; value=&#34;true&#34;/&gt; &lt;property name=&#34;locations&#34;&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;</p><p>注意：这种方式下，如果你在spring-mvc.xml文件中有如下配置，则一定不能缺少下面的红色部分，关于它的作用以及原理，参见另一篇博客：<u><b><a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/hafiz/p/5875770.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">context:component-scan标签的use-default-filters属性的作用以及原理分析</a></b></u></p><p>&lt;!-- 配置组件扫描，springmvc容器中只扫描Controller注解 --&gt; &lt;context:component-scan base-package=&#34;com.hafiz.www&#34; use-default-filters=&#34;false&#34;&gt;     &lt;context:include-filter type=&#34;annotation&#34; expression=&#34;org.springframework.stereotype.Controller&#34;/&gt; &lt;/context:component-scan&gt;</p><p><b>方式2.使用注解的方式注入，主要用在java代码中使用注解注入properties文件中相应的value值</b></p><p>&lt;bean id=&#34;prop&#34; class=&#34;org.springframework.beans.factory.config.PropertiesFactoryBean&#34;&gt; &lt;!-- 这里是PropertiesFactoryBean类，它也有个locations属性，也是接收一个数组，跟上面一样 --&gt; &lt;property name=&#34;locations&#34;&gt; &lt;array&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;</p><p><b>方式3.使用util:properties标签进行暴露properties文件中的内容</b></p><p>&lt;util:properties id=&#34;propertiesReader&#34; location=&#34;classpath:jdbc.properties&#34;/&gt;</p><p>注意：使用上面这行配置，需要在spring-dao.xml文件的头部声明以下红色的部分</p><p>&lt;beans xmlns=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans</span><span class=\"ellipsis\"></span></a>&#34;        xmlns:xsi=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.w3.org/2001/XMLSchema-instance\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">w3.org/2001/XMLSchema-i</span><span class=\"invisible\">nstance</span><span class=\"ellipsis\"></span></a>&#34;        xmlns:context=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/context\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/context</span><span class=\"ellipsis\"></span></a>&#34;        xmlns:util=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/util\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/util</span><span class=\"ellipsis\"></span></a>&#34;        xsi:schemaLocation=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans</span><span class=\"ellipsis\"></span></a>         <a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans/spring-beans-3.2.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans/spring-beans-3.2.xsd</span><span class=\"ellipsis\"></span></a>         <a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/context\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/context</span><span class=\"ellipsis\"></span></a>          <a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/context/spring-context-3.2.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/context/spring-context-3.2.xsd</span><span class=\"ellipsis\"></span></a>         <a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/util\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/util</span><span class=\"ellipsis\"></span></a> <br/>　　　　 <a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/util/spring-util.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/util/spring-util.xsd</span><span class=\"ellipsis\"></span></a>&#34;&gt;</p><p><b>方式4.通过PropertyPlaceholderConfigurer在加载上下文的时候暴露properties到自定义子类的属性中以供程序中使用</b></p><p>&lt;bean id=&#34;propertyConfigurer&#34; class=&#34;com.hafiz.www.util.PropertyConfigurer&#34;&gt; &lt;property name=&#34;ignoreUnresolvablePlaceholders&#34; value=&#34;true&#34;/&gt; &lt;property name=&#34;ignoreResourceNotFound&#34; value=&#34;true&#34;/&gt; &lt;property name=&#34;locations&#34;&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;</p><p>自定义类PropertyConfigurer的声明如下:</p><p>package com.hafiz.www.util;  import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;  import java.util.Properties;  /**  * Desc:properties配置文件读取类  * Created by hafiz.zhang on 2016/9/14.  */ public class PropertyConfigurer extends PropertyPlaceholderConfigurer {      private Properties props;       // 存取properties配置文件key-value结果      @Override     protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)                             throws BeansException {         super.processProperties(beanFactoryToProcess, props);         this.props = props;     }      public String getProperty(String key){         return this.props.getProperty(key);     }      public String getProperty(String key, String defaultValue) {         return this.props.getProperty(key, defaultValue);     }      public Object setProperty(String key, String value) {         return this.props.setProperty(key, value);     } }</p><p>使用方式：在需要使用的类中使用@Autowired注解注入即可。</p><p><b>方式5.自定义工具类PropertyUtil，并在该类的static静态代码块中读取properties文件内容保存在static属性中以供别的程序使用</b></p><p>package com.hafiz.www.util;  import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import java.io.*; import java.util.Properties;  /**  * Desc:properties文件获取工具类  * Created by hafiz.zhang on 2016/9/15.  */ public class PropertyUtil {     private static final Logger logger = LoggerFactory.getLogger(PropertyUtil.class);     private static Properties props;     static{         loadProps();     }      synchronized static private void loadProps(){         <a href=\"https://link.zhihu.com/?target=http%3A//logger.info\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">logger.info</span><span class=\"invisible\"></span></a>(&#34;开始加载properties文件内容.......&#34;);         props = new Properties();         InputStream in = null;         try {<br/>　　　　　　　&lt;!--第一种，通过类加载器进行获取properties文件流--&gt;             in = PropertyUtil.class.getClassLoader().getResourceAsStream(&#34;jdbc.properties&#34;);<br/>　　　　　　  &lt;!--第二种，通过类进行获取properties文件流--&gt;             //in = PropertyUtil.class.getResourceAsStream(&#34;/jdbc.properties&#34;);             props.load(in);         } catch (FileNotFoundException e) {             logger.error(&#34;jdbc.properties文件未找到&#34;);         } catch (IOException e) {             logger.error(&#34;出现IOException&#34;);         } finally {             try {                 if(null != in) {                     in.close();                 }             } catch (IOException e) {                 logger.error(&#34;jdbc.properties文件流关闭出现异常&#34;);             }         }         logger.info(&#34;加载properties文件内容完成...........&#34;);         logger.info(&#34;properties文件内容：&#34; + props);     }      public static String getProperty(String key){         if(null == props) {             loadProps();         }         return props.getProperty(key);     }      public static String getProperty(String key, String defaultValue) {         if(null == props) {             loadProps();         }         return props.getProperty(key, defaultValue);     } }</p><p>说明：这样的话，在该类被加载的时候，它就会自动读取指定位置的配置文件内容并保存到静态属性中，高效且方便，一次加载，可多次使用。</p><h2>四、注意事项及建议</h2><p>　　以上五种方式，前三种方式比较死板，而且如果你想在带有@Controller注解的Bean中使用，你需要在SpringMVC的配置文件spring-mvc.xml中进行声明，如果你想在带有@Service、@Respository等非@Controller注解的Bean中进行使用，你需要在Spring的配置文件中spring.xml中进行声明。原因请参见另一篇博客：<u><b><a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/hafiz/p/5875740.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Spring和SpringMVC父子容器关系初窥</a></b></u></p><p>　　我个人比较建议第四种和第五种配置方式，第五种为最好，它连工具类对象都不需要注入，直接调用静态方法进行获取，而且只一次加载，效率也高。而且前三种方式都不是很灵活，需要修改@Value的键值。</p><h2>五、测试验证是否可用</h2><p>1.首先我们创建PropertiesService</p><p>package com.hafiz.www.service;  /**  * Desc:java程序获取properties文件内容的service  * Created by hafiz.zhang on 2016/9/16.  */ public interface PropertiesService {      /**      * 第一种实现方式获取properties文件中指定key的value      *      * @return */     String getProperyByFirstWay();      /**      * 第二种实现方式获取properties文件中指定key的value      *      * @return */     String getProperyBySecondWay();      /**      * 第三种实现方式获取properties文件中指定key的value      *      * @return */     String getProperyByThirdWay();      /**      * 第四种实现方式获取properties文件中指定key的value      *      * @param key      *      * @return */     String getProperyByFourthWay(String key);      /**      * 第四种实现方式获取properties文件中指定key的value      *      * @param key      *      * @param defaultValue      *      * @return */     String getProperyByFourthWay(String key, String defaultValue);      /**      * 第五种实现方式获取properties文件中指定key的value      *      * @param key      *      * @return */     String getProperyByFifthWay(String key);      /**      * 第五种实现方式获取properties文件中指定key的value      *      * @param key      *      * @param defaultValue      *      * @return */     String getProperyByFifthWay(String key, String defaultValue); }</p><p>2.创建实现类PropertiesServiceImpl</p><p>package com.hafiz.www.service.impl;  import com.hafiz.www.service.PropertiesService; import com.hafiz.www.util.PropertyConfigurer; import com.hafiz.www.util.PropertyUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Service;  /**  * Desc:java程序获取properties文件内容的service的实现类  * Created by hafiz.zhang on 2016/9/16.  */ @Service public class PropertiesServiceImpl implements PropertiesService {      @Value(&#34;${test}&#34;)     private String testDataByFirst;      @Value(&#34;#{prop.test}&#34;)     private String testDataBySecond;      @Value(&#34;#{propertiesReader[test]}&#34;)     private String testDataByThird;      @Autowired     private PropertyConfigurer pc;      @Override     public String getProperyByFirstWay() {         return testDataByFirst;     }      @Override     public String getProperyBySecondWay() {         return testDataBySecond;     }      @Override     public String getProperyByThirdWay() {         return testDataByThird;     }      @Override     public String getProperyByFourthWay(String key) {         return pc.getProperty(key);     }      @Override     public String getProperyByFourthWay(String key, String defaultValue) {         return pc.getProperty(key, defaultValue);     }      @Override     public String getProperyByFifthWay(String key) {         return PropertyUtil.getPropery(key);     }      @Override     public String getProperyByFifthWay(String key, String defaultValue) {         return PropertyUtil.getProperty(key, defaultValue);     } }</p><p>3.控制器类PropertyController</p><p>package com.hafiz.www.controller;  import com.hafiz.www.service.PropertiesService; import com.hafiz.www.util.PropertyUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody;  /**  * Desc:properties测试控制器  * Created by hafiz.zhang on 2016/9/16.  */ @Controller @RequestMapping(&#34;/prop&#34;) public class PropertyController {     @Autowired     private PropertiesService ps;      @RequestMapping(value = &#34;/way/first&#34;, method = RequestMethod.GET)     @ResponseBody     public String getPropertyByFirstWay(){         return ps.getProperyByFirstWay();     }      @RequestMapping(value = &#34;/way/second&#34;, method = RequestMethod.GET)     @ResponseBody     public String getPropertyBySecondWay(){         return ps.getProperyBySecondWay();     }      @RequestMapping(value = &#34;/way/third&#34;, method = RequestMethod.GET)     @ResponseBody     public String getPropertyByThirdWay(){         return ps.getProperyByThirdWay();     }      @RequestMapping(value = &#34;/way/fourth/{key}&#34;, method = RequestMethod.GET)     @ResponseBody     public String getPropertyByFourthWay(@PathVariable(&#34;key&#34;) String key){         return ps.getProperyByFourthWay(key, &#34;defaultValue&#34;);     }      @RequestMapping(value = &#34;/way/fifth/{key}&#34;, method = RequestMethod.GET)     @ResponseBody     public String getPropertyByFifthWay(@PathVariable(&#34;key&#34;) String key){         return PropertyUtil.getProperty(key, &#34;defaultValue&#34;);     } }</p><p>4.jdbc.properties文件</p><p>jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://192.168.1.196:3306/dev?useUnicode=true&amp;characterEncoding=UTF-8 jdbc.username=root jdbc.password=123456 jdbc.maxActive=200 jdbc.minIdle=5 jdbc.initialSize=1 jdbc.maxWait=60000 jdbc.timeBetweenEvictionRunsMillis=60000 jdbc.minEvictableIdleTimeMillis=300000 jdbc.validationQuery=select 1 from t_user jdbc.testWhileIdle=true jdbc.testOnReturn=false jdbc.poolPreparedStatements=true jdbc.maxPoolPreparedStatementPerConnectionSize=20 jdbc.filters=stat #test data test=com.hafiz.www</p><p>5.项目结果图</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6684869edcacc0a7f6b531b583cd0e77_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"384\" data-rawheight=\"571\" class=\"content_image\" width=\"384\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;384&#39; height=&#39;571&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"384\" data-rawheight=\"571\" class=\"content_image lazy\" width=\"384\" data-actualsrc=\"https://pic4.zhimg.com/v2-6684869edcacc0a7f6b531b583cd0e77_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>6.项目GitHub地址</p><p><u><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hafizzhang/SSM/branches\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/hafizzhang/S</span><span class=\"invisible\">SM/branches</span><span class=\"ellipsis\"></span></a></u> 页面下的propertiesConfigurer分支。</p><p>7.测试结果</p><p>　　第一种方式</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-52aec21866cbeba8e47f59b55e66865a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"393\" data-rawheight=\"102\" class=\"content_image\" width=\"393\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;393&#39; height=&#39;102&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"393\" data-rawheight=\"102\" class=\"content_image lazy\" width=\"393\" data-actualsrc=\"https://pic3.zhimg.com/v2-52aec21866cbeba8e47f59b55e66865a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>　　第二种方式</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-92e8a8609ce3c2ecacb468e47fba41ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"120\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"120\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic2.zhimg.com/v2-92e8a8609ce3c2ecacb468e47fba41ed_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>　　第三种方式</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a247d1c1e647babe0e789b5517d07b63_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"429\" data-original=\"https://pic4.zhimg.com/v2-a247d1c1e647babe0e789b5517d07b63_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;429&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"429\" data-original=\"https://pic4.zhimg.com/v2-a247d1c1e647babe0e789b5517d07b63_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a247d1c1e647babe0e789b5517d07b63_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>　　第四种方式</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-847a53060d89bedab1efece464f04d77_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"415\" data-rawheight=\"107\" class=\"content_image\" width=\"415\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;415&#39; height=&#39;107&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"415\" data-rawheight=\"107\" class=\"content_image lazy\" width=\"415\" data-actualsrc=\"https://pic4.zhimg.com/v2-847a53060d89bedab1efece464f04d77_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>　　第五种方式</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7f75e434aee5a23838096999e90a6622_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"391\" data-rawheight=\"116\" class=\"content_image\" width=\"391\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;391&#39; height=&#39;116&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"391\" data-rawheight=\"116\" class=\"content_image lazy\" width=\"391\" data-actualsrc=\"https://pic3.zhimg.com/v2-7f75e434aee5a23838096999e90a6622_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>六、总结</h2><p>　　通过本次的梳理和测试，我们理解了Spring以及context:component-scan标签包扫描时最容易忽略的use-default-filters属性的作用以及原理。能够更好地定位和快速解决再遇到的问题。总之，棒棒哒~~~</p><p>欢迎工作一到五年的Java工程师朋友们加入Java架构开发： 854393687</p><p>群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用&#34;没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！</p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48615436", 
            "userName": "一颗白菜菜", 
            "userLink": "https://www.zhihu.com/people/20603d6675443732bfe26faafdb0caab", 
            "upvote": 2, 
            "title": "支付宝退款总结", 
            "content": "<p><b>1.支付宝退款接口需要的参数</b><br/>支付宝网关,appID,private_key,public_key,sign_type,input_charset,format;<br/><b>2.使用接口需要上传的参数</b><br/>支付宝支付交易号/订单号,退款金额,参数只要这两个就能完成退款,不过支付宝的文档上面有的写的可选的,即使是可选的,你也要写上;<br/><b>3.参数获取方法</b><br/>支付宝网关:&#34;<a href=\"https://link.zhihu.com/?target=https%3A//openapi.alipay.com/gateway.do\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">openapi.alipay.com/gate</span><span class=\"invisible\">way.do</span><span class=\"ellipsis\"></span></a>&#34;; appID:这个就需要商户登陆支付宝开发者平台,在&#34;网页&amp;移动应用&#34;添加应用,创建应用后,添加应用功能,上传所需 的数据,之后生成一个appID,然后提交审核就可以了; sign_type:选择&#34;RSA2&#34;。 public_key:在申请应用的时候,下载一个&#34;RSA签名验签工具windows_V1.4&#34;,网上就可以找到,在这个里面生成公钥,上传到支付宝; private_key:用上面下载的工具,将公钥上传会产生一个对应的秘钥; input_charset:&#34;UTF-8&#34;,网上说必须要大写,这个没试过; format:&#34;json&#34;;<br/><b>4.开始退款代码</b><br/>try {         AlipayClient alipayClient = new DefaultAlipayClient(&#34;支付宝网关&#34;, appID, private_key, &#34;json&#34;, input_charset, public_key, sign_type);         AlipayTradeRefundRequest request = new AlipayTradeRefundRequest();         request.setBizContent(&#34;{&#34; +                 &#34;\\&#34;out_trade_no\\&#34;:\\&#34;&#34; + 订单号 + &#34;\\&#34;,&#34; +                 &#34;\\&#34;trade_no\\&#34;:\\&#34;&#34; + 支付宝交易号 + &#34;\\&#34;,&#34; +                 &#34;\\&#34;refund_amount\\&#34;:&#34; + 退款金额 + &#34;,&#34; +                 &#34;\\&#34;refund_currency\\&#34;:\\&#34;CNY\\&#34;,&#34; +                 &#34;\\&#34;org_pid\\&#34;:\\&#34;&#34; + null + &#34;\\&#34;&#34; +                 &#34;  }&#34;);         AlipayTradeRefundResponse response = alipayClient.execute(request);         <a href=\"https://link.zhihu.com/?target=http%3A//log.info\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">log.info</span><span class=\"invisible\"></span></a>(&#34;返回结果：&#34; + response.getBody()); } catch (AlipayApiException e) {         e.printStackTrace();         <a href=\"https://link.zhihu.com/?target=http%3A//log.info\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">log.info</span><span class=\"invisible\"></span></a>(&#34;支付宝退款&gt;&gt;退款失败: 调用支付宝接口出现异常&#34;);         return ResultUtil.createFailureResult(&#34;REQUEST_EXCEPTION&#34;, &#34;调用支付宝接口出现异常&#34;);     }<br/><b>5.易错点</b><br/>开始说的支付宝API里面的参数,虽然有的是可选的,但是最下面的“org_pid”这个参数,如果加不上的话,就会报40004,参数不正确的错误,这个是一定要加上的,虽然后面跟的值是null;   另外,如果公司之前做过关于支付的话,是不需要重新添加应用签约的,appID可以共用,因为退款的接口在开发者平台上是辅助接口分类里面的,不需要重新签约。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "支付宝", 
                    "tagLink": "https://api.zhihu.com/topics/19552417"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/49423818", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 0, 
            "title": "如何设计一款轻量级高效实用的缓存系统？", 
            "content": "<p>最近项目中在优化系统缓存部分，平时日常大部分系统缓存必不可少，由此设想到将缓存抽取出来写成一个公共服务，并做成一个开源项目供广大仁人志士参考，问题由此展开。</p><h2><b>1 问题：</b></h2><p>如何设计一款轻量级高效实用的开源缓存系统？</p><h2><b>2 目标：</b></h2><p>支持多种一二级缓存自由组合、L1缓存使用内存（可选择guava、Caffeine），L2缓存使用 Redis(推荐)/Memcached等，可以由用户自由拓展。并且，当L2因故障断开时，程序不受影响可正常运行。</p><h2><b>3 应用场景：</b></h2><ul><li>系统原先无缓存情况下，使用cache可快速提升性能，避免应用重启导致的缓存冷启动后对后端业务的冲击。</li><li>2. 与redis /Memcached 等外置缓存解耦，L1的存在可降低对L2的读取次数，即使断开L2外置缓存，系统仍可正常运行并且保持一定缓存效率；</li></ul><h2><b>4 缓存结构：</b></h2><ul><li>L1： 进程内缓存</li><li>L2： Redis/Memcached 外置缓存</li><li>读取顺序：L1-&gt;L2-&gt;database</li></ul><h2><b>5 在springboot 中使用方式</b></h2><p>在方法上进行@Cacheable注解或@CacheClear注解</p><div class=\"highlight\"><pre><code class=\"language-text\">         /**\n\t * 缓存注解\n\t *\n\t * KEY写法：\n\t * 不适配参数：@WechatCacheable(key = &#34;{WechatPlatform}.ht:getEhrUsers&#34;)\n\t * 适配参数：@WechatCacheable(key = &#34;&#39;{WechatPlatform}.ht:getEhrUsers&#39;+#USERID&#34;)\n\t */</code></pre></div><p>@Cacheable 注解参数形式为：</p><div class=\"highlight\"><pre><code class=\"language-text\">         //缓存键\n         public String key() default &#34;&#34;;\n\n         //超时时间，单位秒\n         public int expire() default 3600;\n\n         //一级缓存\n         public L1cacheTpye L1_cache() default L1cacheTpye.NONE ;\n\n        //二级缓存\n         public L2cacheType L2_cache() default L2cacheType.NONE;\n\n        //描述\n         public String desc() default &#34;&#34;;</code></pre></div><h2><b>6 在普通springMVC中兼容</b></h2><p>applicationContext.xml 添加AOP拦截配置：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!-- beans 头部--&gt;\nxmlns:aop=&#34;http://www.springframework.org/schema/aop&#34;\nxmlns:context=&#34;http://www.springframework.org/schema/context&#34;\nxsi:schemaLocation=&#34;\n\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd\n\thttp://www.springframework.org/schema/context  \n\thttp://www.springframework.org/schema/context/spring-context-3.0.xsd&#34;\t\n&lt;!-- 开启AOP配置 --&gt;\t\n&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;\n&lt;context:component-scan base-package=&#34;com.ht.cache&#34;/&gt;\n&lt;context:annotation-config/&gt;</code></pre></div><p>另外添加相应的maven依赖即可。</p><h2><b>7 轻量管理端：</b></h2><ul><li>访问地址：<a href=\"https://link.zhihu.com/?target=http%3A//localhost%3A8080/cache\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">localhost:8080/cache</span><span class=\"invisible\"></span></a> ;</li><li>管理端批量或前缀清除fast-cache-starter注册的缓存，同时也可以快速预览缓存的数据内容，也可以对缓存的失效时间进行延长。 </li></ul><h2><b>8 开源项目地址：</b></h2><a href=\"https://link.zhihu.com/?target=https%3A//github.com/dickyPro/fast-cache-starter\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-25db3204d1733686385852a711e54722_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">dickyPro/fast-cache-starter</a><p></p>", 
            "topic": [
                {
                    "tag": "缓存", 
                    "tagLink": "https://api.zhihu.com/topics/19564998"
                }, 
                {
                    "tag": "开源", 
                    "tagLink": "https://api.zhihu.com/topics/19562746"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/46832830", 
            "userName": "java架构", 
            "userLink": "https://www.zhihu.com/people/533496e066a5fe7ad00d15504268f7fc", 
            "upvote": 0, 
            "title": "使用scrapy前的环境搭建", 
            "content": "<p>刚开始直接scrapy startproject [名称] 创建项目才遇到挺多问题的，执行这个又会提示那个问题，解决后就觉得还好还好啦</p><p>1.pip install scrapy 提示pip 版本要升级；</p><p>You are using pip version 10.0.1, however version 10.0.1 is available.<br/>You should consider upgrading via the &#39;python -m pip install --upgrade pip&#39; command.<br/>--------------------- </p><p>2.python -m pip install --upgrade pip 升级时又有新问题；</p><p>(venv) D:\\Fish&gt;python -m pip install --upgrade pip</p><p>Requirement already up-to-date: pip in d:\\fish\\venv\\lib\\site-packages (10.0.1)</p><p>--------------------- </p><p>于是按照要求将<code>d:\\fish\\venv\\lib\\site-packages (10.0.1)</code> 中的pip-10.0.1.dist-info删除，再次运行<code>python -m pip install --upgrade pip</code> 后升级成功</p><p>3.再执行第1步以为万事大吉了，又有新的问题了</p><p>error: Microsoft Visual C++ 14.0 is required. Get it with &#34;Microsoft Visual C++ Build Tools&#34;: <a href=\"https://link.zhihu.com/?target=http%3A//landinghub.visualstudio.com/visual-cpp-build-tools\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">landinghub.visualstudio.com</span><span class=\"invisible\">/visual-cpp-build-tools</span><span class=\"ellipsis\"></span></a><br/>--------------------- <br/>解决这个问题有两种方法：a.按提示安装Visual Studio （C盘至少需要6G空间，果断找其他方法解决)；</p><p>　　　　　　　　　　　　b.使用wheel安装;</p><p>使用wheel安装:pip install wheel</p><p>成功会提示successfull也可以使用wheel命令验证是否成功，成功后是这样</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9082b21b6351dc79f2a391512fe7b252_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-9082b21b6351dc79f2a391512fe7b252_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;495&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-9082b21b6351dc79f2a391512fe7b252_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9082b21b6351dc79f2a391512fe7b252_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>然后去<a href=\"https://link.zhihu.com/?target=https%3A//www.lfd.uci.edu/~gohlke/pythonlibs/%23lxml\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">lfd.uci.edu/~gohlke/pyt</span><span class=\"invisible\">honlibs/#lxml</span><span class=\"ellipsis\"></span></a>这个网站下载Scrapy库， <br/>进到网站=&gt;搜索’Scrapy’=&gt;下载</p><p>把下载的.whl文件放在一个容易寻找的地址（我放在了D:\\） <br/>然后在控制台进入该地址 <br/>在该地址下输入</p><p>pip install [whl]</p><p>注：[whl]表示你的.whl文件，一定要全名，XXXX.whl</p><p>然后，并没有结束。。。。。</p><p>安装过程还是有可能失败</p><p>可能会出现Failed to build XXXX</p><p>为什么会这样那，因为Scrapy框架基于Twisted</p><p>所以，要做的就是去网站下载Twisted之类的安装文件，先把它们装上，安装方法和上边的相同。</p><p>注意选择好版本号</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-10fe26bc8f76c675a5620433dc4de751_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-10fe26bc8f76c675a5620433dc4de751_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;303&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-10fe26bc8f76c675a5620433dc4de751_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-10fe26bc8f76c675a5620433dc4de751_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>cp代表python的版本号，32/64选择对应你电脑的位数</p><p>最后终于成功了。 <br/>建个项目测试一下</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6983004254a1ef55a30d51f36064a407_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1253\" data-rawheight=\"108\" class=\"origin_image zh-lightbox-thumb\" width=\"1253\" data-original=\"https://pic4.zhimg.com/v2-6983004254a1ef55a30d51f36064a407_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1253&#39; height=&#39;108&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1253\" data-rawheight=\"108\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1253\" data-original=\"https://pic4.zhimg.com/v2-6983004254a1ef55a30d51f36064a407_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6983004254a1ef55a30d51f36064a407_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "scrapy", 
                    "tagLink": "https://api.zhihu.com/topics/19950086"
                }, 
                {
                    "tag": "爬虫 (计算机网络)", 
                    "tagLink": "https://api.zhihu.com/topics/19577498"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45731674", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 1, 
            "title": "rocketMQ 进阶篇——细嗅蔷薇", 
            "content": "<p>现在流行的消息中间件很多，例如ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ，所有这些MQ都遵循一套jms协议规范，对，换句话话说，我们可以利用jms的一些通用协议规范去操作这些MQQ...</p><h2><b>1 应用场景</b></h2><ul><li>异步处理</li><li>应用解耦</li><li>流量削锋 （秒杀系统多见，可以控制人数，可以缓解数据库并发压力）</li><li>消息通讯 （点对点模式 、聊天室广播模式）</li></ul><h2><b>2 整体介绍：</b></h2><p>rocketMQ几个核心的模块：Producer，Consumer，Broker，NameSrv。他们之间的关系如下，<b>其中每一部分都可以部署成集群模式</b>：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4bde625b13238fdab2b171f8f9a0de57_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"474\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic4.zhimg.com/v2-4bde625b13238fdab2b171f8f9a0de57_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;474&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"474\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic4.zhimg.com/v2-4bde625b13238fdab2b171f8f9a0de57_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4bde625b13238fdab2b171f8f9a0de57_b.jpg\"/></figure><ul><li><b>Producer</b>和<b>Consumer</b>很好理解，顾名思义就是生产者和消费者，生产者负责生产消息，消费者负责消费消息，这2块的逻辑都是由业务使用者定义的。<br/> </li><li><b>Broker</b>是RocketMQ的核心，Broker实现了消息的存储、拉取等功能。Broker通常以集群方式启动，并可配置主从，每个Broker上提供对指定topic的服务。<br/> </li><li><b>NameSrv</b>是一个无状态的名称服务，可以集群部署。所有Broker启动的时候会向NameSrv注册自己的信息。Producer会根据目标topic从NameSrv获取到达指定Broker的路由信息，Consumer同理。</li></ul><h2><b>3  jms服务</b></h2><p>刚才讲到jms服务，是一套基本MQ协议规范，基本所有的MQ都遵循，故有必要了解以下：</p><p> a 两种消息模型</p><p>     P2P（Point to Point） 即一旦被消费，消息就不再在消息队列中，保证每个消息都能消费</p><p>     Publish/Subscribe(Pub/Sub)  广播模式， 一个消息可以人人消费</p><p> b 消费方式 </p><p>    在JMS中，消息的产生和消费是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。</p><p>（1）同步：订阅者或接收者通过receive方法来接收消息，receive方法在接收到消息之前（或超时之前）将一直阻塞；</p><p>（2）异步：订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</p><h2><b>4 topic \\tag</b></h2><p>发送消息的时候指定会指定topic(简单理解为消息分类)，如果producer集合中没有会根据指定topic到namesrv获取topic发布信息TopicPublishInfo，并放入本地集合，定时从namesrv更新topic路由信息。</p><p>tag标签可以理解为更细一级的主题 ,标签可以让你的代码变得清晰连贯，还可以给RocketMQ提供更好的查询支持。</p><blockquote>举个栗子，订单系统，topic可以设为“order”,tag设置为 orderId</blockquote><p>如何理解topic下的队列：</p><blockquote>比如broker1, broker2, borker3三台broker机器都配置了Topic_A  <br/>Broker1 的队列为queue0 , queue1  <br/>Broker2 的队列为queue0, queue2, queue3,  <br/>Broker3 的队列为queue0  <br/>当然一般情况下的broker的配置都是一样的  以上当broker启动的时候注册到namesrv的Topic_A队列为共6个分别为：  broker1_queue0, broker1_queue1,  broker2_queue0, broker2_queue1, broker2_queue2,  broker3_queue0</blockquote><h2><b>5 producer轮询方式发送消息（保持了负载均衡）</b></h2><p>Producer从namesrv获取的到Topic_A路由信息TopicPublishInfo  ：      </p><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;MessageQueue&gt; messageQueueList  //Topic_A的所有的队列            \nAtomicInteger   sendWhichQueue        //自增整型             </code></pre></div><p>每次通过<b>原子计数器</b>来选择轮询发送哪个队列  ，即求出</p><div class=\"highlight\"><pre><code class=\"language-text\"> (++sendWitchQueue)% messageQueueList.size</code></pre></div><p>队列集合的下标，如果入参lastBrokerName不为空，代表上次选择的queue发送失败，这次选择应该避开同一个queue</p><h2><b>6 顺序消息发送</b></h2><p>有时需要保证消息的有序性，即要rocketMQ需要producer保证顺序消息按顺序发送到同一个queue中。</p><p>比如某一个USER购买流程(1)下单(2)支付(3)支付成功这三个消息需要根据特定规则将这个三个消息按顺序发送到一个queue ,步骤：</p><p>一般消息是通过轮询所有队列发送的，顺序消息可以根据业务比如说订单号orderId相同的消息发送到同一个队列, 或者同一用户userId发送到同一队列等等  </p><div class=\"highlight\"><pre><code class=\"language-text\">messageQueueList [orderId%messageQueueList.size()]  \nmessageQueueList [userId%messageQueueList.size()] </code></pre></div><h2><b>7 comsumer消费消息</b></h2><p>offset偏移量，当comsumer准备消费消息之前，队列中可能已经存在消息，设置偏移量从第一条读 ，如果非第一次启动，那么按照上次消费的位置继续消费：</p><div class=\"highlight\"><pre><code class=\"language-text\"> consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</code></pre></div><p>pull 主动去拉读取；</p><p>push 添加监听器实时推送读取（观察者模式）；</p><p>MessageListenerOrderly 发送顺序消息的监听 ，保证消息到达有序，消费者只允许有一个线程在接收消息，因为broker只保证是顺序到达，不保证在消费的时候也能顺序消费。</p><p></p>", 
            "topic": [
                {
                    "tag": "RocketMQ", 
                    "tagLink": "https://api.zhihu.com/topics/20072112"
                }, 
                {
                    "tag": "消息队列", 
                    "tagLink": "https://api.zhihu.com/topics/19708788"
                }, 
                {
                    "tag": "消息", 
                    "tagLink": "https://api.zhihu.com/topics/19652134"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45724441", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 1, 
            "title": "rocketMQ操作篇——心有猛虎", 
            "content": "<p>这世上学习的方法有很多种，我是属于那种现实操作流派，什么东西都喜欢先操作一遍再来探究理论，先解决温饱，再来追求文明 ,下面进入如何快速部署rocketMQ环节。</p><p>下载地址：</p><div class=\"highlight\"><pre><code class=\"language-text\">http://rocketmq.apache.org/docs/quick-start/</code></pre></div><p><b>0 部署环境：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt; unzip rocketmq-all-4.3.0-source-release.zip   \n&gt; cd rocketmq-all-4.3.0/   \n&gt; mvn -Prelease-all -DskipTests clean install -U \n&gt; cd distribution/target/apache-rocketmq</code></pre></div><p><b>distribution/target/apache-rocketmq 这个当作是MQ根目录。</b></p><p>加环境变量 vim  /etc/profile  注意linux下用冒号分割开:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7a7fe3ef71d5c93f56b972b8abf8bc3e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic3.zhimg.com/v2-7a7fe3ef71d5c93f56b972b8abf8bc3e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;124&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic3.zhimg.com/v2-7a7fe3ef71d5c93f56b972b8abf8bc3e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7a7fe3ef71d5c93f56b972b8abf8bc3e_b.jpg\"/></figure><p><b>1 启动nameserver</b></p><p>在ROCKET_HOME路径下执行命令nohup...(后台运行)</p><p>可以查看日志</p><div class=\"highlight\"><pre><code class=\"language-text\"> &gt; nohup sh bin/mqnamesrv &amp;  \n &gt; tail -f ~/logs/rocketmqlogs/namesrv.log   \n   The Name Server boot success...\n</code></pre></div><p><b>2 启动broker</b></p><p>Broker节点的配置文件在/rocketmq/conf下面，有三种配置方式：</p><ul><li>2m-noslave： 多Master模式</li><li>2m-2s-sync： 多Master多Slave模式，同步双写</li><li>2m-2s-async：多Master多Slave模式，异步复制</li></ul><p>在ROCKET_HOME路径下执行命令</p><div class=\"highlight\"><pre><code class=\"language-text\">nohup sh mqbroker &amp;</code></pre></div><p>如果<b>没有注册环境变量NAMESRV_ADDR</b>执行</p><div class=\"highlight\"><pre><code class=\"language-text\">nohup sh mqbroker -n服务器IP:9876 &amp;</code></pre></div><p>如有多个broker的配置文件，<b>则还要加上启动哪个broker的配置文件</b>，<b>终极语句</b>如:</p><div class=\"highlight\"><pre><code class=\"language-text\">nohup sh mqbroker -n 服务器IP:9876 -c $ROCKETMQ_HOME/conf/2m-noslave/broker-a.properties &amp;</code></pre></div><p>查看日志：</p><div class=\"highlight\"><pre><code class=\"language-text\">   tail -f ~/logs/rocketmqlogs/broker.log    \n    The broker[%s, 172.30.30.233:10911] boot success...</code></pre></div><p>注意：一般单机做测试的话，namesrv和brocker会耗很大内存，可以修改以下两个sh文件,b比如修改为512M,至于为什么这样修改，涉及到java虚拟机性能调优，后开写专题再讨论，一般来说，正常项目线上环境内存够用，不用调这两个：</p><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//runserver.sh\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">runserver.sh</a>  （namesrv 配置）</li><li>runbroker .sh （brocker 配置）</li></ul><p><b>3  关闭，一般先关闭所有的broker，再关闭nameserver</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&gt; sh bin/mqshutdown broker \n   The mqbroker(36695) is running... Send shutdown request to mqbroker(36695) OK  \n&gt; sh bin/mqshutdown namesrv \n   The mqnamesrv(36664) is running... Send shutdown request to mqnamesrv(36664) OK</code></pre></div><p><b>4 测试</b></p><p>RocketMQ有自带的调试工具模拟Producer和Consumer</p><div class=\"highlight\"><pre><code class=\"language-text\"> &gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer  \n    SendResult [sendStatus=SEND_OK, msgId= ...   \n &gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer  \n    ConsumeMessageThread_%d Receive New Messages: [MessageExt...</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "RocketMQ", 
                    "tagLink": "https://api.zhihu.com/topics/20072112"
                }, 
                {
                    "tag": "消息队列", 
                    "tagLink": "https://api.zhihu.com/topics/19708788"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45677715", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 2, 
            "title": "搭建Maven+nexus私服", 
            "content": "<h2><b>一、私服应用场景</b></h2><p>有些公司都不提供外网给项目组人员，因此就不能使用maven访问远程的仓库地址，所以很有必要在局域网里找一台有外网权限的机器，搭建nexus私服;</p><p>项目做的一些公共入口服务，例如SDK,可以上传至私服供其他项目组使用；</p><p>如果某个IP地址恶意的下载中央仓库内容，例如全公司100台机器使用同一个IP反复下载，这个IP（甚至是IP段）会进入黑名单，因此稍有规模的使用Maven时，应架设私服。</p><p>总结两点：</p><p>a、自己maven私服更容易维护，公司开发从maven私服迁出jar到本地仓库更快</p><p>b、有些公司未开放外网给开发人员</p><h2><b>二、搭建过程</b></h2><p><b>1. 环境 （百度云盘）</b></p><ul><li>nexus-3.13.0-01-unix.tar.gz</li><li>apache-maven-3.5.4-bin.tar.gz</li></ul><p><b>2. 配置Maven</b></p><div class=\"highlight\"><pre><code class=\"language-text\">tar -zxvf apache-maven-3.5.2-bin.tar.gz -C usr/local/</code></pre></div><p>  增加maven环境变量</p><div class=\"highlight\"><pre><code class=\"language-text\">vim /etc/profile \n\n#maven\nMAVEN_HOME=/usr/local/maven3.5\nexport MAVEN_HOME\nexport PATH=${PATH}:${MAVEN_HOME}/bin\n\nsource /etc/profile\n\nmvn -v 查看是否生效</code></pre></div><p><b>3. 配置Nexus3.13.0</b></p><div class=\"highlight\"><pre><code class=\"language-text\">tar -zxvf apache-maven-3.5.2-bin.tar.gz -C /usr/local/</code></pre></div><p>在/nexus-3.13.0-0/bin/下启动 nexus 的两种方式：</p><div class=\"highlight\"><pre><code class=\"language-text\">  ./nexus start (关闭是stop)\n  ./nexus run &amp; (后台运行)</code></pre></div><blockquote><b>启动后，即可访问localhost:8081/ 后台</b></blockquote><ol><li>nexus3 的etc 中配置文件默认是8081端口</li><li>nexus3默认账号是:admin </li><li>nexus3默认密码是:admin123</li></ol><p>无法访问后台的话，记得通过防火墙设置远程访问 在Nexus 的bin下执行：</p><div class=\"highlight\"><pre><code class=\"language-text\">[root@MiWiFi-R3-srv bin]# firewall-cmd --zone=public --add-port=8081/tcp --permanent \n[root@MiWiFi-R3-srv bin]# firewall-cmd --reload\n</code></pre></div><p><b>4. 需要上传的maven项目的pom文件</b></p><p>添加如下2部分：</p><p>1 部署构件</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;distributionManagement&gt;\n    &lt;repository&gt;\n        &lt;id&gt;ht-nexus-releases&lt;/id&gt;\n        &lt;name&gt;镜像releases&lt;/name&gt;\n        &lt;url&gt;http://IP:8081/repository/maven-public&lt;/url&gt;\n    &lt;/repository&gt;\n    &lt;snapshotRepository&gt;\n        &lt;id&gt;ht-nexus-snapshots&lt;/id&gt;\n        &lt;name&gt;镜像snapshots&lt;/name&gt;\n        &lt;url&gt;http://IP:8081/repository/maven-snapshots&lt;/url&gt;\n    &lt;/snapshotRepository&gt;\n&lt;/distributionManagement&gt;</code></pre></div><p>2 maven 编译插件</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;build&gt;\n    &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;\n            &lt;version&gt;2.2.1&lt;/version&gt;\n            &lt;executions&gt;\n                &lt;execution&gt;\n                    &lt;id&gt;attach-sources&lt;/id&gt;\n                    &lt;phase&gt;verify&lt;/phase&gt;\n                    &lt;goals&gt;\n                        &lt;goal&gt;jar-no-fork&lt;/goal&gt;\n                    &lt;/goals&gt;\n                &lt;/execution&gt;\n            &lt;/executions&gt;\n        &lt;/plugin&gt;\n\n\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n            &lt;version&gt;3.2&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;1.7&lt;/source&gt;\n                &lt;target&gt;1.7&lt;/target&gt;\n                &lt;encoding&gt;UTF-8&lt;/encoding&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;</code></pre></div><p><b>5. 本地maven的setting文件</b></p><p>(1) 设置2个镜像 + 2个server</p><p>(2) profle 中代表着 让nexus 成为中央库的代理</p><p>整个Maven setting 的样子，需要的仁人志士可以直接开启血冷眼 : </p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;\n&lt;settings xmlns=&#34;http://maven.apache.org/SETTINGS/1.1.0&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd&#34;&gt;  \n  &lt;mirrors&gt;\n      &lt;mirror&gt;\n          &lt;id&gt;ht-nexus-releases&lt;/id&gt;\n          &lt;name&gt;镜像releases&lt;/name&gt;\n          &lt;url&gt;http://IP:8081/repository/maven-public/&lt;/url&gt;\n          &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\n      &lt;/mirror&gt;\n\n\n      &lt;mirror&gt;\n          &lt;id&gt;ht-nexus-snapshots&lt;/id&gt;\n          &lt;name&gt;镜像snapshots&lt;/name&gt;\n          &lt;url&gt;http://IP:8081/repository/maven-snapshots/&lt;/url&gt;\n          &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\n      &lt;/mirror&gt;\n\n\n      &lt;mirror&gt;\n          &lt;id&gt;nexus-aliyun&lt;/id&gt;\n          &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n          &lt;name&gt;Nexus aliyun&lt;/name&gt;\n          &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;\n      &lt;/mirror&gt;\n&lt;/mirrors&gt;\n\n\n  &lt;pluginGroups&gt; \n    &lt;!-- for maven cargo plugin --&gt;  \n    &lt;pluginGroup&gt;org.codehaus.cargo&lt;/pluginGroup&gt; \n  &lt;/pluginGroups&gt;  \n\n\n  &lt;proxies/&gt;  \n \n  &lt;servers&gt; \n\t&lt;server&gt;  \n\t\t&lt;id&gt;ht-nexus-releases&lt;/id&gt;\n\t\t&lt;username&gt;admin&lt;/username&gt;  \n\t\t&lt;password&gt;admin123&lt;/password&gt;\n\t&lt;/server&gt;\n\n\n\t&lt;server&gt;  \n\t    &lt;id&gt;ht-nexus-snapshots&lt;/id&gt;  \n\t\t&lt;username&gt;admin&lt;/username&gt;  \n\t\t&lt;password&gt;admin123&lt;/password&gt;\n\t&lt;/server&gt;\n  &lt;/servers&gt; \n \n  &lt;profiles&gt; \n     &lt;profile&gt;\n      &lt;id&gt;nexus&lt;/id&gt;\n      &lt;!--Enable snapshots for the built in central repo to direct --&gt;\n      &lt;!--all requests to nexus via the mirror --&gt;\n      &lt;repositories&gt;\n        &lt;repository&gt;\n          &lt;id&gt;central&lt;/id&gt;\n          &lt;url&gt;http://central&lt;/url&gt;\n          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;\n          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;\n        &lt;/repository&gt;\n      &lt;/repositories&gt;\n     &lt;pluginRepositories&gt;\n        &lt;pluginRepository&gt;\n          &lt;id&gt;central&lt;/id&gt;\n          &lt;url&gt;http://central&lt;/url&gt;\n          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;\n          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;\n        &lt;/pluginRepository&gt;\n      &lt;/pluginRepositories&gt;\n    &lt;/profile&gt;\n  &lt;/profiles&gt; \n \n  &lt;activeProfiles&gt; \n    &lt;activeProfile&gt;nexus&lt;/activeProfile&gt; \n  &lt;/activeProfiles&gt; \n&lt;/settings&gt;</code></pre></div><p><br/><b>6. 上传项目包到maven私服</b></p><p> （1）利用 idea deploy </p><p> （2）或者 cmd 命令：</p><p><b>    A.发布不带pom文件的独立jar包：</b> </p><div class=\"highlight\"><pre><code class=\"language-text\"> mvn deploy:deploy-file -DgroupId=&lt;group-id&gt; \\ \n -DartifactId=&lt;artifact-id&gt; \\ \n -Dversion=&lt;version&gt; \\ \n -Dpackaging=&lt;type-of-packaging&gt; \\\n -Dfile=&lt;path-to-file&gt; \\ \n -DrepositoryId=&lt;id-to-map-on-server-section-of-settings.xml&gt; \\   这个是serverId\n -Durl=&lt;url-of-the-repository-to-deploy&gt;</code></pre></div><p>默认情况下，maven会自动为jar包创建pom文件，如果只想保留独立jar包，可以使用参数关闭这个特性： -DgeneratePom=false</p><p><b>    B. 发布带有pom的jar包</b></p><div class=\"highlight\"><pre><code class=\"language-text\"> mvn deploy:deploy-file -DpomFile=&lt;path-to-pom&gt; \\\n -Dfile=&lt;path-to-file&gt; \\\n -DrepositoryId=&lt;id-to-map-on-server-section-of-settings.xml&gt; \\ \n -Durl=&lt;url-of-the-repository-to-deploy&gt;\n</code></pre></div><p><i>----------注意，最好设置为nexus服务为开机启动-----------------</i><br/></p><p><b>7. 其他项目引用maven私服依赖</b></p><p>maven setting 只需加入镜像依赖即可。</p><p>      &lt;mirror&gt;</p><p>          &lt;id&gt;ht-nexus-snapshots&lt;/id&gt;</p><p>          &lt;name&gt;镜像snapshots&lt;/name&gt;</p><p>          &lt;url&gt;<a href=\"https://link.zhihu.com/?target=http%3A//IP%3A8081/repository/maven-snapshots/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">IP:8081/repository/mave</span><span class=\"invisible\">n-snapshots/</span><span class=\"ellipsis\"></span></a>&lt;/url&gt;</p><p>          &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</p><p>      &lt;/mirror&gt;</p><p class=\"ztext-empty-paragraph\"><br/></p><p><i>后记：此篇并无高深理论与有趣演说，只是做一个笔记方便日后复用之。</i></p><p></p>", 
            "topic": [
                {
                    "tag": "Maven", 
                    "tagLink": "https://api.zhihu.com/topics/19629084"
                }, 
                {
                    "tag": "Google Nexus", 
                    "tagLink": "https://api.zhihu.com/topics/19604384"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "Fan Vic", 
                    "userLink": "https://www.zhihu.com/people/c7da2356c3de49a76af43852c818259a", 
                    "content": "请教一下，配置repository的时候为什么要写在profile里", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44939119", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 0, 
            "title": "java基于线程池的异步“行为”处理", 
            "content": "<p>最近做项目的时候遇到这样一个场景: </p><p>用户从前端提交素材消息【理解为文字+图片/视频/语音/文档等等】，项目后台接受消息后，需要先本地服务器存储相应素材[1]，再将消息发送至企业微信。</p><h2><b>1 问题</b></h2><p>上述场景后台存在2个动作：</p><p><b>first  动作A :  </b>存素材</p><p><b>second  动作B : </b> 调用企业微信API发送消息 </p><p>那么问题来了，假如现在存在大量消息需要发送，每条消息必须等前一条消息进行完上述两个动作才能发送，无疑会给系统增加很大时间开销，尤其是第一个动作如果逻辑特别复杂的情况下。所以仔细分析可发现，其实第一个动作可以改为异步进行，因为对用户来说，他并不care你后台存不存素材，先把主流步骤完成，这种额外操作就可延迟异步，类似的案例有很多：</p><p>商城抢优惠券购物，边抢边购物，抢不到优惠券，你仍可以购物</p><h2><b>2、处理</b></h2><p> 经过分析，可知将动作A改为异步，这里采用线程池处理：</p><div class=\"highlight\"><pre><code class=\"language-text\">ExecutorService executor = new ThreadPoolExecutor(1, 12, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(4000));</code></pre></div><p>上述线程池大家不陌生，但对于小细节参数<i>keepAliveTime，jdk中的解释为：当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。翻译成我们乡下话就是：</i></p><blockquote><i>比如说线程池中最大的线程数为50，而其中只有40个线程任务在跑，相当于有10个空闲线程，这10个空闲线程不能让他一直在开着，因为线程的存在也会特别好资源的，所有就需要设置一个这个空闲线程的存活时间，这么解释应该就很清楚了。　　——沃.自己硕德</i></blockquote><p>动作B操作是本次处理的核心. 动作A的异步处理：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-619031fb9558c290d64e0f4261ee53c6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1119\" data-rawheight=\"201\" class=\"origin_image zh-lightbox-thumb\" width=\"1119\" data-original=\"https://pic3.zhimg.com/v2-619031fb9558c290d64e0f4261ee53c6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1119&#39; height=&#39;201&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1119\" data-rawheight=\"201\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1119\" data-original=\"https://pic3.zhimg.com/v2-619031fb9558c290d64e0f4261ee53c6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-619031fb9558c290d64e0f4261ee53c6_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1a0588593a56014d7c1ec3c89e875eab_b.jpg\" data-size=\"normal\" data-rawwidth=\"985\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb\" width=\"985\" data-original=\"https://pic4.zhimg.com/v2-1a0588593a56014d7c1ec3c89e875eab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;985&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"985\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"985\" data-original=\"https://pic4.zhimg.com/v2-1a0588593a56014d7c1ec3c89e875eab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1a0588593a56014d7c1ec3c89e875eab_b.jpg\"/><figcaption>多线程实现runable接口</figcaption></figure><p>这样就能保证程序不会一直阻塞在动作A.</p><p>上述过程还有个小细节注意的是，由于我动作A,B都用到了素材文件的inputstream,由于inputstream内部并未实现cloneable接口，所以在多线程环境下容易造成阻塞。所以先将 inputstream转化为ByteArrayOutputStream，等用到时再还原成inputstream即可。</p><p>inputstream转化为ByteArrayOutputStream ：</p><div class=\"highlight\"><pre><code class=\"language-text\">public static ByteArrayOutputStream inputStream2byteArr(InputStream input) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    byte[] buffer = new byte[1024];\n    int len;\n    while ((len = input.read(buffer)) &gt; -1 ) {\n        baos.write(buffer, 0, len);\n    }\n    input.close();\n    baos.flush();\n    baos.close();\n    return baos;\n}</code></pre></div><p>ByteArrayOutputStream 实例化 inputstream ：</p><div class=\"highlight\"><pre><code class=\"language-text\">InputStream stream1= new ByteArrayInputStream(byteArrayOutputStream.toByteArray());\nInputStream stream2 = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());</code></pre></div><h2><b>结束语：</b></h2><p>貌似分享得东西很简单啊，其实也只是让自己养成随手记录得习惯，自己印象可能更为深刻，诸君且看一笑了之，鄙人自得其乐。<br/></p><p><i>[1]之所以先本地服务器存储相应素材，是因为腾讯服务器上素材三天后过期。</i></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "线程池", 
                    "tagLink": "https://api.zhihu.com/topics/19721742"
                }, 
                {
                    "tag": "异步", 
                    "tagLink": "https://api.zhihu.com/topics/19571217"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44380897", 
            "userName": "愤怒的小吹球", 
            "userLink": "https://www.zhihu.com/people/15146624e262366dd05b4783b7a3b7a6", 
            "upvote": 15, 
            "title": "缓存篇 : Guava cache 之全面剖析", 
            "content": "<p>最近在项目中接触到redis分布式缓存，然后在我师父的指导下，本地缓存guava cache了解一下，不看不知道，一看吓一跳， Guava Cache是本地缓存的不二之选呵，当然，我们也可以写一个map当作缓存，但无疑在多线程环境下，其<b>线程安全，容量溢出，垃圾回收</b>等均得仔细考究，下面来看看 Guava Cache的操作与原理。</p><p>请双手扶好键盘，一顿操作猛如虎：</p><h2><b>1 创建（加载）cache</b></h2><p> 两种方法 CacheLoader和Callable ，直接上代码 ：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cd199a8db410bc1096f79f5e40cc9702_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"893\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb\" width=\"893\" data-original=\"https://pic3.zhimg.com/v2-cd199a8db410bc1096f79f5e40cc9702_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;893&#39; height=&#39;442&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"893\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"893\" data-original=\"https://pic3.zhimg.com/v2-cd199a8db410bc1096f79f5e40cc9702_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cd199a8db410bc1096f79f5e40cc9702_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-44fd76a392f4f0e8a0ee0937fae69dce_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"809\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb\" width=\"809\" data-original=\"https://pic3.zhimg.com/v2-44fd76a392f4f0e8a0ee0937fae69dce_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;809&#39; height=&#39;310&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"809\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"809\" data-original=\"https://pic3.zhimg.com/v2-44fd76a392f4f0e8a0ee0937fae69dce_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-44fd76a392f4f0e8a0ee0937fae69dce_b.jpg\"/></figure><p>以上两种，都实现了一种逻辑：<b>先取缓存——娶不到再执行load 或者call方法来娶</b>。简单比较，CacheLoader 是按key统一加载，所有娶不到的统一执行一种load逻辑；而callable方法允许在get的时候指定key，这就告诉我们一个道理：</p><blockquote><i>在使用缓存前，拍拍自己的四两胸肌，问自己一个问题：有没有【默认方法】来加载或计算与键关联的值？如果有的话，你应当使用CacheLoader。如果没有，或者想要覆盖默认的加载运算。你应该在调用get时传入一个Callable实例。----沃*自己硕德</i></blockquote><h2><b>2 添加 ,插入key</b></h2><p><b>get :</b>  要么返回已经缓存的值，要么使用CacheLoader向缓存原子地加载新值；</p><p><b>getUnchecked</b>：CacheLoader 会抛异常，定义的CacheLoader没有声明任何检查型异常，则可以 getUnchecked 查找缓存；<b>反之不能；</b></p><p><b>getAll ：</b>方法用来执行批量查询；</p><p><b>put : </b> 向缓存显式插入值，Cache.asMap()也能修改值，但不具原子性；</p><p><b>getIfPresent ：</b>该方法只是简单的把Guava Cache当作Map的替代品，不执行load方法；</p><h2><b>3 清除 key</b></h2><p>guava cache 自带 清除机制，但仍旧可以手动清除： </p><p>个别清除：Cache.invalidate(key) </p><p>批量清除：Cache.invalidateAll(keys) </p><p>清除所有缓存项：Cache.invalidateAll()</p><h2><b>4 refresh和expire刷新机制</b></h2><p>expireAfterAccess(30, TimeUnit.<i>MINUTES </i>) // 30min内没有被读或写就会被回收 ；</p><p>expireAfterWrite(30, TimeUnit.<i>MINUTES </i>) // 30min内没有没有更新就会被回收 ：</p><p>refreshAfterAccess(30, TimeUnit.<i>MINUTES</i>) //上一次更新操作30min后再刷新；</p><p>注意这里面精准的措辞，<b>“30min内没有被读或写就会被回收” 不等于 “30min内会被回收” ，因为真正的过期/刷新操作是在key被读或写时发生的。</b></p><p>先用一张图说明expire 与refresh的大体过程：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-92eacd0678bdefa491590f6552f51e40_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb\" width=\"913\" data-original=\"https://pic1.zhimg.com/v2-92eacd0678bdefa491590f6552f51e40_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;913&#39; height=&#39;287&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"913\" data-original=\"https://pic1.zhimg.com/v2-92eacd0678bdefa491590f6552f51e40_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-92eacd0678bdefa491590f6552f51e40_b.jpg\"/></figure><p>从图上容易看出，每次只有找不到值都会进入load方法，换句话说，只有发生“取值”操作，才会执行load，<b>然而为了防止“缓存穿透”，在多线程的环境下，任何时刻只允许一个线程操作执行load操作 。</b></p><p>但在执行load操作这个步骤，<b>expire 与 refresh 的线程机制不同</b>：</p><p><b>expire 在load 阶段——同步机制：</b>当前线程load未完成，其他线程呈阻塞状态，待当前线程load完成，其他线程均需进行”获得锁--获得值--释放锁“的过程。这种方法会让性能有一定的损耗。</p><p><b>refresh 在load阶段——异步机制 ：</b>当前线程load未完成，其他线程仍可以取原来的值，等当前线程load完成后，下次某线程再取值时，会判断系统时间间隔是否时超过设定refresh时间，来决定是否设定新值。所以，refresh机制的特点是，<b>设定30分钟刷新，30min后并不一定就是立马就能保证取到新值。</b></p><p>那么问题来了，expire与refresh 都能控制key得回收，究竟如何选择？</p><p>答案是，<b>两个一起来！</b></p><p>能够想象，只要refresh得时间小于expire时间，就能保证多线程在load取值时不阻塞，也能保证refresh时间到期后，取旧值向新值得平滑过渡，当然，<b>仍旧不能解决取到旧值得问题</b>。</p><h2><b>5 监听</b></h2><p><b>在guava cache中移除key可以设置相应得监听操作，</b>以便key被移除时做一些额外操作。缓存项被移除时，RemovalListener会获取移除通知[RemovalNotification]，其中包含移除原因[RemovalCause]、键和值。监听有同步监听和异步监听两种 :</p><p><b> 同步监听 </b></p><p>默认情况下，监听器方法是被同步调用的（在移除缓存的那个线程中执行）,执行清理key的操作与执行监听是单线程模式，当然监听器中抛出的任何异常都不会影响其正常使用，顶多把异常写到日记了。同步监听示例：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f6bd407cb480e3e896649b5f3a73bf4e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"951\" data-rawheight=\"549\" class=\"origin_image zh-lightbox-thumb\" width=\"951\" data-original=\"https://pic3.zhimg.com/v2-f6bd407cb480e3e896649b5f3a73bf4e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;951&#39; height=&#39;549&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"951\" data-rawheight=\"549\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"951\" data-original=\"https://pic3.zhimg.com/v2-f6bd407cb480e3e896649b5f3a73bf4e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f6bd407cb480e3e896649b5f3a73bf4e_b.jpg\"/></figure><p><b>异步监听</b></p><p>试想这么一种情景，假如在同步监听模式下，<b>监听方法中的逻辑特别复杂，执行效率慢，那此时如果有大量的key进行清理，会使整个缓存性能变得很低下</b>，所以此时适合用异步监听，移除key与监听key的移除分属2个线程。异步监听示例：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f1280726364dc6b4c48a8ee5b32cc78e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"998\" data-rawheight=\"585\" class=\"origin_image zh-lightbox-thumb\" width=\"998\" data-original=\"https://pic3.zhimg.com/v2-f1280726364dc6b4c48a8ee5b32cc78e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;998&#39; height=&#39;585&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"998\" data-rawheight=\"585\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"998\" data-original=\"https://pic3.zhimg.com/v2-f1280726364dc6b4c48a8ee5b32cc78e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f1280726364dc6b4c48a8ee5b32cc78e_b.jpg\"/></figure><h2><b>6 统计</b></h2><p>guava cache还有一些其他特性，比如weight 按权重回收资源，统计等，这里列出统计。<b>CacheBuilder.recordStats()用来开启Guava Cache的统计功能</b>。统计打开后Cache.stats()方法返回如下统计信息：</p><ul><li>hitRate()：缓存命中率；</li><li>hitMiss():  缓存失误率；</li><li>loadcount() ; 加载次数；</li><li>averageLoadPenalty()：加载新值的平均时间，单位为纳秒；</li><li>evictionCount()：缓存项被回收的总数，不包括显式清除。</li></ul><p>唯一值得注意的一点是：<b>当通过asmap（）方法查询key时，stat项是不作任何变化的</b>，修改值时会有影响。此外，还有其他很多统计信息。这些统计信息对于调整缓存设置是至关重要的，在性能监控时可以依据的重要指标。</p>", 
            "topic": [
                {
                    "tag": "缓存", 
                    "tagLink": "https://api.zhihu.com/topics/19564998"
                }, 
                {
                    "tag": "Guava", 
                    "tagLink": "https://api.zhihu.com/topics/20185346"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>可以可以 收藏了</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/frankyho"
}
