{
    "title": "云胡不喜", 
    "description": "云何以为云", 
    "followers": [
        "https://www.zhihu.com/people/edwardxu-89", 
        "https://www.zhihu.com/people/038704", 
        "https://www.zhihu.com/people/sumory-wu", 
        "https://www.zhihu.com/people/ha-ha-ha-98-6-80", 
        "https://www.zhihu.com/people/zhou-feng-xian-45", 
        "https://www.zhihu.com/people/lun-na-de-16", 
        "https://www.zhihu.com/people/40669370", 
        "https://www.zhihu.com/people/xing-dong-liang-19", 
        "https://www.zhihu.com/people/reader2018", 
        "https://www.zhihu.com/people/zhang-yong-chang-63", 
        "https://www.zhihu.com/people/qiang-wei-22-83", 
        "https://www.zhihu.com/people/xu-yan-85-76", 
        "https://www.zhihu.com/people/li-wei-er-54", 
        "https://www.zhihu.com/people/wgfxcu-88", 
        "https://www.zhihu.com/people/hangjun-53", 
        "https://www.zhihu.com/people/jiakon", 
        "https://www.zhihu.com/people/liu-lin-qi-78", 
        "https://www.zhihu.com/people/sysctl", 
        "https://www.zhihu.com/people/cutz", 
        "https://www.zhihu.com/people/zagnix", 
        "https://www.zhihu.com/people/Radar3", 
        "https://www.zhihu.com/people/hu-er-jin-xia-37-75", 
        "https://www.zhihu.com/people/zheng-xiu-jing", 
        "https://www.zhihu.com/people/wind-95", 
        "https://www.zhihu.com/people/wo-mei-26", 
        "https://www.zhihu.com/people/--help", 
        "https://www.zhihu.com/people/hong-lan-rao", 
        "https://www.zhihu.com/people/deng-dai-hua-mi", 
        "https://www.zhihu.com/people/liu246437", 
        "https://www.zhihu.com/people/cybort-21", 
        "https://www.zhihu.com/people/supermxc", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/jiang-4-60", 
        "https://www.zhihu.com/people/yang-kan-81", 
        "https://www.zhihu.com/people/szqh97", 
        "https://www.zhihu.com/people/torwang", 
        "https://www.zhihu.com/people/programmer_song", 
        "https://www.zhihu.com/people/feng-yu-zhe-21-63", 
        "https://www.zhihu.com/people/yt-yt-34", 
        "https://www.zhihu.com/people/liu-lang-de-tian-shu-a", 
        "https://www.zhihu.com/people/nigel-li-46", 
        "https://www.zhihu.com/people/guoqiang-zheng-81", 
        "https://www.zhihu.com/people/gu-shu-9-5", 
        "https://www.zhihu.com/people/rsysw", 
        "https://www.zhihu.com/people/pseudocodes", 
        "https://www.zhihu.com/people/cui-xiao-chen-82", 
        "https://www.zhihu.com/people/imxiaobo", 
        "https://www.zhihu.com/people/magictour", 
        "https://www.zhihu.com/people/wang-hg", 
        "https://www.zhihu.com/people/cai-yu-qiang-65", 
        "https://www.zhihu.com/people/li-wen-chao-99", 
        "https://www.zhihu.com/people/zhang-yi-qian", 
        "https://www.zhihu.com/people/solarhell", 
        "https://www.zhihu.com/people/li-han-yi-35-34", 
        "https://www.zhihu.com/people/tornodo", 
        "https://www.zhihu.com/people/rocketzhang", 
        "https://www.zhihu.com/people/devil-bsd", 
        "https://www.zhihu.com/people/Ted_Liang", 
        "https://www.zhihu.com/people/lhx521", 
        "https://www.zhihu.com/people/chen-yi-liang-64-71", 
        "https://www.zhihu.com/people/iskywalker", 
        "https://www.zhihu.com/people/insight-jing", 
        "https://www.zhihu.com/people/KennyOu", 
        "https://www.zhihu.com/people/wu-zhi-bo-67", 
        "https://www.zhihu.com/people/yuweiz", 
        "https://www.zhihu.com/people/ou-yang-kang-87", 
        "https://www.zhihu.com/people/bai-yao-wei", 
        "https://www.zhihu.com/people/brian-li", 
        "https://www.zhihu.com/people/shengyinng", 
        "https://www.zhihu.com/people/appleleaf", 
        "https://www.zhihu.com/people/li-li-4-91-98", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/hu-hao-kun", 
        "https://www.zhihu.com/people/zeng-yan-jian", 
        "https://www.zhihu.com/people/zheng-si-wen", 
        "https://www.zhihu.com/people/buerse", 
        "https://www.zhihu.com/people/he-landao", 
        "https://www.zhihu.com/people/zhouyujiang", 
        "https://www.zhihu.com/people/hansir-66-1", 
        "https://www.zhihu.com/people/zealoussnow", 
        "https://www.zhihu.com/people/yong-andy", 
        "https://www.zhihu.com/people/simonhao", 
        "https://www.zhihu.com/people/senlie", 
        "https://www.zhihu.com/people/xiejunlong", 
        "https://www.zhihu.com/people/yang-yang-21-70-24", 
        "https://www.zhihu.com/people/wen-qing-71", 
        "https://www.zhihu.com/people/kondi", 
        "https://www.zhihu.com/people/feng-kun-66", 
        "https://www.zhihu.com/people/mu-mu-31-13-6", 
        "https://www.zhihu.com/people/feng-zhi-gu-14", 
        "https://www.zhihu.com/people/luo-po-de-xiao-shu-tong", 
        "https://www.zhihu.com/people/xie-cheng-sheng-43", 
        "https://www.zhihu.com/people/codingfor", 
        "https://www.zhihu.com/people/jingyi244", 
        "https://www.zhihu.com/people/liu-tian-25-85", 
        "https://www.zhihu.com/people/SpectorMercurial", 
        "https://www.zhihu.com/people/GammaGo", 
        "https://www.zhihu.com/people/wang-lin-21-53", 
        "https://www.zhihu.com/people/jiongdu", 
        "https://www.zhihu.com/people/luoxuan-73", 
        "https://www.zhihu.com/people/chen-qing-68", 
        "https://www.zhihu.com/people/xhinliang", 
        "https://www.zhihu.com/people/dulingqiang", 
        "https://www.zhihu.com/people/jun-liu-11", 
        "https://www.zhihu.com/people/sulvto", 
        "https://www.zhihu.com/people/zheng-hao-18", 
        "https://www.zhihu.com/people/hengf", 
        "https://www.zhihu.com/people/vonng", 
        "https://www.zhihu.com/people/shuweiqun", 
        "https://www.zhihu.com/people/fu-dong-wei", 
        "https://www.zhihu.com/people/xlows1227", 
        "https://www.zhihu.com/people/sky-15", 
        "https://www.zhihu.com/people/zvampirem", 
        "https://www.zhihu.com/people/fiisio", 
        "https://www.zhihu.com/people/xiao-yang-90-96", 
        "https://www.zhihu.com/people/qiao-li-yong", 
        "https://www.zhihu.com/people/axurez", 
        "https://www.zhihu.com/people/fjrti", 
        "https://www.zhihu.com/people/orangeapple", 
        "https://www.zhihu.com/people/nan-yi-zhong-cheng", 
        "https://www.zhihu.com/people/yanbin", 
        "https://www.zhihu.com/people/song-jia-yu-97", 
        "https://www.zhihu.com/people/blue-wu-68", 
        "https://www.zhihu.com/people/tan-long-44", 
        "https://www.zhihu.com/people/vm-ll", 
        "https://www.zhihu.com/people/chen-miu-96", 
        "https://www.zhihu.com/people/guo-zhi-qiang-42-91", 
        "https://www.zhihu.com/people/song-xin-21-27-89", 
        "https://www.zhihu.com/people/li-jing-79", 
        "https://www.zhihu.com/people/xiao-qi-e-77-51", 
        "https://www.zhihu.com/people/zhang-xiao-miao-74-31", 
        "https://www.zhihu.com/people/guyue-43-96", 
        "https://www.zhihu.com/people/qian-long-73", 
        "https://www.zhihu.com/people/xiandongqi", 
        "https://www.zhihu.com/people/jie-zhao", 
        "https://www.zhihu.com/people/ding-duo-63", 
        "https://www.zhihu.com/people/way-billy", 
        "https://www.zhihu.com/people/james-liu-56", 
        "https://www.zhihu.com/people/lang-lang-40", 
        "https://www.zhihu.com/people/ma-da-12-30", 
        "https://www.zhihu.com/people/huangdx", 
        "https://www.zhihu.com/people/lvzhaoxing", 
        "https://www.zhihu.com/people/qi-shi-yu-58", 
        "https://www.zhihu.com/people/fan-yuan-35", 
        "https://www.zhihu.com/people/wang-min-7-46", 
        "https://www.zhihu.com/people/dong-dong-82-91", 
        "https://www.zhihu.com/people/lu-chu-kun", 
        "https://www.zhihu.com/people/happiernana", 
        "https://www.zhihu.com/people/pan-fei-16-79"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/40572954", 
            "userName": "杨阳", 
            "userLink": "https://www.zhihu.com/people/a6b0f11c0b760e965469fbb70ba66c58", 
            "upvote": 81, 
            "title": "让事件飞 ——Linux eventfd 原理与实践", 
            "content": "<h2><b>1. eventfd/timerfd 简介</b></h2><p>目前越来越多的应用程序采用事件驱动的方式实现功能，如何高效地利用系统资源实现通知的管理和送达就愈发变得重要起来。在Linux系统中，eventfd是一个用来通知事件的文件描述符，timerfd是的定时器事件的文件描述符。二者都是内核向用户空间的应用发送通知的机制，可以有效地被用来实现用户空间的事件/通知驱动的应用程序。</p><p>简而言之，就是eventfd用来触发事件通知，timerfd用来触发将来的事件通知。</p><p>开发者使用eventfd相关的系统调用，需要包含头文件；对于timerfd，则是。</p><p>系统调用eventfd/timerfd自linux 2.6.22版本加入内核，由Davide Libenzi最初实现和维护。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2. 接口及参数介绍</b></h2><h2>eventfd</h2><p>对于eventfd，只有一个系统调用接口</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"nf\">eventfd</span><span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">initval</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">flags</span><span class=\"p\">);</span></code></pre></div><p>创建一个eventfd对象，或者说打开一个eventfd的文件，类似普通文件的open操作。</p><p>该对象是一个内核维护的无符号的64位整型计数器。初始化为initval的值。</p><p>flags可以以下三个标志位的OR结果：</p><ul><li>EFD_CLOEXEC：FD_CLOEXEC，简单说就是fork子进程时不继承，对于多线程的程序设上这个值不会有错的。</li><li>EFD_NONBLOCK：文件会被设置成O_NONBLOCK，一般要设置。</li><li>EFD_SEMAPHORE：（2.6.30以后支持）支持semophore语义的read，简单说就值递减1。</li></ul><p>这个新建的fd的操作很简单：</p><p>read(): 读操作就是将counter值置0，如果是semophore就减1。</p><p>write(): 设置counter的值。</p><p>注意，还支持epoll/poll/select操作，当然，以及每种fd都都必须实现的close。</p><h2>timerfd</h2><p>对于timerfd，有三个涉及的系统调用接口</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"nf\">timerfd_create</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">clockid</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">flags</span><span class=\"p\">);</span>\n<span class=\"kt\">int</span> <span class=\"nf\">timerfd_settime</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">flags</span><span class=\"p\">,</span>\n                           <span class=\"k\">const</span> <span class=\"k\">struct</span> <span class=\"n\">itimerspec</span> <span class=\"o\">*</span><span class=\"n\">new_value</span><span class=\"p\">,</span>\n                           <span class=\"k\">struct</span> <span class=\"n\">itimerspec</span> <span class=\"o\">*</span><span class=\"n\">old_value</span><span class=\"p\">);</span>\n<span class=\"kt\">int</span> <span class=\"nf\">timerfd_gettime</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"k\">struct</span> <span class=\"n\">itimerspec</span> <span class=\"o\">*</span><span class=\"n\">curr_value</span><span class=\"p\">);</span></code></pre></div><p>timerfd_create就是用来创建新的timerfd对象，clockid可以指定时钟的种类，比较常用的有两种：CLOCK_REALTIME（实时时钟）或 CLOCK_MONOTONIC（单调递增时钟）。实时时钟是指系统的时钟，它可以被手工修改。而后者单调递增时钟则是不会被系统时钟的人为设置的不连续所影响的。通常选择后者。而flags的选择，TFD_CLOEXEC和TFD_NONBLOCK的意义就比较直接了。</p><p>timerfd_settime函数用来设置定时器的过期时间expiration。itmerspec结构定义如下：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">struct</span> <span class=\"n\">timespec</span> <span class=\"p\">{</span>\n    <span class=\"n\">time_t</span> <span class=\"n\">tv_sec</span><span class=\"p\">;</span>                <span class=\"cm\">/* Seconds */</span>\n    <span class=\"kt\">long</span>   <span class=\"n\">tv_nsec</span><span class=\"p\">;</span>               <span class=\"cm\">/* Nanoseconds */</span>\n<span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">itimerspec</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">timespec</span> <span class=\"n\">it_interval</span><span class=\"p\">;</span>  <span class=\"cm\">/* Interval for periodic timer */</span>\n    <span class=\"k\">struct</span> <span class=\"n\">timespec</span> <span class=\"n\">it_value</span><span class=\"p\">;</span>     <span class=\"cm\">/* Initial expiration */</span>\n<span class=\"p\">};</span></code></pre></div><p>该结构包含两个时间间隔：it_value是指第一次过期时间，it_interval是指第一次到期之后的周期性触发到期的间隔时间，（设为0的话就是到期第一次）。</p><p>old_value如果不为NULL，将会用调用时间来更新old_value所指的itimerspec结构对象。</p><p>timerfd_gettime()：返回当前timerfd对象的设置值到curr_value指针所指的对象。</p><p>read()：读操作的语义是：如果定时器到期了，返回到期的次数，结果存在一个8字节的整数(uint64_6)；如果没有到期，则阻塞至到期，或返回EAGAIN（取决于是否设置了NONBLOCK）。</p><p>另外，支持epoll，同eventfd。</p><h2><b>3. 使用实例 - 实现高性能消费者线程池</b></h2><p>生产者-消费者设计模式是常见的后台架构模式。本实例将实现多个生产者和多个消费者的事件通知框架，用以阐释eventfd/timerfd在线程通信中作为通知实现的典型场景。</p><p>本实例采用以下设计：生产者创建eventfd/timerfd并在事件循环中注册事件；消费者线程池中的线程共用一个epoll对象，每个消费者线程并行地进行针对eventfd或timerfd触发的事件循环的轮询（epoll_wait）。</p><h2>eventfd对应实现</h2><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">thread_info</span> <span class=\"p\">{</span>\n    <span class=\"n\">pthread_t</span> <span class=\"n\">thread_id</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">rank</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">epfd</span><span class=\"p\">;</span>\n<span class=\"p\">}</span> <span class=\"n\">thread_info_t</span><span class=\"p\">;</span>\n\n<span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"nf\">consumer_routine</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">thread_info</span> <span class=\"o\">*</span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">thread_info</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">data</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"o\">*</span><span class=\"n\">events</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">epfd</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">-&gt;</span><span class=\"n\">epfd</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">nfds</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">uint64_t</span> <span class=\"n\">result</span><span class=\"p\">;</span>\n\n    <span class=\"n\">log</span><span class=\"p\">(</span><span class=\"s\">&#34;Greetings from [consumer-%d]&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">-&gt;</span><span class=\"n\">rank</span><span class=\"p\">);</span>\n    <span class=\"n\">events</span> <span class=\"o\">=</span> <span class=\"n\">calloc</span><span class=\"p\">(</span><span class=\"n\">MAX_EVENTS_SIZE</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">epoll_event</span><span class=\"p\">));</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">events</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;calloc epoll events</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">);</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(;;)</span> <span class=\"p\">{</span>\n        <span class=\"n\">nfds</span> <span class=\"o\">=</span> <span class=\"n\">epoll_wait</span><span class=\"p\">(</span><span class=\"n\">epfd</span><span class=\"p\">,</span> <span class=\"n\">events</span><span class=\"p\">,</span> <span class=\"n\">MAX_EVENTS_SIZE</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">);</span> <span class=\"c1\">// poll every second\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nfds</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">events</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">events</span> <span class=\"o\">&amp;</span> <span class=\"n\">EPOLLIN</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">log</span><span class=\"p\">(</span><span class=\"s\">&#34;[consumer-%d] got event from fd-%d&#34;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">-&gt;</span><span class=\"n\">rank</span><span class=\"p\">,</span> <span class=\"n\">events</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">fd</span><span class=\"p\">);</span>\n                <span class=\"c1\">// consume events (reset eventfd)\n</span><span class=\"c1\"></span>                <span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">events</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">result</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">));</span>\n                <span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">events</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">fd</span><span class=\"p\">);</span>   <span class=\"c1\">// NOTE: need to close here\n</span><span class=\"c1\"></span>            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"nf\">producer_routine</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">thread_info</span> <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">thread_info</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">data</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"n\">event</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">epfd</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">epfd</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">efd</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\n    <span class=\"n\">log</span><span class=\"p\">(</span><span class=\"s\">&#34;Greetings from [producer-%d]&#34;</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rank</span><span class=\"p\">);</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n        <span class=\"c1\">// create eventfd (no reuse, create new every time)\n</span><span class=\"c1\"></span>        <span class=\"n\">efd</span> <span class=\"o\">=</span> <span class=\"n\">eventfd</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">EFD_CLOEXEC</span><span class=\"o\">|</span><span class=\"n\">EFD_NONBLOCK</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">efd</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;eventfd create: %s&#34;</span><span class=\"p\">,</span> <span class=\"n\">strerror</span><span class=\"p\">(</span><span class=\"n\">errno</span><span class=\"p\">));</span>\n        <span class=\"c1\">// register to poller\n</span><span class=\"c1\"></span>        <span class=\"n\">event</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"n\">efd</span><span class=\"p\">;</span>\n        <span class=\"n\">event</span><span class=\"p\">.</span><span class=\"n\">events</span> <span class=\"o\">=</span> <span class=\"n\">EPOLLIN</span> <span class=\"o\">|</span> <span class=\"n\">EPOLLET</span><span class=\"p\">;</span>    <span class=\"c1\">// Edge-Triggered\n</span><span class=\"c1\"></span>        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">epoll_ctl</span><span class=\"p\">(</span><span class=\"n\">epfd</span><span class=\"p\">,</span> <span class=\"n\">EPOLL_CTL_ADD</span><span class=\"p\">,</span> <span class=\"n\">efd</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">event</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ret</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;epoll_ctl&#34;</span><span class=\"p\">);</span>\n        <span class=\"c1\">// trigger (repeatedly)\n</span><span class=\"c1\"></span>        <span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">efd</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"mh\">0xffffffff</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">argc</span><span class=\"p\">,</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">argv</span><span class=\"p\">[])</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">thread_info</span> <span class=\"o\">*</span><span class=\"n\">p_list</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">c_list</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">epfd</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"c1\">// create epoll fd\n</span><span class=\"c1\"></span>    <span class=\"n\">epfd</span> <span class=\"o\">=</span> <span class=\"n\">epoll_create1</span><span class=\"p\">(</span><span class=\"n\">EPOLL_CLOEXEC</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">epfd</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;epoll_create1: %s&#34;</span><span class=\"p\">,</span> <span class=\"n\">strerror</span><span class=\"p\">(</span><span class=\"n\">errno</span><span class=\"p\">));</span>\n    <span class=\"c1\">// producers\n</span><span class=\"c1\"></span>    <span class=\"n\">p_list</span> <span class=\"o\">=</span> <span class=\"n\">calloc</span><span class=\"p\">(</span><span class=\"n\">NUM_PRODUCERS</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">thread_info</span><span class=\"p\">));</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">p_list</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;calloc&#34;</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">NUM_PRODUCERS</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">p_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">rank</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n        <span class=\"n\">p_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">epfd</span> <span class=\"o\">=</span> <span class=\"n\">epfd</span><span class=\"p\">;</span>\n        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">pthread_create</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">p_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">thread_id</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"n\">producer_routine</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">p_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ret</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;pthread_create&#34;</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// consumers\n</span><span class=\"c1\"></span>    <span class=\"n\">c_list</span> <span class=\"o\">=</span> <span class=\"n\">calloc</span><span class=\"p\">(</span><span class=\"n\">NUM_CONSUMERS</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">thread_info</span><span class=\"p\">));</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">c_list</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;calloc&#34;</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">NUM_CONSUMERS</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">c_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">rank</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n        <span class=\"n\">c_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">epfd</span> <span class=\"o\">=</span> <span class=\"n\">epfd</span><span class=\"p\">;</span>\n        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">pthread_create</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">c_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">thread_id</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"n\">consumer_routine</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">c_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ret</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;pthread_create&#34;</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// join and exit\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">NUM_PRODUCERS</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">pthread_join</span><span class=\"p\">(</span><span class=\"n\">p_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">thread_id</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ret</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;pthread_join&#34;</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">NUM_CONSUMERS</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">pthread_join</span><span class=\"p\">(</span><span class=\"n\">c_list</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">thread_id</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ret</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;pthread_join&#34;</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">p_list</span><span class=\"p\">);</span>\n    <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">c_list</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">EXIT_SUCCESS</span><span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><p>执行过程（2个生产者，4个消费者）：</p><div class=\"highlight\"><pre><code class=\"language-text\">[1532099804] Greetings from [producer-0]\n[1532099804] Greetings from [producer-1]\n[1532099804] Greetings from [consumer-0]\n[1532099804] Greetings from [consumer-1]\n[1532099804] Greetings from [consumer-2]\n[1532099804] Greetings from [consumer-3]\n[1532099805] [consumer-3] got event from fd-4\n[1532099805] [consumer-3] got event from fd-5\n[1532099806] [consumer-0] got event from fd-4\n[1532099806] [consumer-0] got event from fd-4\n[1532099807] [consumer-1] got event from fd-4\n[1532099807] [consumer-1] got event from fd-5\n[1532099808] [consumer-3] got event from fd-4\n[1532099808] [consumer-3] got event from fd-5\n^C</code></pre></div><p>结果符合预期（附：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Pro-YY/event_pool/blob/master/eventfd_pool.c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">源码链接</a>）</p><p>注意，推荐在eventfd在打开时设置<b>NON_BLOCKING</b>，并在注册至epoll监听对象时设为<b>EPOLLET</b>（尽管一次8字节的read就可以读完整个计数器到用户空间），因为毕竟，只有采用了非阻塞IO和边沿触发，epoll的并发能力才能完全发挥极致。</p><p>另外，本实例中的eventfd消费地非常高效，fd号几乎不会超过5（前四个分别为stdin/stdout/stderr/eventpoll），但实际应用中往往在close前会执行一些事务，随着消费者线程的增加，eventfd打开的文件也会增加（这个数值得上限由系统的ulimit -n决定）。然而，eventfd打开、读写和关闭都效非常高，因为它本质并不是文件，而是kernel在内核空间（内存中）维护的一个64位计数器而已。</p><h2>timerfd对应实现</h2><p>main函数和consumer线程实现几乎一致，而producer线程创建timerfd，并注册到事件循环中。</p><p>timer的it_value设为1秒，即第一次触发为1秒以后；it_interval设为3秒，即后续每3秒再次触发一次。</p><p>注意，timerfd_settime函数的位置与之前eventfd的write的相同，二者达到了类似的设置事件的作用，只不过这次是定时器事件。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"nf\">producer_routine</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">thread_info</span> <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">thread_info</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">data</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"n\">event</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">epfd</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">epfd</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">tfd</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">itimerspec</span> <span class=\"n\">its</span><span class=\"p\">;</span>\n    <span class=\"n\">its</span><span class=\"p\">.</span><span class=\"n\">it_value</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>    <span class=\"c1\">// initial expiration\n</span><span class=\"c1\"></span>    <span class=\"n\">its</span><span class=\"p\">.</span><span class=\"n\">it_value</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"n\">its</span><span class=\"p\">.</span><span class=\"n\">it_interval</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span> <span class=\"c1\">// interval\n</span><span class=\"c1\"></span>    <span class=\"n\">its</span><span class=\"p\">.</span><span class=\"n\">it_interval</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n    <span class=\"n\">log</span><span class=\"p\">(</span><span class=\"s\">&#34;Greetings from [producer-%d]&#34;</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rank</span><span class=\"p\">);</span>\n    <span class=\"c1\">// create timerfd\n</span><span class=\"c1\"></span>    <span class=\"n\">tfd</span> <span class=\"o\">=</span> <span class=\"n\">timerfd_create</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"n\">TFD_CLOEXEC</span><span class=\"o\">|</span><span class=\"n\">TFD_NONBLOCK</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tfd</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;timerfd create: %s&#34;</span><span class=\"p\">,</span> <span class=\"n\">strerror</span><span class=\"p\">(</span><span class=\"n\">errno</span><span class=\"p\">));</span>\n    <span class=\"c1\">// register to poller\n</span><span class=\"c1\"></span>    <span class=\"n\">event</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"n\">tfd</span><span class=\"p\">;</span>\n    <span class=\"n\">event</span><span class=\"p\">.</span><span class=\"n\">events</span> <span class=\"o\">=</span> <span class=\"n\">EPOLLIN</span> <span class=\"o\">|</span> <span class=\"n\">EPOLLET</span><span class=\"p\">;</span>    <span class=\"c1\">// Edge-Triggered\n</span><span class=\"c1\"></span>    <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">epoll_ctl</span><span class=\"p\">(</span><span class=\"n\">epfd</span><span class=\"p\">,</span> <span class=\"n\">EPOLL_CTL_ADD</span><span class=\"p\">,</span> <span class=\"n\">tfd</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">event</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ret</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;epoll_ctl&#34;</span><span class=\"p\">);</span>\n    <span class=\"c1\">// register timer expired in future\n</span><span class=\"c1\"></span>    <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">timerfd_settime</span><span class=\"p\">(</span><span class=\"n\">tfd</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">its</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ret</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">handle_error</span><span class=\"p\">(</span><span class=\"s\">&#34;timerfd settime&#34;</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><p>执行过程（2个生产者，4个消费者）：</p><div class=\"highlight\"><pre><code class=\"language-text\">[1532099143] Greetings from [producer-1]\n[1532099143] Greetings from [consumer-1]\n[1532099143] Greetings from [consumer-2]\n[1532099143] Greetings from [consumer-3]\n[1532099143] Greetings from [consumer-0]\n[1532099143] Greetings from [producer-0]\n[1532099144] [consumer-3] got event from fd-4\n[1532099144] [consumer-3] got event from fd-5\n[1532099147] [consumer-3] got event from fd-4\n[1532099147] [consumer-3] got event from fd-5\n[1532099150] [consumer-0] got event from fd-4\n[1532099150] [consumer-0] got event from fd-5\n[1532099153] [consumer-1] got event from fd-4\n[1532099153] [consumer-1] got event from fd-5\n^C</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8c68968ee773b4ac9cd35755740fef06_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"504\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb\" width=\"504\" data-original=\"https://pic3.zhimg.com/v2-8c68968ee773b4ac9cd35755740fef06_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;504&#39; height=&#39;124&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"504\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"504\" data-original=\"https://pic3.zhimg.com/v2-8c68968ee773b4ac9cd35755740fef06_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8c68968ee773b4ac9cd35755740fef06_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从上图可以看出，运行时打开的fd-4和fd-5两个文件描述符即是timerfd。</p><p>结果符合预期（附：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Pro-YY/event_pool/blob/master/timerfd_pool.c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">源码链接</a>）</p><h2><b>4. 典型应用场景及优势</b></h2><p>引用eventfs的Manual中NOTE段落的第一句话： </p><blockquote>Applications can use an eventfd file descriptor instead of a pipe in all cases where a pipe is used simply to signal events.</blockquote><p>在信号通知的场景下，相比pipe有非常大的资源和性能优势。其根本在于counter（计数器）和channel（数据信道）的区别。</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>第一，是打开文件数量的巨大差别。由于pipe是半双工的传统IPC方式，所以两个线程通信需要两个pipe文件，而用eventfd只要打开一个文件。众所周知，文件描述符可是系统中非常宝贵的资源，linux的默认值也只有1024而已。那开发者可能会说，1相比2也只节省了一半嘛。要知道pipe只能在两个进程/线程间使用，并且是面向连接（类似TCP socket）的，即需要之前准备好两个pipe；而eventfd是广播式的通知，可以多对多的。如上面的NxM的生产者-消费者例子，如果需要完成全双工的通信，需要NxMx2个的pipe，而且需要提前建立并保持打开，作为通知信号实在太奢侈了，但如果用eventfd，只需要在发通知的时候瞬时创建、触发并关闭一个即可。</li><li>第二，是内存使用的差别。eventfd是一个计数器，内核维护几乎成本忽略不计，大概是自旋锁+唤醒队列（后续详细介绍），8个字节的传输成本也微乎其微。但pipe可就完全不是了，一来一回数据在用户空间和内核空间有多达4次的复制，而且更糟糕的是，内核还要为每个pipe分配至少4K的虚拟内存页，哪怕传输的数据长度为0。</li><li>第三，对于timerfd，还有精准度和实现复杂度的巨大差异。由内核管理的timerfd底层是内核中的hrtimer（高精度时钟定时器），可以精确至纳秒（1e-9秒）级，完全胜任实时任务。而用户态要想实现一个传统的定时器，通常是基于优先队列/二叉堆，不仅实现复杂维护成本高，而且运行时效率低，通常只能到达毫秒级。</li></ul><p>所以，第一个最佳实践法则：当pipe只用来发送通知（传输控制信息而不是实际数据），放弃pipe，放心地用eventfd/timerfd，&#34;in all cases&#34;。</p><p>另外一个重要优势就是eventfd/timerfd被设计成与epoll完美结合，比如支持非阻塞的读取等。事实上，二者就是为epoll而生的（但是pipe就不是，它在Unix的史前时代就有了，那时不仅没有epoll连Linux都还没诞生）。应用程序可以在用epoll监控其他文件描述符的状态的同时，可以“顺便“”一起监控实现了eventfd的内核通知机制，何乐而不为呢？</p><p>所以，第二个最佳实践法则：eventfd配上epoll才更搭哦。</p><h2><b>5. 内核实现细节</b></h2><p>eventfd在内核源码中，作为syscall实现在内核源码的 fs/eventfd.c下。从Linux 2.6.22版本引入内核，在2.6.27版本以后加入对flag的支持。以下分析参考Linux 2.6.27源码。</p><p>内核中的数据结构：eventfd_ctx</p><p>该结构除了包括之前所介绍的一个64位的计数器，还包括了等待队列头节点（较新的kernel中还加上了一个kref）。</p><p>定义和初始化过程核心代码如下，比较直接：内核malloc，设置count值，创建eventfd的anon_inode。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">struct</span> <span class=\"n\">eventfd_ctx</span> <span class=\"p\">{</span>\n        <span class=\"n\">wait_queue_head_t</span> <span class=\"n\">wqh</span><span class=\"p\">;</span>\n        <span class=\"n\">__u64</span> <span class=\"n\">count</span><span class=\"p\">;</span>\n<span class=\"p\">};</span></code></pre></div><p>以下为创建eventfd的函数的片段，比较直接。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">SYSCALL_DEFINE2</span><span class=\"p\">(</span><span class=\"n\">eventfd2</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">flags</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>\t<span class=\"n\">ctx</span> <span class=\"o\">=</span> <span class=\"n\">kmalloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ctx</span><span class=\"p\">),</span> <span class=\"n\">GFP_KERNEL</span><span class=\"p\">);</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">ENOMEM</span><span class=\"p\">;</span>\n\t<span class=\"n\">init_waitqueue_head</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">);</span>\n\t<span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">count</span><span class=\"p\">;</span>\n\t<span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"n\">anon_inode_getfd</span><span class=\"p\">(</span><span class=\"s\">&#34;[eventfd]&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">eventfd_fops</span><span class=\"p\">,</span> <span class=\"n\">ctx</span><span class=\"p\">,</span>\n\t\t\t      <span class=\"n\">flags</span> <span class=\"o\">&amp;</span> <span class=\"p\">(</span><span class=\"n\">O_CLOEXEC</span> <span class=\"o\">|</span> <span class=\"n\">O_NONBLOCK</span><span class=\"p\">));</span>\n        <span class=\"c1\">// ...\n</span><span class=\"c1\"></span><span class=\"p\">}</span></code></pre></div><p>稍提一下，等待队列是内核中的重要数据结构，在进程调度、异步通知等多种场景都有很多的应用。其节点结构并不复杂，即自带自旋锁的双向循环链表的节点，如下：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">struct</span> <span class=\"n\">__wait_queue_head</span> <span class=\"p\">{</span>\n\t<span class=\"n\">spinlock_t</span> <span class=\"n\">lock</span><span class=\"p\">;</span>\n\t<span class=\"k\">struct</span> <span class=\"n\">list_head</span> <span class=\"n\">task_list</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">__wait_queue_head</span> <span class=\"n\">wait_queue_head_t</span><span class=\"p\">;</span></code></pre></div><p>等待队列中存放的是task（内存中对线程的抽象）的结构。</p><p>操作等待队列的函数主要是和调度相关的函数，如：wake_up和schedule，它们位于sched.c中，前者即唤醒当前等待队列中的task，后者为当前task主动让出CPU时间给等待队列中的其他task。这样，便通过等待队列实现了多个task在运行中（TASK_RUNNING）和IO等待（TASK_INTERRUPTABLE）中的状态切换。</p><p>让我们一起复习下，系统中进程的状态转换：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ff5dde6614f148e237548bac4af8582e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"574\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb\" width=\"574\" data-original=\"https://pic3.zhimg.com/v2-ff5dde6614f148e237548bac4af8582e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;574&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"574\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"574\" data-original=\"https://pic3.zhimg.com/v2-ff5dde6614f148e237548bac4af8582e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ff5dde6614f148e237548bac4af8582e_b.jpg\"/></figure><ul><li>TASK_RUNNING: 正在在CPU上运行，或者在执行队列(run queue)等待被调度执行。</li><li>TASK_INTERRUPTIBLE: 睡眠中等待默写事件出现，task可以被信号打断，一旦接收到信号或显示调用了wake-up，转为TASK_RUNNING状态。常见于IO等待中。 </li></ul><p>清楚了task的两种状态以及run queue / wait queue原理，read函数就不难理解了。</p><p>以下是read函数的实现：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">static</span> <span class=\"n\">ssize_t</span> <span class=\"nf\">eventfd_read</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">file</span> <span class=\"o\">*</span><span class=\"n\">file</span><span class=\"p\">,</span> <span class=\"kt\">char</span> <span class=\"n\">__user</span> <span class=\"o\">*</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">count</span><span class=\"p\">,</span>\n\t\t\t    <span class=\"n\">loff_t</span> <span class=\"o\">*</span><span class=\"n\">ppos</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t<span class=\"k\">struct</span> <span class=\"n\">eventfd_ctx</span> <span class=\"o\">*</span><span class=\"n\">ctx</span> <span class=\"o\">=</span> <span class=\"n\">file</span><span class=\"o\">-&gt;</span><span class=\"n\">private_data</span><span class=\"p\">;</span>\n\t<span class=\"n\">ssize_t</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n\t<span class=\"n\">__u64</span> <span class=\"n\">ucnt</span><span class=\"p\">;</span>\n\t<span class=\"n\">DECLARE_WAITQUEUE</span><span class=\"p\">(</span><span class=\"n\">wait</span><span class=\"p\">,</span> <span class=\"n\">current</span><span class=\"p\">);</span>\n\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">&lt;</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">ucnt</span><span class=\"p\">))</span>\n\t\t<span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">EINVAL</span><span class=\"p\">;</span>\n\t<span class=\"n\">spin_lock_irq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">);</span>\n\t<span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">EAGAIN</span><span class=\"p\">;</span>\n\t<span class=\"n\">ucnt</span> <span class=\"o\">=</span> <span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">count</span><span class=\"p\">;</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ucnt</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t\t<span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">ucnt</span><span class=\"p\">);</span>\n\t<span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"o\">-&gt;</span><span class=\"n\">f_flags</span> <span class=\"o\">&amp;</span> <span class=\"n\">O_NONBLOCK</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n\t\t<span class=\"n\">__add_wait_queue</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">wait</span><span class=\"p\">);</span>\n\t\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;;)</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"n\">set_current_state</span><span class=\"p\">(</span><span class=\"n\">TASK_INTERRUPTIBLE</span><span class=\"p\">);</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">count</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"n\">ucnt</span> <span class=\"o\">=</span> <span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">count</span><span class=\"p\">;</span>\n\t\t\t\t<span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">ucnt</span><span class=\"p\">);</span>\n\t\t\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\n\t\t\t<span class=\"p\">}</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">signal_pending</span><span class=\"p\">(</span><span class=\"n\">current</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">ERESTARTSYS</span><span class=\"p\">;</span>\n\t\t\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\n\t\t\t<span class=\"p\">}</span>\n\t\t\t<span class=\"n\">spin_unlock_irq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">);</span>\n\t\t\t<span class=\"n\">schedule</span><span class=\"p\">();</span>\n\t\t\t<span class=\"n\">spin_lock_irq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">);</span>\n\t\t<span class=\"p\">}</span>\n\t\t<span class=\"n\">__remove_wait_queue</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">wait</span><span class=\"p\">);</span>\n\t\t<span class=\"n\">__set_current_state</span><span class=\"p\">(</span><span class=\"n\">TASK_RUNNING</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">res</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t<span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">waitqueue_active</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">))</span>\n\t\t\t<span class=\"n\">wake_up_locked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"n\">spin_unlock_irq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">);</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">res</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">put_user</span><span class=\"p\">(</span><span class=\"n\">ucnt</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">__u64</span> <span class=\"n\">__user</span> <span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"n\">buf</span><span class=\"p\">))</span>\n\t\t<span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">EFAULT</span><span class=\"p\">;</span>\n\n\t<span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><p>read操作目的是要将count值返回用户空间并清零。ctx中的count值是共享数据，通过加irq自旋锁实现对其的独占安全访问，spin_lock_irq函数可以禁止本地中断和抢占，在SMP体系中也是安全的。从源码可以看出，如果是对于（通常的epoll中的，也是上面实例中的）非阻塞读，count大于0则直接返回并清零，count等于0则直接返回EAGAIN。</p><p>对于阻塞读，如果count值为0则加入等待队列并阻塞，直到值不为0时（被其他线程更新）返回。阻塞是如何实现的呢？是通过TASK_INTERRUPTABLE状态下的循环加schedule。注意，schedule前释放了自旋锁，意味着允许其他线程更新值，只要值被更新大于0且又<b>再次获得cpu时间</b>，那么就可以跳出循环继续执行而返回了。</p><p>考虑一个情景，两个线程几乎同时read请求，那么：两个都会被加入到等待队列中，当第一个抢到自旋锁，返回了大于1的res并重置了count为0，此时它会（在倒数第二个if那里） 第一时间唤醒等待队列中的其他线程，此时第二个线程被调度到，于是开始了自己的循环等待。即实现了：事件只会通知到第一个接收到的线程。</p><p>那么问题来了：我们知道在其他线程write后，阻塞的read线程是马上返回的。那么如何能在count置一旦不为0时，等待的调度的阻塞读线程可以尽快地<b>再次获得cpu时间</b>，从而继续执行呢？关键在于write函数也有当确认可以成功返回时，主动调用wakeup_locked的过程，这样就能实现write后立即向等待队列通知的效果了。</p><p>write操作与read操作过程非常相似，不在此展开。</p><p>关于poll操作的核心代码如下：</p><div class=\"highlight\"><pre><code class=\"language-c\">\t<span class=\"c1\">// ...\n</span><span class=\"c1\"></span>        <span class=\"n\">spin_lock_irqsave</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">,</span> <span class=\"n\">flags</span><span class=\"p\">);</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">count</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t\t<span class=\"n\">events</span> <span class=\"o\">|=</span> <span class=\"n\">POLLIN</span><span class=\"p\">;</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">ULLONG_MAX</span><span class=\"p\">)</span>\n\t\t<span class=\"n\">events</span> <span class=\"o\">|=</span> <span class=\"n\">POLLERR</span><span class=\"p\">;</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ULLONG_MAX</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"o\">&gt;</span> <span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">count</span><span class=\"p\">)</span>\n\t\t<span class=\"n\">events</span> <span class=\"o\">|=</span> <span class=\"n\">POLLOUT</span><span class=\"p\">;</span>\n\t<span class=\"n\">spin_unlock_irqrestore</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"o\">-&gt;</span><span class=\"n\">wqh</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">,</span> <span class=\"n\">flags</span><span class=\"p\">);</span></code></pre></div><p>在count值大于0时，返回了设置POLLIN标志的事件，使得用户层的应用可以通过epoll监控 eventfd的可读事件状态。</p><h2><b>6. 本篇小结</b></h2><p>通过对eventfd/timerfd的接口和实现的了解，可以看出其不仅功能实用，而且调用方式简单。另外，其实现是非常精巧高效的，构建于内核众多系统基础核心功能之上，为用户态的应用封装了十分高效简单的事件通知机制。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>7. 参考资料</b></h2><p>Linux 内核源码  <a href=\"https://link.zhihu.com/?target=https%3A//elixir.bootlin.com/linux/latest/source/fs/eventfd.c\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">elixir.bootlin.com/linu</span><span class=\"invisible\">x/latest/source/fs/eventfd.c</span><span class=\"ellipsis\"></span></a></p><p>Linux Programmer&#39;s Manual  <a href=\"https://link.zhihu.com/?target=http%3A//man7.org/linux/man-pages/man2/eventfd.2.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">eventfd(2) - Linux manual page</a></p>", 
            "topic": [
                {
                    "tag": "云计算", 
                    "tagLink": "https://api.zhihu.com/topics/19550358"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "eventfd + epoll 有例子吗？ 比如nginx 某个模块这么使用什么的", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "zqws", 
                    "userLink": "https://www.zhihu.com/people/4e700c38d27ec41dbd2ea940fd442036", 
                    "content": "你说的1024文件描述符是针对当前shell的，linix的文件描述符应该是在/proc/sys/fs下的吧，定义了进程和整个系统的上线", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "李力", 
                    "userLink": "https://www.zhihu.com/people/b14184a0c2df6c65558d575f84091151", 
                    "content": "<p>腾讯云AutoScaling扩容速度加快15倍</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35336948", 
            "userName": "李力", 
            "userLink": "https://www.zhihu.com/people/b14184a0c2df6c65558d575f84091151", 
            "upvote": 19, 
            "title": "单集群10万节点 走进腾讯云分布式调度系统VStation", 
            "content": "<p></p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/OQ4yEwVdT-doPb-isLOo1g\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-9189cf809d5063b1371b8eaa868a8278_ipico.jpg\" data-image-width=\"638\" data-image-height=\"639\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">单集群10万节点 走进腾讯云分布式调度系统VStation</a><p class=\"ztext-empty-paragraph\"><br/></p><p>我的同事东神和旻神写了一篇关于这个系统调度方面的介绍</p><p class=\"ztext-empty-paragraph\"><br/></p><p>VStation的创始缘由最早的介绍我曾经在知乎上写过（那时起了个别名叫MS-FDC)</p><a href=\"https://www.zhihu.com/question/34511860/answer/104123438\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">国内的云计算平台有没有不是依靠 OpenStack 搭建的？</a><p class=\"ztext-empty-paragraph\"><br/></p><p>东神是这篇回复中故事一的男主角</p><a href=\"https://www.zhihu.com/question/55208502/answer/145706784\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/assets/zhihu/editor/zhihu-card-default.jpg\" class=\"internal\">做一名单身程序员是怎样的一种体验？</a><p>旻神是本专栏前两篇文章的作者</p><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://zhuanlan.zhihu.com/p/27606489\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-a404abe686344aabd50a3649b8dce281_180x120.jpg\" data-image-width=\"522\" data-image-height=\"102\" class=\"internal\">李力：竞价实例与AWS SPOT逆向解析</a><a href=\"https://zhuanlan.zhihu.com/p/29719748\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-23d50fa66d2a9b7104fe80617d7cb721_ipico.jpg\" data-image-width=\"640\" data-image-height=\"580\" class=\"internal\">隔壁老王：腾讯云批量计算介绍</a><p></p><p></p>", 
            "topic": [
                {
                    "tag": "云计算", 
                    "tagLink": "https://api.zhihu.com/topics/19550358"
                }, 
                {
                    "tag": "腾讯云", 
                    "tagLink": "https://api.zhihu.com/topics/19879841"
                }, 
                {
                    "tag": "调度算法", 
                    "tagLink": "https://api.zhihu.com/topics/19795728"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>那篇：国内的云计算平台有没有不是依靠 OpenStack 搭建的？</p><p>的回复已经没了。。。</p><p><br></p><p>回答等待修改（已修改・评估中）：政治敏感</p><p>作者修改内容通过后，回答会重新显示恢复正常 <a href=\"https://www.zhihu.com/question/24752645\" class=\"internal\">为什么回答会被建议修改</a></p><p></p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "李力", 
                            "userLink": "https://www.zhihu.com/people/b14184a0c2df6c65558d575f84091151", 
                            "content": "知乎要完，技术文章都搞掉了", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "feilengcui008", 
                    "userLink": "https://www.zhihu.com/people/43712e8bfeb5729285e3298705543dbd", 
                    "content": "单集群10万节点是只单个物理集群10万节点？集群的统一资源视图是一个master在管？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "李力", 
                            "userLink": "https://www.zhihu.com/people/b14184a0c2df6c65558d575f84091151", 
                            "content": "<p>云是分区域部署的，比如上海和北京，两地之间互不统属互不感知。单集群的10万节点就是单地域多个可用区的10万节点</p>", 
                            "likes": 0, 
                            "replyToAuthor": "feilengcui008"
                        }, 
                        {
                            "userName": "feilengcui008", 
                            "userLink": "https://www.zhihu.com/people/43712e8bfeb5729285e3298705543dbd", 
                            "content": "嗯，每个可用区都有一个master在管？", 
                            "likes": 0, 
                            "replyToAuthor": "李力"
                        }
                    ]
                }, 
                {
                    "userName": "js xs", 
                    "userLink": "https://www.zhihu.com/people/2795410bd4ef3cce6ffc87f0bdca60d7", 
                    "content": "一粒神屌炸天", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/30566901", 
            "userName": "东东东", 
            "userLink": "https://www.zhihu.com/people/8fc26afd3b72cfa45875f8d77c4745bc", 
            "upvote": 5, 
            "title": "VStation Logo 设计由来", 
            "content": "<p>VStation 很早就应用于很多平台中了，但是之前的 Logo 不能很好的表达 VStation 的理念。因为我们一直坚持 VStation 的品牌形象不仅要告诉用户这是 VStation，还要传达 VStation 的理念和态度。于是重新设计了个简洁的 Logo。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在设计 Logo 的时候主要面临了一些挑战：</p><ol><li>Logo 要简洁一些，要和 VStation 的设计理念保持一致；</li><li>扩展性要好，可以在各个地方都可以方便使用 Logo；</li><li>能够将用户对 VStation 品牌认知的部分能够充分表达出来，以及适应不断快速变更的系统。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>团队内部工程师一起讨论参与，评估不同方案的可行性，最后在几个候选 Logo 中多次进行 PK，选择了现在的 Logo 方案。</p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-4a5b0cb0cf63a2218eab3f022db9f636_b.jpg\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic3.zhimg.com/v2-4a5b0cb0cf63a2218eab3f022db9f636_b.jpg\"/><figcaption>VStation Logo</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>理由有以下几个方面：</p><ol><li><b>ASCII 的斜杠和黑色代表了程序员的能力和审美，而且可以提供文本版本的 Logo。</b></li><li><b>黑色的主色调和 Consolas 字体象征稳定可靠。</b></li><li><b>V 的两条臂也在形式上表现出稳定，像是建筑工地的塔吊一样稳定、稳固。</b></li><li><b>对称体现了无状态和平行容灾的核心设计理念。</b></li><li><b>大 V 里包着个小 v，表达了我们对目标一致而持续的追求。</b></li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>Logo 只是品牌形象一部分，后面也会有更多的关于 VStation 品牌形象系统的信息。</p><p></p>", 
            "topic": [
                {
                    "tag": "云计算", 
                    "tagLink": "https://api.zhihu.com/topics/19550358"
                }, 
                {
                    "tag": "腾讯云", 
                    "tagLink": "https://api.zhihu.com/topics/19879841"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/29780547", 
            "userName": "李力", 
            "userLink": "https://www.zhihu.com/people/b14184a0c2df6c65558d575f84091151", 
            "upvote": 14, 
            "title": "公有云按秒计费的难度是什么？", 
            "content": "<p>上周CSDN邀请我做了一次视频直播：<a href=\"https://link.zhihu.com/?target=http%3A//edu.csdn.net/huiyiCourse/detail/525\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">云平台分布式调度系统的演进（注册腾讯云立享免费参课） - 直播课 - CSDN学院 - 在线学习教程 - 会员免费</a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>由于没有露脸，导致观众热情不高，据我的托儿说最多也才百来个人在线观看，好在问答环节挺激烈的，这也使我让托儿准备的几个防冷场问题都没有用上</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其中有个观众提的问题是：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>AWS最近推出了按秒计费的能力，请问按秒计费这个功能的实现难度如何，有哪些重大挑战？</blockquote><p>其实当时我觉得这个问题不是一个特别好的问题，跟直播主题的关联性也没那大，就没有花太多时间去回答。但近两天又有几个朋友在微信上跟我说，最近按秒计费这个东西被炒上天了，你们腾讯云打不打算搞？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>于是我打算花30分钟快速写完这篇文章，表达一下我的看法，当然这也只是我个人的看法，不代表也未接受任何其它个人和团体的看法和要求。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>首先，很无奈的一点是，按秒计费特性的火爆远远超出了我的认知。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我好几年前开始重新设计和开发了云的调度框架（<a href=\"https://www.zhihu.com/question/34511860/answer/104123438\" class=\"internal\">李力：国内的云计算平台有没有不是依靠 OpenStack 搭建的？</a>）。上线运行一段时间后我又去做了一段时间vpc和cbs。2015年初我被调回cvm团队时，做的第一个需求就是：<b>虚拟机支持按秒计费</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果让我回想当时做这个需求的难点和主要挑战，我还真想不出什么太典型的东西来 ，更多的事情反而是一些逻辑模块本身由于初期的一些不合理的设计细节导致性能和可靠性的降低。因为按秒计费对监控粒度的要求非常高，并且它的结算周期的变短也导致了更大规模的计量计费，使得性能要求和实时性要求都相比原来大幅提高了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们的框架（可以看看文章上面的直播链接，好像已经免费了）设计的核心就是性能和可靠性保障，所以并未大动干戈，解决了一些具体的问题之后，按秒计费也就很快支持了。相信绝大部分用户记不得我们是如何发布这个功能的，因为我们只是在官网上放了个链接，告诉大家可以来购买了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我的错愕便是由此而生，毕竟两年前我比现在要轻10公斤，感官上已经是非常遥远的历史了，从未想到这会是2017年下半年云计算领域一个时髦的词汇。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我查了下知乎记录，我还回复过相关的问题（<a href=\"https://www.zhihu.com/question/46347841/answer/102904183\" class=\"internal\">李力：买一小时的云计算服务可行吗？</a>）</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>以腾讯云的按量计费主机为例，账单明细是这样的</blockquote><figure><noscript><img src=\"https://pic4.zhimg.com/f4c883c4cee06576713c481e704f228f_b.png\" data-caption=\"\" data-rawwidth=\"788\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb\" width=\"788\" data-original=\"https://pic4.zhimg.com/f4c883c4cee06576713c481e704f228f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;788&#39; height=&#39;594&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-rawwidth=\"788\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"788\" data-original=\"https://pic4.zhimg.com/f4c883c4cee06576713c481e704f228f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/f4c883c4cee06576713c481e704f228f_b.png\"/></figure><blockquote>不论是虚拟机、弹性外网IP还是弹性磁盘等资源，腾讯云目前的模式都提供了按秒计算、按小时结算的模式。也就是说你所购买的资源可以只使用几秒，价格也只会算这几秒的钱，然后会在下一个小时的结算周期扣费。<br/>在技术上，按量计费其实是比较简单的，只需要把监控的能力做到细致和准确就好了。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>其次，我想探讨一下按秒计费为啥能火？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>也许是阴谋论，我隐约想到两个原因</p><p class=\"ztext-empty-paragraph\"><br/></p><p>一是技术上的问题，二是宣传上的问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>先说技术上的问题吧。前文已经大概说过，在腾讯云两年多前做按秒计费时其实没感觉太多要死要活的技术难关要攻克，大多只是一些局部的优化和加固。窃以为，也许在业界按秒计费变成一个重大特性的原因是，他们遇到了更多的问题。</p><p>既然要阐述两年前的技术，引用我近两年前的回答（<a href=\"https://www.zhihu.com/question/28886875/answer/42465023\" class=\"internal\">李力：云计算在中国的市场格局是怎样的？</a>）</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>云计算要体现出革命性的突破，是需要挑战到这么多年来我们一直坚信和死守的运营实践和技术基础。<br/><br/>简单的说，云计算给技术带来的挑战就是——『堆叠』。虚拟化使计算、存储、网络资源堆叠起来，从扁平化到有层次性，同时问题和故障也就堆叠起来了。我们需要事无巨细，把新架构带来的新问题逐一攻破，比如存储堆叠我们要用走网络的块存储，网络的堆叠要用sdn/vpc来代替vlan，kvm里影子表影响性能只能靠cpu的硬件特性来解决。<br/><br/>总的来说，所有的公有云厂商做的事情都是——填坑。坑有无数个，有的坑浅，只是在扁平化时不重要；有些坑深，必须要集中力量将其填起，还要在长期的运营过程中不断优化不断改近；有些坑一眼望去怎么也解决不了，那又要想办法从它旁边绕过去，最好还对用户无感知。<br/><br/>那么，对用户来说，公有云的意义是什么呢？是帮用户把坑填了，帮用户把运营上能简化的都简化好了。用户使用可靠的公有云就相当于站在了可靠的运营能力和实践经验上。云就是互联网的水和电，用户不用再自己购买劣质煤修建发电厂，甚至他都不用关心电厂在哪里，从此他的生命中与此相关的就只有电网公司年薪百万的抄表工了。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>总的来说，即使是狭义的云计算（虚拟机），它也是包罗万象。在一个复杂的系统当中，调度和优化都因规模而指数增长。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>就像是写代码，对于单个函数而言，我们总是要限制它的圈复杂度在一定的范围之内，以便维护和阅读，但不管是什么技巧，如果一个项目的总体复杂性非常高，那么它的复杂度总是要体现在某一个地方的。抽象、分层、不要重复、把逻辑交给该做的模块、把坑交给别的团队的人，都是减少复杂而不能消除复杂。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>多年以后我们总是回过头去看OpenStack，它的局部代码优美无比，它的设计理念大气潮流，它的语法糖用得精巧卓绝，但所有它没有做的都变成了灾难，比如高可用和性能。同样是完成一组功能的系统，有的几个人就能维护起来，有的需要数百人才搞得定。而后者往往会认为系统的复杂性是固有而非人为增加的，这样的系统不仅替国家增加了就业率，减缓了社会压力，也让从业人员觉得高山仰止，安心做一颗螺丝钉，对动辄数个月做一个版本接纳认同。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么，加班、奉献、感动了很久之后，版本上线，符合预期，确实是让人激动和亢奋。但是，如果你在挑战本不应该有的挑战，在解决自己独创的问题，在感动别人的日常，那么，我觉得这里的意义就不是太大了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样的故事很多，每次想到又有资本家多掏了那么多工资，我都替他们感到惋惜。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当然了，也可能是我杞人忧天了，也许小伙伴们是每天工作三小时，然后在公司待十三个小时的呢，只是故意在宣传上吹嘘着一些功能，反正用户也不一定懂嘛</p><p class=\"ztext-empty-paragraph\"><br/></p><p>舆论是可以引导的，薛之谦们只要肯掏钱，还能让新浪微博的排序算法发生变化呢。我们自以为是在独立思考，天天接收着一大堆扭曲的信息，这些信息要么傲慢，要么偏见：只要是我有的，那就是东半球最牛逼的，只要是我没有的，那就是SB才会用的……</p><p class=\"ztext-empty-paragraph\"><br/></p><p>即使是在技术领域，也充斥着各种导师、专家、先行者，统称为大忽悠，他们有的是收了钱办事，有的是纯粹自己脑子进水，把一些瞎XX扯的东西吹成silver bullet，时常组织一些线下聚会，我年轻的时候去过几次，聚会的topic一言以蔽之：XX大法好</p><p class=\"ztext-empty-paragraph\"><br/></p><p>香农的信息论里说了：越小概率的事发生了信息量越大。那么我的产品没有爆点，没有做出小概率的事（难做的功能）应该怎么办呢？那就把好做的功能吹成难做的功能嘛，信息熵立马指数级增加，顺便创造出更多的就业岗位</p><p class=\"ztext-empty-paragraph\"><br/></p><p>胡扯这么多，<b>最后做个总结</b>吧</p><p class=\"ztext-empty-paragraph\"><br/></p><p>云计算里的工作并不总是高大上的，这应该是个常态，做好每一件事，填好每一个坑，牛逼了吹一吹，犯错了赶紧改，要是觉得岁月静好不刺激，那就多去重构重构框架吧</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（午休时间到，上班去）</p><p></p>", 
            "topic": [
                {
                    "tag": "云计算", 
                    "tagLink": "https://api.zhihu.com/topics/19550358"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>难度很大<br>让客户觉得腾讯云按量计费体验好难道不是难度很大的事情么？</p><p>让客户从万朵云选择腾讯云来进行一些徒增秒杀需求难道不是难度很大的事情么？</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "按秒付费能给客户节省多少钱，能给云平台带来多大麻烦，能带来什么新特性，我感觉就是市场部的人闲了要花经费，就抓这个热点做pr了。", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "陆川", 
                    "userLink": "https://www.zhihu.com/people/d18d290a8285a980aec20cb96c098f1c", 
                    "content": "<p>你确定腾讯云的按秒计算是用监控做的？（监控云主机存活？）</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "PaulSai", 
                    "userLink": "https://www.zhihu.com/people/bb196c55b216fbb8b9d80f8ef94ed6ac", 
                    "content": "我看好云计算这个方向，再加上研究生阶段也主要是云计算这个方向。本人明年硕士毕业，这次秋招也有拿了一些offer，其中有一个云计算创业公司的。就是不知道今后咋样。相对大流，比如随便那些后台开发，不知道前景。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "李力", 
                            "userLink": "https://www.zhihu.com/people/b14184a0c2df6c65558d575f84091151", 
                            "content": "云计算创业有难度，资产太重了", 
                            "likes": 0, 
                            "replyToAuthor": "PaulSai"
                        }, 
                        {
                            "userName": "PaulSai", 
                            "userLink": "https://www.zhihu.com/people/bb196c55b216fbb8b9d80f8ef94ed6ac", 
                            "content": "<p>公司是上海的UCloud，单纯做云计算的公司太少了。阿里估计暂时进不去，不知道前辈对这个公司有何看法。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "李力"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/29719748", 
            "userName": "王旻", 
            "userLink": "https://www.zhihu.com/people/588e454c903474fbd6d3e178b3e58bff", 
            "upvote": 12, 
            "title": "腾讯云批量计算介绍", 
            "content": "<h2>一 批量计算概念介绍</h2><h2>引题：工作负载分类</h2><p>工作负载的分类方法和标准多种多样，其中 Google 提出的一种简单的分类标准广受认可，即将工作负载分为服务型和批处理型。</p><ul><li>服务型 service</li><ul><li>长时间运行，理论上不会停止，对服务质量敏感，主要是线上业务</li><li>例如 web 服务，e-mail 服务等</li></ul><li>批处理型 batch</li><ul><li>运行时间从几秒到几天不等，对短时性能波动相对不敏感，主要是离线业务</li><li>例如日志分析等</li></ul></ul><h2>公有云上的批量计算</h2><p>最初，公有云的工作负载以服务型负载为主，各大厂商也进行了诸多针对性优化。随着云计算的快速发展，越来越多的、不同行业的用户开始使用公有云，批处理型负载显著增加。针对批处理型负载的需求，我们也通过新的产品形式来满足用户。</p><ul><li>专注业务，支持大规模自动化调度与执行，为用户屏蔽资源细节。</li><li>调度逻辑，支持 DAG 和优先级调度，满足用户复杂的业务处理逻辑。</li><li>成本优化，支持资源的动态伸缩，按需分配资源，避免资源浪费，节省成本。</li></ul><h2>腾讯云 Batch 模型</h2><ul><li>执行单元</li><ul><li>Job，作业，一组关联 Task 的集合</li><li>Task，任务，指明执行逻辑和资源需求</li><li>TaskInstance，任务实例，原子执行单元，一个 Task 可并行执行多份</li></ul><li>DAG依赖</li><ul><li>通过图拓扑表示 DAG 依赖，Job 是 DAG 图，Task 是点，依赖 Dependence 是边</li><li>Task 是依赖关系的维护单元，不使用 TaskInstance 作为依赖关系的维护单元是为了防止依赖关系爆炸</li></ul></ul><figure><noscript><img src=\"https://pic2.zhimg.com/v2-35eefcca25bed4243e73ff8d424926ed_b.jpg\" data-rawwidth=\"691\" data-rawheight=\"510\" class=\"origin_image zh-lightbox-thumb\" width=\"691\" data-original=\"https://pic2.zhimg.com/v2-35eefcca25bed4243e73ff8d424926ed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;691&#39; height=&#39;510&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"691\" data-rawheight=\"510\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"691\" data-original=\"https://pic2.zhimg.com/v2-35eefcca25bed4243e73ff8d424926ed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-35eefcca25bed4243e73ff8d424926ed_b.jpg\"/></figure><p>                                                     [ Batch Job 模型示意图 ]</p><h2>批量计算完整流程</h2><p>上一小节是腾讯云 Batch 自身的逻辑模型。本节我们将视角提升到整个处理流程，涵盖调度、计算、存储等方面。流程示意图如下图所示。<br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-864627fe664f0765920ce2e3b8c1c6df_b.jpg\" data-rawwidth=\"1222\" data-rawheight=\"951\" class=\"origin_image zh-lightbox-thumb\" width=\"1222\" data-original=\"https://pic4.zhimg.com/v2-864627fe664f0765920ce2e3b8c1c6df_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1222&#39; height=&#39;951&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1222\" data-rawheight=\"951\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1222\" data-original=\"https://pic4.zhimg.com/v2-864627fe664f0765920ce2e3b8c1c6df_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-864627fe664f0765920ce2e3b8c1c6df_b.jpg\"/></figure><p>                                                    [ 批量计算完整流程示意图 ]</p><ul><li>主要步骤</li></ul><ol><li>用户上传应用程序和输入文件到对象存储COS上</li><li>用户提交 Batch 作业</li><li>Batch 创建 CVM 实例</li><li>CVM 实例中启动 Batch agent，从 COS 下载应用程序和输入文件，执行任务实例</li><li>Batch agent 上传输出文件到 COS</li><li>用户监控 Batch 作业的结果</li><li>用户在 Batch 作业完成后，从 COS 下载获得输出文件</li></ol><li>腾讯云闭环</li><ul><li>整个流程在腾讯云上实现调度、计算、存储闭环</li><li>Batch 提供调度分发能力</li><li>CVM 提供计算能力</li><li>COS 提供持久化存储能力</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>二 竞品调研关键问题</h2><p>在进行产品规划、系统设计的过程中，我们对公有云批量计算产品进行了较为充分的调研，涵盖 AWS, Aliyun, Azure, Google Cloud等友商（其中 Google Cloud Batch 是 Google Dataflow 产品的一部分，专注数据处理，与其他竞品差别较大，不作为主要对比系）。我们从中汲取了大量养分，同时也发现对于一些关键问题和产品规划，不同厂商采用了不同的策略。对此，我们尝试分析背后的产品逻辑和各自优劣，结合目标用户的需求，选择确定了腾讯云批量计算的产品路线。</p><h2>虚拟机与任务实例的耦合关系</h2><ul><li>AWS</li><ul><li>产品策略：作业与 VM 生命周期解耦。一个 VM 可以运行多个作业，作业分配到 VM 需要装箱。</li><li>简评：AWS Batch 作业通过容器的方式执行，看起来可以快速启动，但是容器仍然需要运行在 VM 之中，VM 的规格和启停时机难以把握。在试用过程中，我们发现 AWS Batch 容易出现资源浪费和资源“假死锁”问题。客观来说，容器与 VM 2层概念增加了产品逻辑复杂度，而 AWS Batch 并没有完满的处理好这方面的产品逻辑。</li><li>问题1 资源浪费</li><ul><li>在一个MaxvCPU（AWS Batch 产品概念，大意为计算环境可使用的 CPU 上限）为16C的环境中，用户先提交一个16C的作业A， AWS Batch 会自动创建一个16C的 EC2 实例执行作业A。然后用户再提交一个8C的作业B，在作业A完成之后，AWS Batch 会复用16C的 EC2 实例执行作业B。AWS Batch的收费策略是根据 EC2 实例收费，这样存在一个问题，在执行作业B的时候，Batch 用16C的 EC2 执行8C的作业，造成了资源浪费。实际上，用户提交作业的规格和吞吐量发生变化是较为常见的事情，这样的 case 比较容易出现。</li><li>此外，作业执行完成后，EC2 不会立即销毁，通常会保留数十分钟后才会自动释放，对于不持续提交作业的用户，也会造成明显的资源浪费。</li></ul></ul></ul><figure><noscript><img src=\"https://pic3.zhimg.com/v2-2554396c4992cf761171cdfe41560152_b.jpg\" data-rawwidth=\"649\" data-rawheight=\"283\" class=\"origin_image zh-lightbox-thumb\" width=\"649\" data-original=\"https://pic3.zhimg.com/v2-2554396c4992cf761171cdfe41560152_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;649&#39; height=&#39;283&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"649\" data-rawheight=\"283\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"649\" data-original=\"https://pic3.zhimg.com/v2-2554396c4992cf761171cdfe41560152_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2554396c4992cf761171cdfe41560152_b.jpg\"/></figure><p>                                          [ Batch创建一台16C的 EC2 ]</p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-0d0f3af449e4d8bf36fa7aa6552ae152_b.jpg\" data-rawwidth=\"936\" data-rawheight=\"88\" class=\"origin_image zh-lightbox-thumb\" width=\"936\" data-original=\"https://pic3.zhimg.com/v2-0d0f3af449e4d8bf36fa7aa6552ae152_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;936&#39; height=&#39;88&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"936\" data-rawheight=\"88\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"936\" data-original=\"https://pic3.zhimg.com/v2-0d0f3af449e4d8bf36fa7aa6552ae152_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0d0f3af449e4d8bf36fa7aa6552ae152_b.jpg\"/></figure><p>                                               [ 仅运行一个8C的作业 ]</p><ul><ul><li>问题2 资源“假死锁”</li><ul><li>在一个MaxvCPU为16C的环境中，用户先提交一个8C的作业A，AWS Batch 会自动创建一个8C的 EC2 实例来执行作业 A。然后提交一个16C的作业B。本来预期 AWS Batch 会立即销毁现有的 EC2 实例，然后创建一个新的16C EC2 实例来运行作业B。但是，实际情况要略差于预期，在作业B提交近一小时之后，AWS Batch才创建了16C的 EC2 实例，完成计算环境的调整，以至于用户一度认为 AWS Batch 出现了死锁 bug。虽然最终没有造成死锁，但是 AWS Batch 的调整延迟过大，影响用户体验。<br/></li></ul></ul></ul><figure><noscript><img src=\"https://pic4.zhimg.com/v2-8a48e8c2f02ae4bfdb2bc0b6f02bb1af_b.jpg\" data-rawwidth=\"952\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb\" width=\"952\" data-original=\"https://pic4.zhimg.com/v2-8a48e8c2f02ae4bfdb2bc0b6f02bb1af_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;952&#39; height=&#39;82&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"952\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"952\" data-original=\"https://pic4.zhimg.com/v2-8a48e8c2f02ae4bfdb2bc0b6f02bb1af_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8a48e8c2f02ae4bfdb2bc0b6f02bb1af_b.jpg\"/></figure><p>                                                  [ 16C的作业长期等待资源 ]</p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-d2f0adff8aa2027982fa299fff733d25_b.jpg\" data-rawwidth=\"544\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb\" width=\"544\" data-original=\"https://pic2.zhimg.com/v2-d2f0adff8aa2027982fa299fff733d25_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;544&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"544\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"544\" data-original=\"https://pic2.zhimg.com/v2-d2f0adff8aa2027982fa299fff733d25_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d2f0adff8aa2027982fa299fff733d25_b.jpg\"/></figure><p>                                     [ 约44分钟后，AWS Batch 才完成了资源变更 ]</p><ul><li>Aliyun</li><ul><li>产品策略： Aliyun Batch 分为2种计算环境类型，AutoCluster 自动集群模式和 Cluster 固定集群模式。对于 AutoCluster 模式，任务实例与 VM 生命周期一致；对于 Cluster 模式，虽然任务实例与 VM 生命周期不一致，但是目前仍然采用1对1模式，即 VM 同时只运行一个任务实例。</li><li>简评：Aliyun Batch，特别是 AutoCluster 模式，产品逻辑简单直接。</li></ul><li>Azure</li><ul><li>产品策略： 任务与 VM 生命周期解耦。一个 VM 可以运行多个任务。与 AWS Batch 不同，任务分配到 VM 不进行装箱，而是通过参数设置，即一个 VM 可以同时运行 n 个任务，n 可设置。。</li><li>简评：与 AWS Batch 类似，可能出现浪费资源的问题。不进行装箱，直接为 VM 分配 n 个任务的策略，对于异构化的任务，存在资源评估不准确的问题。</li></ul><li>用户反馈</li><ul><li>用户关心业务本身，对耦合关系无明显偏好，希望产品逻辑保持简洁直观，避免资源浪费。</li></ul><li>腾讯云做法</li><ul><li>CVM 和 任务实例生命周期耦合，一一对应，执行任务实例前夕创建 CVM 实例，执行完成后立即销毁 CVM 实例。保证按需分配和使用资源，节省成本。</li><li>同时，充分利用 CVM 快速创建优势，快速响应 Batch 业务。</li></ul></ul><h2>执行单元的层级关系</h2><ul><li>AWS</li><ul><li>产品策略：执行单元为 Job，是原子执行单元，相当于腾讯云的 TaskInstance。</li><li>简评：保证接口原子性。虽然可以通过指定前序 Job 来表示 Job 间的依赖关系，但是需要用户记录和维护前序 Job 的唯一 ID，并在提交后序 Job 时指定前序 Job 的唯一 ID，相当于用户需要参与维护DAG 关系。同时，AWS Batch 目前无法提供完成的 DAG 视图。</li></ul><li>Aliyun</li><ul><li>产品策略：Job、Task、Instance三层单元</li><ul><li>简评：可以在 Job 内部实现 DAG 关系。Aliyun Batch 和 ECS 是两款产品，但是二者的 Instance 和 InstanceId 容易混淆。Aliyun Batch 中存在 InstanceId 的概念，却并非 ECS InstanceId，而是类似 Instance 在 Task 内部索引的概念。</li></ul></ul><li>Azure</li><ul><li>产品策略：具有 Job 和 Task 两层单元，Job 其实是类似队列或者任务集合的静态概念，Task 是其执行单元。</li><li>简评：Azure Batch 中的 Task 类似于 AWS Batch 中的 Job，二者优缺点相似。</li></ul><li>用户反馈</li><ul><li>希望 Batch 产品可以优雅地处理 DAG 关系，同时对用户简单。</li></ul><li>腾讯云做法</li><ul><li>借鉴工作流系统 airflow 的命名方式，采用 Job、Task、TaskInstance 三层执行单元。</li><li>TaskInstance 与 CVM Instance 概念区分。虽然我们目前采用 TaskInstance 和 CVM Instance 生命周期一致的策略，但是二者本身不同，不要混淆。</li></ul></ul><h2>CVM 用户是否可见</h2><ul><li>AWS</li><ul><li>Batch 创建的虚拟机，在其控制台可见</li></ul><li>Aliyun</li><ul><li>Batch 创建的虚拟机，在其控制台不可见，不可直接登录。虽然 Aliyun Batch 提供了内网连通的拓展功能，但是产品体验有待提高。</li></ul><li>Azure</li><ul><li>Batch 创建的虚拟机，在其控制台可见</li></ul><li>用户反馈</li><ul><li>多方用户提到友商 Batch 创建虚拟机控制台不可见、无法登录的痛点。当出现问题时较难定位。</li></ul><li>腾讯云做法</li><ul><li>保证“搭积木式”的产品观</li><li>Batch 和用户使用相同的方式使用基础产品（例如 CVM），保证基础产品逻辑一致</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>三 系统设计</h2><h2>TaskInstance 状态机</h2><p>腾讯云 Batch 包括 Job、Task、TaskInstance 三层执行单元，TaskInstance 系原子执行单元，这里介绍其状态机。Job、Task 的状态依赖其所含 TaskInstance 的状态，不做展开。</p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-daba6ced620d509de126e882ed26637f_b.jpg\" data-rawwidth=\"820\" data-rawheight=\"1021\" class=\"origin_image zh-lightbox-thumb\" width=\"820\" data-original=\"https://pic4.zhimg.com/v2-daba6ced620d509de126e882ed26637f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;820&#39; height=&#39;1021&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"820\" data-rawheight=\"1021\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"820\" data-original=\"https://pic4.zhimg.com/v2-daba6ced620d509de126e882ed26637f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-daba6ced620d509de126e882ed26637f_b.jpg\"/></figure><p>                                                      [ TaskInstance 状态机 ]</p><ul><li>SUBMITTED</li><ul><li>已经接收到 Job 并解析拆分。</li><li>如果存在依赖项，则任务实例进入 PENDING 状态，否则进入 RUNNABLE 状态。</li></ul><li>PENDING</li><ul><li>驻留在队列中，因为等待其他依赖任务，而无法运行</li><li>在满足依赖关系后，任务实例将进入 RUNNABLE 状态。</li></ul><li>RUNNABLE</li><ul><li>驻留在队列中且没有任何未完成依赖项，因为没有资源或者资源配额不足而暂时无法运行</li><li>当资源足够时，任务实例会被调度运行。</li></ul><li>STARTING</li><ul><li>任务实例完成调度开始执行和下发，任务实例尚未启动执行</li></ul><li>RUNNING</li><ul><li>任务实例在计算环境中运行</li><li>当应用程序退出时，进程退出代码将确定任务实例是成功还是失败。退出代码 0 表示成功，非零退出代码表示失败。</li></ul><li>SUCCEEDED</li><ul><li>任务实例成功完成，返回码为 0</li></ul><li>FAILED</li><ul><li>在执行所有可用尝试后，任务实例失败。</li></ul></ul><h2>系统架构与设计细节</h2><p>定位为工作流 workflow 系统，适用于 Batch 场景，命名为 Wonderflow。<br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-d37257a4faff1fb737069a650c50e785_b.jpg\" data-rawwidth=\"1725\" data-rawheight=\"1051\" class=\"origin_image zh-lightbox-thumb\" width=\"1725\" data-original=\"https://pic2.zhimg.com/v2-d37257a4faff1fb737069a650c50e785_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1725&#39; height=&#39;1051&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1725\" data-rawheight=\"1051\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1725\" data-original=\"https://pic2.zhimg.com/v2-d37257a4faff1fb737069a650c50e785_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d37257a4faff1fb737069a650c50e785_b.jpg\"/></figure><p>                                                       [ Wonderflow 架构图 ]</p><ul><li>Wonderflow API</li></ul><ol><li>生成唯一 JobId，并将 Job 基本信息提交到数据库中</li><li>将 Job 完整信息发送至 MQ 中</li><li>向调用方返回 JobId</li></ol><li>依赖关系</li><ul><li>Job 拆分时，根据有无依赖，将 TaskInstance 的状态设置为 PENDING 或者 RUNNABLE</li><li>TaskInstance 完成后，会变更关联对象的状态，可能包括 Task、Job、后续 Task、后续 TaskInstance 的状态。</li></ul><li>调度策略</li><ul><li>以 owner 为粒度进行集中调度，查询同一 owner、状态为 RUNNABLE 的 TaskInstance，按照优先级排序，逐个遍历</li></ul><ol><li>如果 TaskInstance 有足够资源配额，则下发执行，将 TaskInstance 信息发送至pre-executor MQ</li><li>如果 TaskInstance 无足够资源配额，则continue</li></ol><li>owner 之间并行调度；同一 owner 串行调度，避免无意义加锁。</li><li>TaskInstance 存储使用数据库，不使用优先级队列，避免“队列头阻塞”或者优先级变化。</li><li>Wonderflow 内部回滚</li><ul><li>pre-executor 和 post-executor 相对复杂，需要内部回滚</li><li>例如 pre-executor 如果执行失败，进行回滚，销毁已经创建的 CVM 实例</li></ul><li>Wonderflow 与 CVM API 交互</li><ul><li>支持两种模式，调用内部 CVM API 和 SDK</li><li>默认采用 CVM API 模式，应用在腾讯公有云场景下</li><li>可选通过 SDK 模式，与 CVM 用户行为完全一致，意味着用户可以在自己的 CVM 集群中搭建 Wonderflow 系统并直接使用。</li></ul><li>与CVM实例的交互</li><ul><li>镜像只需安装 cloudinit，而无须提前嵌入 Batch agent，即可运行批量计算作业</li><li>cloudinit 是业界认可的标准初始化工具，镜像制作标准规范、简易</li><li>腾讯云计划近期更新主流公有镜像，使之支持 cloudinit</li></ul><h2>设计原则小结</h2><ul><li>“搭积木”</li><ul><li>批量计算保证基础产品的原生能力，不进行封装或阉割。批量计算和用户使用基础产品的方式一致，保证产品表现一致</li></ul><li>多调度器并发架构</li><ul><li>多调度器并发调度，用户（owner）级别并发，类似于 Google Omega 的无锁乐观并发调度架构， 可提升调度系统的吞吐率。用户（owner）内部串行，保证按照优先级调度下发，同时避免无意义加锁。</li><li>在产品调度策略上，目前批量计算对所有用户采用对等公平策略。如果特定场景（比如私有云环境）需要采用相对公平策略，不同用户具有不同的权重值，则需要增加一个调度组件和一层调度策略，决定优先为哪个/哪些用户进行调度。</li></ul><li>轻量 API</li><ul><li>API 逻辑轻量，保持快速响应</li><li>复杂逻辑交由异步消费者完成</li></ul><li>消费者处理逻辑简洁明确</li><ul><li>TaskInstance 状态机相对复杂，但是每类消费者只做一类事，相当于解耦了状态机。</li><li>例如，Splitter 负责拆分Job，根据 TaskInstance 有无依赖将状态置为 PENDING 或者 RUNNABLE；Scheduler 只负责调度下发状态为 RUNNABLE 的 TaskInstance，不会考虑依赖关系；post-executor 在销毁 CVM 实例之后，负责变更 TaskInstance 状态和关联对象状态，会将已经无依赖的后续 TaskInstance 状态从 PENDING 变更为 RUNNABLE。</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>四 核心功能与产品优势</h2><ul><li>自动托管</li><ul><li>自动调度、下发、执行海量作业，为用户屏蔽资源细节，专注业务本身。</li></ul><li>DAG 依赖</li><ul><li>通过 DAG 拓扑形式，描述任务间依赖关系，根据依赖关系保证任务的先后执行顺序。通过简单形式满足用户复杂处理逻辑的业务需求。</li></ul><li>优先级调度</li><ul><li>对于无依赖任务实例，基于优先级进行先后调度。</li></ul><li>计算资源动态伸缩</li><ul><li>资源与任务实例生命周期一致，根据业务需求动态扩展和释放计算资源，按需分配资源，避免浪费，节省成本。</li></ul><li>天然集成</li><ul><li>Batch 与腾讯云基础产品天然集成，涵盖计算（CVM）、网络（VPC）、存储（COS/CFS）、安全（安全组）等多个方面，用户业务可在腾讯云上轻松闭环。</li><li>复用基础产品优势，例如腾讯云 CVM 快速创建。</li></ul><li>调试 Debug 模式</li><ul><li>TaskInstance 失败后，CVM 实例不销毁，保留现场</li><li>批量计算创建的 CVM 实例，在 CVM 控制台可见、可登陆，便于用户观察应用运行状态。</li></ul></ul><p>批量计算作为一款新产品，可能还存在一些不足，也欢迎大家多多试用 &amp; 反馈问题。</p><h2>参考</h2><p>[1] Schwarzkopf, Malte, et al. “Omega: flexible, scalable schedulers for large compute clusters.” Proceedings of the 8th ACM European Conference on Computer Systems. ACM, 2013.<br/>[2] Verma, Abhishek, et al. “Large-scale cluster management at Google with Borg.” Proceedings of the Tenth European Conference on Computer Systems. ACM, 2015.<br/>[3] Konwinski A D. Multi-agent cluster scheduling for scalability and flexibility[M]. University of California, Berkeley, 2012.<br/>[4] AWS Batch. <u><a href=\"https://link.zhihu.com/?target=https%3A//aws.amazon.com/cn/batch/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">aws.amazon.com/cn/batch</span><span class=\"invisible\">/</span><span class=\"ellipsis\"></span></a></u><br/>[5] Azure Batch. <u><a href=\"https://link.zhihu.com/?target=https%3A//azure.microsoft.com/en-us/services/batch/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">azure.microsoft.com/en-</span><span class=\"invisible\">us/services/batch/</span><span class=\"ellipsis\"></span></a></u><br/>[6] Aliyun BatchCompute. <u><a href=\"https://link.zhihu.com/?target=https%3A//www.aliyun.com/product/batchcompute\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">aliyun.com/product/batc</span><span class=\"invisible\">hcompute</span><span class=\"ellipsis\"></span></a></u><br/>[7] Google Dataflow. <u><a href=\"https://link.zhihu.com/?target=https%3A//cloud.google.com/dataflow/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">cloud.google.com/datafl</span><span class=\"invisible\">ow/</span><span class=\"ellipsis\"></span></a></u></p>", 
            "topic": [
                {
                    "tag": "云计算", 
                    "tagLink": "https://api.zhihu.com/topics/19550358"
                }, 
                {
                    "tag": "腾讯云", 
                    "tagLink": "https://api.zhihu.com/topics/19879841"
                }
            ], 
            "comments": [
                {
                    "userName": "齐显东", 
                    "userLink": "https://www.zhihu.com/people/21d9ee2b44408f3ac4c22743a97ab0b9", 
                    "content": "<p>也看到 《单集群10万节点 走进腾讯云分布式调度系统VStation》。我有一个问题，如果有异构的 集群-1，集群-2， 因为 “软约束”/“soft constraints”的存在，不同用户如何在异构的情况下，保证“Fair”sharing。    （当然，现在YARN的做法是 不同异构（node label ）下直接设置 用户分配数量的百分比，但是觉得还是没回答好“异构”的情况下，什么是“Fair”，怎么sharing合理。）</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "王旻", 
                            "userLink": "https://www.zhihu.com/people/588e454c903474fbd6d3e178b3e58bff", 
                            "content": "<p>很好的问题。不过客观上，公有云场景和私有场景会有一些不同，这里简单说一下。</p><p>1. 针对异构资源，VStation 不会直接限定某个特定资源的配额。我个人理解，这里的核心区别是，用户使用公有云的资源，是要付费的，而在YARN、Mesos主要使用的私有环境中，用户使用资源通常不会付出真的代价，所以通常通过配额等手段进行限制。进一步地，在公有云中，许多资源层面的异构性会通过产品化的手段向用户展示出来，例如我们会把Haswell、Broadwell、Skylake通过系列1、2、3机型展示给用户，而用户对不同的付费也是不一样的。公有云通过付费这种非常直观的方法把异构性包装之后展示给用户，而相对少地（也不是完全没有）直接对用户和异构性进行“计划性限制”。</p><p>2. 异构性通常是多个维度的，在 VStation 中，比较常用的异构维度有5-10个，而且这些异构性在物理节点上又可能是“交叉”的。所以我们通常不说有几个异构集群，而是有一个集群，通过一些维度，可以把集群在逻辑上划分为几个部分。当然，这里只是一个说法而已，本质上是一回事。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "齐显东"
                        }
                    ]
                }, 
                {
                    "userName": "齐显东", 
                    "userLink": "https://www.zhihu.com/people/21d9ee2b44408f3ac4c22743a97ab0b9", 
                    "content": "<p>实习申请的话，发邮件给那位呢？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "王旻", 
                            "userLink": "https://www.zhihu.com/people/588e454c903474fbd6d3e178b3e58bff", 
                            "content": "联系李力或者我都可以，我的邮箱是alexmwang@tencent.com。", 
                            "likes": 0, 
                            "replyToAuthor": "齐显东"
                        }
                    ]
                }, 
                {
                    "userName": "daydream", 
                    "userLink": "https://www.zhihu.com/people/156c5c9d2ad2758a152136298ebb782b", 
                    "content": "<p>请教一个问题。上述批量计算的问题拆解成了两个问题：一个问题是决定哪些任务执行顺序（除了必须满足要满足的顺序，其实还要决定哪些可执行任务先执行，这个不仅会关系到集群资源使用率还会关系到任务的等待时间，例如考虑到大小任务的问题等等）；第二个就是装箱问题；。由于批量计算是构建在CVM之上，任务集是感知不到集群整体资源使用情况的， 整体资源也是不知道目前任务情况的，所以是无法做到多对多的适配的。而像yarn这种资源管理器，既能感知整体资源使用率，也能感知整体任务使用情况，这是我理解的不同。我觉得yarn也要解决上述两个问题，但是并没有理解到装箱体现在哪里。是我对两个问题的理解出了偏差吗？请指教！！</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "王旻", 
                            "userLink": "https://www.zhihu.com/people/588e454c903474fbd6d3e178b3e58bff", 
                            "content": "您的理解准确，没有偏差。公有云会进行分层，腾讯云batch解决“第一个问题”，腾讯云cvm解决“第二个问题”，batch不会直接感受到cvm内部的资源使用情况，不过batch cvm可以配合完成调度。<br>对应到yarn中，其实也会分工，只是一个体系中的不同组件。可以类比，AM负责处理任务间的关系；而RM专注资源调度，为任务分配资源。", 
                            "likes": 0, 
                            "replyToAuthor": "daydream"
                        }, 
                        {
                            "userName": "daydream", 
                            "userLink": "https://www.zhihu.com/people/156c5c9d2ad2758a152136298ebb782b", 
                            "content": "<p>谢谢大佬的回答！能否解释一下资源调度和装箱问题这两者之间的关系</p>", 
                            "likes": 0, 
                            "replyToAuthor": "王旻"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/27606489", 
            "userName": "李力", 
            "userLink": "https://www.zhihu.com/people/b14184a0c2df6c65558d575f84091151", 
            "upvote": 19, 
            "title": "竞价实例与AWS SPOT逆向解析", 
            "content": "<p><i>作者是我的同事alexmwang，已经获得授权</i></p><br/><h2>竞价实例是什么 —— what</h2><h4>用户视角的竞价实例</h4><ul><li>AWS竞价实例，即AWS EC2 SPOT instance</li><li>用户在竞价型实例请求中指定愿意支付的最高出价。</li><li>如果竞价型实例价格不高于用户的出价，则用户实例可以运行，且按照竞价型实例的实际价格付费；如果竞价型实例价格高于用户出价，则实例中断运行，会被销毁。</li><li>竞价实例加个由Amazon EC2设定，并且根据竞价型实例容量的供求关系发生周期性波动。</li></ul><h4>直观认识：AWS SPOT 价格示例</h4><figure><noscript><img data-rawheight=\"579\" src=\"https://pic3.zhimg.com/v2-ea526753d6909c6f6923f5ee248b5792_b.png\" data-rawwidth=\"907\" class=\"origin_image zh-lightbox-thumb\" width=\"907\" data-original=\"https://pic3.zhimg.com/v2-ea526753d6909c6f6923f5ee248b5792_r.jpg\"/></noscript><img data-rawheight=\"579\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;907&#39; height=&#39;579&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"907\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"907\" data-original=\"https://pic3.zhimg.com/v2-ea526753d6909c6f6923f5ee248b5792_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ea526753d6909c6f6923f5ee248b5792_b.png\"/></figure><br/><ul><li>多数时候为折扣形式（低于按量计费）</li><li>可能高于按量计费，通常为倍数关系 <br/><ul><li>验证应当是售罄的一种表现形式</li></ul></li></ul><h4>AWS SPOT 控制台</h4><figure><noscript><img data-rawheight=\"785\" src=\"https://pic4.zhimg.com/v2-d733538edc492106c3472080ba981a53_b.png\" data-rawwidth=\"1148\" class=\"origin_image zh-lightbox-thumb\" width=\"1148\" data-original=\"https://pic4.zhimg.com/v2-d733538edc492106c3472080ba981a53_r.jpg\"/></noscript><img data-rawheight=\"785\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1148&#39; height=&#39;785&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1148\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1148\" data-original=\"https://pic4.zhimg.com/v2-d733538edc492106c3472080ba981a53_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d733538edc492106c3472080ba981a53_b.png\"/></figure><br/><ul><li>请求类型 <br/><ul><li>请求，提交一次性竞价实例请求。实例被抢占后不会自动补充。</li><li>请求并维护，自动补充由竞价中断的竞价实例。可以修改请求的容量，即实例个数。</li><li>预留持续时间，请求在1到6小时内不中断的竞价实例，在持续时间内不被抢占。</li></ul></li><li>目标容量 <br/><ul><li>即实例个数</li></ul></li><li>AMI镜像 <br/><ul><li>可选公有镜像和私有镜像。</li></ul></li><li>实例类型 <br/><ul><li>具体小机型，可单选or多选</li><li>2个工具，辅助用户选择，包括定价历史记录、*<em>竞价出价顾问</em>*。</li></ul></li><li>分配策略 <br/><ul><li>关于可用区&amp;实例类型</li><li>选择最便宜的可用区&amp;实例类型</li><li>在选定可用区和实例类型之间平衡竞价实例</li></ul></li><li>可用区 <br/><ul><li>无首选项，或者选择若干个zone</li></ul></li><li>最高价 <br/><ul><li>使用自动出价（推荐），按照市场现货价格预配置竞价实例，以按需价格为上限</li><li>用户人为设定最高价</li></ul></li></ul><h4>定价历史记录</h4><p><figure><noscript><img data-rawheight=\"585\" src=\"https://pic2.zhimg.com/v2-1c755b1d8a03ce81e7f5e0bbd97fc0e9_b.png\" data-rawwidth=\"907\" class=\"origin_image zh-lightbox-thumb\" width=\"907\" data-original=\"https://pic2.zhimg.com/v2-1c755b1d8a03ce81e7f5e0bbd97fc0e9_r.jpg\"/></noscript><img data-rawheight=\"585\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;907&#39; height=&#39;585&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"907\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"907\" data-original=\"https://pic2.zhimg.com/v2-1c755b1d8a03ce81e7f5e0bbd97fc0e9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1c755b1d8a03ce81e7f5e0bbd97fc0e9_b.png\"/></figure><br/>- 按照下列维度检索 <br/>- 实例类型，即具体小机型 <br/>- 日期范围 <br/>- 产品，具体来看是不同的OS平台 <br/>- 结果 <br/>- 该region内部多个zone的价格曲线 <br/>- 可能超过按量计费的原价，推测为售罄表现形式 <br/>- 疑问 <br/>- 价格与实例的OS平台有关，难道是预生产了？ <br/>- 预生产对镜像和规格都有限制，如果不match，将造成浪费。加之竞价实例理论上生产销毁更为频繁，采用预生产机制预计会增加复杂性</p><h4>竞价出价顾问</h4><p><figure><noscript><img data-rawheight=\"885\" src=\"https://pic2.zhimg.com/v2-b2c34eef8b6c647c78a5d190136667c5_b.png\" data-rawwidth=\"898\" class=\"origin_image zh-lightbox-thumb\" width=\"898\" data-original=\"https://pic2.zhimg.com/v2-b2c34eef8b6c647c78a5d190136667c5_r.jpg\"/></noscript><img data-rawheight=\"885\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;898&#39; height=&#39;885&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"898\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"898\" data-original=\"https://pic2.zhimg.com/v2-b2c34eef8b6c647c78a5d190136667c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b2c34eef8b6c647c78a5d190136667c5_b.png\"/></figure><br/>- 按照下列维度检索 <br/>- 区域，即region <br/>- 操作系统 <br/>- 出价：相对于按需计费的比例，25%、50%、100% <br/>- 实例类型刷选条件：vCPU和内存下限 <br/>- 结果包括下列维度 <br/>- 具体机型和配置 <br/>- 相比按需，可节省成本比例 <br/>- 出价过高的频次 <br/>- 上述数据依据过去30天的历史数据 <br/>- 小结 <br/>- 对于同一机型，出价越高，节省成本比例越小，但是出价过高的频次越小 <br/>- AWS 希望通过Advisor机制，建议用户购买“低频”机型，避免竞价超出用户出价，导致实例销毁。同时，引导到达市场适度平衡。</p><h2>竞价实例的价值 —— why</h2><h4>用户侧</h4><ul><li>有效降低用户成本 <br/><ul><li>考虑到云服务厂商自身成本，通常只能给用户一个适中的折扣。如果使用竞价实例，可以将闲时计费降到很低，有效降低用户成本。</li></ul></li><li>不仅batch场景，广义的离线计算都可以使用竞价实例，用户可以接受实例被销毁 </li></ul><figure><noscript><img data-rawheight=\"413\" src=\"https://pic3.zhimg.com/v2-b9f0ec8ec131830f27752eae1224fc02_b.png\" data-rawwidth=\"627\" class=\"origin_image zh-lightbox-thumb\" width=\"627\" data-original=\"https://pic3.zhimg.com/v2-b9f0ec8ec131830f27752eae1224fc02_r.jpg\"/></noscript><img data-rawheight=\"413\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;627&#39; height=&#39;413&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"627\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"627\" data-original=\"https://pic3.zhimg.com/v2-b9f0ec8ec131830f27752eae1224fc02_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b9f0ec8ec131830f27752eae1224fc02_b.png\"/></figure><br/><br/><h4>平台侧</h4><ul><li>错峰填谷，提升综合售卖率。</li><li>我们时常售罄，但是每周仍然有相当时间资源空闲，这其实也是浪费</li><li>单一在线业务与终端用户行为有关，通常难以改变“高峰-低谷趋势”；但是公有云上运行混合负载，涵盖在线业务和离线业务，可以引导离线业务客户购买竞价实例，实现错峰填谷</li><li>AWS 竞价实例规模巨大，曾披露：2016年一周的EC2 SPOT的计算能力大于2012一年EC2的计算实例 </li></ul><br/><h2>如何实现竞价实例 —— how</h2><h4>竞价实例整体设计</h4><ul><li>竞价市场 <br/><ul><li>以可用区zone + 具体机型为基本单位，不考虑OS平台</li><li>竞价市场，根据供需关系确定实时价格，后文专题展开</li><li>竞价市场的输出是price table，即指定zone + 指定机型，输出定价历史曲线。这样拉看，前文中的“定价历史记录”不仅是运营工具，更是核心数据</li></ul></li><li>计费方式 <br/><ul><li>Cvm bill组件查询price table获得具体分时价格，结合实例存在时间，向计费侧进行计费</li><li>整体流程与按量计费类似，不同点在于引入竞价市场的price table，计费粒度更小</li></ul></li><li>请求与实例 <br/><ul><li>维护请求与实例2层关系</li></ul></li><li>抢占 <br/><ul><li>抢占前2分钟，通知实例。子机内程序可识别信号，进行自我清理，实现“优雅退出”</li><li>子机计费，不得超过用户最高出价，特别注意抢占阶段。</li></ul></li><li>售罄与配额 <br/><ul><li>与当前售罄机制、配额向配合，包括总体按量售罄、具体机型售罄、用户配额。</li><li>当具体机型售罄时，竞价实例也应当售罄；每个用户在指定region的竞价实例也应当具有配额。</li></ul></li><li>API <br/><ul><li>需要支持API方式</li></ul></li></ul><h4>竞价市场和定价规则</h4><p>关于AWS竞价市场和定价规则，AWS从未公开，最初有2种思路，auction model或者后台设定价格。 <br/>- 思路一 <br/>- auction model <br/>- 类似互联网广告，m个广告主，n个广告位，最终价格与市场供需（包括广告主的出价）有关。常见模型包括GSP（广义第二价格）等。 <br/>- 思路二 <br/>- 与市场用户的竞价行为无关，后台设定价格 <br/>- 调研结论 <br/>- 很可能是思路二 <br/>- 代表论文：《Deconstructing Amazon EC2 Spot Instance Pricing》，以色列理工，以2010年数据为例，234次引用 <br/>- 核心观点：AWS SPOT的价格不是由市场驱动。相反，价格通常是根据后台预留好的价格生成的。 <br/>- 备注：论文年限相对较久，但是在本问题上影响力很大，引用广泛，因此主要参考本论文。</p><h4>论文核心</h4><ul><li>背景 <br/><ul><li>AWS为了售卖空闲资源，推出竞价实例</li><li>AWS并未披露其市场定价的机制与规则，只是公开了定价历史记录（不公开定价记录，则整套机制无法运转）</li><li>作者尝试去逆向AWS市场定价机制</li></ul></li><li>基本方法 <br/><ul><li>定义出价D的可用性，即在一个时间段内D大于等于实际价格的时间片分数</li><li>公式较为抽象，论文中仅配备了公式，并无配图。读者这里脑中可以结合定价历史记录想想一个走势图，易于理解此公式。 </li><figure><noscript><img data-rawheight=\"102\" src=\"https://pic2.zhimg.com/v2-a404abe686344aabd50a3649b8dce281_b.png\" data-rawwidth=\"522\" class=\"origin_image zh-lightbox-thumb\" width=\"522\" data-original=\"https://pic2.zhimg.com/v2-a404abe686344aabd50a3649b8dce281_r.jpg\"/></noscript><img data-rawheight=\"102\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;522&#39; height=&#39;102&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"522\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"522\" data-original=\"https://pic2.zhimg.com/v2-a404abe686344aabd50a3649b8dce281_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a404abe686344aabd50a3649b8dce281_b.png\"/></figure><br/></ul></li><li>统计数据 <br/><ul><li>横坐标为最高出价，纵坐标为前文定义的可用性</li><li>windows，不同region、不同机型的变化曲线，出价为绝对值 <br/></li><figure><noscript><img data-rawheight=\"203\" src=\"https://pic1.zhimg.com/v2-7abe2e2590b354bf5c8c6bb64db70fd4_b.png\" data-rawwidth=\"633\" class=\"origin_image zh-lightbox-thumb\" width=\"633\" data-original=\"https://pic1.zhimg.com/v2-7abe2e2590b354bf5c8c6bb64db70fd4_r.jpg\"/></noscript><img data-rawheight=\"203\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;633&#39; height=&#39;203&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"633\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"633\" data-original=\"https://pic1.zhimg.com/v2-7abe2e2590b354bf5c8c6bb64db70fd4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7abe2e2590b354bf5c8c6bb64db70fd4_b.png\"/></figure><br/><li>linux，不同region、不同机型的变化曲线，出价为归一化结果（折扣，出价除以按需原价的比例） <br/></li><figure><noscript><img data-rawheight=\"224\" src=\"https://pic2.zhimg.com/v2-3008b0f7d26a3a4e23eceaf3e8919d01_b.png\" data-rawwidth=\"738\" class=\"origin_image zh-lightbox-thumb\" width=\"738\" data-original=\"https://pic2.zhimg.com/v2-3008b0f7d26a3a4e23eceaf3e8919d01_r.jpg\"/></noscript><img data-rawheight=\"224\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;738&#39; height=&#39;224&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"738\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"738\" data-original=\"https://pic2.zhimg.com/v2-3008b0f7d26a3a4e23eceaf3e8919d01_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3008b0f7d26a3a4e23eceaf3e8919d01_b.png\"/></figure><br/><li>windows，不同region、不同机型的变化曲线，出价为归一化结果（折扣，出价除以按需原价的比例） <br/></li><figure><noscript><img data-rawheight=\"233\" src=\"https://pic1.zhimg.com/v2-855bcf687184e635e627cf3422f92fcc_b.png\" data-rawwidth=\"737\" class=\"origin_image zh-lightbox-thumb\" width=\"737\" data-original=\"https://pic1.zhimg.com/v2-855bcf687184e635e627cf3422f92fcc_r.jpg\"/></noscript><img data-rawheight=\"233\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;737&#39; height=&#39;233&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"737\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"737\" data-original=\"https://pic1.zhimg.com/v2-855bcf687184e635e627cf3422f92fcc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-855bcf687184e635e627cf3422f92fcc_b.png\"/></figure><br/></ul></li><li>先破后立 <br/>形成上述趋势，有两种可能 <br/><ol><li>AWS采用市场竞价模型，自然形成的这种趋势。</li><li>AWS后台设定“保留价格“，然后动态随机波动。 <br/>论文先假设第一种可能，并推翻；然后证明第二种可能成立。两部分有所呼应，但整体行文是先破后立。</li></ol></li><li>假设与推翻 <br/><ul><li>假设AWS定价是根据市场供需、用户出价自然形成的</li><li>反推几乎不可能： <br/><ul><li>论文提出，如果是市场驱动形成的，不可能同时满足多个趋势，例如：不同机型、不同地域，出价与可用性存在刚线性关系。按照绝对值计算，不同机型趋势相同，但取值不同；按照归一化结果计算，不同机型趋势和取值都近似等，这里不做展开。</li><li>并用数学AR（auto-regresive）推导，大概率不是根据市场生成的，与用户出价无关。</li></ul></li></ul></li><li>猜想与证明 <br/><ul><li>作者猜想的方法：动态随机保留价格算法，后台预先设定好若干个价格值，动态随机波动</li><li>算法需要一对入参，保留价格的下限F和上线C，然后通过AR推导出多个保留价格 <br/></li><figure><noscript><img data-rawheight=\"103\" src=\"https://pic2.zhimg.com/v2-113f3fa3041620e1c2bac14219a834b1_b.png\" data-rawwidth=\"773\" class=\"origin_image zh-lightbox-thumb\" width=\"773\" data-original=\"https://pic2.zhimg.com/v2-113f3fa3041620e1c2bac14219a834b1_r.jpg\"/></noscript><img data-rawheight=\"103\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;773&#39; height=&#39;103&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"773\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"773\" data-original=\"https://pic2.zhimg.com/v2-113f3fa3041620e1c2bac14219a834b1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-113f3fa3041620e1c2bac14219a834b1_b.png\"/></figure><br/><li>用数学AR推导，这种猜想的方法大概率是成立的</li><li>私货：对于价格与需求侧（用户出价）无关，论文说服力强；但是对于价格与供给侧（库存量）无关，论文说服力弱，因为研究者无从知道AWS的库存情况。有可能AWS实时查询库存值，然后根据预先设定好的若干个价格值中，进行关联波动。</li></ul></li><li>后台设定价格的好处 <br/><ul><li>保证成本，避免用户竞价对最终价格产生直接影响，保证售价符合成本预期</li></ul></li><li>当前数据 <br/>私货：论文利用的是2010年的数据，有没有可能AWS现在已经扬弃了当年的做法呢？我们来看下2017年5月最新的数据。 <br/>刻意选取了一种变化相对不规律的机型和一种变化非常规律的机型。可以发现即使是前者图中，也有很多设定的值，即最终定价是在若干个（几种或者几十种）价格中波动的；而对于后者图中，价格只有一折、十倍两种取值。 <br/>因此，大概率AWS目前仍然在沿用类似的机制。 <br/><figure><noscript><img data-rawheight=\"582\" src=\"https://pic3.zhimg.com/v2-bf86b62fb98e150bce8b93d4ba274b0e_b.png\" data-rawwidth=\"905\" class=\"origin_image zh-lightbox-thumb\" width=\"905\" data-original=\"https://pic3.zhimg.com/v2-bf86b62fb98e150bce8b93d4ba274b0e_r.jpg\"/></noscript><img data-rawheight=\"582\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;905&#39; height=&#39;582&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"905\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"905\" data-original=\"https://pic3.zhimg.com/v2-bf86b62fb98e150bce8b93d4ba274b0e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bf86b62fb98e150bce8b93d4ba274b0e_b.png\"/></figure><figure><noscript><img data-rawheight=\"584\" src=\"https://pic1.zhimg.com/v2-6af3b4750153a25d7b5a1386a02886e0_b.png\" data-rawwidth=\"908\" class=\"origin_image zh-lightbox-thumb\" width=\"908\" data-original=\"https://pic1.zhimg.com/v2-6af3b4750153a25d7b5a1386a02886e0_r.jpg\"/></noscript><img data-rawheight=\"584\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;908&#39; height=&#39;584&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"908\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"908\" data-original=\"https://pic1.zhimg.com/v2-6af3b4750153a25d7b5a1386a02886e0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6af3b4750153a25d7b5a1386a02886e0_b.png\"/></figure><br/></li></ul><h4>竞价市场原型</h4><ul><li>算法思路：阶梯折扣 <br/><ul><li>设定库存阈值与预留价格的对应关系</li><li>定时查询库存，根据阈值设定实时价格</li></ul></li><li>举例 <br/><ul><li>后台预先设定好若干个价格值，并与库存阈值关联</li><li>其中价格5元类似论文中的上限C，3元类似论文中的下限F</li><li>其中库存值和价格的关系，是根据经验人为设定，并非市场竞价模型得出</li></ul></li></ul><figure><noscript><img data-rawheight=\"227\" src=\"https://pic2.zhimg.com/v2-fd2ca988c635aea154b7c564c714a995_b.png\" data-rawwidth=\"451\" class=\"origin_image zh-lightbox-thumb\" width=\"451\" data-original=\"https://pic2.zhimg.com/v2-fd2ca988c635aea154b7c564c714a995_r.jpg\"/></noscript><img data-rawheight=\"227\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;451&#39; height=&#39;227&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"451\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"451\" data-original=\"https://pic2.zhimg.com/v2-fd2ca988c635aea154b7c564c714a995_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fd2ca988c635aea154b7c564c714a995_b.png\"/></figure><br/><br/><h4>需配合方支持</h4><ul><li>计费 <br/><ul><li>支持分时计费，子机不同时段费用不同，时间粒度细</li><li>支持更多价格，同一机型、同一配置，具有不同价格，可以供调用方（CVM）灵活调用</li></ul></li><li>资源管理 <br/><ul><li>适当扩大资源buff，尽量避免售罄</li><li>可跟随竞价实例的运营推广程度同步进行</li></ul></li><li>库存统计 <br/><ul><li>VStation已经支持模拟装箱算法进行准确库存统计</li><li>其他维度的库存待对齐支持，例如cbs、ip等</li></ul></li><li>运营监控 <br/><ul><li>竞价实例产品对运营监控能力要求较高，包括要展示各个机型的定价历史记录，使用者包括腾讯云用户和产品运营人员。</li><li>对资源库存统计、子机创建销毁进行监控，形成运营报表，同时覆盖竞价实例单独的运营报表</li><li>目前已有相关报表，进一步完善</li></ul></li><li>客户筛选 <br/><ul><li>理论上，子机随时可能被销毁，用户可接受</li><li>用户自行解决“断点重算”等问题，对用户有一定要求</li><li>剖析用户需求为增量需求，还是存量需求转换（按需计费改买竞价实例）。理论上，售价越便宜，客户购买量越大，但是实际情况还要观察。</li></ul></li></ul><h2>参考</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//aws.amazon.com/cn/ec2/spot/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Amazon EC2竞价型实例_Amazon EC2优势_AWS实例-AWS云服务</a> <br/><a href=\"https://link.zhihu.com/?target=https%3A//aws.amazon.com/cn/ec2/faqs/%23spot-instances\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">AWS EC2常见问题_EC2虚拟云服务器托管常见问题-AWS 云服务</a> <br/><a href=\"https://link.zhihu.com/?target=http%3A//blog.fit2cloud.com/2016/04/06/ec2-spot-instance-scale.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">你知道AWS的EC2竞价实例规模有多大了吗？</a> <br/><a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Auction\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Auction - Wikipedia</a> <br/><a href=\"https://link.zhihu.com/?target=http%3A//theory.stanford.edu/~tim/f13/l/l2.pdf\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">theory.stanford.edu/~ti</span><span class=\"invisible\">m/f13/l/l2.pdf</span><span class=\"ellipsis\"></span></a> <br/><a href=\"https://link.zhihu.com/?target=http%3A//www.mulix.org/pubs/cloud/spotprice-cloudcom.pdf\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">mulix.org/pubs/cloud/sp</span><span class=\"invisible\">otprice-cloudcom.pdf</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "云计算", 
                    "tagLink": "https://api.zhihu.com/topics/19550358"
                }, 
                {
                    "tag": "腾讯云", 
                    "tagLink": "https://api.zhihu.com/topics/19879841"
                }, 
                {
                    "tag": "Amazon Web Services (AWS)", 
                    "tagLink": "https://api.zhihu.com/topics/19558548"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/whycloud"
}
