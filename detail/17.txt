{
    "title": "绅士喵呜的技术小屋", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/cheng-xiang-dong-88", 
        "https://www.zhihu.com/people/lemonsen", 
        "https://www.zhihu.com/people/ni-ming-zhu-58-2", 
        "https://www.zhihu.com/people/masx200", 
        "https://www.zhihu.com/people/shoutleaf", 
        "https://www.zhihu.com/people/zbz-51", 
        "https://www.zhihu.com/people/StuHK", 
        "https://www.zhihu.com/people/CodeInception", 
        "https://www.zhihu.com/people/peng-zhi-qiang-28", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/srww", 
        "https://www.zhihu.com/people/zzsnail5", 
        "https://www.zhihu.com/people/johnny-63-54", 
        "https://www.zhihu.com/people/fang-kai-long", 
        "https://www.zhihu.com/people/chen-lin-21-45", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/luokexi", 
        "https://www.zhihu.com/people/forevercc-42", 
        "https://www.zhihu.com/people/bin-li-25-58", 
        "https://www.zhihu.com/people/awslong", 
        "https://www.zhihu.com/people/pitopi2010", 
        "https://www.zhihu.com/people/sa-jia-zhu-27", 
        "https://www.zhihu.com/people/murmansk-90", 
        "https://www.zhihu.com/people/dan-huang-53", 
        "https://www.zhihu.com/people/reseted1511020788305", 
        "https://www.zhihu.com/people/xiao-zi-4-59", 
        "https://www.zhihu.com/people/da-di-fang-dang-bu-ji", 
        "https://www.zhihu.com/people/jian-feng-he-41", 
        "https://www.zhihu.com/people/runze-86", 
        "https://www.zhihu.com/people/moore-kennedy", 
        "https://www.zhihu.com/people/liu-jiang-hua-41", 
        "https://www.zhihu.com/people/song-ya-zheng", 
        "https://www.zhihu.com/people/dou-bi-zong-he-zheng-wan-qi", 
        "https://www.zhihu.com/people/jiang-kai-ping-70-3", 
        "https://www.zhihu.com/people/xpal7512", 
        "https://www.zhihu.com/people/happyhappysuccess", 
        "https://www.zhihu.com/people/PualAzhenER", 
        "https://www.zhihu.com/people/curieux-87", 
        "https://www.zhihu.com/people/kan-kan-3-52", 
        "https://www.zhihu.com/people/li-qi-long-23", 
        "https://www.zhihu.com/people/mo-lin-97-96", 
        "https://www.zhihu.com/people/dong-teng-86-38", 
        "https://www.zhihu.com/people/di-zhai-24", 
        "https://www.zhihu.com/people/linshuai-tian", 
        "https://www.zhihu.com/people/he-jing-52-25", 
        "https://www.zhihu.com/people/he-zi-ran-79-34", 
        "https://www.zhihu.com/people/shit-yang", 
        "https://www.zhihu.com/people/yuan-zai-tian-bian-bian", 
        "https://www.zhihu.com/people/likelxl", 
        "https://www.zhihu.com/people/shu-yuan-27-67", 
        "https://www.zhihu.com/people/lishijie-78", 
        "https://www.zhihu.com/people/feng-lin-37-27", 
        "https://www.zhihu.com/people/wang-xiao-kui", 
        "https://www.zhihu.com/people/yu-guo-tian-qing-60-94", 
        "https://www.zhihu.com/people/zhang-qu-ji", 
        "https://www.zhihu.com/people/xuan-che", 
        "https://www.zhihu.com/people/ALLenLAS", 
        "https://www.zhihu.com/people/xiao-chuang-81-23", 
        "https://www.zhihu.com/people/sky-15", 
        "https://www.zhihu.com/people/jorden-chang", 
        "https://www.zhihu.com/people/duan-fang-liang", 
        "https://www.zhihu.com/people/ruan-dao", 
        "https://www.zhihu.com/people/liuzhibib", 
        "https://www.zhihu.com/people/shi-zi-dan-bo-ming-li", 
        "https://www.zhihu.com/people/wanhai", 
        "https://www.zhihu.com/people/ding-yi-97-8", 
        "https://www.zhihu.com/people/zhao-yue-chun-61", 
        "https://www.zhihu.com/people/xu-jun-fa-13", 
        "https://www.zhihu.com/people/shigebeyond", 
        "https://www.zhihu.com/people/guo-ke-49-2", 
        "https://www.zhihu.com/people/allen-gan", 
        "https://www.zhihu.com/people/leisideshenna", 
        "https://www.zhihu.com/people/yh-ding", 
        "https://www.zhihu.com/people/inextime", 
        "https://www.zhihu.com/people/cpm-81", 
        "https://www.zhihu.com/people/liu-xian-sen-21-26", 
        "https://www.zhihu.com/people/liwei-xie-50", 
        "https://www.zhihu.com/people/jian-dan-qin-xin-26-36", 
        "https://www.zhihu.com/people/wang-zheng-yu-69-44", 
        "https://www.zhihu.com/people/yang-dong-36-99", 
        "https://www.zhihu.com/people/rkfecode", 
        "https://www.zhihu.com/people/victor-51-11-70", 
        "https://www.zhihu.com/people/xiao-zhi-san-4", 
        "https://www.zhihu.com/people/bi-an-zhu-hua-diao-ling-67", 
        "https://www.zhihu.com/people/planetes-11"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/62074713", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 0, 
            "title": "简单了解 JavaScript 历史", 
            "content": "<blockquote>很多前端开始学习 JavaScript 语言的时候都或多或少地了解它的历史，本文就和你再次回顾一下 JavaScript 的历史，使得我们能够更快更全面地去上手 JavaScript。</blockquote><h2><b>一、周边事记</b></h2><blockquote>先来梳理一下和 JavaScript 相关的事件的时间轴，快速浏览一下即可，有兴趣的部分可以分别去百科了解。</blockquote><ol><li><b>1990</b> 李爵士创造出了 HTML，同时他在 1990 年底发明了 WWW 万维网。</li><li><b>1992</b> 第一个浏览器 Mosaic，由 NCSA 创造，从此网页可以在图形界面的窗口浏览。</li><li><b>1994</b> Håkon Wium Lie（李爵士的小伙伴）等人，发明 CSS。</li><li><b>1994</b> W3C 成立。</li><li><b>1994</b> NCSA 的一个主要程序员成立 Mosaic 通信公司，之后改名为 Netscape（网景）。</li><li><b>1994</b> Netscape 公司发布 Netscape Navigator 浏览器，面向普通用户。</li><li><b>1995</b> Netscape 雇佣 Brendan Eich（JS 之父）为 Navigator 开发网页脚本语言。同年年底发布 JavaScript</li><li><b>1996</b> Navigator 2.0 浏览器发布，内置重量级功能：脚本。</li><li><b>1996</b> 微软发布 IE 3，仿照 JS 发明了 JScript，抢占浏览器市场。</li><li><b>1996</b> 微软的 CAB（MS Cabinet）规格在UTF-8标准正式落实前就明确容许在任何地方使用UTF-8编码系统。这也表明了 JS 的编码不是完整的 Unicode，这是一个 BUG，比较落后的编码，请记住这个 BUG。</li><li><b>1997</b> Netscape 决定将 JavaScript 交给国际标准化组织 ECMA，希望 JavaScript 成为标准来抵抗微软，ECMAScript 1.0 发布。</li><li><b>1998</b> Netscape 打不过微软，开源了浏览器，Monzilla 项目诞生，Netscape 之后也别美国在线收购。</li><li><b>1999</b> 微软发布 IE 5，部署了 XMLHttpRequest 接口，允许 JavaScript 发 HTTP 请求，为后面的 Ajax 应用创造条件。</li><li><b>2000</b> KDE 项目重写浏览器引擎 KHTML，为之后的 WebKit 和 Blink 引擎打下基础。同年 KDE 2.0 发布。</li><li><b>2001</b> 大名鼎鼎的 IE 6 发布，之后统治浏览器市场很多年。</li><li><b>2001</b> JSON 格式诞生，由 Douglas Crockford 提出，用于取代 XML 格式进行服务器和网页间的数据交换。</li><li><b>2002</b> Firefox 由 Monzilla 发布。</li><li><b>2003</b> Safari 由 苹果发布。</li><li><b>2004</b> Gmail 由 Google 发布，运用的就是 JS 发送 HTTP 请求功能，这促成了 Web Application 概念的诞生，JavaScript 也正式被当做是一门编程语言。这时候以 JavaScript 为生的人，也就是 Font-end（前端）程序员出现。</li><li><b>2004</b> Dojo 框架诞生，JavaScript 编程框架时代来临。</li><li><b>2005</b> Ajax 方法诞生，同年发布的 Google Maps 项目大量运用该方法。Web 2.0 时代来临。</li><li><b>2005</b> 基于 JSON 格式的数据库 CouchDB 由 Apache 基金会发布，标志 NoSQL 类型数据库诞生。</li><li><b>2006</b> jQuery 函数库诞生，推动了 JavaScript 的流行。</li><li><b>2008</b> V8 编译器诞生，它是 Google 公司为 Chrome 浏览器而开发的，它提高了 JavaScript 的性能，推动了语法的改进和标准化。</li><li><b>2009</b> Node.js 项目诞生，标志着 JavaScript 可以用于服务器端编程。</li><li><b>2009</b> CoffeeScript 最初版本由 Jeremy Ashkenas 发布，开启了其他语言转为 JavaScript 的风潮。（Ruby 对现代编程语言真是影响颇大啊）。</li><li><b>2010</b> NPM、BackboneJS 和 RequireJS 诞生，标志着 JavaScript 进入模块化开发的时代。</li><li><b>2011</b> Dart 语言由 Google 发布。</li><li><b>2012</b> SPA 框架开始崛起，AngularJS 项目和 Ember 项目都发布了1.0版本。</li><li><b>2012</b> TypeScript 由微软发布，该语言是 JavaScript 的超集，适用于大型项目的开发。</li><li><b>2013</b> ECMA 正式推出 JSON 的国际标准。</li><li><b>2013</b> React 由 Facebook 发布，引入很多语法和概念。</li><li><b>2014</b> React Native 由 Facebook 发布，为 JavaScript 语言开发高性能的原生 App 打开了一条道路。</li><li><b>2015</b>  Polymer 框架 1.0 版由 Google 发布，该项目的目标是生产环境可以使用 WebComponent 组件，如果能够达到目标，Web 开发将进入一个全新的以组件为开发基础的阶段。</li><li><b>2015</b> ECMA 6 发布，JavaScript 正式进入下一个阶段，成为一种企业级的、开发大规模应用的语言。</li></ol><h2><b>二、JavaScript 的诞生</b></h2><p>从上面的时间轴我们可以知道，1994 年 Netscape 发布 Navigator 1.0 版本之后很快发现，浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时的网速很慢并且网费很贵，有些操作不适合在服务端完成，能在浏览器的网页中完成那是再好不过的了。所以 Netscape 设想的这种浏览器脚本语言需要满足这几个条件：<b>功能简单、语法简单、容易学习、容易部署。</b></p><p>1994 年，恰逢 Sun 公司的 Java 问世，市场推广很成功，所以 Netscape 决定和 Sun 公司合作，浏览器支持嵌入 Java 小程序，但是脚本语言不需要 Java 那么重型的语法，Netscape 决定开发一个接近 Java 的轻量级脚本语言。</p><p>1995 年，Netscape 雇佣 Brendan Eich 来开发这种网页脚本语言。Brendan Eich 有很强的函数式编程背景。</p><p>Brendan Eich 主要方向和兴趣是函数式编程，Netscape 招募他是为了研究将 Scheme 语言作为网页脚本语言的可能性，他本人也是这么认为的，以为以后会在 Netscape 里使用 Scheme。但是一个月后，Netscape 决定未来的网页脚本语言必须看上去和 Java 类似，但是要更简单，以使得更多人快速上手。</p><p>Brendan 用了十天就把 JavaScript 设计出来了，emmmmm，这么短的事件时间显然是为了应付公司安排，他对 Java 没有太大兴趣。由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript 写出来的程序混乱不堪。</p><h3><b>JavaScript 诞生之初的设计来源</b></h3><ul><li>基本语法：借鉴 C 语言和 Java 语言。</li><li>数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。</li><li>函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。</li><li>原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。</li><li>正则表达式：借鉴 Perl 语言。</li><li>字符串和数组处理：借鉴 Python 语言。</li></ul><h3><b>JavaScript 诞生时带有的缺陷</b></h3><p>为了简单，JavaScript 缺少很多关键功能，比如块级作用域、模块、子类型（subtyping）等等，但是可以利用现有功能找出解决办法（设计模式）。由于来源多样，JavaScript 从一开始就决定了它的编程风格是<b>函数式编程和面向对象编程的混合体</b>。</p><p>我们可以看到最初的 JavaScript 并不满足现在的编程需求，它都是全局变量，互相干扰，没有模块化。而且标准库不行，内置代码不够多，HTTP 模块、date 模块、常见算法模块之类的都没有。</p><h3><b>JavaScript 与 Java</b></h3><p>JavaScript 的基本语法和对象体系，是模仿 Java 而设计的，但是没有采用 Java 的静态类型。JavaScript 和 Java 语法的最大两点区别是：</p><ul><li>函数是一种独立的数据类型。</li><li>采用基于原型对象（prototype）的继承链。</li></ul><p>JavaScript 语法要更加自由，JavaScript 语言直接由解释器执行运行，不需要编译。</p><p>Java 对 JavaScript 的影响，主要是把数据分成基本类型和对象类型两种，比如字符串和字符串对象。</p><h3><b>Brendan Eich 的评价</b></h3><blockquote>&#34;与其说我爱Javascript，不如说我恨它。它是C语言和Self语言一夜情的产物。<b>十八世纪英国文学家约翰逊博士说得好：&#39;它的优秀之处并非原创，它的原创之处并不优秀。&#39;</b>（the part that is good is not original, and the part that is original is not good.）&#34;</blockquote><h2><b>三、JavaScript 继承机制的设计</b></h2><p>JavaScript 没有子类和父类的概念，也没有类（class）和实例（instance）的区分，它都是靠一种特有的<b>原型链</b>（prototype chain）模式来实现继承，想必每个前端工程师都花过一定时间去了解这个原型链，下面来说一说它是怎么设计出来的。</p><p>1994 年正式面向对象编程兴盛的时期，当时 C++ 是最流行的语言，Java 也被广泛推广。JavaScript 的设计无疑也受到了影响，JavaScript 中所有的数据类型都是对象（基本类型可以在你调用属性或方法的时候给你包装对象），即使是一个布尔值，当它被声明后，也拥有了对应的属性和方法。这时候，Brendan Eich 遇到了一个难题，他要不要设计继承机制呢？</p><h3><b><code>new</code> 的使用</b></h3><p>一个简单的脚本语言，并不需要继承机制，但是 JavaScript 中的对象，得需要一种机制将这些对象串联起来，所以 Brendan Eich 还是设计了继承机制，但是并没有设计类。他看到 C++ 和 Java 都是通过 <code>new</code> 生成实例，因此他将 <code>new</code> 引入了 JavaScript，用以从原型对象生成一个实例对象。但是 JavaScript 怎么来表示原型对象呢？它没有类啊。</p><p>他看到 C++ 和 Java 使用 <code>new</code> 命令的时候，都会调用类的构造函数（constructor），于是他就做了一个简化设计，在 JavaScript 中，<code>new</code> 命令后面跟的不是一个类，而是构造函数。</p><div class=\"highlight\"><pre><code class=\"language-js\"> <span class=\"c1\">// 构造函数 DOG，表示狗对象的原型\n</span><span class=\"c1\"></span> <span class=\"kd\">function</span> <span class=\"nx\">DOG</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n   <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n <span class=\"err\">​</span>\n <span class=\"c1\">// 使用 new，生成狗对象实例\n</span><span class=\"c1\"></span> <span class=\"kd\">var</span> <span class=\"nx\">corgi</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">DOG</span><span class=\"p\">(</span><span class=\"s1\">&#39;柯基&#39;</span><span class=\"p\">);</span>\n <span class=\"nx\">alert</span><span class=\"p\">(</span><span class=\"nx\">corgi</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">);</span> <span class=\"c1\">// 柯基\n</span></code></pre></div><p>构造函数中的 <code>this</code> 关键字，代表了新创建的实例对象。</p><h3><b><code>new</code> 的缺点</b></h3><p>使用构造函数生成实例对象，是无法共享属性和方法的。每一个实例对象都拥有自己的属性和方法的副本，这就使得数据无法共享，资源被浪费。</p><h3><b><code>prototype</code> 的引入</b></h3><p>针对上面的缺点，Brendan Eich 决定为构造函数设置一个属性 <code>prototype</code>。这个属性包含一个对象，所有实例对象需要共享的属性和方法，都放在这个 <code>prototype 对象</code> 中。实例对象一旦被创建，自动引用 <code>prototype</code> 对象的属性和方法。也就是说，实例对象的属性和方法分成两种，一种是本地的，一种是引用的。</p><div class=\"highlight\"><pre><code class=\"language-js\"> <span class=\"kd\">function</span> <span class=\"nx\">DOG</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n   <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">name</span><span class=\"p\">;</span>\n <span class=\"p\">}</span> \n <span class=\"err\">​</span>\n <span class=\"nx\">DOG</span><span class=\"p\">.</span><span class=\"nx\">prototype</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">species</span><span class=\"o\">:</span> <span class=\"s1\">&#39;犬科&#39;</span> <span class=\"p\">};</span>\n <span class=\"err\">​</span>\n <span class=\"kd\">var</span> <span class=\"nx\">corgi</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">DOG</span><span class=\"p\">(</span><span class=\"s1\">&#39;柯基&#39;</span><span class=\"p\">);</span>\n <span class=\"kd\">var</span> <span class=\"nx\">shiba</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">DOG</span><span class=\"p\">(</span><span class=\"s1\">&#39;柴犬&#39;</span><span class=\"p\">);</span>\n <span class=\"err\">​</span>\n <span class=\"nx\">alert</span><span class=\"p\">(</span><span class=\"nx\">corgi</span><span class=\"p\">.</span><span class=\"nx\">species</span><span class=\"p\">);</span> <span class=\"c1\">// 犬科\n</span><span class=\"c1\"></span> <span class=\"nx\">alert</span><span class=\"p\">(</span><span class=\"nx\">shiba</span><span class=\"p\">.</span><span class=\"nx\">species</span><span class=\"p\">);</span> <span class=\"c1\">// 犬科\n</span><span class=\"c1\"></span> <span class=\"err\">​</span>\n <span class=\"c1\">// 修改 prototype\n</span><span class=\"c1\"></span> <span class=\"nx\">DOG</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">species</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;小型犬&#39;</span><span class=\"p\">;</span>\n <span class=\"err\">​</span>\n <span class=\"nx\">alert</span><span class=\"p\">(</span><span class=\"nx\">corgi</span><span class=\"p\">.</span><span class=\"nx\">species</span><span class=\"p\">);</span> <span class=\"c1\">// 小型犬\n</span><span class=\"c1\"></span> <span class=\"nx\">alert</span><span class=\"p\">(</span><span class=\"nx\">shiba</span><span class=\"p\">.</span><span class=\"nx\">species</span><span class=\"p\">);</span> <span class=\"c1\">// 小型犬\n</span></code></pre></div><p>修改了 <code>prototype</code> 对象，会同时影响到两个实例对象。</p><h2><b>四、JavaScript 与 ECMAScript</b></h2><p>1996 年微软发布了 JScript，Netscape 丧失浏览器脚本语言主导地位，于是 Netcape 为了抵抗微软，将 JavaScript 交给 ECMA 来制定标准获得话语权，免得微软一家独大。因为 Sun 公司授权的 JavaScript 这个名字只能由 Netscape 使用，所以 ECMA 发布的浏览器脚本语言标准叫做 ECMAScript，1997 年 ECMAScript 1.0 发布。</p><p>我们可以将 ECMAScript 理解为 JavaScript 的规范，ECMAScript 只用来标准化 JavaScript 的基本语法结构，DOM 这种部署环境相关的标准由 W3C 组织指定。</p><ol><li><b>1997</b> ECMAScript 1.0 发布。</li><li><b>1998</b> ECMAScript 2.0 发布。</li><li><b>1999</b> ECMAScript 3.0 发布，并获得了广泛支持。</li><li><b>2007</b> ECMAScript 4.0 草案发布，但是此版本过于激进，大家分歧过大，于 2008 年被终止。</li><li><b>2008</b> ECMAScript 3.1 发布，对 4.0 草案中一小部分进行发布，其他设想放入以后版本。</li><li><b>2009</b> ECMAScript 5.0 发布。</li><li><b>2011</b> ECMAScript 5.1 发布，2012 年底所有浏览器都支持此版本的所有功能。</li><li><b>2015</b> ECMAScript 6 发布，并且更名为 ECMAScript 2015，之后每年都会发布一个版本。</li></ol><p>总之，就是 ES4 的设想过于激进，项目中止，ES5 升级步伐吸取教训，进行小升级，之后的版本都是逐渐完成当初的一些设想。我们可以看到 ES6 吸取了 CoffeeScript 很多特性：类、箭头函数、optional chain 语法。我们也能从中理解到 JavaScript 作者所说的 &#34;the part that is good is not original, and the part that is original is not good.&#34;</p><p>其实现在没有发布的新特性，我们可以通过 babel 等转译器，使用这些未发布的虚空语法。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>相关阅读</b></h2><ol><li><a href=\"https://link.zhihu.com/?target=https%3A//wangdoc.com/javascript/basic/history.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript 语言的历史</a> 阮一峰；</li><li><a href=\"https://link.zhihu.com/?target=https%3A//itbilu.com/javascript/js/V1APADgrG.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript(ECMAScript) 语言标准历史及标准制定过程介绍</a> IT 笔录；</li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Javascript继承机制的设计思想</a> 阮一峰；</li><li><a href=\"https://link.zhihu.com/?target=http%3A//nostarsnow.github.io/2016/03/19/What-is-the-Significance-of-Javascript/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Javascript的意义何在？个人理解的js发展史</a> nostar；</li><li><a href=\"https://link.zhihu.com/?target=http%3A//oreilly.com/javascript/radarreports/past-present-future-javascript.csp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Past, Present, and Future of JavaScript</a> Axel Rauschmayer；</li><li><a href=\"https://link.zhihu.com/?target=http%3A//creativejs.com/2013/06/the-race-for-speed-part-4-the-future-for-javascript/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The race for speed part 4: The future for JavaScript</a> John Dalziel。</li></ol>", 
            "topic": [
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }, 
                {
                    "tag": "JavaScript 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19681416"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59015413", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 9, 
            "title": "ES6 - Promise", 
            "content": "<h2><b>零、引入</b></h2><p>众所周知，在 JavaScript 的世界里，所有代码都是单线程执行的。由于这个原因，使得 JavaScript 所有的网络操作、浏览器事件，都得是异步执行的。</p><p>异步执行可以用一个回调函数实现：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">function</span> <span class=\"nx\">callback</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;执行完成&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;调用之前&#39;</span><span class=\"p\">);</span>\n  <span class=\"nx\">setTimeout</span><span class=\"p\">(</span><span class=\"nx\">callback</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">);</span><span class=\"c1\">// 1s 之后调用 callback()\n</span><span class=\"c1\"></span>  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;调用之后&#39;</span><span class=\"p\">);</span>\n</code></pre></div><p>然后我们可以在控制台中看到：</p><div class=\"highlight\"><pre><code class=\"language-text\">  调用之前\n  调用之后\n  --- 1s 延迟 ---\n  执行完成</code></pre></div><p>可见，异步操作会在定时器过期后触发函数调用。</p><p>我们看一下使用异步操作的 AJAX：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">request</span><span class=\"p\">.</span><span class=\"nx\">onReadyStateChange</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">request</span><span class=\"p\">.</span><span class=\"nx\">readyState</span> <span class=\"o\">===</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">request</span><span class=\"p\">.</span><span class=\"nx\">status</span> <span class=\"o\">===</span> <span class=\"mi\">200</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nx\">success</span><span class=\"p\">(</span><span class=\"nx\">request</span><span class=\"p\">.</span><span class=\"nx\">responseText</span><span class=\"p\">)</span>\n      <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nx\">fail</span><span class=\"p\">(</span><span class=\"nx\">request</span><span class=\"p\">.</span><span class=\"nx\">status</span><span class=\"p\">)</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>把回调函数 <code>success(request.responseText)</code> 和 <code>fail(request.status)</code> 写到一个 AJAX 操作里很正常，但不好看，不利于代码复用。</p><p>我们来优化一下写法：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">var</span> <span class=\"nx\">ajax</span> <span class=\"o\">=</span> <span class=\"nx\">ajaxGet</span><span class=\"p\">(</span><span class=\"s1\">&#39;http://...&#39;</span><span class=\"p\">);</span>\n  <span class=\"nx\">ajax</span><span class=\"p\">.</span><span class=\"nx\">ifSuccess</span><span class=\"p\">(</span><span class=\"nx\">success</span><span class=\"p\">)</span>\n    <span class=\"p\">.</span><span class=\"nx\">ifFail</span><span class=\"p\">(</span><span class=\"nx\">fail</span><span class=\"p\">);</span>\n</code></pre></div><p>这种链式写法，不关心执行结果，先执行逻辑再说，然后根据执行结果调用相对应的函数。</p><p>这种 “承诺将来会执行” 的对象在 JavaScript 中被称为 <code>Promise</code> 对象。</p><p><code>Promise</code> 是异步编程的一种解决方案，比起上面的 “回调函数和事件” 的传统解决方案要更为简洁合理。所谓的 <code>Promise</code> 就是一个容器，里面存放着某个未来才会结束的事件（一般是一个异步操作）。从语法上看，它是一个对象，可以获取异步操作的消息。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>一、Promise</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p><code>Promise</code> 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。</p><blockquote>本条目为 Promise 构造函数</blockquote><p>JavaScript Demo:</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">var</span> <span class=\"nx\">promise1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setTimeout</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n      <span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"s1\">&#39;foo&#39;</span><span class=\"p\">);</span>\n    <span class=\"p\">},</span> <span class=\"mi\">300</span><span class=\"p\">);</span>\n  <span class=\"p\">});</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">peomise1</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">value</span><span class=\"p\">);</span>\n    <span class=\"c1\">// excepted output: &#39;foo&#39;\n</span><span class=\"c1\"></span>  <span class=\"p\">});</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">promise1</span><span class=\"p\">);</span>\n  <span class=\"c1\">// excepted output: [object Promise]\n</span></code></pre></div><h2><b>1.1 语法</b></h2><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">{...}</span> <span class=\"cm\">/*executor*/</span> <span class=\"p\">);</span>\n</code></pre></div><h2><b>参数</b></h2><p><b>executor</b></p><ul><li><code>executor</code> 是带有 <code>resolve</code> 和 <code>reject</code> 两个参数的函数、<code>Promise</code> 构造函数执行时立即调用 <code>executor</code> 函数，<code>resolve</code> 和 <code>reject</code> 两个函数作为参数传递给 <code>executor</code> （<code>executor</code> 函数在 <code>Promise</code> 构造函数返回新建对象之前被调用）。<code>resolve</code> 和 <code>reject</code> 函数别调用时，分别将 <code>promise</code> 的状态改为 <code>fulfilled</code>（完成）或 <code>rejected</code>（失败）。<code>executor</code> 内部通常会执行一些异步操作，一旦完成，可以调用 <code>resolve</code> 函数来将 <code>promise</code> 的状态改成 <code>fulfilled</code>，或者发生错误的时候将它状态改成 <code>rejected</code>。</li><li>如果在 <code>executor</code> 函数中抛出一个错误，那么该 <code>promise</code> 状态为 <code>rejected</code>。<code>executor</code> 函数返回值被忽略。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.2 描述</b></h2><p><code>Promise</code> 对象是一个代理对象（代理一个值），被代理的值在 <code>Promise</code> 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果。 而是一个能代表未来出现的结果的 <code>promise</code> 对象。</p><p>一个 <code>Promise</code> 有以下几种状态：</p><ul><li>pending：初始状态，即不是成功，也不是失败状态</li><li>fulfilled：意味着操作成功完成</li><li>rejected：意味着操作失败</li></ul><p><code>pending</code> 状态的 <code>Promise</code> 对象可能触发 <code>fulfilled</code> 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，<code>Promise</code> 对象的 <code>then</code> 方法绑定的处理方法（handlers）就会被调用。</p><p><code>then</code> 方法包含两个参数：<code>onfulfilled</code> 和 <code>onrejected</code>，它们都是 <code>Function</code> 类型。</p><ul><li>当 <code>Promise</code> 状态为 <i>fulfilled</i> 时，调用 <code>then</code> 的 <code>onfulfilled</code> 方法</li><li>当 <code>Promise</code> 状态为 <i>rejected</i> 时，调用 <code>then</code> 的 <code>onrejected</code> 方法</li></ul><p>所以在异步操作的完成和绑定处理方法之间不存在竞争。</p><p>因为 <code>Promise.prototype.then</code> 和 <code>Promise.protoytype.catch</code> 方法返回 <code>promise</code> 对象，所以它们可以被链式调用。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2473f81ef824fb9d349d243137f282f3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"801\" data-rawheight=\"297\" class=\"origin_image zh-lightbox-thumb\" width=\"801\" data-original=\"https://pic4.zhimg.com/v2-2473f81ef824fb9d349d243137f282f3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;801&#39; height=&#39;297&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"801\" data-rawheight=\"297\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"801\" data-original=\"https://pic4.zhimg.com/v2-2473f81ef824fb9d349d243137f282f3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2473f81ef824fb9d349d243137f282f3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><blockquote><b>不要和惰性求值混淆：</b> 有一些语言中有惰性求值和延时计算的特性，它们也被称为“promises”，例如Scheme. Javascript中的promise代表一种已经发生的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的&#34;<a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">箭头方法</a>&#34;:  <code>f = () =&gt;</code><i>表达式</i> 创建惰性求值的表达式<i>，</i>使用 <code>f()</code> 求值。<br/><b>注意：</b> 如果一个promise对象处在fulfilled或rejected状态而不是pending状态，那么它也可以被称为<i>settled</i>状态。你可能也会听到一个术语<i>resolved</i> ，它表示promise对象处于fulfilled状态。关于promise的术语， Domenic Denicola 的 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">States and fates</a> 有更多详情可供参考。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.3 属性</b></h2><ul><li><code>Promise.length</code>：length 的属性，其值总是为 1（构造器参数的数目）</li><li><code>Promise.prototype</code>：表示 <code>Promise</code> 构造器的原型</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.4 方法</b></h2><ul><li><code>Promise.all(iterable)</code><br/></li><ul><li>这个方法返回一个新的 <code>promise</code> 对象，该 <code>promise</code> 对象在 <code>iterable</code> 参数对象里所有的 <code>promise</code> 对象都成功的时候才触发成功，一旦有任何一个 <code>iterable</code> 里面的 <code>promise</code> 对象失败则立即触发该 <code>promise</code> 对象的失败。这个新的 <code>promise</code> 对象在触发成功状态以后，会把一个包含 <code>iterable</code> 里所有 <code>promise</code> 返回值的数组作为成功回调的返回值，顺序跟 <code>iterable</code> 的顺序保持一致；如果这个新的 <code>promise</code> 对象触发了失败状态，它会把 <code>iterable</code> 里第一个触发失败的 <code>promise</code> 对象的错误作为它的失败错误信息。</li><li><code>Promise.all</code> 常用于处理多个 Promise 对象的状态集合。（参考 jQuery.when 方法）</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><code>Promise.race(iterable)</code><br/></li><ul><li>当 <code>iterable</code> 参数里的任意一个子 <code>promise</code> 被成功或失败后，父 <code>promise</code> 马上也会用子 <code>promise</code> 的成功返回值或失败详情作为参数调用父 <code>promise</code> 绑定的相应句柄，并返回该 promise 对象。</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><code>Promise.reject(reason)</code><br/></li><ul><li>返回一个状态为失败的 <code>Promise</code> 对象，并将给定的失败信息传递给对应的处理方法</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><code>Promise.resolve(value)</code><br/></li><ul><li>返回一个状态由给定 <code>value</code> 决定的 <code>Promise</code> 对象。</li><li>如果该值是一个 <code>Promise</code> 对象，则直接返回该对象；</li><li>如果该值是 <code>thenable</code>（即，带有 <code>then</code> 方法的对象），返回的 <code>Promise</code> 对象的最终状态由 <code>then</code> 方法执行决定；</li><li>否则的话（该 <code>value</code> 为空，基本类型或者不带 <code>then</code> 方法的对象），返回的 <code>Promise</code> 对象状态为 <code>fulfilled</code>，并且将该 <code>value</code> 值传递给对应的 <code>then</code> 方法。</li></ul></ul><p>通常而言，如果你不知道一个值是否是 <code>Promise</code> 对象，使用 <code>Promise.resolve(value)</code> 来返回一个 <code>Promise</code> 对象，这样就能够将该 <code>value</code> 以 <code>Promise</code> 对象形式使用。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.5 Promise 原型</b></h2><h2><b>属性</b></h2><p><code>Promise.prototype.constructor</code></p><p> 返回被创建的实例函数，默认为 <code>Promise</code> 函数</p><h2><b>方法</b></h2><p><code>Promise.prototype.catch(onRejected)</code></p><ul><li>添加一个拒绝（<code>rejected</code>）回调到当前 <code>promise</code>，返回一个新的 <code>promise</code>。当这个回调函数被调用，新的 <code>promise</code> 将以它的返回值来 <code>resolve</code>，否则如果当前 <code>promise</code> 进入 <code>fulfilled</code> 状态，则以当前 <code>promise</code> 的完成结果作为新的 <code>promise</code> 的完成结果。</li></ul><p><code>Promise.prototype.then(onFulfilled, onRejected)</code></p><ul><li>添加解决（<code>fulfilled</code>）和拒绝（<code>rejected</code>）回调到当前 <code>promise</code>，返回一个新的 <code>promise</code>，将以回调的返回值来 <code>resolve</code></li></ul><p><code>Promise.prototype.finally(onFinally)</code></p><ul><li>添加一个事件处理回调于当前 <code>promise</code> 对象，并且在原 <code>promise</code> 对象解析完毕后，返回一个新的 <code>promise</code> 对象。回调会在当前的 <code>promise</code> 运行完毕后被调用，无论当前 <code>promise</code> 的状态是完成 <code>fulfilled</code> 还是拒绝 <code>rejected</code></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.6 创建 Promise</b></h2><p><code>Promise</code> 对象是由关键字 <code>new</code> 及其构造函数来创建的。该构造函数会把一个叫做 “处理器函数” 的函数作为它的参数。这个 “处理器函数” 接受两个函数——<code>resolve</code> 和 <code>reject</code>——作为其参数。当异步任务顺利完成且返回结果值时，会调用 <code>resolve</code> 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用 <code>reject</code> 函数。</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">myFirstPromise</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">((</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// ?做一些异步操作，最终会调用下面两者之一:\n</span><span class=\"c1\"></span>    <span class=\"c1\">//\n</span><span class=\"c1\"></span>    <span class=\"c1\">//   resolve(someValue); // fulfilled\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ?或\n</span><span class=\"c1\"></span>    <span class=\"c1\">//   reject(&#34;failure reason&#34;); // rejected\n</span><span class=\"c1\"></span>  <span class=\"p\">});</span>\n</code></pre></div><p>想要某个函数？拥有 promise 功能，只需让其返回一个 promise 即可。</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">function</span> <span class=\"nx\">myAsyncFunction</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">((</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"o\">=</span><span class=\"err\">》</span> <span class=\"p\">{</span>\n      <span class=\"k\">const</span> <span class=\"nx\">xhr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">XMLHttpRequest</span><span class=\"p\">();</span>\n      <span class=\"nx\">xhr</span><span class=\"p\">.</span><span class=\"nx\">open</span><span class=\"p\">(</span><span class=\"s2\">&#34;GET&#34;</span><span class=\"p\">,</span> <span class=\"nx\">url</span><span class=\"p\">);</span>\n      <span class=\"nx\">xhr</span><span class=\"p\">.</span><span class=\"nx\">onload</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">xhr</span><span class=\"p\">.</span><span class=\"nx\">responseText</span><span class=\"p\">);</span>\n      <span class=\"nx\">xhr</span><span class=\"p\">.</span><span class=\"nx\">onerror</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">reject</span><span class=\"p\">(</span><span class=\"nx\">xhr</span><span class=\"p\">.</span><span class=\"nx\">statusText</span><span class=\"p\">);</span>\n      <span class=\"nx\">xhr</span><span class=\"p\">.</span><span class=\"nx\">send</span><span class=\"p\">();</span>\n    <span class=\"p\">});</span>\n  <span class=\"p\">};</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.7 实例</b></h2><h2><b>非常简单的例子</b></h2><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">let</span> <span class=\"nx\">myFirstPromise</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 当异步代码执行成功的时候，我们才会调用 resolve(...)，当异步代码失败时就会调用 reject(...)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 在本例中，我们使用 setTimeout(...) 来模拟异步代码，实际编码时可能是 XHR 请求或是 HTML5 API\n</span><span class=\"c1\"></span>    <span class=\"nx\">setTimeout</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(){</span>\n      <span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"s2\">&#34;成功！&#34;</span><span class=\"p\">);</span> <span class=\"c1\">// 代码正常执行！\n</span><span class=\"c1\"></span>    <span class=\"p\">},</span> <span class=\"mi\">250</span><span class=\"p\">);</span>\n  <span class=\"p\">});</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">myFirstPromise</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">successMessage</span><span class=\"p\">){</span>\n    <span class=\"c1\">// successMessage 的值是上面调用 resolve(...) 方法传入的值\n</span><span class=\"c1\"></span>    <span class=\"c1\">// successMessage 参数不一定非要是字符串类型，这里只是个例子\n</span><span class=\"c1\"></span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">&#34;Yay! &#34;</span> <span class=\"o\">+</span> <span class=\"nx\">successMessage</span><span class=\"p\">);</span>\n  <span class=\"p\">})</span>\n</code></pre></div><h2><b>高级一点的例子</b></h2><p>本例展示了 <code>Promise</code> 的一些机制。 <code>testPromise()</code> 方法在每次点击 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">``</a> 按钮时被调用，该方法会创建一个 <code>promise</code> 对象，使用 <code><a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">window.setTimeout()</a></code> 让Promise等待 1-3 秒不等的时间来填充数据（通过Math.random()方法）。</p><p>Promise 的值的填充过程都被日志记录（logged）下来，这些日志信息展示了方法中的同步代码和异步代码是如何通过Promise完成解耦的。</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"s1\">&#39;use strict&#39;</span><span class=\"p\">;</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">promiseCount</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"err\">​</span>\n  <span class=\"kd\">function</span> <span class=\"nx\">testPromise</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n      <span class=\"kd\">let</span> <span class=\"nx\">thisPromiseCount</span> <span class=\"o\">=</span> <span class=\"o\">++</span><span class=\"nx\">promiseCount</span><span class=\"p\">;</span>\n  <span class=\"err\">​</span>\n      <span class=\"kd\">let</span> <span class=\"nx\">log</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">getElementById</span><span class=\"p\">(</span><span class=\"s1\">&#39;log&#39;</span><span class=\"p\">);</span>\n      <span class=\"nx\">log</span><span class=\"p\">.</span><span class=\"nx\">insertAdjacentHTML</span><span class=\"p\">(</span><span class=\"s1\">&#39;beforeend&#39;</span><span class=\"p\">,</span> <span class=\"nx\">thisPromiseCount</span> <span class=\"o\">+</span>\n          <span class=\"s1\">&#39;) 开始 (&lt;small&gt;同步代码开始&lt;/small&gt;)&lt;br/&gt;&#39;</span><span class=\"p\">);</span>\n  <span class=\"err\">​</span>\n      <span class=\"c1\">// 新构建一个 Promise 实例：使用Promise实现每过一段时间给计数器加一的过程，每段时间间隔为1~3秒不等\n</span><span class=\"c1\"></span>      <span class=\"kd\">let</span> <span class=\"nx\">p1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">(</span>\n          <span class=\"c1\">// resolver 函数在 Promise 成功或失败时都可能被调用\n</span><span class=\"c1\"></span>         <span class=\"p\">(</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n              <span class=\"nx\">log</span><span class=\"p\">.</span><span class=\"nx\">insertAdjacentHTML</span><span class=\"p\">(</span><span class=\"s1\">&#39;beforeend&#39;</span><span class=\"p\">,</span> <span class=\"nx\">thisPromiseCount</span> <span class=\"o\">+</span>\n                  <span class=\"s1\">&#39;) Promise 开始 (&lt;small&gt;异步代码开始&lt;/small&gt;)&lt;br/&gt;&#39;</span><span class=\"p\">);</span>\n              <span class=\"c1\">// 创建一个异步调用\n</span><span class=\"c1\"></span>              <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">setTimeout</span><span class=\"p\">(</span>\n                  <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n                      <span class=\"c1\">// 填充 Promise\n</span><span class=\"c1\"></span>                      <span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">thisPromiseCount</span><span class=\"p\">);</span>\n                  <span class=\"p\">},</span> <span class=\"nb\">Math</span><span class=\"p\">.</span><span class=\"nx\">random</span><span class=\"p\">()</span> <span class=\"o\">*</span> <span class=\"mi\">2000</span> <span class=\"o\">+</span> <span class=\"mi\">1000</span><span class=\"p\">);</span>\n          <span class=\"p\">}</span>\n      <span class=\"p\">);</span>\n  <span class=\"err\">​</span>\n      <span class=\"c1\">// Promise 不论成功或失败都会调用 then\n</span><span class=\"c1\"></span>      <span class=\"c1\">// catch() 只有当 promise 失败时才会调用\n</span><span class=\"c1\"></span>      <span class=\"nx\">p1</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span>\n          <span class=\"c1\">// 记录填充值\n</span><span class=\"c1\"></span>          <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">val</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n              <span class=\"nx\">log</span><span class=\"p\">.</span><span class=\"nx\">insertAdjacentHTML</span><span class=\"p\">(</span><span class=\"s1\">&#39;beforeend&#39;</span><span class=\"p\">,</span> <span class=\"nx\">val</span> <span class=\"o\">+</span>\n                  <span class=\"s1\">&#39;) Promise 已填充完毕 (&lt;small&gt;异步代码结束&lt;/small&gt;)&lt;br/&gt;&#39;</span><span class=\"p\">);</span>\n          <span class=\"p\">})</span>\n      <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(</span>\n          <span class=\"c1\">// 记录失败原因\n</span><span class=\"c1\"></span>         <span class=\"p\">(</span><span class=\"nx\">reason</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n              <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;处理失败的 promise (&#39;</span><span class=\"o\">+</span><span class=\"nx\">reason</span><span class=\"o\">+</span><span class=\"s1\">&#39;)&#39;</span><span class=\"p\">);</span>\n          <span class=\"p\">});</span>\n  <span class=\"err\">​</span>\n      <span class=\"nx\">log</span><span class=\"p\">.</span><span class=\"nx\">insertAdjacentHTML</span><span class=\"p\">(</span><span class=\"s1\">&#39;beforeend&#39;</span><span class=\"p\">,</span> <span class=\"nx\">thisPromiseCount</span> <span class=\"o\">+</span>\n          <span class=\"s1\">&#39;) Promise made (&lt;small&gt;同步代码结束&lt;/small&gt;)&lt;br/&gt;&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>二、使用 Promise</b></h2><p>一个 <code>Promise</code> 就是一个代表了异步操作最终完成或者失败的结果对象。大多数人仅使用 Promise，因此这里我们来说明怎样使用 Promise。</p><p>Promise 本质上是一个绑定了回调对象，而不是将回调传进函数内部。</p><p>假设存在一个名为 <code>createAudioFileAsync()</code> 的函数，这个函数异步地生成声音文件，在声音文件创建成功或者创建失败后执行回调函数。</p><p>以下为使用 <code>createAudioFileAsync()</code> 的示例：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"c1\">// 成功的回调函数\n</span><span class=\"c1\"></span>  <span class=\"kd\">function</span> <span class=\"nx\">successCallback</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">&#34;声音文件创建成功：&#34;</span> <span class=\"o\">+</span> <span class=\"nx\">result</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 失败的回调函数\n</span><span class=\"c1\"></span>  <span class=\"kd\">function</span> <span class=\"nx\">failureCallback</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">&#34;声音文件创建失败：&#34;</span> <span class=\"o\">+</span> <span class=\"nx\">error</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">createAudioFileAsync</span><span class=\"p\">(</span><span class=\"nx\">audioSettings</span><span class=\"p\">,</span> <span class=\"nx\">successCallback</span><span class=\"p\">,</span> <span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n</code></pre></div><p>如果函数返回 Promise 对象：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">promise</span> <span class=\"o\">=</span> <span class=\"nx\">createAudioFileAsync</span><span class=\"p\">(</span><span class=\"nx\">audioSettings</span><span class=\"p\">);</span>\n  <span class=\"nx\">promise</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">successCallback</span><span class=\"p\">,</span> <span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n  <span class=\"nx\">createAudioFileAsync</span><span class=\"p\">(</span><span class=\"nx\">audioSettings</span><span class=\"p\">).</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">successCallback</span><span class=\"p\">,</span> <span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n</code></pre></div><p>我们将这个称为异步函数调用，这种形式有若干优点，我们会逐一讨论。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.1 约定</b></h2><p>不同于老式的传入回调，在应用 Promise 时，我们将会有以下约定：</p><ul><li>在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。</li><li>通过 <code>.then</code> 形式添加的回调函数，甚至都在异步操作完成之后才被添加的函数，都会被调用。</li><li>通过多次调用 <code>.then</code> ，可以添加多个回调函数，它们会按照插入顺序并且独立运行。</li></ul><p>因此，<code>Promise</code> 最直接的好处就是链式调用。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.2 链式调用</b></h2><p>一个常见的需求就是连续执行两个或者多个异步操作，这种情况下，每一个后来的操作都在前面的异步执行成功之后，带着上一步操作所返回的结果开始执行。我们可以通过创造一个 <code>Promise chain</code> 来完成这种需求。</p><p>见证奇迹的时刻：<code>then</code> 函数会返回一个新的 <code>Promise</code>，跟原来的不同：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">promise1</span> <span class=\"o\">=</span> <span class=\"nx\">doSomething</span><span class=\"p\">();</span>\n  <span class=\"nx\">cosnt</span> <span class=\"nx\">promise2</span> <span class=\"o\">=</span> <span class=\"nx\">promise1</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">successCallback</span><span class=\"p\">,</span> <span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n</code></pre></div><p>或者</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">promise2</span> <span class=\"o\">=</span> <span class=\"nx\">doSomething</span><span class=\"p\">().</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">successCallback</span><span class=\"p\">,</span> <span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n</code></pre></div><p>第二个对象 <code>promise2</code> 不仅代表 <code>doSomething()</code> 函数的完成，也代表了你传入的 <code>successCallback</code> 或者 <code>failureCallback</code> 的完成，这也可能是其它异步函数返回的 <code>Promise</code>。这样的话，任何被添加给 <code>promise2</code> 的回调函数都会被排在 <code>successCallback</code> 或 <code>failureCallback</code> 返回的 <code>Promsie</code> 后面。</p><p>基本上，每一个 <code>Promise</code> 代表了链式中另一个异步过程的完成。</p><p>在过去，做多重的异步操作，会导致经典的回调地狱：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">doSomething</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">doSomethingElse</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">newResult</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">doThirdThing</span><span class=\"p\">(</span><span class=\"nx\">newResult</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">finalResult</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Got the final result: &#39;</span> <span class=\"o\">+</span> <span class=\"nx\">finalResult</span><span class=\"p\">);</span>\n      <span class=\"p\">},</span> <span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n    <span class=\"p\">},</span> <span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n  <span class=\"p\">},</span> <span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n</code></pre></div><blockquote>这种回调地狱不仅看起来很不舒服，可读性比较差；除此之外还有比较重要的一点就是对异常的捕获无法支持。</blockquote><p>通过新式函数，我们把回调绑定到被返回的 <code>Promise</code> 上代替以往的做法，形成一个 <code>Promise</code> 链：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">doSomething</span><span class=\"p\">().</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">doSomethingElse</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">);</span>\n  <span class=\"p\">})</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">newResult</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">doThirdThing</span><span class=\"p\">(</span><span class=\"nx\">newResult</span><span class=\"p\">);</span>\n  <span class=\"p\">})</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">finalResult</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Got the final result: &#39;</span> <span class=\"o\">+</span> <span class=\"nx\">finalResult</span><span class=\"p\">);</span>\n  <span class=\"p\">})</span>\n  <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n</code></pre></div><p><code>then</code> 里的参数是可选的，<code>catch(failureCallback)</code> 是 <code>then(null, failureCallback)</code> 的缩略形式。如下所示，也可以用 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">arrow functions</a>（箭头函数）来表示：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">doSomething</span><span class=\"p\">()</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">result</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">doSomethingElse</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">))</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">newResult</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">doThirdThing</span><span class=\"p\">(</span><span class=\"nx\">newResult</span><span class=\"p\">))</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">finalResult</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"sb\">`Got the final result: </span><span class=\"si\">${</span><span class=\"nx\">finalResult</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">);</span>\n  <span class=\"p\">})</span>\n  <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n</code></pre></div><blockquote>注意：如果想要在回调获取上个 Promise 中的结果，上个 <code>Promise</code> 中必须要返回结果。（使用 <code>() =&gt; x</code> 比 <code>() =&gt; { return x; }</code> 更简洁一点）</blockquote><h2><b>Catch 的后续链式操作</b></h2><p>在一个失败操作（即一个 <code>catch</code>）之后可以继续使用链式操作，即使链式中的一个动作失败之后还能有助于新的动作继续完成：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">((</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Initial&#39;</span><span class=\"p\">);</span>\n    <span class=\"nx\">resolve</span><span class=\"p\">();</span>\n  <span class=\"p\">})</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"s1\">&#39;Something failed&#39;</span><span class=\"p\">);</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Do this&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">})</span>\n  <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Do that&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">})</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Do this whatever happened before&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">});</span>\n</code></pre></div><p>输出结果如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">  Initial\n  Do that\n  Do this whatever happened before</code></pre></div><blockquote>注意，由于 “Something failed” 错误导致了拒绝操作，所以 “Do this” 文本没有被输出。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.3 错误传播</b></h2><p>在之前的回调地狱示例中，你可能记得 3 次 <code>failureCallback</code> 的调用，而在 <code>Promise</code> 链中只有底部的一次调用：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">doSomething</span><span class=\"p\">()</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">result</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">doSomethingElse</span><span class=\"p\">(</span><span class=\"nx\">value</span><span class=\"p\">))</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">newRusult</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">doThirdThing</span><span class=\"p\">(</span><span class=\"nx\">newResult</span><span class=\"p\">))</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">finalResult</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"sb\">`Got the final result: </span><span class=\"si\">${</span><span class=\"nx\">finalResult</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">))</span>\n  <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n</code></pre></div><p>基本上，一个 <code>Promise</code> 链式遇到异常就会停止，查看链式的底端，寻找 <code>catch</code> 处理程序来代替当前执行。在同步的代码执行之后，这是非常模型化的。</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">try</span> <span class=\"p\">{</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"nx\">syncDoSomething</span><span class=\"p\">();</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">newResult</span> <span class=\"o\">=</span> <span class=\"nx\">syncDoSomethingElse</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">);</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">finalResult</span> <span class=\"o\">=</span> <span class=\"nx\">syncDoThirdTing</span><span class=\"p\">(</span><span class=\"nx\">newResult</span><span class=\"p\">);</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"sb\">`Got the final result: </span><span class=\"si\">${</span><span class=\"nx\">finalResult</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span> <span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">failureCallback</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>在 ECMAScript2017 标准的 <code>async/await</code> 语法糖中，这主公同步形式代码的整齐性得到了极致的体现：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kr\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">foo</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">try</span> <span class=\"p\">{</span>\n      <span class=\"kd\">let</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">doSomething</span><span class=\"p\">();</span>\n      <span class=\"kd\">let</span> <span class=\"nx\">newResult</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">doSomethingElse</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">);</span>\n      <span class=\"kd\">let</span> <span class=\"nx\">finalResult</span> <span class=\"o\">=</span> <span class=\"kr\">await</span> <span class=\"nx\">doThirdThing</span><span class=\"p\">(</span><span class=\"nx\">newResult</span><span class=\"p\">);</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"sb\">`Got the final result: </span><span class=\"si\">${</span><span class=\"nx\">finalResult</span><span class=\"si\">}</span><span class=\"sb\">`</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span> <span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">failureCallback</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>这个例子是在 <code>Promise</code> 的基础上构建的，例如，<code>doSomething()</code> 与之前的函数是相同的。</p><p>通过捕获所有的错误，甚至抛出异常和程序错误，<code>Promise</code> 解决了回调地狱的基本缺陷。这是异步操作的基本功能。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.4 在旧式回调 API 中创建 Promise</b></h2><p><code>Promise</code> 通过它的构造器从头开始创建，只应用在包裹旧的 API。</p><p>理想状态下，所有的异步函数都已经返回 <code>Promise</code> 了。但有一些 API 仍然使用旧式的被传入的成功或者失败的回调。典型的例子旧式 <code>setTimeout()</code> 函数：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">setTimeout</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">saySomething</span><span class=\"p\">(</span><span class=\"s2\">&#34;10 seconds passed&#34;</span><span class=\"p\">),</span> <span class=\"mi\">10000</span><span class=\"p\">);</span>\n</code></pre></div><p>混用旧式回调和 <code>Promise</code> 是会有问题的，如果 <code>saySomething</code> 函数失败了或者包含了变成错误，那就没办法捕获它了。</p><p>幸运的是我们可以用 <code>Promise</code> 来包裹它。最好的做法是将有问题的函数包装在最低级别，并且永远不要再直接调用它们：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">wait</span> <span class=\"o\">=</span> <span class=\"nx\">ms</span> <span class=\"p\">=&gt;</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">(</span><span class=\"nx\">resolve</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">setTimeout</span><span class=\"p\">(</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">ms</span><span class=\"p\">));</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">wait</span><span class=\"p\">(</span><span class=\"mi\">10000</span><span class=\"p\">).</span><span class=\"nx\">then</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">saySomething</span><span class=\"p\">(</span><span class=\"s2\">&#34;10 seconds&#34;</span><span class=\"p\">)).</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">failureCallback</span><span class=\"p\">);</span>\n</code></pre></div><p>通常，<code>Promise</code> 的构造器会有一个可以让我们手动操作 <code>resolve</code> 和 <code>reject</code> 的执行函数，既然 <code>setTimeout</code> 没有真的执行失败，那么我们可以在这种情况下忽略 <code>reject</code>。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.5 组合</b></h2><p><code>Promise.resolve()</code> 和 <code>Promise.reject()</code> 是手动创建一个已经 <code>resolve</code> 或者 <code>reject</code> 的 <code>promise</code> 快捷方法。它们有时候很有用。</p><p><code>Promise.all()</code> 和 <code>Promise.race()</code> 是并行运行异步操作的两个组合式工具。</p><p>时许组合可以使用一些优雅的 javascript 形式：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"p\">[</span><span class=\"nx\">func1</span><span class=\"p\">,</span> <span class=\"nx\">func2</span><span class=\"p\">].</span><span class=\"nx\">reduce</span><span class=\"p\">((</span><span class=\"nx\">p</span><span class=\"p\">,</span> <span class=\"nx\">f</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span>  <span class=\"nx\">p</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">f</span><span class=\"p\">),</span> <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">());</span>\n</code></pre></div><p>通常，我们递归调用一个由异步函数组成的数组时相当于一个 Promise 链式：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">().</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">func1</span><span class=\"p\">).</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">func2</span><span class=\"p\">);</span>\n</code></pre></div><p>我们也可以写成可复用的函数形式，这在函数式编程中极为普遍：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">let</span> <span class=\"nx\">applyAsync</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">acc</span><span class=\"p\">,</span> <span class=\"nx\">val</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">acc</span><span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">val</span><span class=\"p\">);</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">composeAsync</span> <span class=\"o\">=</span> <span class=\"p\">(...</span><span class=\"nx\">funcs</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">x</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">funcs</span><span class=\"p\">.</span><span class=\"nx\">reduce</span><span class=\"p\">(</span><span class=\"nx\">applyAsync</span><span class=\"p\">,</span> <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">));</span>\n</code></pre></div><p><code>composeAsync</code> 函数将会接受任意数量的函数作为其参数，并返回一个新的函数，该函数接受一个通过 <code>composition pipeline</code> 传入的初始值。这对我们来说非常有益，因为任意函数可以是异步或同步的，它们能被保证按顺序执行：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">let</span> <span class=\"nx\">transformData</span> <span class=\"o\">=</span> <span class=\"nx\">composeAsync</span><span class=\"p\">(</span><span class=\"nx\">func1</span><span class=\"p\">,</span> <span class=\"nx\">asyncFunc1</span><span class=\"p\">,</span> <span class=\"nx\">asyncFunc2</span><span class=\"p\">,</span> <span class=\"nx\">func2</span><span class=\"p\">);</span>\n  <span class=\"nx\">transformData</span><span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">);</span>\n</code></pre></div><p>在 ECMAScript 2017 标准中，时序组合可以通过使用 <code>async/await</code> 而变得简单：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">f</span> <span class=\"k\">of</span> <span class=\"p\">[</span><span class=\"nx\">func1</span><span class=\"p\">,</span> <span class=\"nx\">func2</span><span class=\"p\">])</span> <span class=\"p\">{</span>\n    <span class=\"kr\">await</span> <span class=\"nx\">f</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.6 时序</b></h2><p>为了避免意外，即使是一个已经变成 resolve 状态的 Promise，传递给 <code>then</code> 的函数也总是会被异步调用：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">().</span><span class=\"nx\">then</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">));</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">// 1, 2\n</span></code></pre></div><p>传递到then中的函数被置入了一个微任务队列，而不是立即执行，这意味着它是在JavaScript事件队列的所有运行时结束了，事件队列被清空之后才开始执行：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">wait</span> <span class=\"o\">=</span> <span class=\"nx\">ms</span> <span class=\"p\">=&gt;</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"p\">(</span><span class=\"nx\">resolve</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">setTimeout</span><span class=\"p\">(</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">ms</span><span class=\"p\">));</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">wait</span><span class=\"p\">().</span><span class=\"nx\">then</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">));</span>\n  <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">().</span><span class=\"nx\">then</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)).</span><span class=\"nx\">then</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">));</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">// 1, 2, 3, 4\n</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.7 嵌套</b></h2><p>简便的 <code>Promise</code> 链式编程最好保持扁平化，不要嵌套 <code>Promise</code>，嵌套经常会是粗心导致的。</p><p>嵌套 Promise 是一种可以限制 catch 语句的作用域的控制结构写法。明确来说，嵌套的 catch 仅捕捉在其之前同时还必须是其作用域的 failureres，而捕捉不到在其链式以外或者其嵌套域以外的 error。如果使用正确，那么可以实现高精度的错误修复。</p><div class=\"highlight\"><pre><code class=\"language-text\">  doSomethingCritical()\n  .then(result =&gt; doSomethingOptional()\n    .then(optionalResult =&gt; doSomethingExtraNice(optionalResult))\n    .catch(e =&gt; {console.log(e.message)})) // 即使有异常也会忽略，继续运行;(最后会输出)\n  .then(() =&gt; moreCriticalStuff())\n  .catch(e =&gt; console.log(&#34;Critical failure: &#34; + e.message));// 没有输出</code></pre></div><p>注意,有些代码步骤是嵌套的，而不是一个简单的纯链式，这些语句前与后都被（）包裹着。</p><p>这个内部的 catch 语句仅能捕获到 <code>doSomethingOptional() 和 doSomethingExtraNice() 的失败，而且还是在</code>moreCriticalStuff() 并发运行以后。重要提醒，如果 doSomethingCritical() 失败，这个错误才仅会被最后的（外部）catch 语句捕获到。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.8 常见错误</b></h2><p>在编写 Promise 链时，需要注意以下示例中展示的几个错误：</p><div class=\"highlight\"><pre><code class=\"language-text\">  // 错误示例，包含 3 个问题\n  ​\n  doSomething().then(function(result) {\n    doSomethingElse(result) // 没有返回 Promise 以及没有必要的嵌套 Promise\n    .then(newResult =&gt; doThirdThing(newResult));\n  }).then(() =&gt; doFourthThing());\n  // 最后是没有使用 catch 终止 Promise 调用链，可能导致没有捕获的异常\n  ​</code></pre></div><p>第一个错误是没有正确地将事物相连接。当我们创建新 Promise 但忘记返回它时，会发生这种情况。因此，链条被打破，或者更确切地说，我们有两个独立的链条竞争（同时在执行两个异步而非一个一个的执行）。这意味着 <code>doFourthThing()</code> 不会等待 <code>doSomethingElse()</code>或<code>doThirdThing()</code> 完成，并且将与它们并行运行，可能是无意的。单独的链也有单独的错误处理，导致未捕获的错误。</p><p>第二个错误是不必要地嵌套，实现第一个错误。嵌套还限制了内部错误处理程序的范围，如果是非预期的，可能会导致未捕获的错误。其中一个变体是 <a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">promise 构造函数反模式</a>，它结合了 Promise 构造函数的多余使用和嵌套。</p><p>第三个错误是忘记用 <code>catch</code> 终止链。这导致在大多数浏览器中不能终止的 Promise 链里的 rejection。</p><p>一个好的经验法则是总是返回或终止 Promise 链，并且一旦你得到一个新的 Promise，返回它。下面是修改后的平面化的代码：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">doSomething</span><span class=\"p\">()</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">doSomethingElse</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">);</span>\n  <span class=\"p\">})</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">newResult</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">doThirdThing</span><span class=\"p\">(</span><span class=\"nx\">newResult</span><span class=\"p\">))</span>\n  <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">doFourthThing</span><span class=\"p\">());</span>\n  <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">error</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">));</span>\n</code></pre></div><p>现在我们有一个具有适当错误处理的确定性链。</p><p>使用 <code>async/await</code> 解决了大多数，如果不是所有这些问题的话 - 最常见的错误就是忘记了<code>await</code> 关键字。</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58837269", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 53, 
            "title": "axios 上手指南", 
            "content": "<blockquote>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</blockquote><h2><b>1 - 功能</b></h2><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><h2><b>2 - 安装</b></h2><p>使用 npm：</p><div class=\"highlight\"><pre><code class=\"language-text\">  $ npm install axios</code></pre></div><p>使用 bower:</p><div class=\"highlight\"><pre><code class=\"language-text\">  $ bower install axios</code></pre></div><p>使用 cdn:</p><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">script</span> <span class=\"na\">src</span><span class=\"o\">=</span><span class=\"s\">&#34;https://unpkg.com/axios/dist/axios.min.js&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3 - 例子</b></h2><h2><b>3.1 GET</b></h2><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user?ID=123&#39;</span><span class=\"p\">)</span>\n      <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span> <span class=\"nx\">res</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 请求数据成功并返回数据\n</span><span class=\"c1\"></span>        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">res</span><span class=\"p\">)</span>\n      <span class=\"p\">}).</span><span class=\"k\">catch</span><span class=\"p\">(</span> <span class=\"nx\">e</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"c1\">// 请求已发出，服务器返回状态码不是 2xx\n</span><span class=\"c1\"></span>          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">data</span><span class=\"p\">)</span>\n          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">status</span><span class=\"p\">)</span>\n          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">headers</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"c1\">// 请求已发出，但没有收到响应\n</span><span class=\"c1\"></span>          <span class=\"c1\">// e.request 在浏览器里是一个 XMLHttpRequest 实例\n</span><span class=\"c1\"></span>          <span class=\"c1\">// 在 node 中是一个 http.ClientRequest 实例\n</span><span class=\"c1\"></span>          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n          <span class=\"c1\">// 发送请求时异常，捕获到错误\n</span><span class=\"c1\"></span>          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"s1\">&#39;error&#39;</span><span class=\"p\">,</span> <span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">message</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">config</span><span class=\"p\">)</span>\n      <span class=\"p\">})</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 等同于以下写法\n</span><span class=\"c1\"></span>  <span class=\"nx\">axios</span><span class=\"p\">({</span>\n    <span class=\"nx\">url</span><span class=\"o\">:</span> <span class=\"s1\">&#39;/user&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">methods</span><span class=\"o\">:</span> <span class=\"s1\">&#39;GET&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">params</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">ID</span><span class=\"o\">:</span> <span class=\"mi\">123</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}).</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">res</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">res</span><span class=\"p\">)</span>\n  <span class=\"p\">}).</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">e</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">)</span>\n  <span class=\"p\">})</span>\n  <span class=\"err\">​</span>\n  <span class=\"err\">​</span>\n  <span class=\"err\">​</span>\n  <span class=\"err\">​</span>\n  <span class=\"err\">​</span>\n  <span class=\"err\">​</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 为给定 ID 的 user 创建请求\n</span><span class=\"c1\"></span>  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user?ID=12345&#39;</span><span class=\"p\">)</span>\n    <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">);</span>\n    <span class=\"p\">})</span>\n    <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>\n    <span class=\"p\">});</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 可选地，上面的请求可以这样做\n</span><span class=\"c1\"></span>  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n      <span class=\"nx\">params</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">ID</span><span class=\"o\">:</span> <span class=\"mi\">12345</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">})</span>\n    <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">);</span>\n    <span class=\"p\">})</span>\n    <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>\n    <span class=\"p\">});</span>\n</code></pre></div><h2><b>3.2 POST</b></h2><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">post</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n    <span class=\"nx\">firstName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Mike&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">lastName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Allen&#39;</span>\n  <span class=\"p\">}).</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">res</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">res</span><span class=\"p\">)</span>\n  <span class=\"p\">}).</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">e</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">)</span>\n  <span class=\"p\">})</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 等同于以下写法\n</span><span class=\"c1\"></span>  <span class=\"nx\">axios</span><span class=\"p\">({</span>\n    <span class=\"nx\">url</span><span class=\"o\">:</span> <span class=\"s1\">&#39;/user&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">method</span><span class=\"o\">:</span> <span class=\"s1\">&#39;POST&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">firstName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Mike&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">lastName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Allen&#39;</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}).</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">res</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">res</span><span class=\"p\">)</span>\n  <span class=\"p\">}).</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"nx\">e</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">info</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">)</span>\n  <span class=\"p\">})</span>\n  <span class=\"err\">​</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">post</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n      <span class=\"nx\">firstName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Fred&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">lastName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Flintstone&#39;</span>\n    <span class=\"p\">})</span>\n    <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">);</span>\n    <span class=\"p\">})</span>\n    <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>\n    <span class=\"p\">});</span>\n</code></pre></div><h2><b>3.3 执行多个并发请求</b></h2><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">function</span> <span class=\"nx\">getUserAccount</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user/12345&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"err\">​</span>\n  <span class=\"kd\">function</span> <span class=\"nx\">getUserPermissions</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user/12345/permissions&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">all</span><span class=\"p\">([</span><span class=\"nx\">getUserAccount</span><span class=\"p\">(),</span> <span class=\"nx\">getUserPermission</span><span class=\"p\">()])</span>\n    <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">spread</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">acct</span><span class=\"p\">,</span> <span class=\"nx\">perms</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 两个请求现在都执行完成\n</span><span class=\"c1\"></span>  <span class=\"p\">}));</span>\n</code></pre></div><h2><b>3.4 注意事项</b></h2><p>在使用 <code>GET</code> 方法传递参数时使用的是 <code>params</code>，并且官方文档中介绍：</p><blockquote>params are the URL parameters to be sent with the request. Must be a plain object or a URLSearchParams object.</blockquote><p><code>params</code> 作为 URL 链接中的参数发送请求，且其必须是一个 <code>plain object</code> 或者是 <code>URLSearchParams object</code> 。</p><ul><li><code>plain object</code>（纯对象）：是指 <code>JSON</code> 形式定义的普通对象或者 <code>new Object()</code> 创建的简单对象；</li><li><code>URLSearchParams object</code>：指的是一个可以由 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">URLSearchParams</a> 接口定义的一些实用方法来处理 URL 的查询字符串的对象，也就是说 <code>params</code> 传参是以 <code>/user?ID=1&amp;name=mike&amp;sex=male</code> 形式传递的。</li></ul><p>而在使用 <code>POST</code> 时对应的传参使用的是 <code>data</code>，<code>data</code> 是作为 <b>请求体</b> 发送的，同样使用这种形式的还有 <code>PUT</code>、<code>PATCH</code> 等请求方法。有一点需要注意的是，<code>axios</code> 中 <code>POST</code> 的默认请求体类型为 <code>Content-Type:application/json</code>（JSON 规范流行），这也是最常见的请求体类型，也就是说使用的是序列化后的 <code>json</code> 格式字符串来传递参数，如： <code>{ &#34;name&#34; : &#34;mike&#34;, &#34;sex&#34; : &#34;male&#34; }</code>；同时，后台必须要以支持 <code>@RequestBody</code> 的形式来接收参数，否则会出现前台传参正确，后台不接收的情况。</p><p>如果想要设置类型为 <code>Content-Type:application/x-www-form-urlencoded</code>（浏览器原生支持），<code>axios</code> 提供了两种方式，如下：</p><h2><b>浏览器端</b></h2><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">params</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">URLSearchParams</span><span class=\"p\">();</span>\n  <span class=\"nx\">params</span><span class=\"p\">.</span><span class=\"nx\">append</span><span class=\"p\">(</span><span class=\"s1\">&#39;param1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;value1&#39;</span><span class=\"p\">);</span>\n  <span class=\"nx\">params</span><span class=\"p\">.</span><span class=\"nx\">append</span><span class=\"p\">(</span><span class=\"s1\">&#39;param2&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;value2&#39;</span><span class=\"p\">);</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">post</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user&#39;</span><span class=\"p\">,</span> <span class=\"nx\">params</span><span class=\"p\">);</span>\n</code></pre></div><p>不过，并不是所有浏览器都支持 <code>URLSearchParams</code>，<a href=\"https://link.zhihu.com/?target=https%3A//www.caniuse.com/%23feat%3Durlsearchparams\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">兼容性查询caniuse.com</a>，但是这里有一个<a href=\"https://link.zhihu.com/?target=https%3A//github.com/WebReflection/url-search-params\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Polyfill</a>（<code>polyfill</code>：用于实现浏览器并不支持的原生 API 的代码，可以模糊理解为补丁，同时要确保 <code>polyfill</code> 在全局环境中）。</p><p>或者，你也可以用 <code>qs</code> 这个库来格式化数据，默认情况下在安装完 <code>axios</code> 后就可以使用 <code>qs</code> 库。</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">qs</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;qs&#39;</span><span class=\"p\">);</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">post</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user&#39;</span><span class=\"p\">,</span> <span class=\"nx\">qs</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">({</span><span class=\"s1\">&#39;name&#39;</span><span class=\"o\">:</span> <span class=\"s1\">&#39;mike&#39;</span><span class=\"p\">}));</span>\n</code></pre></div><h2><b>node 层</b></h2><p>在 <code>node</code> 环境中可以使用 <code>querystring</code> 。同样，也可以使用 <code>qs</code> 来格式化数据。</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">querystring</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;querystring&#39;</span><span class=\"p\">);</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">post</span><span class=\"p\">(</span><span class=\"s1\">&#39;http://something.com/&#39;</span><span class=\"p\">,</span> <span class=\"nx\">querystring</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">({</span><span class=\"s1\">&#39;name&#39;</span><span class=\"o\">:</span><span class=\"s1\">&#39;mike&#39;</span><span class=\"p\">}));</span>\n</code></pre></div><h2><b>3.5 补充</b></h2><p>常见的请求体类型还有一种方式，即<code>multipart/form-data</code>（浏览器原生支持），也就是提交表单数据常用的一种格式。和<code>x-www-form-urlencoded</code>对比起来，后者则是数据被编码成以 &#39;&amp;&#39; 分隔的键-值对, 同时以 &#39;=&#39; 分隔键和值。非字母或数字的字符会被<a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Percent-encoding\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Percent-encoding（URL encoding）</a>，这也就是为什么这种类型不支持二进制数据的原因 (应使用 multipart/form-data 代替)。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4 - axios API</b></h2><h2><b>4.1 请求方法的别名</b></h2><p>为了方便起见，<code>axios</code> 提供了别名：</p><ul><li><code>axios.request(config)</code></li><li><code>axios.get(url[, config])</code></li><li><code>axios.delete(url[, config])</code></li><li><code>axios.head(url[, config])</code></li><li><code>axios.post(url[, data[, config]])</code></li><li><code>axios.put(url[, data[, config]])</code></li><li><code>axios.patch(url[, data[, config])</code></li></ul><p>在使用别名方法时，<code>url</code>、<code>methods</code>、<code>data</code> 这些属性都不必在配置中指定。</p><h2><b>4.2 并发</b></h2><p>处理并发请求的助手函数</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">all</span><span class=\"p\">(</span><span class=\"nx\">iterable</span><span class=\"p\">)</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">spread</span><span class=\"p\">(</span><span class=\"nx\">callback</span><span class=\"p\">)</span>\n</code></pre></div><h2><b>4.3 创建实例</b></h2><p>可以使用自定义配置新建一个 <code>axios</code> 实例</p><p><code>axios.create([config])</code></p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">var</span> <span class=\"nx\">instance</span> <span class=\"o\">=</span> <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">create</span><span class=\"p\">({</span>\n    <span class=\"nx\">baseURL</span><span class=\"o\">:</span> <span class=\"s1\">&#39;https://something.com/api/&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">timeout</span><span class=\"o\">:</span> <span class=\"mi\">1000</span><span class=\"p\">,</span>\n    <span class=\"nx\">headers</span><span class=\"o\">:</span> <span class=\"p\">{</span><span class=\"s1\">&#39;X-Custom-Header&#39;</span><span class=\"o\">:</span> <span class=\"s1\">&#39;foobar&#39;</span><span class=\"p\">}</span>\n  <span class=\"p\">})</span>\n</code></pre></div><h2><b>4.4 实例方法</b></h2><p>以下是可用的实例方法，指定的配置将与实例的配置合并。</p><ul><li><b>axios#request(config)</b></li><li><b>axios#get(url[, config])</b></li><li><b>axios#delete(url[, config])</b></li><li><b>axios#head(url[, config])</b></li><li><b>axios#post(url[, data[, config]])</b></li><li><b>axios#put(url[, data[, config]])</b></li><li><b>axios#patch(url[, data[, config]])</b></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5 - 请求配置</b></h2><p>这些是创建请求时可以使用的配置选项。只有 <code>url</code> 是必需的，如果没有指定的 <code>method</code>，请求将默认使用 <code>get</code> 方法。</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"p\">{</span>\n    <span class=\"c1\">// `url` 是用于请求的服务器 URL\n</span><span class=\"c1\"></span>    <span class=\"nx\">url</span><span class=\"o\">:</span> <span class=\"s1\">&#39;/user&#39;</span><span class=\"p\">,</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `method` 是创建请求时使用的方法\n</span><span class=\"c1\"></span>    <span class=\"nx\">method</span><span class=\"o\">:</span> <span class=\"s1\">&#39;get&#39;</span><span class=\"p\">,</span> <span class=\"c1\">// 默认是 get\n</span><span class=\"c1\"></span>  <span class=\"err\">​</span>\n    <span class=\"c1\">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n</span><span class=\"c1\"></span>    <span class=\"nx\">baseURL</span><span class=\"o\">:</span> <span class=\"s1\">&#39;https://some-domain.com/api/&#39;</span><span class=\"p\">,</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `transformRequest` 允许在向服务器发送前，修改请求数据\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 只能用在 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n</span><span class=\"c1\"></span>    <span class=\"nx\">transformRequest</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 对 data 进行任意转换处理\n</span><span class=\"c1\"></span>  <span class=\"err\">​</span>\n      <span class=\"k\">return</span> <span class=\"nx\">data</span><span class=\"p\">;</span>\n    <span class=\"p\">}],</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n</span><span class=\"c1\"></span>    <span class=\"nx\">transformResponse</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 对 data 进行任意转换处理\n</span><span class=\"c1\"></span>  <span class=\"err\">​</span>\n      <span class=\"k\">return</span> <span class=\"nx\">data</span><span class=\"p\">;</span>\n    <span class=\"p\">}],</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `headers` 是即将被发送的自定义请求头\n</span><span class=\"c1\"></span>    <span class=\"nx\">headers</span><span class=\"o\">:</span> <span class=\"p\">{</span><span class=\"s1\">&#39;X-Requested-With&#39;</span><span class=\"o\">:</span> <span class=\"s1\">&#39;XMLHttpRequest&#39;</span><span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `params` 是即将与请求一起发送的 URL 参数\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n</span><span class=\"c1\"></span>    <span class=\"nx\">params</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">ID</span><span class=\"o\">:</span> <span class=\"mi\">12345</span>\n    <span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `paramsSerializer` 是一个负责 `params` 序列化的函数\n</span><span class=\"c1\"></span>    <span class=\"c1\">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n</span><span class=\"c1\"></span>    <span class=\"nx\">paramsSerializer</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"nx\">Qs</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"nx\">params</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"nx\">arrayFormat</span><span class=\"o\">:</span> <span class=\"s1\">&#39;brackets&#39;</span><span class=\"p\">})</span>\n    <span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `data` 是作为请求主体被发送的数据\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 只适用于这些请求方法 &#39;PUT&#39;, &#39;POST&#39;, 和 &#39;PATCH&#39;\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 在没有设置 `transformRequest` 时，必须是以下类型之一：\n</span><span class=\"c1\"></span>    <span class=\"c1\">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n</span><span class=\"c1\"></span>    <span class=\"c1\">// - 浏览器专属：FormData, File, Blob\n</span><span class=\"c1\"></span>    <span class=\"c1\">// - Node 专属： Stream\n</span><span class=\"c1\"></span>    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">firstName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Fred&#39;</span>\n    <span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 如果请求话费了超过 `timeout` 的时间，请求将被中断\n</span><span class=\"c1\"></span>    <span class=\"nx\">timeout</span><span class=\"o\">:</span> <span class=\"mi\">1000</span><span class=\"p\">,</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `withCredentials` 表示跨域请求时是否需要使用凭证\n</span><span class=\"c1\"></span>    <span class=\"nx\">withCredentials</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"c1\">// 默认的\n</span><span class=\"c1\"></span>  <span class=\"err\">​</span>\n    <span class=\"c1\">// `adapter` 允许自定义处理请求，以使测试更轻松\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n</span><span class=\"c1\"></span>    <span class=\"nx\">adapter</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">config</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"cm\">/* ... */</span>\n    <span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n</span><span class=\"c1\"></span>    <span class=\"nx\">auth</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">username</span><span class=\"o\">:</span> <span class=\"s1\">&#39;janedoe&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">password</span><span class=\"o\">:</span> <span class=\"s1\">&#39;s00pers3cret&#39;</span>\n    <span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `responseType` 表示服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;\n</span><span class=\"c1\"></span>    <span class=\"nx\">responseType</span><span class=\"o\">:</span> <span class=\"s1\">&#39;json&#39;</span><span class=\"p\">,</span> <span class=\"c1\">// 默认的\n</span><span class=\"c1\"></span>  <span class=\"err\">​</span>\n    <span class=\"c1\">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n</span><span class=\"c1\"></span>    <span class=\"nx\">xsrfCookieName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;XSRF-TOKEN&#39;</span><span class=\"p\">,</span> <span class=\"c1\">// default\n</span><span class=\"c1\"></span>  <span class=\"err\">​</span>\n    <span class=\"c1\">// `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称\n</span><span class=\"c1\"></span>    <span class=\"nx\">xsrfHeaderName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;X-XSRF-TOKEN&#39;</span><span class=\"p\">,</span> <span class=\"c1\">// 默认的\n</span><span class=\"c1\"></span>  <span class=\"err\">​</span>\n    <span class=\"c1\">// `onUploadProgress` 允许为上传处理进度事件\n</span><span class=\"c1\"></span>    <span class=\"nx\">onUploadProgress</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">progressEvent</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 对原生进度事件的处理\n</span><span class=\"c1\"></span>    <span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `onDownloadProgress` 允许为下载处理进度事件\n</span><span class=\"c1\"></span>    <span class=\"nx\">onDownloadProgress</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">progressEvent</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 对原生进度事件的处理\n</span><span class=\"c1\"></span>    <span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `maxContentLength` 定义允许的响应内容的最大尺寸\n</span><span class=\"c1\"></span>    <span class=\"nx\">maxContentLength</span><span class=\"o\">:</span> <span class=\"mi\">2000</span><span class=\"p\">,</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n</span><span class=\"c1\"></span>    <span class=\"nx\">validateStatus</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">status</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"nx\">status</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">200</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">status</span> <span class=\"o\">&lt;</span> <span class=\"mi\">300</span><span class=\"p\">;</span> <span class=\"c1\">// 默认的\n</span><span class=\"c1\"></span>    <span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 如果设置为0，将不会 follow 任何重定向\n</span><span class=\"c1\"></span>    <span class=\"nx\">maxRedirects</span><span class=\"o\">:</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"c1\">// 默认的\n</span><span class=\"c1\"></span>  <span class=\"err\">​</span>\n    <span class=\"c1\">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n</span><span class=\"c1\"></span>    <span class=\"c1\">// `keepAlive` 默认没有启用\n</span><span class=\"c1\"></span>    <span class=\"nx\">httpAgent</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"nx\">http</span><span class=\"p\">.</span><span class=\"nx\">Agent</span><span class=\"p\">({</span> <span class=\"nx\">keepAlive</span><span class=\"o\">:</span> <span class=\"kc\">true</span> <span class=\"p\">}),</span>\n    <span class=\"nx\">httpsAgent</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"nx\">https</span><span class=\"p\">.</span><span class=\"nx\">Agent</span><span class=\"p\">({</span> <span class=\"nx\">keepAlive</span><span class=\"o\">:</span> <span class=\"kc\">true</span> <span class=\"p\">}),</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// &#39;proxy&#39; 定义代理服务器的主机名称和端口\n</span><span class=\"c1\"></span>    <span class=\"c1\">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n</span><span class=\"c1\"></span>    <span class=\"nx\">proxy</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">host</span><span class=\"o\">:</span> <span class=\"s1\">&#39;127.0.0.1&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">port</span><span class=\"o\">:</span> <span class=\"mi\">9000</span><span class=\"p\">,</span>\n      <span class=\"nx\">auth</span><span class=\"o\">:</span> <span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">username</span><span class=\"o\">:</span> <span class=\"s1\">&#39;mikeymike&#39;</span><span class=\"p\">,</span>\n        <span class=\"nx\">password</span><span class=\"o\">:</span> <span class=\"s1\">&#39;rapunz3l&#39;</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `cancelToken` 指定用于取消请求的 cancel token\n</span><span class=\"c1\"></span>    <span class=\"c1\">// （查看后面的 Cancellation 这节了解更多）\n</span><span class=\"c1\"></span>    <span class=\"nx\">cancelToken</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"nx\">CancelToken</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">cancel</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"p\">})</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>6 - 响应结构</b></h2><p>某个请求的响应包含以下信息：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"p\">{</span>\n    <span class=\"c1\">// `data` 由服务器提供的响应\n</span><span class=\"c1\"></span>    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"p\">{},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `status` 来自服务器响应的 HTTP 状态码\n</span><span class=\"c1\"></span>    <span class=\"nx\">status</span><span class=\"o\">:</span> <span class=\"mi\">200</span><span class=\"p\">,</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `statusText` 来自服务器响应的 HTTP 状态信息\n</span><span class=\"c1\"></span>    <span class=\"nx\">statusText</span><span class=\"o\">:</span> <span class=\"s1\">&#39;OK&#39;</span><span class=\"p\">,</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `headers` 服务器响应的头\n</span><span class=\"c1\"></span>    <span class=\"nx\">headers</span><span class=\"o\">:</span> <span class=\"p\">{},</span>\n  <span class=\"err\">​</span>\n    <span class=\"c1\">// `config` 是为请求提供的配置信息\n</span><span class=\"c1\"></span>    <span class=\"nx\">config</span><span class=\"o\">:</span> <span class=\"p\">{}</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>使用 <code>then</code> 时，你将接收下面这样的响应：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user/12345&#39;</span><span class=\"p\">)</span>\n    <span class=\"p\">.</span><span class=\"nx\">then</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">data</span><span class=\"p\">);</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">status</span><span class=\"p\">);</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">statusText</span><span class=\"p\">);</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">headers</span><span class=\"p\">);</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">config</span><span class=\"p\">);</span>\n    <span class=\"p\">});</span>\n</code></pre></div><p>在使用 <code>catch</code> 时，或传递 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">rejection callback</a> 作为 <code>then</code> 的第二个参数时，响应可以通过 <code>error</code> 对象可被使用，正如在<a href=\"https://link.zhihu.com/?target=https%3A//www.kancloud.cn/yunye/axios/234845%23handling-errors\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">错误处理</a>这一节所讲。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>7 - 配置的默认值/defaults</b></h2><p>你可以指定将别用在各个请求的配置默认值</p><h2><b>7.1 全局的 axios 默认值</b></h2><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">defaults</span><span class=\"p\">.</span><span class=\"nx\">baseURL</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;https://api.example.com&#39;</span><span class=\"p\">;</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">defaults</span><span class=\"p\">.</span><span class=\"nx\">headers</span><span class=\"p\">.</span><span class=\"nx\">common</span><span class=\"p\">[</span><span class=\"s1\">&#39;Authorization&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">AUTH_TOKEN</span><span class=\"p\">;</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">defaults</span><span class=\"p\">.</span><span class=\"nx\">headers</span><span class=\"p\">.</span><span class=\"nx\">post</span><span class=\"p\">[</span><span class=\"s1\">&#39;Content-Type&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;application/x-www-form-urlencoded&#39;</span><span class=\"p\">;</span>\n</code></pre></div><h2><b>7.2 自定义实例默认值</b></h2><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"c1\">// 创建实例时设置配置的默认值\n</span><span class=\"c1\"></span>  <span class=\"kd\">var</span> <span class=\"nx\">instance</span> <span class=\"o\">=</span> <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">create</span><span class=\"p\">({</span>\n    <span class=\"nx\">baseURL</span><span class=\"o\">:</span> <span class=\"s1\">&#39;https://api.example.com&#39;</span>\n  <span class=\"p\">});</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 在实例已创建后修改默认值\n</span><span class=\"c1\"></span>  <span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">defaults</span><span class=\"p\">.</span><span class=\"nx\">headers</span><span class=\"p\">.</span><span class=\"nx\">common</span><span class=\"p\">[</span><span class=\"s1\">&#39;Authorization&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">AUTH_TOKEN</span><span class=\"p\">;</span>\n</code></pre></div><h2><b>7.3 配置的优先顺序</b></h2><p>配置会以一个优先顺序进行合并。这个顺序是：在 <code>lib/defaults.js</code> 找到的库的默认值，然后是实例的 <code>defaults</code> 属性，最后是请求的 <code>config</code> 参数。后者将优先于前者。这里是一个例子：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"c1\">// 使用由库提供的配置的默认值来创建实例\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 此时超时配置的默认值是 `0`\n</span><span class=\"c1\"></span>  <span class=\"kd\">var</span> <span class=\"nx\">instance</span> <span class=\"o\">=</span> <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">create</span><span class=\"p\">();</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 覆写库的超时默认值\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 现在，在超时前，所有请求都会等待 2.5 秒\n</span><span class=\"c1\"></span>  <span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">defaults</span><span class=\"p\">.</span><span class=\"nx\">timeout</span> <span class=\"o\">=</span> <span class=\"mi\">2500</span><span class=\"p\">;</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 为已知需要花费很长时间的请求覆写超时设置\n</span><span class=\"c1\"></span>  <span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/longRequest&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n    <span class=\"nx\">timeout</span><span class=\"o\">:</span> <span class=\"mi\">5000</span>\n  <span class=\"p\">});</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>8 - 拦截器</b></h2><p>在请求或响应被 <code>then</code> 或 <code>catch</code> 处理前拦截它们。</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"c1\">// 添加请求拦截器\n</span><span class=\"c1\"></span>  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">interceptors</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">.</span><span class=\"nx\">use</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">config</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 在发送请求之前做些什么\n</span><span class=\"c1\"></span>      <span class=\"k\">return</span> <span class=\"nx\">config</span><span class=\"p\">;</span>\n    <span class=\"p\">},</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 对请求错误做些什么\n</span><span class=\"c1\"></span>      <span class=\"k\">return</span> <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">reject</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>\n    <span class=\"p\">});</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 添加响应拦截器\n</span><span class=\"c1\"></span>  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">interceptors</span><span class=\"p\">.</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">use</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 对响应数据做点什么\n</span><span class=\"c1\"></span>      <span class=\"k\">return</span> <span class=\"nx\">response</span><span class=\"p\">;</span>\n    <span class=\"p\">},</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 对响应错误做点什么\n</span><span class=\"c1\"></span>      <span class=\"k\">return</span> <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">reject</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">);</span>\n    <span class=\"p\">});</span>\n</code></pre></div><p>如果你想在稍后移除拦截器，可以这样：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">var</span> <span class=\"nx\">myInterceptor</span> <span class=\"o\">=</span> <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">interceptors</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">.</span><span class=\"nx\">use</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{</span><span class=\"cm\">/*...*/</span><span class=\"p\">});</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">interceptors</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">.</span><span class=\"nx\">eject</span><span class=\"p\">(</span><span class=\"nx\">myInterceptor</span><span class=\"p\">);</span>\n</code></pre></div><p>可以为自定义 axios 实例添加拦截器：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">var</span> <span class=\"nx\">instance</span> <span class=\"o\">=</span> <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">create</span><span class=\"p\">();</span>\n  <span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">interceptors</span><span class=\"p\">.</span><span class=\"nx\">request</span><span class=\"p\">.</span><span class=\"nx\">use</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{</span><span class=\"cm\">/*...*/</span><span class=\"p\">});</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>9 - 错误处理</b></h2><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user/12345&#39;</span><span class=\"p\">)</span>\n      <span class=\"p\">.</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">.</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"c1\">// 请求已发出，但服务器响应的状态码不在 2xx 范围内\n</span><span class=\"c1\"></span>          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">.</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">data</span><span class=\"p\">);</span>\n          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">.</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">status</span><span class=\"p\">);</span>\n          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">.</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">headers</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n          <span class=\"c1\">// 在配置请求和触发报错之前做些什么\n</span><span class=\"c1\"></span>          <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Error&#39;</span><span class=\"p\">,</span> <span class=\"nx\">error</span><span class=\"p\">.</span><span class=\"nx\">message</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">error</span><span class=\"p\">.</span><span class=\"nx\">config</span><span class=\"p\">);</span>\n      <span class=\"p\">})</span>\n</code></pre></div><p>可以使用 <code>validateStatus</code> 配置选项定义一个自定义 HTTP 状态码的错误范围。</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user/12345&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n    <span class=\"nx\">validateStatus</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">status</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"nx\">status</span> <span class=\"o\">&lt;</span> <span class=\"mi\">500</span><span class=\"p\">;</span> <span class=\"c1\">// 状态码在大于或等于 500 时才会 reject\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n  <span class=\"p\">})</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>10 - 取消</b></h2><p>使用 <code>cancel token</code> 取消请求</p><blockquote>Axios 的 cancel token API 基于 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-cancelable-promises\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cancelable promises proposal</a>，它还处于第一阶段。</blockquote><p>可以使用 <code>CancelToken.source</code> 工厂方法创建 <code>cancel token</code>，像这样：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">var</span> <span class=\"nx\">CancelToken</span> <span class=\"o\">=</span> <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">CancelToken</span><span class=\"p\">;</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">source</span> <span class=\"o\">=</span> <span class=\"nx\">CancelToken</span><span class=\"p\">.</span><span class=\"nx\">source</span><span class=\"p\">();</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user/12345&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n    <span class=\"nx\">cancelToken</span><span class=\"o\">:</span> <span class=\"nx\">source</span><span class=\"p\">.</span><span class=\"nx\">token</span>\n  <span class=\"p\">}).</span><span class=\"k\">catch</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">thrown</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">isCancel</span><span class=\"p\">(</span><span class=\"nx\">thrown</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Request canceled&#39;</span><span class=\"p\">,</span> <span class=\"nx\">thrown</span><span class=\"p\">.</span><span class=\"nx\">message</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// 处理错误\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n  <span class=\"p\">});</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 取消请求（message 参数是可选的）\n</span><span class=\"c1\"></span>  <span class=\"nx\">source</span><span class=\"p\">.</span><span class=\"nx\">cancel</span><span class=\"p\">(</span><span class=\"s1\">&#39;Operation canceled by the user.&#39;</span><span class=\"p\">);</span>\n</code></pre></div><p>还可以通过传递一个 <code>executor</code> 函数到 <code>CancelToken</code> 的构造函数来创建 <code>cancel token</code>：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"kd\">var</span> <span class=\"nx\">CancelToken</span> <span class=\"o\">=</span> <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">CancelToken</span><span class=\"p\">;</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">cancel</span><span class=\"p\">;</span>\n  <span class=\"err\">​</span>\n  <span class=\"nx\">axios</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;/user/12345&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n    <span class=\"nx\">cancelToken</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"nx\">CancelToken</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"nx\">executor</span><span class=\"p\">(</span><span class=\"nx\">c</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">// executor 函数接收一个 cancel 函数作为参数\n</span><span class=\"c1\"></span>      <span class=\"nx\">cancel</span> <span class=\"o\">=</span> <span class=\"nx\">c</span><span class=\"p\">;</span>\n    <span class=\"p\">})</span>\n  <span class=\"p\">});</span>\n  <span class=\"err\">​</span>\n  <span class=\"c1\">// 取消请求\n</span><span class=\"c1\"></span>  <span class=\"nx\">cancel</span><span class=\"p\">();</span>\n</code></pre></div><blockquote>Note：可以使用同一个 <code>cancel token</code> 取消多个请求。</blockquote>", 
            "topic": [
                {
                    "tag": "axios", 
                    "tagLink": "https://api.zhihu.com/topics/20068338"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }, 
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }
            ], 
            "comments": [
                {
                    "userName": "李元秋", 
                    "userLink": "https://www.zhihu.com/people/f7c12327d8b5fb3d22f77301417e7e53", 
                    "content": "这东西看官方文档不是更靠谱、更全面？", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "绅士喵呜", 
                            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
                            "content": "<p>QWQ...这是类似于读书笔记类的专栏，前辈无需较真，很抱歉给您的推送造成不快。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "李元秋"
                        }
                    ]
                }, 
                {
                    "userName": "绅士喵呜", 
                    "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
                    "content": "<p>小弟最近有点忙...如果下周有空，打算把这篇文章改写一下，结合文档加点自己的代码经验什么的，还有配合 mock.js 实现数据模拟啥的...（呜呜呜 ，我好想放假啊）</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "伍佰", 
                    "userLink": "https://www.zhihu.com/people/bc531c736f259cccc9708eac8fa7817c", 
                    "content": "jsonp的请求如何写", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "绅士喵呜", 
                            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
                            "content": "<p>axios 推荐用 CORS 方式，官方明确不支持 jsonp，如果你的项目需要 jsonp 支持，只能独立安装  jsonp 了。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "伍佰"
                        }, 
                        {
                            "userName": "绅士喵呜", 
                            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
                            "content": "<p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/axios/axios/blob/master/COOKBOOK.md%23jsonp\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/axios/axios/</span><span class=\"invisible\">blob/master/COOKBOOK.md#jsonp</span><span class=\"ellipsis\"></span></a></p>", 
                            "likes": 0, 
                            "replyToAuthor": "伍佰"
                        }
                    ]
                }, 
                {
                    "userName": "97年的夜光", 
                    "userLink": "https://www.zhihu.com/people/16d8fd54868b4beb95df62da5232af40", 
                    "content": "感觉挺好，对我这种小白挺友好的", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58110403", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 23, 
            "title": "正则表达式入门", 
            "content": "<blockquote>本文是对正则表达式的笔记，附一些常用技巧</blockquote><h2><b>1 - 前言</b></h2><h2><b>1.1 目标</b></h2><blockquote>30分钟让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</blockquote><h2><b>1.2 怎么学</b></h2><p>别被下面那些复杂的表达式吓倒，只要跟着我一步步来，你会发现正则表达式其实并没有想象中的那么困难。当然，如果看完教程之后发现懂了很多却啥都不记得，那也是很正常的——只有练习才能掌握。</p><p>除了作为入门教程，本文还试图称为日常工作中的正则表达式语法参考手册。</p><blockquote><b>清除格式</b> 本文格式约定：<b>专业术语</b> <code>元字符/语法格式</code> 正则表达式 正则表达式中的一部分（用于分析）对其进行匹配的源字符串<br/><b>隐藏边注</b> 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者</blockquote><h2><b>1.3 正则表达式到底是什么东西？</b></h2><blockquote>字符是计算机软件处理文字时最基本的单位，可能是字母、数字、标点符号、空格、换行符、汉字等。字符串是 0 个或更多字符的序列。文本也就是文字、字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分）能满足表达式给出的条件。</blockquote><p>编写处理字符串的程序或网页时，会经常有查找某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。总而言之，<b>正则表达式就是记录文本规则的代码。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2 - 入门</b></h2><blockquote>由实例学习知识是最快的上手方式，下面提供了一些简单易懂的例子，带你了解正则。</blockquote><ul><li><b>阶段一</b>：假设要找出英文文章中所有的 <i>hi</i>，那么直接使用正则表达式 <code>hi</code><br/>这几乎是最简单的正则表达式，可以精确匹配到这样的字符串：两字符组成，前一个是 h，后一个是 i。如果选中忽略大小写的选项，可以匹配 <i>hi, HI, Hi, hI</i> 这四种情况。</li><li><b>阶段二</b>：不幸的是，诸如 <i>history, high</i> 这种单词也包含 <i>hi</i>，那么我们 <code>hi</code> 这个正则就不够精确，因为我们只要 <i>hi</i>，这时候我们需要使用 <code>\\bin\\b</code>。<br/><code>\\b</code> 是正则表达式规定的一个特殊代码（<b>元字符，metacharacter</b>），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格、标点或者换行符来分隔的，但是 <code>\\b</code> 不匹配这些，它只<b>匹配一个位置</b>。</li><li><b>阶段三</b>：比如你匹配 <code>hi 后面不远跟一个 Lucy</code>，就应该用 <code>\\bhi\\b.*Lucy\\b</code>。<br/>这里，<code>.</code>是另一个元字符，匹配<b>除了换行符以外的任意字符</b>。<br/><code>*</code> 同样是元字符，它代表的是数量：它指定<b>前边的内容可以连续重复使用任意次以使整个表达式得到匹配</b>。<br/><code>.*</code>组合在一起就表示了<b>任意数量的不包含换行的字符。</b><br/><code>\\bhi\\b.*Lucy\\b</code> 意思就是：hi 加上任意个任意字符串（不含换行符）最后以 Lucy 结尾</li></ul><p>如果使用其他连字符，我们就能构造出功能更强大的正则：</p><p><code>0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d</code> 匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字。</p><p>也可以这么缩写：<code>0\\d{2}-\\d{8}</code>，这里 <code>\\d</code>后面的 <code>{}</code> 中的数字就是连续重复匹配的次数。</p><blockquote>更精确的说法：<code>\\b</code> 匹配了的位置的前一个字符和后一个字符不全是 <code>\\w</code><br/>换行符就是 <code>\\n</code></blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3 - 工具</b></h2><h2><b>3.1 在线的测试工具</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.regexpal.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://www.regexpal.com</a></p><blockquote>挂代理我居然打不开。。。。得在墙内登录</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9ac79828781904e038fcfaf595e65412_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1245\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb\" width=\"1245\" data-original=\"https://pic3.zhimg.com/v2-9ac79828781904e038fcfaf595e65412_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1245&#39; height=&#39;369&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1245\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1245\" data-original=\"https://pic3.zhimg.com/v2-9ac79828781904e038fcfaf595e65412_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9ac79828781904e038fcfaf595e65412_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.2 可视化工具</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//regexper.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">regexper.com/</span><span class=\"invisible\"></span></a></p><blockquote>用于学习，构建和测试正则表达式的在线工具</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-eeafa424b130ab481dbc9913b1c4beeb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"940\" data-rawheight=\"246\" class=\"origin_image zh-lightbox-thumb\" width=\"940\" data-original=\"https://pic4.zhimg.com/v2-eeafa424b130ab481dbc9913b1c4beeb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;940&#39; height=&#39;246&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"940\" data-rawheight=\"246\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"940\" data-original=\"https://pic4.zhimg.com/v2-eeafa424b130ab481dbc9913b1c4beeb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-eeafa424b130ab481dbc9913b1c4beeb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.3 在线测试工具</b></h2><p>上面的只能在墙内看，我就重新找了个，如下：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//regex101.com/%23javascript\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">regex101.com/#</span><span class=\"invisible\">javascript</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9f26a4dd72baf2f8caa79313fd528226_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"936\" data-rawheight=\"507\" class=\"origin_image zh-lightbox-thumb\" width=\"936\" data-original=\"https://pic3.zhimg.com/v2-9f26a4dd72baf2f8caa79313fd528226_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;936&#39; height=&#39;507&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"936\" data-rawheight=\"507\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"936\" data-original=\"https://pic3.zhimg.com/v2-9f26a4dd72baf2f8caa79313fd528226_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9f26a4dd72baf2f8caa79313fd528226_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4 - 元字符</b></h2><p>上面我们已经了解了一些很有用的<b>元字符</b>，如 <code>\\b</code> ，<code>.</code> ，<code>*</code>，还有 <code>\\d.</code> ，来几个例子：</p><ul><li><code>\\ba\\w*\\b</code> ：匹配以字母 <i>a</i> 开头的单词。先是某个单词开始处（<code>\\b</code>），然后是字母 <i>a</i> ，然后是任意数量的<b>字母或数字</b>（<code>\\w*</code>），最后是单词结束（<code>\\b</code>）</li><li><code>\\d+</code> ：匹配1个或更多连续的数字。这里的 <code>+</code> 是和 <code>*</code> 类似的元字符，不同的是 <code>*</code> 匹配重复任意次数（包括 0），而 <code>+</code> 则匹配 1 次或更多次。</li><li><code>\\b\\w{6}\\b</code>：匹配长度为 6 的单词</li></ul><p>常用元字符：</p><p><b>代码说明</b><code>.</code>匹配除换行符以外的任意字符<code>\\w</code>匹配字母或数字或下划线<code>\\s</code>匹配任意的空白符<code>\\d</code>匹配数字<code>\\b</code>匹配单词的开始或结束<code>^</code>匹配字符串的开始<code>$</code>匹配字符串的结束</p><p>元字符 <code>^</code>和 <code>$</code> 都匹配一个位置，这和 <code>\\b</code> 有点类似。<code>^</code> 匹配你要用来查找的字符串的开头，<code>$</code> 匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的 QQ 号必须为 5 到 12 位，可以使用：<code>^\\d{5,12}$</code>。</p><p>这里的 <code>{5,12}</code> 和前面介绍过的 <code>{2}</code> 是类似的，只不过 <code>{2}</code> 匹配只能不多不少，而 <code>{5,12}</code> 是重复次数不能少于 5 次，不能少于 12 次。</p><p>因为使用了 <code>^</code> 和 <code>$</code>，所以输入的整个字符串都要用来和 <code>\\d{5,12}</code> 来匹配。</p><blockquote>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，<code>^</code>和<code>$</code>的意义就变成了匹配行的开始处和结束处。<br/><b>对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。</b><br/>正则表达式引擎通常会提供一个 “测试指定的字符串是否匹配一个正则表达式” 的方法，如 JavaScript 里的 RegExp.test() 方法或 .NET 里的 Regex.IsMatch() 方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用 <code>^</code> 和 <code>$</code> 的话，对于 <code>\\d{5,12}</code> 而言，使用这样的方法就只能保证字符串里包含 5 到 12 连续位数字，而不是整个字符串就是 5 到 12 位数字。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5 - 字符转义</b></h2><p>有时候我们查找 <code>.</code> 或者 <code>*</code> ，或者一些元字符本身的话，会有一些问题，因为这些元字符已经变成别的意思了（被转义了），我们没法准确找到这些元字符。出现这种情况，我们就得使用 <code>\\</code> 来取消这些字符的特殊意义。所以，我们应该使用 <code>\\.</code> 和 <code>\\*</code>。当然，要查找 <code>\\</code> 本身，你也得用 <code>\\\\</code>。</p><p>例子：<code>deerchao\\.net</code> 匹配 <i><a href=\"https://link.zhihu.com/?target=http%3A//deerchao.net\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">deerchao.net</span><span class=\"invisible\"></span></a></i>，<code>C:\\\\Windows</code> 匹配 <i>C:\\Windows</i>。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>6 - 重复</b></h2><p>上面已经看过了 <code>*</code>，<code>+</code>，<code>{2}</code>，<code>{5,12}</code> 这几个匹配重复的方式了。下面是正则表达式中所有限定符（指定数量的代码，例如 *，{5,12} 等）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5318ca4509f3b76d3be9bb285fac84c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic3.zhimg.com/v2-5318ca4509f3b76d3be9bb285fac84c2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;259&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic3.zhimg.com/v2-5318ca4509f3b76d3be9bb285fac84c2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5318ca4509f3b76d3be9bb285fac84c2_b.jpg\"/></figure><p>例子：</p><ul><li><code>Windows\\d+</code>：匹配 Windows 后面跟 1 个或更多数字</li><li><code>^\\w?</code>：匹配一行的第一个单词（或整个字符串的第一个单词，具体匹配哪个意思得看选项设置）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>7 - 字符类</b></h2><p>如果想要查找 <i>数字、字母或数字、空白</i> 是很简单的，因为对应这些字符集合的元字符是已经存在的了，不过要想匹配像元音字母 <i>a、e、i、o、u</i> 这种没有事先定义元字符的字符集合该怎么做呢？我们使用 <b>方括号</b> <code>[]</code>，比如 <code>[aeiou]</code> 就匹配<b>任何一个英文元音字母</b>，<code>[.?!]</code> 匹配标点符号（<i>. 或  ? 或  !</i>）。</p><p>我们也可以指定一个字符范围，比如  <code>[0-9]</code> 代表的含义就和 <code>\\d</code> 就是完全一样的；同理 <code>[a-z0-9A-Z]</code> 也完全等同于 <code>\\w</code> （如果只考虑英文的话）。</p><p>接着我们来看一个更复杂的表达式：<code>\\(?0\\d{2}[) -]?\\d{8}</code></p><p>这个表达式可以匹配几种格式的电话号码，比如 <code>(010)88886666</code>、<code>022-22334455</code>、<code>02912345678</code></p><ul><li><code>\\(?</code>：出现一个个转义字符，出现 0 或 1 次</li><li><code>0\\d{2}</code>：0 + 两个数字</li><li><code>[) -]?</code>：匹配一个括号、空格或者连字符</li><li><code>\\d{8}</code>：接 8 个数字</li></ul><blockquote><code>(</code> 和 <code>)</code> 也是元字符，后面的分组章节里会提到，所以在这里需要使用转义。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>8 - 分支条件</b></h2><p>上面的正则并不完美，因为它可以匹配 <code>010)12345678</code> 或者 <code>(022-87654321</code> 这种错误格式。解决这个问题我们使用<b>分支条件</b>。正则表达式中的分支条件指的是：存在几种规则，只要满足其中任何一个，就会被当成匹配。我们使用 <code>|</code> 来分隔各个规则。以下是例子：</p><ul><li><code>0\\d{2}-\\d{8}|0\\d{3}-\\d{7}</code>：可以匹配形如 <code>010-12345678</code> 和 <code>0376-2233445</code> 的号码</li><li><code>\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}</code>：号码前三位可以用括号括起来也可以不用</li><li><code>\\d{5}-\\d{4}|\\d{5}</code>：匹配没过的邮政编码，<code>五位数字</code> 或者 <code>五位数字 + 连字符 + 九位数字</code> ，这个例子告诉我们：<b>使用分支条件时，要注意各个条件的顺序。</b>如果改成 <code>\\d{5}|\\d{5}-\\d{4}</code>，就会只匹配 5 位 的邮编，因为匹配分支时，会从左到右测试每个条件，满足条件则不会执行下一个条件。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>9 - 分组</b></h2><p>我们已经知道了重复单个字符怎么写（<code>[a-z]{5}</code>），那么多个字符的重复又该如何实现呢？我们可以使用 <code>()</code> 来指定子表达式（也成为 <b>分组</b>），然后对子表达式进行重复。</p><p><code>(\\d{1,3}\\.){3}\\d{1,3}</code> 是一个简单的 IP 地址匹配表达式“</p><ul><li><code>\\d{1,3}\\.</code>：匹配 1 到 3 位的数字加上一个 <code>.</code></li><li><code>(\\d{1,3}\\.){3}</code>：将上面的分组重复三次</li><li><code>\\d{1,3}</code>：最后再加上一个三位数字</li></ul><p>但是问题又来了，这个正则将匹配 <code>256.300.888.999</code> 这种错误地址。我们在正则表达式中无法使用算数比较，所以只能使用冗长的分组、选择、字符类来描述一个正确的 IP 地址：<code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code></p><h2><b>9.1 分析一下 IP4 的正则表达式子：</b></h2><p>先来拆分：</p><ul><li>250-255：三位数，百位是 2，十位是 5，个位是 0-5，用正则表达式可以写成：<code>25[0-5]</code></li><li>200-249：三位数，百位是 2，十位是 0-4，个位是 0-9，用正则表达式可以写成：<code>2[0-4]\\d</code></li><li>0-199：这个可以继续拆：<br/></li><ul><li>0-9：一位数，个位是 0-9，用正则表达式可以写成：<code>\\d</code></li><li>10-99：二位数，十位是 1-9，个位是 0-9，用正则表达式可以写成：<code>[1-9]\\d</code></li><li>100-199：三位数，百位是 1，十位是 0-9，个位是 0-9，用正则表达式可以写成：<code>1\\d{2}</code></li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>再来合并：</p><ul><li>0-99：<code>[0-9]?\\d</code></li><li>0-199：<code>1\\d{2}|[1-9]?\\d</code></li></ul><p>我们来优化一下：</p><ul><li>0-199：<code>[01]?\\d\\d?</code></li></ul><blockquote>IP 地址中每个数字都不能大于 255，那么 01.02.03.04 这样前面带有 0 的数字，是不是正确的 IP 地址呢？答案是：是的，IP 地址里的数字可以包含有前导 0（leading zeroes）。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>10 - 反义</b></h2><p>有时候想找不是这个条件的字符，这时候就需要用到<b>反义</b>（相反的意思，很好理解吧）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-039761b4988c9bcb6d4f9f473611dacb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"227\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic4.zhimg.com/v2-039761b4988c9bcb6d4f9f473611dacb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;227&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"227\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic4.zhimg.com/v2-039761b4988c9bcb6d4f9f473611dacb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-039761b4988c9bcb6d4f9f473611dacb_b.jpg\"/></figure><p>例子：</p><ul><li><code>\\S+</code> 匹配不包含空白符的字符串</li><li><code>&lt;a[^&gt;]+&gt;</code> 匹配用尖括号括起来的以a开头的字符串。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>11 - 后向引用</b></h2><p>当我们使用小括号指定一个子表达式之后，就要对这个子表达式的文本进行匹配，即此分组捕获的内容，可以在表达式或者其它程序中作进一步的处理。一般情况下，每个分组都会自动拥有一个组号，规则是：<b>从左到右以分组的左括号为标志，把第一次出现的分组的组号定为 1，第二个为 2，以此类推。</b></p><p><b>后向引用</b>用于重复搜索前面某个分组匹配的文本，例如，<code>\\1</code> 代表分组 1 匹配的文本，我们来看一下例子：</p><p><code>\\b(\\w+)\\b\\s+\\1\\b</code> 可以用来匹配重复的单词，像 <i>hi hi</i>，<i>hei hei</i>，这种的。分析：</p><ul><li><code>\\b(\\w+)\\b</code>：首先是一个单词，被捕获为编号为 1 的分组中</li><li><code>\\s+</code>：接着是一个或多个空格</li><li><code>\\1\\b</code>：最后是分组 1 中捕获的内容，也就是重复分组 1 的单词。</li></ul><p>你也可以自定义子表达式的<b>组名</b>。要指定一个子表达式的组名，用这样的语法：<code>(?&lt;Word&gt;\\w+)</code> 或者 <code>(?&#39;Word&#39;\\w+))</code>。这时候就可以使用 <code>\\k&lt;Word&gt;</code>来捕获这个分组，这样改写：<code>\\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Work&gt;\\b</code> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cee74fb24a9c782f4e5e43e4981a125e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic3.zhimg.com/v2-cee74fb24a9c782f4e5e43e4981a125e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic3.zhimg.com/v2-cee74fb24a9c782f4e5e43e4981a125e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cee74fb24a9c782f4e5e43e4981a125e_b.jpg\"/></figure><p>我们已经讨论了前两种语法，第三个 <code>(?:exp)</code> 不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样呗捕获到某个组里面，也不会拥有组号。为什么要这样做呢？一般来说是为了节省资源，提高效率。</p><p>比如说输入的数据是整数，这么写：</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^([1-9][0-9]*|0)$</code></pre></div><p>这时候的 <code>|</code> 仅仅用来分隔分支条件，没有捕获的需求，那么我们就可以使用 <code>(?:exp)</code> 来定义它为非捕获组。</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^(?:[1-9][0-9]*|0)$</code></pre></div><p>这只是个简单的例子，如果我们来做一个日期正则：</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^(?:(?:(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))([-/.])(?:0?2\\1(?:29)))|(?:(?:(?:1[6-9]|[2-9]\\d)?\\d{2})([-/.])(?:(?:(?:0?[13578]|1[02])\\2(?:31))|(?:(?:0?[13-9]|1[0-2])\\2(29|30))|(?:(?:0?[1-9])|(?:1[0-2]))\\2(?:0?[1-9]|1\\d|2[0-8]))))$</code></pre></div><p>可见极大优化了资源利用率。<b>有的时候我们不得不用 ()，而 () 默认情况下会将其中 exp 匹配的内容捕获到组里，而有些情况我们只是判断规则，或者后面并不需要对此处 () 中匹配的内容进行引用时，就没有必要把它捕获到组里了，一方面会造成资源的浪费，另一方面会降低效率，这时候就要用到非捕获组了。</b></p><blockquote>其实，组号分配还不像说的这么简单的：<br/></blockquote><ul><li>分组 0 对应整个正则表达式</li><li>实际上组号分配过程要从左向右扫描两遍：<br/></li><ul><li>第一遍给未命名组分配</li><li>第二遍给命名组分配</li></ul></ul><p>因此所有命名组的组号都大于未命名</p><ul><li>你可以使用 <code>(?:exp)</code> 这样的语法来剥夺一个分组对组号分配的参与权。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>12 - 零宽断言</b></h2><p>接下来的四个用于查找在某些内容的之前或之后的东西，但是有不包含这些内容本身的时候，零宽断言就起到作用了。</p><p>也就是说它们像 <code>\\b</code>， <code>^</code>，<code>$</code> 那样用于指定一个位置，这个位置应该满足一定的条件（即断言），因此它们也被称为<b>零宽断言</b>。</p><ul><li><code>(?=exp)</code>：<b>零宽度正预测先行断言</b>，它断言自身出现的位置的后面能匹配表达式 exp。<br/>比如<code>\\b\\w+(?=ing\\b)</code>，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找 <i>I&#39;m singing while you&#39;re dancing.</i> 时，它会匹配 sing 和 danc。</li><li><code>(?&lt;=exp)</code>：<b>零宽度正回顾后发断言</b>，它断言自身出现的位置的前面能匹配表达式 exp。<br/>比如 <code>(?&lt;=\\bre)\\w+\\b</code> 会匹配以 re 开头的单词的后半部分（除了 re 以外的部分），例如在查找 <i>reading a book</i> 时，它匹配 ading。</li></ul><p>假如你想要给一个很长的数字中每三位间加一个逗号（当然是从右边加起了），你可以这样查找需要在前面和里面添加逗号的部分：<code>((?&lt;=\\d)\\d{3})+\\b</code>，用它对 <i>1234567890</i> 进行查找时结果是 234567890。</p><p>下面这个例子同时使用了这两种断言：</p><p><code>(?&lt;=\\s)\\d+(?=\\s)</code> 匹配以空白符间隔的数字（再次强调，不包括这些空白符）。</p><blockquote>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>13 - 负向零宽断言</b></h2><p>当我们的目的不是去匹配某个字符，而是只想要该字符是否出现过，怎么办？例如，如果我们想要查找的单词中出现了字母 q，但是字母 q 的后面跟着的不是字母 u ，这种情况我们尝试：</p><p><code>\\b\\w*q[^u]\\w*\\b</code> 匹配包含<b>后面不是字母 u 的字母 q</b>的单词。但是这样子会发现它匹配不了 <code>Benq</code> 这种以 <i>q</i> 结尾的单词，因为 <code>[^u]</code> 总是要匹配一个字符的，这样它就可能会匹配到单词分隔符，可能会形成匹配两个单词的情况，比如匹配到：<i>Iraq fighting</i> </p><p><b>负向零宽断言</b> 能解决这样的问题，因为它只匹配一个位置，并不<b>消费</b>任何字符。我们这么写 <code>\\b\\w*q(?!u)\\w*\\b</code></p><p><b>零宽度负预测先行断言</b> <code>(?!exp)</code>，断言此位置的后面不能匹配表达式 exp。例如：</p><ul><li><code>\\d{3}(?!\\d)</code> 匹配三位数字，而且这三位数字的后面不能是数字；</li><li><code>\\b((?!abc)\\w)+\\b</code> 匹配不包含连续字符串 abc 的单词。</li></ul><p><b>零宽度负回顾后发断言</b> <code>(?&lt;!exp)</code> ，来断言此位置的前面不能匹配表达式 exp：</p><ul><li><code>(?&lt;![a-z])\\d{7}</code> 匹配前面不是小写字母的七位数字。</li></ul><p>一些更复杂的例子：</p><ul><li><code>(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)</code> 匹配不包含属性的简单HTML标签内里的内容。<br/></li><ul><li><code>(?&lt;=&lt;(\\w+)&gt;)</code> 指定了这样的<b>前缀</b>：被尖括号括起来的单词（形如 &lt;p&gt;）</li><li><code>.*</code> 任意字符串</li><li><code>(?=&lt;\\/\\1&gt;)</code> 注意 <code>\\/</code>，用到了前面提过的字符转义；<code>\\1</code> 则是一个反向引用，引用捕获到的第一组。</li></ul></ul><p>这个例子就是匹配的标签之间的内容。</p><blockquote>请详细分析表达式<code>(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)</code>，这个表达式最能表现零宽断言的真正用途。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>14 - 注释</b></h2><p>小括号还有一种用途，就是通过语法 <code>(?#comment)</code> 来包含注释，例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">  2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)</code></pre></div><p>如果要包含注释，最好是启用“忽略模式里的空白符”选项，因为这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。</p><p>例如，我们可以前面的一个表达式写成这样：</p><div class=\"highlight\"><pre><code class=\"language-text\">  (?&lt;= # 断言要匹配的文本的前缀\n  &lt;(\\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)\n  ) # 前缀结束\n  .* # 匹配任意文本\n  (?= # 断言要匹配的文本的后缀\n  &lt;\\/\\1&gt; # 查找尖括号括起来的内容：前面是一个&#34;/&#34;，后面是先前捕获的标签\n  ) # 后缀结束</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>15 - 贪婪与懒惰</b></h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<b>尽可能多</b>的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串 <i>aabab</i>。这被称为<b>贪婪</b>匹配。</p><p>有时，我们更需要<b>懒惰</b>匹配，也就是匹配<b>尽可能少</b>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 <code>?</code>。这样 <code>.*?</code> 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p><p><code>a.*?b</code> 匹配最短的，以a开始，以b结束的字符串。如果把它应用于 <i>aabab</i> 的话，它会匹配 aab（第一到第三个字符）和ab（第四到第五个字符）。</p><p>懒惰限定符</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d778ae5e58e0689f1766254c4e0608fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic3.zhimg.com/v2-d778ae5e58e0689f1766254c4e0608fe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;195&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic3.zhimg.com/v2-d778ae5e58e0689f1766254c4e0608fe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d778ae5e58e0689f1766254c4e0608fe_b.jpg\"/></figure><blockquote>为什么匹配得到的是 aab 而不是 ab 呢？因为另一条规则，比 贪婪/懒惰 规则优先级更高：The match that begins earliest wins。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>16 - 处理选项</b></h2><p>以下是 .Net 中常用到的正则表达式选项：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d67c41df54796ea1139db75dd5129661_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"233\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-d67c41df54796ea1139db75dd5129661_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;233&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"233\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-d67c41df54796ea1139db75dd5129661_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d67c41df54796ea1139db75dd5129661_b.jpg\"/></figure><blockquote> 是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>17 - 衡组/递归匹配</b></h2><p>有时候我们需要匹配像 <code>( 100 * ( 50 + 15 ) )</code> 这种嵌套的层次结构，简单使用 <code>\\(.+\\)</code> 只匹配最左和最右之间的内容，加入左右括号不匹配，数量不等，形如 <code>( 5 / ( 3 + 2 ) ) )</code> 匹配就很麻烦。</p><p>为了避免 <code>(</code> 和 <code>\\(</code> 把你搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把 <i>xx &lt;aa &lt;bbb&gt;</i> <i>&lt;bbb&gt; aa&gt; yy</i>这样的字符串里，最长的配对的尖括号内的内容捕获出来？</p><p>这里就需要用到以下的语法构造：</p><ul><li><code>(?&#39;group&#39;)</code>：把捕获的内容命名为 group，并压入<b>堆栈（Stack）</b></li><li><code>(?&#39;-group&#39;)</code>：从堆栈顶部弹出名为 group 的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li><li><code>(?(group)yes|no)</code>：如若堆栈存在以名为 group 的捕获内容的话，继续匹配 yes 部分的表达式，否则继续匹配 no</li><li><code>(?!)</code>：零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;                         #最外层的左括号\n      [^&lt;&gt;]*                #最外层的左括号后面的不是括号的内容\n      (\n          (\n              (?&#39;Open&#39;&lt;)    #碰到了左括号，在黑板上写一个&#34;Open&#34;\n              [^&lt;&gt;]*       #匹配左括号后面的不是括号的内容\n          )+\n          (\n              (?&#39;-Open&#39;&gt;)   #碰到了右括号，擦掉一个&#34;Open&#34;\n              [^&lt;&gt;]*        #匹配右括号后面不是括号的内容\n          )+\n      )*\n      (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&#34;Open&#34;；如果还有，则匹配失败\n  ​\n  &gt;                         #最外层的右括号</code></pre></div><p>最常见的应用场景就是匹配 HTML，我们来匹配嵌套的 <code>div</code> 标签：</p><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?&#39;Open&#39;&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?&#39;-Open&#39;&lt;/div&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))&lt;/div&gt;.</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>18 - 常用代码</b></h2><h2><b>18.1  校验密码强度</b></h2><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></pre></div><h2><b>18.2 校验中文</b></h2><p>字符串仅能是中文。</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^[\\\\u4e00-\\\\u9fa5]{0,}$</code></pre></div><h2><b>18.3 由数字、26 个英文字母或下划线组成的字符串</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">  ^\\\\w+$</code></pre></div><h2><b>18.4 校验E-Mail 地址</b></h2><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p><div class=\"highlight\"><pre><code class=\"language-text\">  [\\\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\\\.[\\\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[\\\\w](?:[\\\\w-]*[\\\\w])?</code></pre></div><h2><b>18.5 校验身份证号码</b></h2><p>下面是身份证号码的正则校验。15 或 18位。</p><div class=\"highlight\"><pre><code class=\"language-text\">  15位：\n  ^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$\n  18位：\n  ^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$</code></pre></div><h2><b>18.6 校验日期</b></h2><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code></pre></div><h2><b>18.7 校验金额</b></h2><p>金额校验，精确到2位小数。</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^[0-9]+(.[0-9]{2})?$</code></pre></div><h2><b>18.8 校验手机号</b></h2><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d{8}$</code></pre></div><h2><b>18.9 判断IE的版本</b></h2><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$</code></pre></div><h2><b>18.10 校验IP-v4地址</b></h2><p>IP4 正则语句。</p><div class=\"highlight\"><pre><code class=\"language-text\">  \\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b</code></pre></div><h2><b>18.11 校验IP-v6地址</b></h2><p>IP6 正则语句。</p><div class=\"highlight\"><pre><code class=\"language-text\">  (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</code></pre></div><h2><b>18.12 检查URL的前缀</b></h2><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p><div class=\"highlight\"><pre><code class=\"language-text\">  if (!s.match(/^[a-zA-Z]+:\\\\/\\\\//))\n  {\n      s = &#39;http://&#39; + s;\n  }</code></pre></div><h2><b>18.13 提取URL链接</b></h2><p>下面的这个表达式可以筛选出一段文本中的URL。</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?</code></pre></div><h2><b>18.14 文件路径及扩展名校验</b></h2><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?&#34;&lt;&gt;|]+\\\\.txt(l)?$</code></pre></div><h2><b>18.15 提取Color Hex Codes</b></h2><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$</code></pre></div><h2><b>18.16 提取网页图片</b></h2><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p><div class=\"highlight\"><pre><code class=\"language-text\">  \\\\&lt; *[img][^\\\\\\\\&gt;]*[src] *= *[\\\\&#34;\\\\&#39;]{0,1}([^\\\\&#34;\\\\&#39;\\\\ &gt;]*)</code></pre></div><h2><b>18.17 提取页面超链接</b></h2><p>提取html中的超链接。</p><div class=\"highlight\"><pre><code class=\"language-text\">  (&lt;a\\\\s*(?!.*\\\\brel=)[^&gt;]*)(href=&#34;https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?&#39;.implode(&#39;|(?:www\\\\.)?&#39;, $follow_list).&#39;))[^&#34;]+)&#34;((?!.*\\\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</code></pre></div><h2><b>18.18 查找CSS属性</b></h2><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p><div class=\"highlight\"><pre><code class=\"language-text\">  ^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1}</code></pre></div><h2><b>18.19 抽取注释</b></h2><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;!--(.*?)--&gt;</code></pre></div><h2><b>18.20 匹配HTML标签</b></h2><p>通过下面的表达式可以匹配出HTML中的标签属性。</p><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;\\\\/?\\\\w+((\\\\s+\\\\w+(\\\\s*=\\\\s*(?:&#34;.*?&#34;|&#39;.*?&#39;|[\\\\^&#39;&#34;&gt;\\\\s]+))?)+\\\\s*|\\\\s*)\\\\/?&gt;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>19 - 总结</b></h2><p>上面的只是常用的匹配语法，完整地参见<a href=\"https://link.zhihu.com/?target=http%3A//msdn.microsoft.com/zh-cn/library/az24scfc.aspx\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">关于正则表达式语言元素的 MSDN 在线文档</a>。</p><p>30 分钟看完？我骗你的哇，老铁，不然你怎么看得下去呢？</p>", 
            "topic": [
                {
                    "tag": "正则表达式", 
                    "tagLink": "https://api.zhihu.com/topics/19577832"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "好奇宝宝", 
                    "userLink": "https://www.zhihu.com/people/ebc933bffc2d135d7702eb89940ec8b8", 
                    "content": "不错，谢谢作者，很有收获啊", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "谷月老师", 
                    "userLink": "https://www.zhihu.com/people/17e6309b1da7f8bfe7ce00063ac728a6", 
                    "content": "正则表达式真难😭而且如果不常用，看过就忘了", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "丁一", 
                    "userLink": "https://www.zhihu.com/people/6989959269a75d6338839a0e30948f36", 
                    "content": "<p>因为我们只要 hi，这时候我们需要使用 \\bin\\b      <br>这一句后面写错了。。。</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57928060", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 8, 
            "title": "分布式系统架构 - 初窥", 
            "content": "<h2>先抛出几个问题：</h2><ul><li>对分布式系统了解有多少</li><li>分布式系统相对于单机或集中式系统有啥优势</li><li>分布式系统主要用于解决什么问题</li><li>分布式系统面临的最大挑战是什么</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>最大的挑战：数据一致性问题，比如数据库主从延迟，导致高并发情况下读取数据不一致<br/>主要解决的问题之一：单点故障，通过负载均衡解决单点性能和可用性问题<br/>看起来，集群在多台服务器上部署相同的应用，分布式是在多台服务器中部署的不同服务模块。但是集群部署就是分布式系统的体现，只是不同业务部署方式不同。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1 - 分布式出现背景及面临的问题</b></h2><h2><b>1.1 出现背景</b></h2><blockquote>因为集中式系统不能满足互联网爆炸式增长的需求。</blockquote><p>一方面随着系统变得越来越复杂，集中式系统的成本越来越高，这个成本包含两个方面</p><ul><li>人才成本，机器成本：大型主机动辄几百上千万</li><li>集中式系统明显的单点问题：扩展困难，与之相对，随着技术发展分布式有了硬件基础</li></ul><blockquote>关于集中式转型分布式，最出名的就是阿里去 IOE 运动（IBM、Oracle、EMC 存储设备）</blockquote><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统，具备分布性、对等性、并发性等特征。</p><h2><b>1.2 面临问题</b></h2><p>分布式系统可以很好的解决系统扩容、可用性以及降低成本，但是在部署和实践中要解决其存在的问题：</p><ul><li><b>通信异常</b>：分布式系统需要在各个节点之间进行网络通信，而网络本身是不可靠的，因此每次网络通信都会伴随着网络不可用的风险（比如硬件设备异常），另外响应延迟也会远大于单机操作（网络通信比内存操作肯定是慢很多的）</li><li><b>三态</b>：由于网络是不可靠的，分布式系统每次请求与响应，存在特有的 ”三态“ 概念，即成功、失败与超时。出现超时状态时，网络通信发起方是无法确定当前请求是否被成功处理的。</li><li><b>节点故障</b>：分布式系统的服务器节点出现宕机或者 “僵死”，导致部分节点不可用，进而引起分布式一致性问题。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2 - 从单机事务到分布式事务</b></h2><blockquote>此处事务指的是数据库事务</blockquote><h2><b>2.1 单机事务</b></h2><blockquote>ACID 特征：原子性、一致性、隔离性和持久性</blockquote><p>单机上我们解决数据一致性的办法是通过数据库事务，数据库事务具有 ACID 特征，好处是：</p><ul><li>保证了当多个应用程序并发访问数据的时候，事务可在这些程序之间提供一个隔离方法，以防止彼此之间的操作互相干扰</li><li>事务为数据库操作提供了一个从失败中恢复到正常状态的方法，这样数据库即使在异常状态下仍然能保持数据一致性</li></ul><h2><b>2.2 分布式事务</b></h2><p>分布式事务涉及到操作多个数据库的事务，分布式事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上。一个分布式事务可以看作是由多个分布式的操作序列组成的，通常可以把这一系列分布式的操作序列称为子事务，但由于在分布式事务中，各个子事务的执行是分布式的，因此要实现一种能够保证 ACID 特性的分布式事务处理系统就显得格外复杂。</p><p>为了解决分布式事务问题，这就提出了两个著名理论：<b>CAP 理论 </b>和 <b>BASE 理论</b></p><ul><li><b>CAP 理论 </b>认为一个分布式系统不可能同时满足 CAP （Consistency、Availability、Partition tolerance）也就是一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中两项</li><li><b>BASE 理论 </b>是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个单词的简写，是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）</li></ul><blockquote>BASE 理论面向的是大型高可用可扩展的分布式系统，和传统事务的 ACID 特性是相反的，它完全不同于 ACID 的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态（弱一致性）。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3 - 一致性协议之 2PC、3PC</b></h2><p>当一个事务操作需要跨越多个分布式节点的时候（分布式事务），为了保持事务处理的 ACID 特性，就需要引入一个称为 “协作者” 的组件来同一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为 “参与者”。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。基于这个思想，衍生出了二阶段提交和三阶段提交两种协议。</p><h2><b>3.1 2PC</b></h2><p>2PC（Two-Phase Commit），即二阶段提交，是计算机网络尤其是数据库领域内，为了使基于分布式系统架构下所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。二阶段提交是一个<b>强一致性</b>算法，目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，<b>统一决定事务的提交或回滚</b>，从而能够有效地保证分布式数据一致性。</p><p>顾名思义，二阶段提交协议分为两个阶段：</p><ul><li>提交事务请求（投票阶段）<br/></li><ul><li>事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待响应</li><li>执行事务：各个参与者执行事务操作，并将 Undo 和 Redo 信息记入事务日志</li><li>各参与者向协调者反馈事务的响应：成功执行，反馈 Yes，表示可执行；否则返回 No</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>执行事务提交（两种情况）<br/></li><ul><li>协调者从所有参与者都获得 Yes 响应，会执行事务提交<br/></li><ul><li>发送提交请求：协调者向所有参与者节点发送 Commit 请求</li><li>事务提交：参与者接收到 Commit 请求后，会正式执行事务提交操作，并在完成提示之后释放事务资源</li><li>反馈结果：参与者完成事务提交，向协调者发送 Ack 消息</li><li>完成事务：协调者接收到所有参与者反馈的 Ack 消息，完成事务</li></ul></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><ul><li>存在 No 反馈，即任何一个参与者反馈了 No 或者等待超时，就会中断事务<br/></li><ul><li>发送回滚请求：协调者向所有参与者节点发送 Rollback 请求</li><li>事务回滚：参与者收到请求，会利用阶段一中的记录的 Undo 信息来执行事务回滚操作，回滚完释放资源</li><li>反馈结果：参与者在完成事务回滚之后，向协调者发送 Ack 消息</li><li>中断事务：协调者接收到所有参与者反馈的 Ack 消息后，完成事务中断</li></ul></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>优缺点总结：</p><ul><li>优点：原理简单，实现方便</li><li>缺点：同步阻塞、单点问题（协调者）、脑裂（数据不一致）、过于保守（容错机制不完善）</li></ul><h2><b>3.2 3PC</b></h2><p>3PC（Three-Phase Commit），即三阶段提交，是 2PC 的改进版，将其二阶段重新划分，最终形成为 CanCommit、PreCommit 和 doCommit，三个阶段如下：</p><ul><li>阶段一：CanCommit<br/></li><ul><li>事务询问：协调者向所有的参与者发送一个包含事务内容的 canCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应</li><li>各参与者向协调者反馈事务询问的响应：参与者在接收到来自协调者的 canCommit 请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈 Yes 响应，并进入预备状态，否则反馈 No 响应</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>阶段二：PreCommit<br/>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务预提交：<br/></li><ul><li>发送预提交请求：协调者向所有参与者节点发出 preCommit 的请求，并进入 Prepared 阶段。</li><li> 事务预提交：参与者接收到 preCommit 请求后，会执行事务操作，并将 Undo 和 Redo 记录到事务日志中。</li></ul></ul><p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务：<br/></p><ul><ul><li>发送中断请求：协调者向所有参与者节点发出 abort 请求。</li><li>中断事务：无论是收到来自协调者的 abort 请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>阶段三：doCommit<br/></li><ul><li>协调者从所有的参与者获得的反馈都是 Yes 响应，则执行提交：<br/></li><ul><li>发送提交请求：进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发送 doCommit 请求。</li><li> 事务提交：参与者接收到 doCommit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li> 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送 Ack 消息。</li><li>完成事务：协调者接收到所有参与者反馈的 Ack 消息后，完成事务。</li></ul></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><ul><li>任何一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者会中断事务：<br/></li><ul><li>发送中断请求：协调者向所有的参与者节点发送 abort 请求。</li><li>事务回滚：参与者接收到 abort 请求后，会利用其在阶段二中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li><li>反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 Ack 消息。</li><li>中断事务：协调者接收到所有参与者反馈的 Ack 消息后，中断事务。</li></ul></ul></ul><p>注：在doCommit 阶段，如果参与者无法及时接收到来自协调者的 doCommit 或者 abort 请求时，会在等待超时之后，会继续进行事务的提交。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>优缺点总结：</p><ul><li>优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致（原因结合上面的注）。</li><li> 缺点：三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到 preCommit 消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。</li></ul><blockquote>了解了 2PC 和 3PC 之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， 世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。下一次我们就来介绍这个公认为难于理解但是行之有效的Paxos算法。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4 - 大名鼎鼎的Paxos算法</b></h2><p>Paxos 是一个基于消息传递的一致性算法，Leslie Lamport 在 1990 年提出，近几年被广泛应用于分布式计算中。有个问题要提一下，Paxos 有一个前提：没有拜占庭将军问题。就是说 Paxos 只有在一个可信的计算环境中才能成立，这个环境是不会被入侵所破坏的。</p><p>这里简单描述一下：</p><p>Paxos 描述了这样一个场景，有一个叫做 Paxos 的小岛（Island）上面住了一批居民，到上面所有的事情由一群特殊的人决定，他们叫做议员（Senator），议员的总数（SenatorCount）是确定的，不能更改。岛上每次环境的变更都需要通过一个提议（Proposal），每个提议都有一个编号（PID），这个编号是一直增长的，不可以倒退。每次提议都需要超过半数（SenatorCount/2 + 1）的议员同意才能生效。每个议员只会同意大于当前编号的提议（也就是新的提议），包括已生效的和未生效的。如果收到小于当前编号的提议，则会拒绝，并告知对方：你的提议已经有人提出过了。这里的当前编号是每个议员在自己的记事本上（日志）记录的编号，他会不断更新这个编号，整个议会无法保证所有议员的记事本上的编号总是相同的（弱一致性）。现在议会有一个目标：保证所有议员对于提议都能达成一致的看法。</p><p>好了，现在议会开始运作，所有议员一开始记事本上记录的都是 0。有一个议员提出一个提议：上调油价，+3毛钱。他首先看了下记事本，嗯，当前编号 0，那我提出的就是 1，于是给所有议员发消息：1 号提议：油价 + 3毛。其他议员看了下记事本，嗯，当前编号为 0，这个 1 号提议是可以接受的，于是记录下这个提议并回复：我们已收到你的 1 号提议 ，这时候大家记事本上编号为 1。当发起者收到超半数的回复，就发出通知：1 号提议生效！收到生效通知的议员会将 1 号提议由记录更改为正式法令，当有人问他油价变化多少，它会查看法令并回复：上调 3 毛钱。</p><p>现在看怎么解决这个过程中的冲突：假设三个议员 S1、S2、S3，S1 和 S2 同时发起一个提议：1 号提议，上调油价。S1 想上调 3 毛，S2 想上调 5 毛。结果 S3 先收到 S1 的提议，于是按照上面的过程回复收到信息。接着他收到 S2 的提案，查了下记事本，根据程序拒绝了这个提案。于是 S2 被拒绝，S1 正式宣布 1 号生效。S2 向 S1 或者 S3 打听并更新了 1 号法令内容，然后他可以选择继续发起 2 号提议。</p><p>Paxos 算法引入了 “过半” 的理念，通俗地讲就是少数服从多数。同时 Paxos 算法支持分布式节点角色之间的轮换，这极大避免了分布式单点的出现，因此 Paxos 算法既解决了无限期等待的问题，也解决了 “脑裂” 的问题，是目前最优秀的分布式一致性协议之一。</p><p>在这种一致性算法中，有三种参与角色，我们用 Proposer、Acceptor 和 Learner 来表示，具体实现中，一个进程可能充当不止一种角色。</p><p><b>提案的选定</b></p><ul><li>阶段一<br/></li><ul><li>Proposer 选择一个提案编号 Mn，然后向 Acceptor 的某个超过半数的子集成员发送编号为 Mn 的 Prepare 请求。</li><li>如果一个 Acceptor 收到一个编号为 Mn 的 Prepare 请求，且编号 Mn 大于该 Acceptor 已经响应的所有 Prepare 请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给 Proposer，同时该 Acceptor 会承诺不会再批准任何编号小于 Mn 的提案。</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>阶段二<br/></li><ul><li>如果 Proposer 收到来自半数以上的 Acceptor 对于其发出的编号为 Mn 的 Prepare 请求的响应，那么它就会发送一个针对［Mn，Vn］提案的 Accept 请求给 Acceptor。注意，Vn 的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。</li><li> 如果 Acceptor 收到这个针对［Mn，Vn］提案的 Accept 请求，只要该 Acceptor 尚未对编号大于 Mn 的Prepare 请求做出响应，它就可以通过这个提案。</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>活锁问题：假设存在这样一种极端情况，有两个 Proposer 依次提出了一系列编号递增的议案，但是最终都无法被选定，为此我们的解决方法是选择一个主 Proposer，并规定只有主 Proposer 才能提出议案。</blockquote><p><b>提案的获取</b></p><p>Learner 获取一个已经被选定的提案的前提是，该提案已经被半数以上的 Acceptor 批准。因此，最简单的做法就是一旦 Acceptor 批准了一个提案，就将该提案发送给所有的 Learner。很显然，这种做法虽然可以让 Learner 尽快地获取被选定的提案，但是却需要让每个 Acceptor 与所有的 Learner 逐个进行一次通信，通信的次数至少为二者个数的乘积。</p><p>为了解决这个问题，我们可以让所有的 Acceptor 将它们对提案的批准情况，统一发送给一个特定的 Learner（下文中我们将这样的 Learner 称为 “主 Learner”），在不考虑拜占庭将军问题的前提下，我们假定 Learner 之间可以通过消息通信来互相感知提案的选定情况。基于这样的前提，当主 Learner 被通知一个提案已经被选定时，它会负责通知其他的 Learner。但是这个方案引入了新的问题就是主 Learner 故障导致的单点，解决的办法是设置多个主 Learner（或者通过选举产生新的主 Learner）。</p><blockquote>Paxos 算法是现代分布式系统实现的算法基础，现有分布式系统几乎都是基于此算法，此后我们将开始分布式系统的工程实践之旅</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5 - 分布式数据一致性工业级解决方案 — Zookeeper</b></h2><h2><b>5.1 Zookeeper 从何而来</b></h2><p>ZooKeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。</p><p>关于 “ZooKeeper” 这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的 Pig 项目），雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 Raghu Ramakr-ishnan 开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧——因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而 ZooKeeper 正好要用来进行分布式环境的协调——于是，ZooKeeper 的名字也就由此诞生了。  </p><h2><b>5.2 Zookeeper 是什么</b></h2><p>ZooKeeper 是一个开放源代码的分布式协调服务，使用 Java 语言开发，由知名互联网公司雅虎创建然后捐给 Apache，是 Google Chubby 的开源实现。</p><p>ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。</p><p>ZooKeeper 是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如<b>数据发布/订阅</b>、<b>负载均衡</b>、<b>命名服务</b>、<b>分布式协调/通知</b>、<b>集群管理</b>、<b>Master选举</b>、<b>分布式锁</b>和<b>分布式队列</b>等功能。ZooKeeper 可以保证如下分布式一致性特性：</p><ul><li><b>顺序一致性</b>：同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到 ZooKeeper 中去。</li><li><b>原子性</b>：所有事务请求的处理结果在整个集群中所有机器上的应用情，况是一致的，也就是说，要么整个集群所有机器都成功应用了某一个事务，要么都没有应用。</li><li><b>单一视图</b>：无论客户端连接的是哪个 ZooKeeper 服务器，其看到的服务端数据模型都是一致的。</li><li><b>可靠性</b>：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来。</li><li><b>实时性</b>：这里需要注意的是，ZooKeeper 仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</li></ul><p>ZooKeeper 致力于提供一个高性能、高可用，且具有严格的顺序访问控制能力（主要是写操作的严格顺序性）的分布式协调服务。高性能使得 ZooKeeper 能够应用于那些对系统吞吐有明确要求的大型分布式系统中，高可用使得分布式的单点问题得到了很好的解决，而严格的顺序访问控制使得客户端能够基于 ZooKeeper 实现一些复杂的同步原语。</p><h2><b>5.3 为什么使用 Zookeeper</b></h2><p>随着分布式架构的出现，越来越多的分布式应用会面临数据一致性问题。很遗憾的是，在解决分布式数据一致性上，除了 ZooKeeper 之外，目前还没有一个成熟稳定且被大规模应用的解决方案。ZooKeeper 无论从性能、易用性还是稳定性上来说，都已经达到了一个工业级产品的标准。</p><p>此外，Zookeeper 开源、免费、并且已经得到了广泛的应用。诸如 Hadoop、HBase、Storm 和 Solr 等越来越多的大型分布式项目都已经将 ZooKeeper 作为其核心组件，用于分布式协调。</p><h2><b>5.4 Zookeeper 的基本概念</b></h2><p><b>集群角色</b></p><p>ZooKeeper 没有沿用传统传统集群中的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台被称为 “Leader” 的机器，Leader 服务器为客户端提供读和写服务。除 Leader 外，其他机器包括 Follower 和 Observer。Follower 和 Observer 都能够提供读服务，唯一的区别在于，Observer 机器不参与 Leader 选举过程，也不参与写操作的 “过半写成功” 策略，因此 Observer 可以在不影响写性能的情况下提升集群的读性能。</p><p><b>Session</b></p><p>在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。ZooKeeper 对外的服务端口默认是 2181，客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watch 事件通知。Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><p><b>ZNode（数据结点）</b></p><p>在ZooKeeper中，“节点” 分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点——ZNode。ZooKeeper 将所有数据存储在内存中，数据模型是一棵树（ZNode Tree），由斜杠（/）进行分割的路径，就是一个Znode，例如 /foo/path1。每个 ZNode 上都会保存自己的数据内容，同时还会保存一系列属性信息。</p><p>在 ZooKeeper 中，ZNode 可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 ZooKeeper 上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，ZooKeeper 还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper 会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p><p><b>版本</b></p><p>ZooKeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，ZooKeeper 都会为其维护一个叫作 Stat 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本，分别是 version（当前 ZNode 的版本）、cversion（当前 ZNode 子节点的版本）和 aversion（当前 ZNode 的 ACL 版本）。</p><p><b>Watcher（事件监听器）</b></p><p>ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p><p><b>ACL</b></p><p>ZooKeeper 采用 ACL（Access Control Lists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。ZooKeeper 定义了如下5种权限： </p><ul><li>CREATE：创建子节点的权限  </li><li>READ：获取节点数据和子节点列表的权限  </li><li>WRITE：更新节点数据的权限</li><li>DELETE：删除子节点的权限  </li><li>ADMIN：设置节点ACL的权限</li></ul><p>其中尤其需要注意的是，<code>CREATE</code> 和 <code>DELETE</code> 这两种权限都是针对子节点的权限控制。</p><h2><b>5.5 Zookeeper 的 ZAB 协议</b></h2><p>事实上，ZooKeeper 并没有完全采用 Paxos 算法，而是使用了一种称为 ZooKeeperAtomic Broadcast（ZAB，ZooKeeper 原子消息广播协议）的协议作为其数据一致性的核心算法。ZAB 协议是为分布式协调服务 ZooKeeper 专门设计的一种<b>支持崩溃恢复</b>的原子广播协议。</p><p>在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体的，ZooKeeper 使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用 ZAB 的原子广播协议，将服务器数据的状态变更以事务 Proposal 的形式广播到所有的副本进程上去。ZAB 协议的这个主备模型架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端大量的并发请求。另一方面，考虑到在分布式环境中，顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更，例如变更C需要依赖变更A和变更B。这样的依赖关系也对 ZAB 协议提出了一个要求：ZAB 协议必须能够保证一个全局的变更序列被顺序应用，也就是说，ZAB 协议需要保证如果一个状态变更已经被处理了，那么所有其依赖的状态变更都应该已经被提前处理掉了。最后，考虑到主进程在任何时候都有可能出现崩溃退出或重启现象，因此，ZAB 协议还需要做到在当前主进程出现上述异常情况的时候，依旧能够正常工作。</p><p>ZAB 协议的核心是定义了对于那些会改变 ZooKeeper 服务器数据状态的事务请求的处理方式，即：所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为 Leader 服务器，而余下的其他服务器则成为 Follower 服务器。Leader 服务器负责将一个客户端事务请求转换成一个事务 Proposal（提议），并将该 Proposal 分发给集群中所有的 Follower 服务器。之后 Leader 服务器需要等待所有 Follower 服务器的反馈，一旦超过半数的 Follower 服务器进行了正确的反馈后，那么 Leader 就会再次向所有的 Follower 服务器分发 Commit 消息，要求其将前一个 Proposal 进行提交。</p><p><b>ZAB 与 Paxos 算法的联系与区别</b></p><p>ZAB 协议并不是 Paxos 算法的一个典型实现，在讲解 ZAB 和 Paxos 之间的区别之前，我们首先来看下两者的联系：</p><ul><li>两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行。</li><li> Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交。</li><li>在 ZAB 协议中，每个 Proposal 中都包含了一个 epoch 值，用来代表当前的 Leader 周期，在 Paxos 算法中，同样存在这样的一个标识，只是名字变成了 Ballot。</li></ul><p>在 Paxos 算法中，一个新选举产生的主进程会进行两个阶段的工作。第一阶段被称为读阶段，在这个阶段中，这个新的主进程会通过和所有其他进程进行通信的方式来收集上一个主进程提出的提案，并将它们提交。第二阶段被称为写阶段，在这个阶段，当前主进程开始提出它自己的提案。在 Paxos 算法设计的基础上，ZAB 协议额外添加了一个同步阶段。在同步阶段之前，ZAB 协议也存在一个和 Paxos 算法中的读阶段非常类似的过程，称为发现（Discovery）阶段。在同步阶段中，新的 Leader 会确保存在过半的 Follower 已经提交了之前 Leader 周期中的所有事务 Proposal。这一同步阶段的引入，能够有效地保证 Leader 在新的周期中提出事务 Proposal 之前，所有的进程都已经完成了对之前所有事务 Proposal 的提交。一旦完成同步阶段后，那么 ZAB 就会执行和 Paxos 算法类似的写阶段。</p><blockquote>总的来讲，ZAB 协议和 Paxos 算法的本质区别在于，两者的设计目标不太一样。ZAB 协议主要用于构建一个高可用的分布式数据主备系统，例如 ZooKeeper，而 Paxos 算法则是用于构建一个分布式的一致性状态机系统。</blockquote>", 
            "topic": [
                {
                    "tag": "笔记", 
                    "tagLink": "https://api.zhihu.com/topics/19554982"
                }, 
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }, 
                {
                    "tag": "Paxos", 
                    "tagLink": "https://api.zhihu.com/topics/19773822"
                }
            ], 
            "comments": [
                {
                    "userName": "Zzzzzz", 
                    "userLink": "https://www.zhihu.com/people/ec21adcb0e3757b6fc3c1f3675996464", 
                    "content": "<p>老太太的裹脚布，跟同济高数一样，让人看了想睡觉。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "绅士喵呜", 
                            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
                            "content": "<p>没办法，本人水平比较次。。。写不了多生动哇</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Zzzzzz"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57716025", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 5, 
            "title": "Vue 基础知识之 Vue.extend", 
            "content": "<p><code>Vue.extend</code> 属于 Vue 的全局 API，在实际业务开发中我们很少使用，因为相比常用的 <code>Vue.component</code> 写法使用 <code>extend</code> 步骤要更加繁琐一些。但是在一些独立组件开发场景中，<code>Vue.extend</code> + <code>$mount</code> 这对组合是我们需要去关注的。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>官方文档</b></h2><blockquote>学习开始之前我们先来看一下官方文档是怎么描述的。</blockquote><h2><b><a href=\"https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/api/index.html%23Vue-extend\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Vue.extend( options )</a></b></h2><ul><li><b>参数</b>：<br/></li><ul><li><code>{Object} options</code></li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>用法</b>：<br/>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。<br/><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code> 中它必须是函数</li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"o\">&lt;</span><span class=\"nx\">div</span> <span class=\"nx\">id</span><span class=\"o\">=</span><span class=\"s2\">&#34;mount-point&#34;</span><span class=\"o\">&gt;&lt;</span><span class=\"err\">/div&gt;</span>\n\n<span class=\"c1\">// 创建构造器\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">Profile</span> <span class=\"o\">=</span> <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">extend</span><span class=\"p\">({</span>\n  <span class=\"nx\">template</span><span class=\"o\">:</span> <span class=\"s1\">&#39;&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;&#39;</span><span class=\"p\">,</span>\n  <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n      <span class=\"nx\">firstName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Walter&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">lastName</span><span class=\"o\">:</span> <span class=\"s1\">&#39;White&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">alias</span><span class=\"o\">:</span> <span class=\"s1\">&#39;Heisenberg&#39;</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">})</span>\n<span class=\"c1\">// 创建 Profile 实例，并挂载到一个元素上。\n</span><span class=\"c1\"></span><span class=\"k\">new</span> <span class=\"nx\">Profile</span><span class=\"p\">().</span><span class=\"nx\">$mount</span><span class=\"p\">(</span><span class=\"s1\">&#39;#mount-point&#39;</span><span class=\"p\">)</span>\n</code></pre></div><ul><li>结果如下：</li></ul><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>Walter White aka Heisenberg<span class=\"p\">&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span></code></pre></div><ul><li><b>参考</b>：<a href=\"https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/components.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">组件</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>可以看到，<code>extend</code> 创建的是 Vue 构造器，而不是我们平时常写的组件实例，所以不可以通过 <code>new Vue({ components: testExtend })</code> 来直接使用，需要通过 <code>new Profile().$mount(&#39;#mount-point&#39;)</code> 来挂载到指定的元素上。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>为什么使用 extend</b></h2><p>在 vue 项目中，我们有了初始化的根实例后，所有页面基本上都是通过 router 来管理，组件也是通过 <code>import</code> 来进行局部注册，所以组件的创建我们不需要去关注，相比 <code>extend</code> 要更省心一点点。但是这样做会有几个缺点：</p><ol><li>组件模板都是事先定义好的，如果我要从接口动态渲染组件怎么办？</li><li>所有内容都是在 <code>#app</code> 下渲染，注册组件都是在当前位置渲染。如果我要实现一个类似于 <code>window.alert()</code> 提示组件要求像调用 JS 函数一样调用它，该怎么办？</li></ol><p>这时候，<code>Vue.extend + vm.$mount</code> 组合就派上用场了。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>简单示例</b></h2><p>我们照着官方文档来创建一个示例：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">import</span> <span class=\"nx\">Vue</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;vue&#39;</span>\n  <span class=\"err\">​</span>\n  <span class=\"k\">const</span> <span class=\"nx\">testComponent</span> <span class=\"o\">=</span> <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">extend</span><span class=\"p\">({</span>\n    <span class=\"nx\">template</span><span class=\"o\">:</span> <span class=\"s1\">&#39;&lt;div&gt;{{ text }}&lt;/div&gt;&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"nx\">text</span><span class=\"o\">:</span> <span class=\"s1\">&#39;extend test&#39;</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">})</span>\n</code></pre></div><p>然后我们将它手动渲染：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"k\">const</span> <span class=\"nx\">extendComponent</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">testComponent</span><span class=\"p\">().</span><span class=\"nx\">$mount</span><span class=\"p\">()</span>\n</code></pre></div><p>这时候，我们就将组件渲染挂载到 <code>body</code> 节点上了。</p><p>我们可以通过 <code>$el</code> 属性来访问 <code>extendComponent</code> 组件实例：</p><div class=\"highlight\"><pre><code class=\"language-js\">  <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">body</span><span class=\"p\">.</span><span class=\"nx\">appendChild</span><span class=\"p\">(</span><span class=\"nx\">extendComponent</span><span class=\"p\">.</span><span class=\"nx\">$el</span><span class=\"p\">)</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>如果想深入掌握 extend 知识，不妨做一个 alert 组件来实现类似于原生的全局调用。</p><p>加油！</p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "前端框架", 
                    "tagLink": "https://api.zhihu.com/topics/19806306"
                }
            ], 
            "comments": [
                {
                    "userName": "剑指天涯心有梦", 
                    "userLink": "https://www.zhihu.com/people/883ada1413ae14ec5e9d39d468624dc7", 
                    "content": "<p>哈哈  新同学啊</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "绅士喵呜", 
                            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
                            "content": "<p>嗯呐，是的，做做笔记~</p>", 
                            "likes": 0, 
                            "replyToAuthor": "剑指天涯心有梦"
                        }, 
                        {
                            "userName": "剑指天涯心有梦", 
                            "userLink": "https://www.zhihu.com/people/883ada1413ae14ec5e9d39d468624dc7", 
                            "content": "嘿嘿，加油💪，来自一个菜鸡学长的鼓励", 
                            "likes": 0, 
                            "replyToAuthor": "绅士喵呜"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57713138", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 15, 
            "title": "CSS（1）- 布局", 
            "content": "<h2><b>CSS 布局</b></h2><ol><li>左右布局（两列自适应）</li><li>左中右布局（三栏布局）</li><li>水平居中</li><li>垂直居中</li><li>等高布局</li><li>粘连布局</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1 - 左右布局（两列自适应）</b></h2><blockquote>一列由内容撑开，另一列撑满剩余宽度</blockquote><h2><b>1.1 float + overflow:hidden</b></h2><p>如果是普通的布局，浮动 + 元素 margin 就可以实现，但是如果是自适应撑满的两列布局，用 <code>float + overflow:hidden</code> 可以实现。</p><p>此方法通过 <code>overflow</code> 触发 BFC，而 BFC 不会重叠浮动元素。由于设置 <code>overflow: hidden</code> 并不会触发 IE-6 的 <code>haslayout</code> 属性，所以需要设置 <code>zoom: 1</code> 来兼容 IE-6。代码：</p><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;parent&#34;</span> <span class=\"na\">style</span><span class=\"o\">=</span><span class=\"s\">&#34;background-color: lightgrey;&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;left&#34;</span> <span class=\"na\">style</span><span class=\"o\">=</span><span class=\"s\">&#34;background-color: lightblue;&#34;</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>left<span class=\"p\">&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;right&#34;</span>  <span class=\"na\">style</span><span class=\"o\">=</span><span class=\"s\">&#34;background-color: lightgreen;&#34;</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>right<span class=\"p\">&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>right<span class=\"p\">&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>        \n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .parent {\n    overflow: hidden;\n    zoom: 1;\n  }\n  .left {\n    float: left;\n    margin-right: 20px;\n  }\n  .right {\n    overflow: hidden;\n    zoom: 1;\n  }</code></pre></div><blockquote>注意：如果侧边栏在右边，注意渲染顺序。</blockquote><h2><b>1.2 Flex 布局</b></h2><blockquote>弹性布局，很简单就能实现：</blockquote><div class=\"highlight\"><pre><code class=\"language-css\">  <span class=\"p\">.</span><span class=\"nc\">parent</span> <span class=\"p\">{</span>\n    <span class=\"k\">display</span><span class=\"p\">:</span><span class=\"kc\">flex</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>  \n  <span class=\"p\">.</span><span class=\"nc\">right</span> <span class=\"p\">{</span>\n    <span class=\"k\">margin-left</span><span class=\"p\">:</span><span class=\"mi\">20</span><span class=\"kt\">px</span><span class=\"p\">;</span> \n    <span class=\"k\">flex</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span></code></pre></div><h2><b>1.3 Grid 布局</b></h2><blockquote>Grid 二维布局系统</blockquote><div class=\"highlight\"><pre><code class=\"language-css\">  <span class=\"p\">.</span><span class=\"nc\">parent</span> <span class=\"p\">{</span>\n    <span class=\"k\">display</span><span class=\"p\">:</span><span class=\"k\">grid</span><span class=\"p\">;</span>\n    <span class=\"k\">grid-template-columns</span><span class=\"p\">:</span><span class=\"kc\">auto</span> <span class=\"mi\">1</span><span class=\"n\">fr</span><span class=\"p\">;</span>\n    <span class=\"k\">grid-gap</span><span class=\"p\">:</span><span class=\"mi\">20</span><span class=\"kt\">px</span>\n  <span class=\"p\">}</span> </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2 - 三栏布局（圣杯/双飞翼）</b></h2><blockquote>利用 Flex 和 Grid 可以迅速进行三栏布局，和上面两列布局类似<br/>这里我们重点讨论一下<b>中间自适应，两侧固定</b>的圣杯布局和双飞翼布局</blockquote><h2><b>2.1 圣杯布局</b></h2><h2><b>介绍</b></h2><blockquote>比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是 DOM 结构必须是先写中间的部分以确保中间列可以优先加载。</blockquote><div class=\"highlight\"><pre><code class=\"language-html\">    <span class=\"p\">&lt;</span><span class=\"nt\">article</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;container&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;center&#34;</span><span class=\"p\">&gt;</span>\n        <span class=\"p\">&lt;</span><span class=\"nt\">h2</span><span class=\"p\">&gt;</span>圣杯布局<span class=\"p\">&lt;/</span><span class=\"nt\">h2</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;left&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;right&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n    <span class=\"p\">&lt;/</span><span class=\"nt\">article</span><span class=\"p\">&gt;</span>\n    .container {\n      padding-left: 220px;//为左右栏腾出空间\n      padding-right: 220px;\n    }\n    .left {\n      float: left;\n      width: 200px;\n      height: 400px;\n      background: red;\n      margin-left: -100%;\n      position: relative;\n      left: -220px;\n    }\n    .center {\n      float: left;\n      width: 100%;\n      height: 500px;\n      background: yellow;\n    }\n    .right {\n      float: left;\n      width: 200px;\n      height: 400px;\n      background: blue;\n      margin-left: -200px;\n      position: relative;\n      right: -220px;\n    }</code></pre></div><h2><b>原理</b></h2><ol><li>三列都设置为左浮动，使得三列保持在一行</li><li>设置中间列宽度为 100% （自适应的关键），这时候左右会自动流动到下一行</li><li>设置 <code>margin-left</code> 为负值，使得左右两列回到中间列一行</li><li>设置大容器的 padding，为左右两列留出空间</li><li>通过 <code>position: relative</code> 调整左右两列</li></ol><h2><b>缺陷</b></h2><ul><li><code>center</code> 的 <code>min-width</code> 不能小于 <code>left</code> 的 <code>width</code></li><li>三列中任何一列高度边长，其他两列不会自动填充</li></ul><h2><b>2.2 双飞翼布局</b></h2><h2><b>介绍</b></h2><blockquote>优化了圣杯布局，解决圣杯布局错乱问题，实现内容与布局分离，而且没有高度适应问题</blockquote><div class=\"highlight\"><pre><code class=\"language-html\">      <span class=\"p\">&lt;</span><span class=\"nt\">article</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;container&#34;</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;center&#34;</span><span class=\"p\">&gt;</span>\n              <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;inner&#34;</span><span class=\"p\">&gt;</span>双飞翼布局<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;left&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;right&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;/</span><span class=\"nt\">article</span><span class=\"p\">&gt;</span>\n      .container {\n          min-width: 600px;//确保中间内容可以显示出来，两倍left宽+right宽\n      }\n      .left {\n          float: left;\n          width: 200px;\n          height: 400px;\n          background: red;\n          margin-left: -100%;\n      }\n      .center {\n          float: left;\n          width: 100%;\n          height: 500px;\n          background: yellow;\n      }\n      .center .inner {\n          margin: 0 200px; //新增部分\n      }\n      .right {\n          float: left;\n          width: 200px;\n          height: 400px;\n          background: blue;\n          margin-left: -200px;\n      }</code></pre></div><h2><b>原理</b></h2><ol><li>三列都设置为左浮动，使得三列保持在一行</li><li>设置中间列宽度为 100% （自适应的关键），这时候左右会自动流动到下一行</li><li>设置 <code>margin-left</code> 为负值，使得左右两列回到中间列一行</li><li>在 <code>center</code> 新增 <code>inner</code> 子容器，样式 <code>margin: 0 200px；</code></li></ol><h2><b>缺点</b></h2><blockquote>多加了一层 DOM 节点~</blockquote><h2><b>2.3 比较</b></h2><ul><li>相同<br/></li><ul><li>中间列写在最前，主列优先加载</li><li>三列浮动，用负 <code>margin</code> 形成三列</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>不同<br/></li><ul><li><b>圣杯布局是利用父容器的左、右内边距 + 两个从列相对定位</b>；</li><li><b>双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整</b></li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3 - 水平居中</b></h2><h2><b>3.1 inline-block + text-align</b></h2><blockquote>兼容性好，甚至可以兼容ie6、ie7</blockquote><h2><b>代码</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;parent&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;child</span><span class=\"p\">&gt;</span>DEMO<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .child{\n      display: inline-block;\n  }\n  .parent{\n      text-align: center;\n  }</code></pre></div><h2><b>原理</b></h2><ul><li>子块变为行内块元素，再设置行内块元素居中</li></ul><h2><b>缺点</b></h2><ul><li><code>child</code> 里的文字会被影响也会水平居中，需要使用 <code>text-align: left;</code> 在 <code>.child</code>  中还原样式</li><li>不过这说不定也是个优点，省的子块文字居中了~</li></ul><h2><b>3.2 table + margin</b></h2><blockquote>只设置了child，样式简单。IE 8 以上都支持。</blockquote><h2><b>代码</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;parent&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;child</span><span class=\"p\">&gt;</span>DEMO<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .child {\n      display: table;\n      margin: 0 auto;\n  }</code></pre></div><h2><b>原理</b></h2><ul><li>将子块设置为块级表格来显示（类似 &lt;table&gt;），再设置子块居中</li></ul><h2><b>缺点</b></h2><ul><li>不支持 IE 6、IE 7，需要将 <code>div</code> 换成 <code>table</code></li></ul><h2><b>3.3 absolute + transform</b></h2><blockquote>居中元素不会对其他的产生影响的水平居中办法</blockquote><h2><b>代码</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;parent&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;child</span><span class=\"p\">&gt;</span>DEMO<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .parent {\n      position:relative;\n  }\n  .child {\n      position:absolute;\n      left:50%;\n      transform:translateX(-50%);\n  }</code></pre></div><h2><b>原理</b></h2><ul><li>父块设置为相对定位，子块设置为绝对定位</li><li>移动子块，使得其左侧距离相对父块左边框距离为相对父块宽度的一半</li><li>再向左移动子块的一半宽度</li></ul><h2><b>缺点</b></h2><ul><li><code>transform</code> 属于 CSS3 标签，有兼容性问题</li></ul><h2><b>3.4 flex + margin</b></h2><h2><b>代码</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;parent&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;child</span><span class=\"p\">&gt;</span>DEMO<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .parent {\n      display:flex;\n  }\n  .child {\n      margin:0 auto;\n  }</code></pre></div><h2><b>原理</b></h2><ul><li>flex 将子块声明为 flex item，然后设置子块居中</li></ul><h2><b>缺点</b></h2><ul><li>沙雕 IE 6/7/8 不支持</li></ul><h2><b>3.4 flex + justify-content</b></h2><blockquote>不考虑兼容性的情况下，无脑用这个就行了</blockquote><h2><b>代码</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;parent&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;child</span><span class=\"p\">&gt;</span>DEMO<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .parent {\n      display:flex;\n      justify-content:center;\n  }</code></pre></div><h2><b>原理</b></h2><ul><li>flex 语法</li></ul><h2><b>缺点</b></h2><ul><li>沙雕 IE 6/7/8 不支持</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4 - 垂直居中</b></h2><h2><b>4.1 table-cell + vertical-align</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;parent&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;child</span><span class=\"p\">&gt;</span>DEMO<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .parent {\n      display:table-cell;\n      vertical-align:middle;\n  }</code></pre></div><blockquote>将父块转化为一个表格单元格显示，再通过设置属性，使表格单元格内容垂直居中以达到垂直居中。<br/>兼容性好，IE 8 以上均支持</blockquote><h2><b>4.2 absolute + transform</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;parent&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;child</span><span class=\"p\">&gt;</span>DEMO<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .parent {\n      position:relative;\n  }\n  .child {\n      position:absolute;\n      top:50%;\n      transform:translateY(-50%);\n  }</code></pre></div><blockquote>同水平居中时的 absolute + transform 原理。<br/>居中元素不会对其他的产生影响<br/>transform 兼容性问题</blockquote><h2><b>4.3 flex + align-items</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;parent&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;child</span><span class=\"p\">&gt;</span>DEMO<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .parent {\n      position:flex;\n      align-items:center;\n  }</code></pre></div><h2><b>flex 赛高~不考虑兼容性，无脑用就是了。</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5 - 等高布局</b></h2><blockquote>子元素在父元素中高度相等的布局方式</blockquote><h2><b>5.1 正 padding + 负 margin</b></h2><blockquote>用等高布局解决上面圣杯布局的第二缺点：<br/>因为<b>背景</b>是在 <code>padding</code> 区域显示的，设置一个大数值的 <code>padding-bottom</code>，再设置相同数值的负的 <code>margin-bottom</code>，并在所有列外面加上一个容器，并设置 <code>overflow: hidden</code> 把溢出背景切掉。</blockquote><div class=\"highlight\"><pre><code class=\"language-css\">        <span class=\"p\">.</span><span class=\"nc\">center</span><span class=\"o\">,</span>\n        <span class=\"p\">.</span><span class=\"nc\">left</span><span class=\"o\">,</span>\n        <span class=\"p\">.</span><span class=\"nc\">right</span> <span class=\"p\">{</span>\n          <span class=\"k\">padding-bottom</span><span class=\"p\">:</span> <span class=\"mi\">10000</span><span class=\"kt\">px</span><span class=\"p\">;</span>\n          <span class=\"k\">margin-bottom</span><span class=\"p\">:</span> <span class=\"mi\">-10000</span><span class=\"kt\">px</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"p\">.</span><span class=\"nc\">container</span> <span class=\"p\">{</span>\n          <span class=\"k\">padding-left</span><span class=\"p\">:</span> <span class=\"mi\">220</span><span class=\"kt\">px</span><span class=\"p\">;</span>\n          <span class=\"k\">padding-right</span><span class=\"p\">:</span> <span class=\"mi\">220</span><span class=\"kt\">px</span><span class=\"p\">;</span>\n          <span class=\"k\">overflow</span><span class=\"p\">:</span> <span class=\"kc\">hidden</span><span class=\"p\">;</span><span class=\"err\">//把溢出背景切掉</span>\n        <span class=\"p\">}</span></code></pre></div><h2><b>5.2 背景图片</b></h2><blockquote>实现等高列最早使用的一种方法，在父容器上使用背景图进行 Y 轴的重复平铺，从而实现等高列的假象。实现方法简单，兼容性强，不需要太多的 CSS 样式，但是此方法不适合刘布局等高列的布局。</blockquote><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">”container</span> <span class=\"na\">clearfix</span><span class=\"err\">”</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">”left”</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span>  <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">”content”</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">”right”</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .container {\n    background: url(&#34;column.png&#34;) repeat-y;\n    width: 960px;\n    margin: 0 auto;\n  }\n  .left {\n    float: left;\n    width: 220px;\n  }\n  .content {\n    float: left;\n    width: 480px;\n  }\n  .right {\n    float: left;\n    width: 220px;\n  }</code></pre></div><h2><b>5.3 表格布局</b></h2><blockquote>这是一种非常简单，易于实现的方法。不过兼容性不好，在 IE 6-7 无法正常运行（又是辣鸡 IE 的问题）</blockquote><div class=\"highlight\"><pre><code class=\"language-html\">     <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;container table&#34;</span><span class=\"p\">&gt;</span>\n        <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;containerInner tableRow&#34;</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;column tableCell cell1&#34;</span><span class=\"p\">&gt;</span>\n            <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;left aside&#34;</span><span class=\"p\">&gt;</span>\n              ....\n            <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;column tableCell cell2&#34;</span><span class=\"p\">&gt;</span>\n            <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;content section&#34;</span><span class=\"p\">&gt;</span>\n              ...\n            <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;column tableCell cell3&#34;</span><span class=\"p\">&gt;</span>\n            <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;right aside&#34;</span><span class=\"p\">&gt;</span>\n              ...\n            <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n          <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n        <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  .table {\n    width: auto;\n    min-width: 1000px;\n    margin: 0 auto;\n    padding: 0;\n    display: table;\n  }\n  .tableRow {\n    display: table-row;\n  }\n  .tableCell {\n    display: table-cell;\n    width: 33%;\n  }\n  .cell1 {\n    background: #f00;\n    height: 800px;\n  }\n  .cell2 {\n    background: #0f0;\n  }\n  .cell3 {\n    background: #00f;\n  }</code></pre></div><h2><b>5.4 利用边框和定位</b></h2><blockquote>使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。</blockquote><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">&#34;wrapper&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">&#34;mainContent&#34;</span><span class=\"p\">&gt;</span>...<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">&#34;sidebar&#34;</span><span class=\"p\">&gt;</span>...<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  #wrapper {\n    width: 960px;\n    margin: 0 auto;\n  }\n  #mainContent {\n    border-right: 220px solid #dfdfdf;\n    position: absolute;\n    width: 740px;\n    height: 800px;  \n    background: green;\n  }\n  #sidebar {\n    background: #dfdfdf;\n    margin-left: 740px;\n    position: absolute;\n    height: 800px;\n    width: 220px;\n  }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>6 - 粘连布局</b></h2><h2><b>介绍</b></h2><ul><li>高度足够时，会显示屏幕在底部</li><li>高度不够时，跟在内容下方，不显示</li></ul><div class=\"highlight\"><pre><code class=\"language-html\">      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">&#34;wrap&#34;</span><span class=\"p\">&gt;</span>\n        <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;main&#34;</span><span class=\"p\">&gt;</span>\n          main <span class=\"p\">&lt;</span><span class=\"nt\">br</span> <span class=\"p\">/&gt;</span>\n          main <span class=\"p\">&lt;</span><span class=\"nt\">br</span> <span class=\"p\">/&gt;</span>\n          main <span class=\"p\">&lt;</span><span class=\"nt\">br</span> <span class=\"p\">/&gt;</span>\n        <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">&#34;footer&#34;</span><span class=\"p\">&gt;</span>footer<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n     * {\n          margin: 0;\n          padding: 0;\n        }\n        html,\n        body {\n          height: 100%;//高度一层层继承下来\n        }\n        #wrap {\n          min-height: 100%;\n          background: pink;\n          text-align: center;\n          overflow: hidden;\n        }\n        #wrap .main {\n          padding-bottom: 50px;\n        }\n        #footer {\n          height: 50px;\n          line-height: 50px;\n          background: deeppink;\n          text-align: center;\n          margin-top: -50px;\n        }\n  ​</code></pre></div><h2><b>原理</b></h2><ul><li><code>footer</code> 需要是一个独立结构，与 <code>wrap</code> 没有任何嵌套关系</li><li><code>wrap</code> 区域高度通过设置 <code>min-height</code>，变为窗口高度</li><li><code>footer</code> 要使用负 <code>margin</code> 确定自己的位置</li><li><code>main</code> 区域要设置和 <code>-margin</code> 对应的 <code>padding-bottom</code>，防止盖掉 <code>footer</code></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>小技巧~集合</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用CSS复位</b></h2><p>CSS复位可以在不同的浏览器上保持一致的样式风格。您可以使用CSS reset 库<a href=\"https://link.zhihu.com/?target=http%3A//necolas.github.io/normalize.css/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Normalize</a>等，也可以使用一个更简化的复位方法：</p><div class=\"highlight\"><pre><code class=\"language-text\">  *,\n  *::before,\n  *::after {\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n  }</code></pre></div><p>现在元素的 margin 和 padding 已为0，<code>box-sizing</code>可以管理您的CSS盒模型布局。</p><blockquote>注意：如果你遵循接下来href=&#34;<a href=\"https://link.zhihu.com/?target=https%3A//github.com/AllThingsSmitty/css-protips/tree/master/translations/zh-CN%23inherit-box-sizing\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/AllThingsSmi</span><span class=\"invisible\">tty/css-protips/tree/master/translations/zh-CN#inherit-box-sizing</span><span class=\"ellipsis\"></span></a>&#34;&gt;继承 box-sizing讲解的这个技巧, 你不需要在以上代码中添加 <code>box-sizing</code> 属性。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>继承 <code>box-sizing</code></b></h2><p>从 <code>html</code> 元素继承 <code>box-sizing</code> ：</p><div class=\"highlight\"><pre><code class=\"language-text\">  html {\n    box-sizing: border-box;\n  }\n  ​\n  *,\n  *::before,\n  *::after {\n    box-sizing: inherit;\n  }</code></pre></div><blockquote>如此在插件或其它组件里改变 <code>box-sizing</code> 变得简单。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用<code>unset</code>而不是重置所有属性</b></h2><p>重置元素的属性时，不需要重置每个单独的属性：</p><div class=\"highlight\"><pre><code class=\"language-text\">  button {\n    background: none;\n    border: none;\n    color: inherit;\n    font: inherit;\n    outline: none;\n    padding: 0;\n  }</code></pre></div><p>你可以用<code>all</code>简写來指定所有元素的属性。 将该值设置为<code>unset</code>会将元素的属性更改为其初始值：</p><div class=\"highlight\"><pre><code class=\"language-text\">  button {\n    all: unset;\n  }</code></pre></div><blockquote><b>注意：</b> 所有速记在IE11中不被支持，目前正在考虑Edge的支持。 IE11不支持<code>unset</code>。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用 <code>:not()</code> 选择器来决定表单是否显示边框</b></h2><p>先为元素添加边框</p><div class=\"highlight\"><pre><code class=\"language-text\">  /* 添加边框 */\n  .nav li {\n    border-right: 1px solid #666;\n  }</code></pre></div><p>为最后一个元素去除边框</p><div class=\"highlight\"><pre><code class=\"language-text\">  /* 去掉边框 */\n  .nav li:last-child {\n    border-right: none;\n  }</code></pre></div><p>不过不要这么做，使用 <code>:not()</code> 伪类来达到同样的效果：</p><div class=\"highlight\"><pre><code class=\"language-text\">  .nav li:not(:last-child) {\n    border-right: 1px solid #666;\n  }</code></pre></div><blockquote>当然，你也可以使用 <code>.nav li + li</code>，但是 <code>:not()</code> 更加清晰，具有可读性。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>为 <code>body</code> 元素添加行高</b></h2><p>不必为每一个 <code>&lt;p&gt;</code>，<code>&lt;h*&gt;</code> 元素逐一添加 <code>line-height</code>，直接添加到 <code>body</code> 元素：</p><div class=\"highlight\"><pre><code class=\"language-text\">  body {\n    line-height: 1.5;\n  }</code></pre></div><blockquote>文本元素可以很容易地继承 <code>body</code> 的样式。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>为表单元素设置 <code>:focus</code></b></h2><p>依靠焦点确定键盘事件在页面中的位置，突出表单元素焦点，与浏览器默认实现保持一致。</p><div class=\"highlight\"><pre><code class=\"language-text\">  a:focus,\n  button:focus,\n  input:focus,\n  select:focus,\n  textarea:focus {\n    box-shadow: none;\n    outline: #000 dotted 2px;\n    outline-offset: .05em;\n  }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>垂直居中任何元素</b></h2><p>可以垂直居中任何元素：</p><div class=\"highlight\"><pre><code class=\"language-text\">html,\nbody {\n  height: 100%;\n  margin: 0;\n}\n\nbody {\n  -webkit-align-items: center;  \n  -ms-flex-align: center;  \n  align-items: center;\n  display: -webkit-flex;\n  display: flex;\n}\n</code></pre></div><p>...还有CSS Grid:</p><div class=\"highlight\"><pre><code class=\"language-text\">  body {\n    display: grid;\n    height: 100vh;\n    margin: 0;\n    place-items: center center;\n  }</code></pre></div><p>这还不够？垂直方向，水平方向？任何元素，任何时间，任何地点？CSS-Tricks <a href=\"https://link.zhihu.com/?target=https%3A//css-tricks.com/centering-css-complete-guide/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">有篇好文</a> 讲到了各种居中的技巧。</p><blockquote><b>注意：</b> IE11 对 flexbox 的支持<a href=\"https://link.zhihu.com/?target=https%3A//github.com/philipwalton/flexbugs%233-min-height-on-a-flex-container-wont-apply-to-its-flex-items\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">有点 bug</a>。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>逗号分隔列表</b></h2><p>使列表的每项都由逗号分隔：</p><div class=\"highlight\"><pre><code class=\"language-text\">  ul &gt; li:not(:last-child)::after {\n    content: &#34;,&#34;;\n  }</code></pre></div><p>因最后一项不加逗号，可以使用 <code>:not()</code> 伪类。</p><blockquote><b>注意：</b> 这一技巧对于无障碍，特别是屏幕阅读器而言并不理想。而且复制粘贴并不会带走CSS生成的内容,需要注意。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用负的 <code>nth-child</code> 来选择元素</b></h2><p>使用负的 <code>nth-child</code> 可以选择 1 至 n 个元素。</p><div class=\"highlight\"><pre><code class=\"language-text\">  li {\n    display: none;\n  }\n  ​\n  /* 选择第 1 至第 3 个元素并显示出来 */\n  li:nth-child(-n+3) {\n    display: block;\n  }</code></pre></div><p>或许你已经掌握了ef=&#34;<a href=\"https://link.zhihu.com/?target=https%3A//github.com/AllThingsSmitty/css-protips/tree/master/translations/zh-CN%23use-not-to-applyunapply-borders-on-navigation\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/AllThingsSmi</span><span class=\"invisible\">tty/css-protips/tree/master/translations/zh-CN#use-not-to-applyunapply-borders-on-navigation</span><span class=\"ellipsis\"></span></a>&#34;&gt;如何使用 :not()这个技巧，试下这个：</p><div class=\"highlight\"><pre><code class=\"language-text\">  /* 选择除前3个之外的所有项目，并显示它们 */\n  li:not(:nth-child(-n+3)) {\n    display: none;\n  }</code></pre></div><blockquote>如此简单！妈妈再也不用担心......</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用 SVG 图标</b></h2><p>没有理由不使用 SVG 图标：</p><div class=\"highlight\"><pre><code class=\"language-text\">  .logo {\n    background: url(&#34;logo.svg&#34;);\n  }</code></pre></div><p>SVG 在所有分辨率下都可以良好缩放，并且支持所有 IE9 以后的浏览器，丢掉你的 .png, .jpg, 或 .gif-jif-whatev 文件吧。</p><p><b>注意：</b> 针对仅有图标的按钮，如果 SVG 没有加载成功的话，以下样式对无障碍有所帮助：</p><div class=\"highlight\"><pre><code class=\"language-text\">  .no-svg .icon-only::after {\n    content: attr(aria-label);\n  }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用 “形似猫头鹰” 的选择器</b></h2><p>这个名字可能比较陌生，不过通用选择器 (<code>*</code>) 和 相邻兄弟选择器 (<code>+</code>) 一起使用，效果非凡：</p><div class=\"highlight\"><pre><code class=\"language-text\">  * + * {\n    margin-top: 1.5em;\n  }</code></pre></div><p>在此示例中，文档流中的所有的相邻兄弟元素将都将设置 <code>margin-top: 1.5em</code> 的样式。</p><p>更多 “形似猫头鹰” 的选择器，可参考 <i>A List Apart</i> 上面 <a href=\"https://link.zhihu.com/?target=http%3A//alistapart.com/article/axiomatic-css-and-lobotomized-owls\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Heydon Pickering 的文章</a></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用 <code>max-height</code> 来建立纯 CSS 的滑块</b></h2><p><code>max-height</code> 与 overflow hidden 一起来建立纯 CSS 的滑块：</p><div class=\"highlight\"><pre><code class=\"language-text\">  .slider {\n    max-height: 200px;\n    overflow-y: hidden;\n    width: 300px;\n  }\n  ​\n  .slider:hover {\n    max-height: 600px;\n    overflow-y: scroll;\n  }</code></pre></div><p>鼠标移入滑块元素时增大它的 <code>max-height</code> 值，便可以显示溢出部分。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>创造格子等宽的表格</b></h2><p><code>table-layout: fixed</code> 可以让每个格子保持等宽：</p><div class=\"highlight\"><pre><code class=\"language-text\">  .calendar {\n    table-layout: fixed;\n  }</code></pre></div><p>无痛的 table 布局。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>利用 Flexbox 去除多余的外边距</b></h2><p>与其使用 <code>nth-</code>， <code>first-</code>， 和 <code>last-child</code> 去除列之间多余的间隙，不如使用 flexbox 的 <code>space-between</code> 属性：</p><div class=\"highlight\"><pre><code class=\"language-text\">  .list {\n    display: flex;\n    justify-content: space-between;\n  }\n  ​\n  .list .person {\n    flex-basis: 23%;\n  }</code></pre></div><p>列之间的间隙总是均匀相等。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>利用属性选择器来选择空链接</b></h2><p>当 <code>&lt;a&gt;</code> 元素没有文本内容，但有 <code>href</code> 属性的时候，显示它的 <code>href</code> 属性：</p><div class=\"highlight\"><pre><code class=\"language-text\">  a[href^=&#34;http&#34;]:empty::before {\n    content: attr(href);\n  }</code></pre></div><p>相当简便。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>给 “默认” 链接定义样式</b></h2><p>给 “默认” 链接定义样式：</p><div class=\"highlight\"><pre><code class=\"language-text\">  a[href]:not([class]) {\n    color: #008000;\n    text-decoration: underline;\n  }</code></pre></div><p>通过 CMS 系统插入的链接，通常没有 <code>class</code> 属性，以上样式可以甄别它们，而且不会影响其它样式。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>一致垂直节奏</b></h2><p>通用选择器 (<code>*</code>) 跟元素一起使用，可以保持一致的垂直节奏：</p><div class=\"highlight\"><pre><code class=\"language-text\">  .intro &gt; * {\n    margin-bottom: 1.25rem;\n  }</code></pre></div><p>一致的垂直节奏可以提供视觉美感，增强内容的可读性。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>固定比例盒子</b></h2><p>要创建具有固定比例的一个盒子，所有你需要做的就是给 div 设置一个 padding：</p><div class=\"highlight\"><pre><code class=\"language-text\">  .container {\n    height: 0;\n    padding-bottom: 20%;\n    position: relative;\n  }\n  ​\n  .container div {\n    border: 2px dashed #ddd;  \n    height: 100%;\n    left: 0;\n    position: absolute;\n    top: 0;\n    width: 100%;\n  }</code></pre></div><p>使用20％的padding-bottom使得框等于其宽度的20％的高度。与视口宽度无关，子元素的div将保持其宽高比（100％/ 20％= 5:1）。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>为破碎图象定义样式</b></h2><p>只要一点CSS就可以美化破碎的图象：</p><div class=\"highlight\"><pre><code class=\"language-text\">  img {  \n    display: block;\n    font-family: sans-serif;\n    font-weight: 300;\n    height: auto;\n    line-height: 2;\n    position: relative;\n    text-align: center;\n    width: 100%;\n  }</code></pre></div><p>以添加伪元素的法则来显示用户信息和URL的引用：</p><div class=\"highlight\"><pre><code class=\"language-text\">  img::before {  \n    content: &#34;We&#39;re sorry, the image below is broken :(&#34;;\n    display: block;\n    margin-bottom: 10px;\n  }\n  ​\n  img::after {  \n    content: &#34;(url: &#34; attr(src) &#34;)&#34;;\n    display: block;\n    font-size: 12px;\n  }</code></pre></div><p>了解更多关于这类样式的技巧 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/ireade/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Ire Aderinokun</a>的 <a href=\"https://link.zhihu.com/?target=http%3A//bitsofco.de/styling-broken-images/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">原帖</a>.</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>用 <code>rem</code> 来调整全局大小；用 <code>em</code> 来调整局部大小</b></h2><p>在根元素设置基本字体大小后 (<code>html { font-size: 100%; }</code>), 使用 <code>em</code> 设置文本元素的字体大小:</p><div class=\"highlight\"><pre><code class=\"language-text\">  h2 { \n    font-size: 2em;\n  }\n  ​\n  p {\n    font-size: 1em;\n  }</code></pre></div><p>然后设置模块的字体大小为 <code>rem</code>:</p><div class=\"highlight\"><pre><code class=\"language-text\">  article {\n    font-size: 1.25rem;\n  }\n  ​\n  aside .module {\n    font-size: .9rem;\n  }</code></pre></div><p>现在，每个模块变得独立，更容易、灵活的样式便于维护。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>隐藏没有静音、自动播放的影片</b></h2><p>这是一个自定义用户样式表的不错的技巧。避免在加载页面时自动播放。如果没有静音，则不显示视频：</p><div class=\"highlight\"><pre><code class=\"language-text\">  video[autoplay]:not([muted]) {\n    display: none;\n  }</code></pre></div><p>再次，我们利用了 <code><a href=\"https://link.zhihu.com/?target=https%3A//github.com/AllThingsSmitty/css-protips/tree/master/translations/zh-CN%23use-not-to-applyunapply-borders-on-navigation\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">:not()</a></code> 的优点。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用选择器<code>:root</code>来控制字体弹性</b></h2><p>在响应式布局中，字体大小应需要根据不同的视口进行调整。你可以计算字体大小根据视口高度的字体大小和宽度，这时需要用到<code>:root</code>:</p><div class=\"highlight\"><pre><code class=\"language-text\">  :root {\n    font-size: calc(1vw + 1vh + .5vmin);\n  }</code></pre></div><p>现在，您可以使用 <code>root em</code></p><div class=\"highlight\"><pre><code class=\"language-text\">  body {\n    font: 1rem/1.6 sans-serif;\n  }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>为更好的移动体验，为表单元素设置字体大小</b></h2><p>当触发<code>&lt;select&gt;</code>的下拉列表时，为了避免表单元素在移动浏览器（IOS Safari 等等）上的缩放，加上<code>font-size</code>：</p><div class=\"highlight\"><pre><code class=\"language-text\">  input[type=&#34;text&#34;],\n  input[type=&#34;number&#34;],\n  select,\n  textarea {\n    font-size: 16px;\n  }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用指针事件來控制鼠标事件</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">指针事件</a>允許您指定鼠标如何与其触摸的元素进行交互。 要禁用按钮上的默认指针事件，例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">  .button-disabled {\n    opacity: .5;\n    pointer-events: none;\n  }</code></pre></div><p>就这么简单。</p>", 
            "topic": [
                {
                    "tag": "CSS", 
                    "tagLink": "https://api.zhihu.com/topics/19551326"
                }, 
                {
                    "tag": "CSS 布局", 
                    "tagLink": "https://api.zhihu.com/topics/19620819"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": [
                {
                    "userName": "minemine", 
                    "userLink": "https://www.zhihu.com/people/5257685ee9d553a0feb9b776e86d5c06", 
                    "content": "很到位，学习", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57712910", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 56, 
            "title": "如何管理好你的 CSS", 
            "content": "<blockquote>当我们开始编写前端页面的时候，是不是都经历过 css 命名不规范，导致自己修改页面样式时，需要通过开发者工具查找自己的类名，然后再进行修改的情况呢？</blockquote><p>众所周知，CSS 是一门不正交、属性多、调试方便的语言，而正是因为它的功能众多，使得我们在使用 CSS 实现各种各样页面效果的时候，很容易控制不好 CSS 的代码结构。它不像其它逻辑性强的语言，有很多管理代码的方式，我们能管理 CSS 的方式只有两种：文件引用、命名。而由于我们经常会把页面样式文件合并（减少 HTTP 请求），所以我们用来管理 CSS 的方式就只剩下命名。</p><h2><b>解决好命名问题，就能管理好我们的 CSS</b></h2><p>下面分别来简单了解一下管理 CSS我觉得 比较有效的两种方式：</p><ul><li><b>BEM</b>：CSS 命名规范</li><li><b>ACSS</b>：原子化使用 CSS</li></ul><h2><b>目录</b></h2><p>B.E.M</p><p>  1 - B.E.M 介绍</p><p>         1.1 BEM 是什么？</p><p>         1.2 命名规范</p><p>         1.3 BEM 优点</p><p>  2 - BEM 使用场景</p><p>          2.1 什么场景适合 BEM</p><p>          2.2 预处理语言 + BEM</p><p>          2.3 前端框架 + BEM</p><p>                   scoped 实现原理</p><p>                   慎用 scoped</p><p>                   BEM 在框架中存在的意义</p><p>  3 - 例子</p><p>  4 - 使用其思想</p><p>ACSS</p><p>  1 - 引入</p><p>  2 - 原子化</p><p>  3 - 相较于 BEM 的一些优势</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>B.E.M</b></h2><blockquote>经典的 CSS 命名规范</blockquote><h2><b>1 - B.E.M 介绍</b></h2><h2><b>1.1 BEM 是什么？</b></h2><p>BEM 其实就是块（block）、元素（element）、修饰符（modifier）的缩写，由 Yandex 团队提出的一种前端 CSS 命名方法。利用不同的区块、功能以及样式给元素命名。</p><ul><li><code>-</code> 中划线：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。</li><li><code>__</code> 双下划线：双下划线用来连接块和块的子元素</li><li><code>_</code> 单下划线：单下划线用来描述一个块或者块的子元素的一种状态</li></ul><blockquote>BEM 使用这种命名规范使得你的代码更加易读，让代码更加严密，从而有助于协作、控制和维护。</blockquote><h2><b>1.2 命名规范</b></h2><p>BEM 命名约定的模式如下：</p><div class=\"highlight\"><pre><code class=\"language-css\">  <span class=\"p\">.</span><span class=\"nc\">block</span> <span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">block__element</span> <span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">block--modifier</span> <span class=\"p\">{}</span></code></pre></div><p>每一个 Block 名应该有一个命名空间（前缀）</p><ul><li><code>block</code> 代表了更高级别的抽象或组件</li><li><code>block__element</code> 代表 <code>block</code> 的后代，用于形成一个完整的 <code>block</code> 的整体</li><li><code>block--modifier</code>代表 <code>block</code> 的不同状态或不同版本</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8ab988caef4bd9a32a149327bbd3758a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"615\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb\" width=\"615\" data-original=\"https://pic3.zhimg.com/v2-8ab988caef4bd9a32a149327bbd3758a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;615&#39; height=&#39;376&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"615\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"615\" data-original=\"https://pic3.zhimg.com/v2-8ab988caef4bd9a32a149327bbd3758a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8ab988caef4bd9a32a149327bbd3758a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>使用两个连字符而不是一个，是为了给块用单个连字符进行自定义：</p><div class=\"highlight\"><pre><code class=\"language-css\">  <span class=\"p\">.</span><span class=\"nc\">nav-block__element</span> <span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">side-block--modifier</span> <span class=\"p\">{}</span></code></pre></div><h2><b>1.3 BEM 优点</b></h2><p>获得更多的描述和更加清晰的代码结构，从命名中就能得知这个标记的意思、类属性、元素之间的关联。</p><h2><b>一般的 CSS 命名：</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;student&#34;</span><span class=\"p\">&gt;</span>\n    <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;content&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">button</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;button-primary&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">button</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">button</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;button-success&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">button</span><span class=\"p\">&gt;</span>\n    <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span></code></pre></div><blockquote>用这种写法也许我们能通过父容器猜到大致意思，但是首先你需要了解它的代码结构，也就是时候你需要审查页面元素才能确定某一元素的属性、功能、关系，光从命名中是没法确定的。而且，在纯 CSS 代码中，需要通过层级约束其作用域，避免和其他组件元素冲突。</blockquote><h2><b>BEM 命名方法：</b></h2><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;student&#34;</span><span class=\"p\">&gt;</span>\n    <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;student__content&#34;</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">button</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;student__contentv--primary&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">button</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;</span><span class=\"nt\">button</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;student__content--success&#34;</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">button</span><span class=\"p\">&gt;</span>\n    <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span></code></pre></div><blockquote>通过 BEM 改进之后，元素之间的关系更加清晰了，而且在 CSS 文件中也不必作过多考虑层级约束，直接使用名称即可。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2 - BEM 使用场景</b></h2><h2><b>2.1 什么场景适合 BEM</b></h2><ul><li>有比较明确的层级关系和组件关联的时候，需要使用 BEM。</li><li>单条公共样式，不需要使用 BEM：<br/> .theme-red {color: red;}</li></ul><h2><b>2.2 预处理语言 + BEM</b></h2><p>BEM 有利也有弊，最明显的就是命名看起来很长，但是相较于其优点，不值一提。</p><p>和 CSS 的预处理语言相结合，能使得你的 CSS 代码书写更快：</p><div class=\"highlight\"><pre><code class=\"language-css\">  <span class=\"p\">.</span><span class=\"nc\">student</span>\n    <span class=\"nt\">max-width</span> <span class=\"nt\">1000px</span>\n    <span class=\"o\">&amp;</span><span class=\"nt\">__body</span>\n      <span class=\"nt\">padding</span> <span class=\"nt\">20px</span>\n    <span class=\"o\">&amp;</span><span class=\"nt\">__button</span>\n      <span class=\"nt\">padding</span> <span class=\"nt\">5px</span> <span class=\"nt\">8px</span>\n      <span class=\"o\">&amp;</span><span class=\"nt\">--primary</span> \n        <span class=\"nt\">background</span> <span class=\"nt\">blue</span>\n      <span class=\"o\">&amp;</span><span class=\"nt\">--success</span> \n        <span class=\"nt\">background</span> <span class=\"nt\">green</span></code></pre></div><blockquote>CSS 预处理语言：LESS、SASS、Stylus，具体介绍到各个官网查看，本文不做介绍。</blockquote><h2><b>2.3 前端框架 + BEM</b></h2><p>我们知道在 Vue / React / Angular 等前端框架中，都有 CSS 作用域限制。我们以 Vue 的 <code>scoped</code> 为例，在组件样式区域中添加 <code>scoped</code> ，会让样式作用域限定在当前作用域中，但是在 Vue 中，慎用 <code>scoped</code>。</p><h2><b><code>scoped</code> 实现原理</b></h2><p>通过观察DOM结构可以发现：vue通过在DOM结构以及css样式上加上唯一的标记，保证唯一，达到样式私有化，不污染全局的作用，如图，样式属性上也会多一个该字符，以保证唯一：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ccd873773329db98502913e04434257e_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"467\" data-rawheight=\"65\" class=\"origin_image zh-lightbox-thumb\" width=\"467\" data-original=\"https://pic3.zhimg.com/v2-ccd873773329db98502913e04434257e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;467&#39; height=&#39;65&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"467\" data-rawheight=\"65\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"467\" data-original=\"https://pic3.zhimg.com/v2-ccd873773329db98502913e04434257e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ccd873773329db98502913e04434257e_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>添加了 <code>scoped</code> 属性，为了达到不污染全局，做了如下处理：</p><ul><li>给 HTML DOM 节点添加不重复的唯一标志</li><li>在 <code>scoped</code> 组件每个样式选择器后添加标志字段，实现类似于命名空间的功能</li><li>对组件内部的组件，给最外层组件中的标签加上标志字段，不会影响内部引用</li></ul><h2><b>为什么慎用</b></h2><ul><li>父组件无 <code>scoped</code> ，子组件有 <code>scoped</code>：<br/>父组件无法操作子组件的样式，虽然能在全局中设置，但是会影响到别的组件</li><li>父组件有 <code>scoped</code> ，子组件无 <code>scoped</code>：<br/>父组件无法操作子组件的样式，因为父组件有标志字段，子组件没有</li><li>父组件有 <code>scoped</code> ，子组件有 <code>scoped</code>：<br/>同样无法设置。</li></ul><blockquote>当然我们知道 <code>scoped</code> 设计的初衷就是不能让当前组件的样式修改其他任何地方的样式，一个组件的样式是建议写死的，但是我们总会有改样式的时候不是嘛，所以即使是在框架中，BEM 依然大有用处。</blockquote><h2><b>BEM 在框架中存在的意义</b></h2><ul><li>当选择了局部作用域的写法时，在较小的组件中，BEM 格式可能显得没那么重要。但对于<b>公共的、全局性的</b>模块样式定义，依然推荐使用 BEM 格式。</li><li>对于对外发布的公共组件来说，一般为了风格的可定制性，都不会使用这种局部作用域方式来定义组件样式。这也是 BEM 的使用场景之一。</li></ul><p>### </p><blockquote>注意：深层次嵌套的 DOM 中，避免过长的样式命名，层级组好不要超 4 层。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3 - 例子</b></h2><div class=\"highlight\"><pre><code class=\"language-css\">  <span class=\"p\">.</span><span class=\"nc\">xxx</span><span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx__item</span><span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx__item_current</span><span class=\"p\">{}</span>\n  <span class=\"err\">​</span>\n  <span class=\"o\">//</span> <span class=\"nt\">嵌套写法</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx__item_current</span> <span class=\"p\">.</span><span class=\"nc\">mod-xxx__link</span><span class=\"p\">{}</span>\n  <span class=\"nt\">推荐</span><span class=\"err\">：</span>\n  <span class=\"err\">​</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx</span><span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx__item</span><span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx__item_hightlight</span><span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx__product-name</span><span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx__link</span><span class=\"p\">{}</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx__ming-zi-ke-yi-hen-chang</span><span class=\"p\">{}</span>\n  <span class=\"err\">​</span>\n  <span class=\"o\">//</span> <span class=\"nt\">嵌套写法</span>\n  <span class=\"p\">.</span><span class=\"nc\">xxx__item_current</span><span class=\"p\">{</span>\n      <span class=\"err\">.xxx__link{</span><span class=\"p\">}</span>\n  <span class=\"err\">}</span>\n  <span class=\"err\">​</span>\n  <span class=\"o\">//</span><span class=\"nt\">对应的HTML结构如下</span><span class=\"err\">：</span>\n  <span class=\"o\">&lt;</span><span class=\"nt\">ul</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx&#34;</span><span class=\"o\">&gt;</span>\n      <span class=\"o\">&lt;</span><span class=\"nt\">li</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__item&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">第一项</span>\n          <span class=\"o\">&lt;</span><span class=\"nt\">div</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__product-name&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">我是名称</span><span class=\"o\">&lt;/</span><span class=\"nt\">div</span><span class=\"o\">&gt;</span>\n          <span class=\"o\">&lt;</span><span class=\"nt\">span</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__ming-zi-ke-yi-hen-chang&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">看类名</span><span class=\"o\">&lt;/</span><span class=\"nt\">span</span><span class=\"o\">&gt;</span>\n          <span class=\"o\">&lt;</span><span class=\"nt\">a</span> <span class=\"nt\">href</span><span class=\"o\">=</span><span class=\"s2\">&#34;#&#34;</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__link&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">我是link</span><span class=\"o\">&lt;/</span><span class=\"nt\">a</span><span class=\"o\">&gt;</span>\n      <span class=\"o\">&lt;</span><span class=\"nt\">li</span><span class=\"o\">&gt;</span>\n      <span class=\"o\">&lt;</span><span class=\"nt\">li</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__item xxx__item_current&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">第二项</span> <span class=\"nt\">且</span> <span class=\"nt\">当前选择项</span>\n          <span class=\"o\">&lt;</span><span class=\"nt\">div</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__product-name&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">我是名称</span><span class=\"o\">&lt;/</span><span class=\"nt\">div</span><span class=\"o\">&gt;</span>\n          <span class=\"o\">&lt;</span><span class=\"nt\">a</span> <span class=\"nt\">href</span><span class=\"o\">=</span><span class=\"s2\">&#34;#&#34;</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__item-link&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">我是link</span><span class=\"o\">&lt;/</span><span class=\"nt\">a</span><span class=\"o\">&gt;</span>\n      <span class=\"o\">&lt;</span><span class=\"nt\">li</span><span class=\"o\">&gt;</span>\n      <span class=\"o\">&lt;</span><span class=\"nt\">li</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__item xxx__item_hightlight&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">第三项</span> <span class=\"nt\">且</span> <span class=\"nt\">特殊高亮</span>\n           <span class=\"o\">&lt;</span><span class=\"nt\">div</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__product-name&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">我是名称</span><span class=\"o\">&lt;/</span><span class=\"nt\">div</span><span class=\"o\">&gt;</span>\n          <span class=\"o\">&lt;</span><span class=\"nt\">a</span> <span class=\"nt\">href</span><span class=\"o\">=</span><span class=\"s2\">&#34;#&#34;</span> <span class=\"nt\">class</span><span class=\"o\">=</span><span class=\"s2\">&#34;xxx__item-link&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">我是link</span><span class=\"o\">&lt;/</span><span class=\"nt\">a</span><span class=\"o\">&gt;</span>\n      <span class=\"o\">&lt;</span><span class=\"nt\">li</span><span class=\"o\">&gt;</span>\n  <span class=\"o\">&lt;/</span><span class=\"nt\">ul</span><span class=\"o\">&gt;</span>\n  <span class=\"err\">​</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4 - 使用其思想</b></h2><p>当然，不是说一定要百分百像素级遵守 BEM 的规范，比如状态我们可以这样写：</p><div class=\"highlight\"><pre><code class=\"language-css\">  <span class=\"p\">.</span><span class=\"nc\">blockName-elName</span><span class=\"p\">.</span><span class=\"nc\">modifier</span> <span class=\"p\">{}</span></code></pre></div><p>这样可能符合一部分不喜欢划线的人哈~具体怎么弄看 Leader 怎么定吧~</p><p>反正万变不离其宗，怎么舒服怎么写就是了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>ACSS</b></h2><blockquote>将样式原子化的思维方式，来自雅虎团队的 <b><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Facss.io%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Atomic CSS</a></b> （简称 ACSS ）。<br/>相较于上面介绍的 BEM，ACSS 没有很严格的格式规范，但是它们解决的问题是一样的，都是希望 CSS 在大型项目下能够拥有更好的重用性与维护性，只是采用的方法与方向不同而已。</blockquote><h2><b>1 - 引入</b></h2><p>一件物品的属性可能是多种多样的，比如一件衬衫：颜色、尺寸、材料、花纹、品牌...我们同样可以将一个页面元素想象成一件衬衫，我们暂定一个完整的衬衫定义如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">  品牌 + 尺寸 + 颜色 +  花纹 + 季节 + 材料 + 样式     衬衫</code></pre></div><p>比如我要拿一件 <b>李宁 L 码 黑色 带Logo 夏季 速干 短袖 衬衫</b>，那么名字是不是写起来特别长？</p><p>但是我有时候又不需要所有的标签都需要带上，我可能只需要一件 <b>XL 码 白色 长袖 衬衫</b>，然后我想给家人买一件 <b>L 码 红色 纯棉 衬衫</b>，这样不太好写一个可复用的 CSS 衬衫样式。</p><blockquote>看到这里聪明的你一定已经大致有了复用样式的思路，没错，就是原子化。</blockquote><h2><b>2 - 原子化</b></h2><p>众所周知 CSS 是一个所见即所得的语言，只要你给他什么样式，它立马就可以显示给你看。那么我就可以直接在页面上通过 <code>inline</code> 的方式写我想要的样式，岂不是很爽？这才是 CSS 所原有的样子。当然它有很多问题，但是我们可以用原子化的思维去解决它。</p><p>我们之所以需要去管理代码，很大部分是为了我们想要去<b>复用代码</b>和<b>团队协作</b>，我个人是因为代码复用和管理结构，才会去想怎么给元素命名。</p><p>那么，如果我们不要思考通过命名管理 CSS，而是将精力放在管理 CSS 的各种属性上，也就是构成我们衬衫的<b>原子</b>上，会不会更好呢？比如我要一件衬衫，什么样子的我不清楚，当需求逐渐清晰的时候，再添加上各种属性：冷了就添加长袖，想舒服点就添加纯棉，骚了就添加夏威夷风，岂不美哉？</p><h2><b>3 - 相较于 bem 的一些优势</b></h2><p>前面的 BEM 思想下，我们可以用类选择器处理命名冲突，但是还是可能造成代码过大，因为你可能会根据不同的组件设置不同的命名空间，很容易使得 CSS 层数过多，于是复杂的页面效果，层级越是容易多。而且几个团队协作的时候，更容易引发问题：</p><div class=\"highlight\"><pre><code class=\"language-css\">  <span class=\"nt\">block1__text_highlight</span> <span class=\"p\">{</span><span class=\"k\">color</span><span class=\"p\">:</span> <span class=\"kc\">yellow</span><span class=\"p\">;}</span>\n  <span class=\"err\">​</span>\n  <span class=\"o\">...</span>\n  <span class=\"err\">​</span>\n  <span class=\"nt\">block2__text_bright</span> <span class=\"p\">{</span><span class=\"k\">color</span><span class=\"p\">:</span> <span class=\"kc\">yellow</span><span class=\"p\">;}</span></code></pre></div><p>显然，这种命名还不是拆分的最小单位，而 ACSS 是不可以拆分并且容易固化的，所以管理的难度会小很多，甚至随着需求的清晰，可以做到代码量的只增不减，并且复用率极高。</p><h2><b>將 CSS style 最小元件化，重用性最大化</b></h2><p>只要确保同一个 <code>style</code> 只会被定义一次，并且可以通用在各个地方，就饿能解决这些问题！</p><p>范例：</p><div class=\"highlight\"><pre><code class=\"language-html\">  <span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">&#34;D(f) W(100px)&#34;</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span></code></pre></div><p>利用 atomic css 的工具，会帮你将上述 html 中的 class name 解析：</p><div class=\"highlight\"><pre><code class=\"language-css\">  <span class=\"p\">.</span><span class=\"nc\">D</span><span class=\"err\">\\</span><span class=\"o\">(</span><span class=\"nt\">f</span><span class=\"err\">\\</span><span class=\"o\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">display</span><span class=\"p\">:</span> <span class=\"kc\">flex</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n  <span class=\"err\">​</span>\n  <span class=\"p\">.</span><span class=\"nc\">W</span><span class=\"err\">\\</span><span class=\"o\">(</span><span class=\"nt\">100px</span><span class=\"err\">\\</span><span class=\"o\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">width</span><span class=\"p\">:</span> <span class=\"mi\">100</span><span class=\"kt\">px</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span></code></pre></div><p>稍微想一下，这其实就是在写 <code>inline</code> 样式，这样的好处就是：</p><blockquote>Define once, use everywhere.</blockquote><p>而且，从此以后只要看一眼组件，就可以直接从 JSX 中看到完整的元件状态，不需要再切换 JS / CSS 文件了</p><h2><b>列举一下优点</b></h2><ul><li>将 class name 定义最小化，让全站都可复用</li><li>通过 atomic css 的打包，只会产生用到的样式</li><li>比起 inline 的方式更加简单，不会冲突</li><li>很好压缩，整体 size 小一点</li></ul><h2><b>当然也有缺点</b></h2><ul><li>写起来丑</li><li>没有语义化</li></ul><blockquote>总的来说，acss 是很值得你去尝试一种方式，熟练了之后哦会极大提高你的编码效率</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>相关阅读</b></h2><ol><li><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.zhangxinxu.com%252Fwordpress%252F2014%252F03%252Fquicklayout-css-%2525E5%2525BF%2525AB%2525E9%252580%25259F%2525E6%25259E%252584%2525E5%2525BB%2525BA%2525E7%2525BB%252593%2525E6%25259E%252584%2525E5%252585%2525BC%2525E5%2525AE%2525B9%2525E7%25259A%252584web%2525E9%2525A1%2525B5%2525E9%25259D%2525A2%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">quickLayout.css-快速构建结构兼容的web页面</a> 张鑫旭 ；</li><li><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjohnpolacek.com%252Frethinking%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「英」在组件化浪潮中重新思考CSS </a> johnpolacek ；</li><li><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5b4063936fb9a04fb016b738\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「CSS思维」组件化VS原子化</a> ziven27 ；</li><li><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Facss.io%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> ACSS 官网 </a> 雅虎 ；</li><li><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.smashingmagazine.com%252F2013%252F10%252Fchallenging-css-best-practices-atomic-approach%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「英」CSS最佳实践探讨 - Atomic CSS</a> smashingmagazine；</li><li><a href=\"https://link.zhihu.com/?target=https%3A//en.bem.info/methodology/quick-start/%23file-structure\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">BEM</a> Yandex</li><li><a href=\"https://link.zhihu.com/?target=http%3A//sj82516-blog.logdown.com/posts/1077348/finish-css-intro-oocss-smacss-bem\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Scalable CSS - 介紹OOCSS/SMACSS/BEM</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fgetbem.com\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">getbem.com</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FTencent%252Ftmt-workflow%252Fwiki%252F%2525E2%252592%25259B-%25255B%2525E8%2525A7%252584%2525E8%25258C%252583%25255D--CSS-BEM-%2525E4%2525B9%2525A6%2525E5%252586%252599%2525E8%2525A7%252584%2525E8%25258C%252583\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">github.com/Tencent/tmt…</a></li></ol><p></p>", 
            "topic": [
                {
                    "tag": "CSS", 
                    "tagLink": "https://api.zhihu.com/topics/19551326"
                }, 
                {
                    "tag": "HTML+CSS", 
                    "tagLink": "https://api.zhihu.com/topics/19603480"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "绅士喵", 
                    "userLink": "https://www.zhihu.com/people/7eb8dd6d1e665c9b53832a0d8ab3a4c2", 
                    "content": "<p>额，无意间看到了。首先支持你开技术专栏 我恰好也是同行。但是你可以考虑一下把专栏改为《绅士喵呜的技术小屋》吗？毕竟我是绅士喵，你是绅士喵呜……</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "绅士喵呜", 
                            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
                            "content": "<p>好哒，没问题的~握爪</p>", 
                            "likes": 0, 
                            "replyToAuthor": "绅士喵"
                        }
                    ]
                }, 
                {
                    "userName": "DESTINY", 
                    "userLink": "https://www.zhihu.com/people/f9ca8854818f368dcfd207d41641e1c3", 
                    "content": "一直不明白下划线为啥要写俩，谁能解释下", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "绅士喵呜", 
                            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
                            "content": "<p>因为单横线和单下划线都是比较常见的命名方式。嘛，上面只是 BEM 一个示例，不一定要严格按那种格式写的，只要符合分块的思想就好了。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "DESTINY"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57712768", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 7, 
            "title": "HTML 常用标签", 
            "content": "<p><b>1 - 链接</b></p><blockquote>又称超链接，设置页面中允许被点击的内容。</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">  【标签】&lt;a&gt;&lt;/a&gt;\n  【属性】\n  href：链接地址（要跳转到的页面的地址）\n  target：目标，打开新网页的形式\n  取值：\n       _blank：在新标签页中打开\n       _self：在自身页面中打开（默认值）\n  title：鼠标放到链接上的提示\n  &lt;!-- 新窗口打开 --&gt;\n  &lt;a href=&#34;http://www.baidu.com&#34; target=&#34;_blank&#34;&gt;百度&lt;/a&gt;\n  &lt;!-- 旧窗口打开 --&gt;\n  &lt;a href=&#34;http://www.baidu.com&#34; target=&#34;_self&#34;&gt;百度&lt;/a&gt;\n  &lt;!-- 父级窗口打开 --&gt;\n  &lt;a href=&#34;http://www.baidu.com&#34; target=&#34;_parent&#34;&gt;百度&lt;/a&gt;\n  &lt;!-- 顶层窗口打开 --&gt;\n  &lt;a href=&#34;http://www.baidu.com&#34; target=&#34;_top&#34;&gt;百度&lt;/a&gt;\n  ​\n  &lt;a href=&#34;http://www.baidu.com&#34; download&gt;下载&lt;/a&gt;\n  content-type: application/octet-stream 浏览器会以下载的形式响应请求，而不是展示\n  ​\n  &lt;!-- 无协议，自动继承协议 --&gt;\n  &lt;a href=&#34;//www.baidu.com&#34;&gt;下载&lt;/a&gt;\n  ​\n  &lt;!-- 路径 --&gt;\n  &lt;a href=&#34;xxx.html&#34;&gt;下载&lt;/a&gt;\n  ​\n  &lt;!-- 条件查询 --&gt;\n  &lt;a href=&#34;xxxx?name=qqqq&#34;&gt;下载&lt;/a&gt;\n  ​\n  &lt;!-- 路锚点是不发送请求的 --&gt;\n  &lt;a href=&#34;#sss&#34;&gt;下载&lt;/a&gt;\n  ​\n  &lt;!-- 伪协议 --&gt;\n  &lt;a href=&#34;javascript: alert(1);&#34;&gt;下载&lt;/a&gt;\n  &lt;!-- 使用 a 标签但是不跳转 --&gt;\n  &lt;a href=&#34;javascript:;&#34;&gt;下载&lt;/a&gt;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2 - 文本标记</b></h2><ul><li>特殊字符</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  空格： \n  &lt;:  &lt;\n  &gt;:  ≷  \n  ©:  ©\n  ￥: ¥ </code></pre></div><ul><li>文本样式<br/>### </li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  斜体：&lt;i&gt;&lt;/i&gt;\n  粗体：&lt;b&gt;&lt;/b&gt;\n  删除线：&lt;s&gt;&lt;/s&gt;\n  下划线：&lt;u&gt;&lt;/u&gt;\n  上标：&lt;sup&gt;&lt;/sup&gt;\n  下标：&lt;sub&gt;&lt;/sub&gt;</code></pre></div><ul><li>标题元素</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  以标题的形式来显示文本内容\n  &lt;h1&gt;&lt;/h1&gt;\n  &lt;h2&gt;&lt;/h2&gt;\n  &lt;h3&gt;&lt;/h3&gt;\n  &lt;h4&gt;&lt;/h4&gt;\n  &lt;h5&gt;&lt;/h5&gt;\n  &lt;h6&gt;&lt;/h6&gt;\n  【特点】\n  - 改变字号（一级最大，六级最小）\n  - 加粗显示\n  - 上下有垂直的空白距离\n  - 独立成行</code></pre></div><ul><li>段落元素</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  【标签】&lt;p&gt;&lt;/p&gt;\n  【特点】\n  - 默认文字大小\n  - 独立成行\n  - 上下垂直空白</code></pre></div><ul><li>换行元素</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  【标签】&lt;br&gt;</code></pre></div><ul><li>分隔线元素</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  【标签】&lt;hr&gt;\n  【属性】\n          size：尺寸，取值单位为 px（像素），可以省略\n          width：宽度，取值单位为px（像素）可以省略或百分比\n          color：颜色，取值自然颜色值\n          align：水平对齐方式，取值：left/center/right</code></pre></div><ul><li>分区元素</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  （1）块分区元素：&lt;div&gt;&lt;/div&gt;\n  【特点】独立成行\n  【作用】页面布局\n  （2）行内分区元素：&lt;span&gt;&lt;/span&gt;\n  【特点】多个元素在一行内显示\n  【作用】设置同一行文字内的不同格式</code></pre></div><ul><li>行内元素与块级元素</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  （1）块级元素（div 、p、h1~h6）\n  【特点】元素会独占一行，即元素前后都会自动换行，主要用于网页布局\n  （2）、行内元素（ span、i、b、s、u、sub、sup、img、a）\n  【特点】不会换行，多个元素会在一行内显示</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3 - 图像</b></h2><ul><li>路径</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  URL：Uniform Resource Locator（统一资源定位器，俗称：路径） \n  作用：标识网络任何资源的位置\n  ​\n  （1）绝对路径：从文件所在的最高级目录下开始查找资源文件所经过的路径\n  -包括网络资源&amp;本地资源（如：E:\\mmper\\练习\\img\\flower.jpg）\n  （2）相对路径：从当前文件位置处开始，查找资源文件所经过的路径\n  - 同目录，直接用， 直接通过资源文件名称进行引用（a.jpg）\n  - 子目录，进入到子目录中，然后再对资源文件进行引用（img/a.jpg）\n  - 父目录，返回到父级目录再对资源文件进行引用（../a.jpg）</code></pre></div><ul><li>图像</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  【标签】&lt;img&gt;\n  【属性】\n          src：图片地址（绝对/相对）\n          width：图像宽度\n          height：图像高度</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4 - 表格</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">  由&lt;table&gt;元素定义。\n  【标签】&lt;table&gt;&lt;/table&gt;\n  【属性】\n          width ：设置表格的宽度\n          height：设置表格的高度\n          align：设置表格的对齐方式，取值: left/center/right\n          border：设置表格边框宽度\n          cellpadding：内边距（单元格边框与内容之间的距离）\n          cellspacing：外边距（单元格之间的距离）\n          bgcolor：设置表格的背景颜色</code></pre></div><ul><li>table中包含的子元素</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;table&gt;&lt;/table&gt;中包含的子元素：\n  【标签】&lt;tr&gt;&lt;/tr&gt; （创建表行）\n  【属性】\n         align：该行内容水平对齐方式，取值: left/center/right\n         valign：该行内容的垂直对齐方式，取值: top/middle/bottom\n         bgcolor：设置表格的背景颜色\n  ​\n  【标签】&lt;td&gt;&lt;/td&gt; （创建单元格）\n  【属性】\n          align：内容水平对齐方式\n          valign：内容垂直对齐方式\n          width ：宽度\n          height ：高度\n  【标签】&lt;caption&gt;&lt;/caption&gt; （表格标题）\n  【标签】&lt;th&gt;&lt;/th&gt; （列标题）\n          行标题或列标题，字体有加粗的效果，放在tr中\n  【标签】&lt;thead&gt;&lt;/thead&gt; （表头）\n  【标签】&lt;tbody&gt;&lt;/tbody&gt; 表主体）\n  【标签】&lt;tfoot&gt;&lt;/tfoot&gt; （表尾）</code></pre></div><ul><li>一个完整的表格</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;caption&gt;标题文本&lt;/caption&gt;\n  &lt;table&gt;\n     &lt;thead&gt;\n      &lt;tr&gt;\n        &lt;td&gt;姓名&lt;/td&gt;\n         &lt;td&gt;性别&lt;/td&gt;\n      &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n      &lt;tr&gt;\n        &lt;td&gt;张三&lt;/td&gt;\n        &lt;td&gt;男&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr&gt;\n        &lt;td&gt;李四&lt;/td&gt;\n        &lt;td&gt;女&lt;/td&gt;\n      &lt;/tr&gt;\n    &lt;/tbody&gt;\n  &lt;/table&gt;</code></pre></div><ul><li>两行两列的表格</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;table&gt;\n    &lt;tr&gt;\n      &lt;td&gt;&lt;/td&gt;\n      &lt;td&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;&lt;/td&gt;\n      &lt;td&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/table&gt;</code></pre></div><ul><li>表格的其他应用</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  （1）不规则表格\n  - 跨列：从指定单元格位置处，横向向右合并几个（包含自己）单元格\n    属性：colspan=值（数字，合并单元格的个数）;\n  - 跨行：从指定单元格位置处，纵向向下合并几个（包含自己）单元格\n    属性：rowspan=值（数字，合并单元格的个数）;\n  （2）表格的嵌套\n    在单元格中去嵌套另一个表格，但嵌套的表格必须要放在td中</code></pre></div><p>跳转页面（HTTP POST 请求）</p><p>属性见 MDN：<a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">developer.mozilla.org/z</span><span class=\"invisible\">h-CN/docs/Web/HTML/Element/form</span><span class=\"ellipsis\"></span></a></p><div class=\"highlight\"><pre><code class=\"language-text\">  username=lalalal&amp;password=123123\n  // 如果是中文（英文字母和特殊字符之外）会被转义成特殊编码\n  // 也就是 utf-8 的 三个字节</code></pre></div><ul><li>必须要有提交按钮（submit）</li><li>主要是用来发起一个 post 请求的，响应啥，不管</li><li>file 协议不支持 post，我们需要使用 <code>http-server</code></li><li>只能写两个值：post/get，而 get 一般不用，所以就要用 post，get 会把参数放到查询里面</li><li>get 请求是没有第四部分的，post 有</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5 - 列表</b></h2><blockquote>将一组具有相似特征或者具有先后顺序的内容按照从上到下的顺序排列在一起</blockquote><ul><li>有序列表</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;ol&gt;\n      &lt;li&gt;&lt;/li&gt;\n  &lt;/ol&gt;\n  【属性】\n          type:指定列表项标志的类型，默认为数字排列\n          取值：1（默认值）/a/A/i/I\n          start:定义起始值(数字)，默认从1开始\n          取值：数字，如：start:1;  start:i;等 </code></pre></div><ul><li>无序列表</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;ul&gt;\n       &lt;li&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n  【属性】\n          type：指定无序列表的列表项标识\n          取值： disc,默认,实心圆/circle，空心圆/square，实心矩形none，不显示标识</code></pre></div><ul><li>自定义列表</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">&lt;dl&gt;\n  &lt;dt&gt;列表中的标题内容&lt;/dt&gt;\n  &lt;dd&gt;列表中的数据&lt;/dd&gt;\n&lt;/dl&gt;\n使用场合：图文混排时使用\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>6- 表单</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">由&lt;form&gt;定义，将用户输入的数据提交给后台。\n【常见属性】\n        action：提交的服务器地址\n        method：表单数据提交的方式，取值： get：明文提交/post：隐式提交\n        name：定义表单名称，JS用到的比较多\n        id： 独一无二的标识\n如：&lt;form action=&#34;url&#34; method=&#34;get/post&#34;&gt; &lt;/form&gt;\n</code></pre></div><h2><b>input 元素</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">【主要属性】\n        type：根据不同的type属性值可以创建各种类型的输入字段\n        value：最终提交给服务器的值\n        name：控件的名称，提供给服务器使用，没有name，控件则无法提交\n        id：唯一标识，只能在当前页面使用，服务器不能用\n        disabled：禁用，不能被提交\n</code></pre></div><ul><li>常用的表单控件：</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">（1）文本框：&lt;input type=&#34;text&#34;&gt;\n（2）密码框：&lt;input type=&#34;password&#34;&gt;\n 【专有属性】\n         maxlength：限制输入的字符数，取值：数字\n         readonly：设置文本控件只读\n（3）单选按钮：&lt;input type=&#34;radio&#34;&gt;\n（4）复选框：&lt;input type=&#34;checkbox&#34;&gt;\n【专有属性】\n         checked，设置默认被选中\n（5）提交按钮：&lt;input type=&#34;submit&#34;&gt;\n（6）重置按钮：&lt;input type=&#34;reset&#34;&gt;\n（7）普通按钮：&lt;input type=&#34;button&#34;&gt;\n（8）图片按钮：&lt;input type=&#34;image&#34; src=&#34;&#34;&gt; \n（9）隐藏域：&lt;input type=&#34;hidden&#34;&gt;\n（10）文件选择框：&lt;input type=&#34;file&#34;&gt;\n</code></pre></div><h2><b>按钮（提交按钮）</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">&lt;button&gt;内容&lt;/button&gt;\n</code></pre></div><h2><b>下拉选择框 select 和 option</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">&lt;section name=&#34;&#34;&gt;\n  &lt;option value=&#34;&#34; selected&gt;&lt;/option&gt;\n&lt;/section&gt;\n</code></pre></div><h2><b>7- 结构标记</b></h2><blockquote>HTML5所提供的结构标记，专门用于表示常见的网页结构（即制作布局），提升布局代码的语义性和可读性</blockquote><ul><li>常见结构标记</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">&lt;header&gt;&lt;/header&gt;：定义文档的页眉即页面顶部信息\n&lt;nav&gt;&lt;/nav&gt;：定义页面的导航链接部分\n&lt;section&gt;&lt;/section&gt;：定义文档中的节，文档中主体内容\n&lt;article&gt;&lt;/article&gt; ：定义独立于文档的其他部分内容(章、节等)\n&lt;footer&gt;&lt;/footer&gt;：定义某区域的脚注信息，页面底部内容等\n&lt;aside&gt;&lt;/aside&gt;：多用于侧边栏和相关引用信息等\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>8 - iframe 框架</b></h2><p>嵌套的浏览上下文, 有效地将另一个HTML页面嵌入到当前页面中。在HTML 4.01中，文档可能包含头部和正文，或头部和框架集，但不能包含正文和框架集。但是，可以在正常的文档主体中使用。每个浏览上下文都有自己的会话历史记录和活动文档。包含嵌入内容的浏览上下文称为父浏览上下文。顶级浏览上下文（没有父级）通常是浏览器窗口。</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;iframe name=&#34;xxx&#34; src=&#34;https://www.baidu.com&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;\n&lt;a target=&#34;xxx&#34; href=&#34;http://xxx.html&#34;&gt;加载子页面&lt;/a&gt;\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>9 - <code>input / button</code></b></h2><p>区别：是否为空标签</p><p>input 的属性见：<a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">developer.mozilla.org/z</span><span class=\"invisible\">h-CN/docs/Web/HTML/Element/Input</span><span class=\"ellipsis\"></span></a></p><p> type=&#34;button&#34; 没什么卵用~</p><p> submit 唯一能确定表单能不能提交的按钮</p><p> 所有没给 name 的东西，提交是没有数据的</p><div class=\"highlight\"><pre><code class=\"language-html\">// 成对出现的初级写法\n<span class=\"p\">&lt;</span><span class=\"nt\">label</span> <span class=\"na\">for</span><span class=\"o\">=</span><span class=\"s\">&#34;xxx&#34;</span><span class=\"p\">&gt;</span>用户名<span class=\"p\">&lt;</span><span class=\"nt\">label</span><span class=\"p\">&gt;&lt;</span><span class=\"nt\">input</span> <span class=\"na\">type</span><span class=\"o\">=</span><span class=\"s\">&#34;text&#34;</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">&#34;xxx&#34;</span><span class=\"p\">&gt;</span>\n  \n// 另一种写法，为什么，不知道呢\n<span class=\"p\">&lt;</span><span class=\"nt\">label</span><span class=\"p\">&gt;</span>用户名<span class=\"p\">&lt;</span><span class=\"nt\">input</span> <span class=\"na\">type</span><span class=\"o\">=</span><span class=\"s\">&#34;text&#34;</span><span class=\"p\">&gt;&lt;</span><span class=\"nt\">label</span><span class=\"p\">&gt;</span>\n  \n<span class=\"p\">&lt;</span><span class=\"nt\">label</span><span class=\"p\">&gt;</span>用户名<span class=\"p\">&lt;</span><span class=\"nt\">input</span> <span class=\"na\">type</span><span class=\"o\">=</span><span class=\"s\">&#34;checkbox&#34;</span> <span class=\"na\">name</span><span class=\"o\">=</span><span class=\"s\">&#34;loveme&#34;</span> <span class=\"na\">va</span><span class=\"err\">;</span><span class=\"na\">ue</span><span class=\"o\">=</span><span class=\"s\">&#34;yes&#34;</span><span class=\"p\">&gt;</span>爱我<span class=\"p\">&lt;</span><span class=\"nt\">label</span><span class=\"p\">&gt;</span>\n  \n</code></pre></div><p>button 的属性见：<a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">developer.mozilla.org/z</span><span class=\"invisible\">h-CN/docs/Web/HTML/Element/button</span><span class=\"ellipsis\"></span></a></p><blockquote>button 如果没有写 type，那么就会自动升级为 submit 按钮</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>空标签 </b></h2><blockquote>一个<b>空元素（empty element）</b>可能是 HTML，SVG，或者 MathML 里的一个不可能存在子节点（例如内嵌的元素或者元素内的文本）的 element。<br/>在 HTML 中，通常在一个空元素上使用一个闭标签是无效的。例如， <code>&lt;input type=&#34;text&#34;&gt;&lt;/input&gt;</code> 的闭标签是无效的 HTML。</blockquote><p>在 HTML 中由以下空标签：</p><div class=\"highlight\"><pre><code class=\"language-text\">在 HTML 中由以下空标签：\n\t&lt;area&gt;\n\t&lt;base&gt;\n\t&lt;br&gt;\n\t&lt;col&gt;\n\t&lt;colgroup&gt; when the span is present\n\t&lt;command&gt;\n\t&lt;embed&gt;\n\t&lt;hr&gt;\n\t&lt;img&gt;\n\t&lt;input&gt;\n\t&lt;keygen&gt;\n\t&lt;link&gt;\n\t&lt;meta&gt;\n\t&lt;param&gt;\n\t&lt;source&gt;\n\t&lt;track&gt;\n\t&lt;wbr&gt;\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>可替换标签</b></h2><blockquote><b>可替换元素</b>（<b>replaced element</b>）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。<br/>内容不受当前文档的样式的影响。</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">典型的可替换元素有：\n\t&lt;iframe&gt;\n\t&lt;video&gt;\n\t&lt;embed&gt;\n\t&lt;img&gt;\n\n有些元素仅在特定情况下被作为可替换元素处理，例如：\n\t&lt;option&gt;\n\t&lt;audio&gt;\n\t&lt;canvas&gt;\n\t&lt;object&gt;\n\t&lt;applet&gt;</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "网页", 
                    "tagLink": "https://api.zhihu.com/topics/19571150"
                }, 
                {
                    "tag": "HTML+CSS", 
                    "tagLink": "https://api.zhihu.com/topics/19603480"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57712655", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 12, 
            "title": "前端学习需要知道的 HTTP 知识（1/7）", 
            "content": "<h2><b>基础知识</b></h2><h2><b>场景</b></h2><p>我们打开浏览器，输入网址（比如 <code>https://www.bilibili.com/</code>），然后我们就可以看到 b 站的 Web 页面，Web 页面当然不能凭空显示出来。根据 Web 浏览器地址栏中指定的 URL（<code>https://www.bilibili.com/</code>），Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。</p><blockquote>​客户端：像这种通过发送请求获取服务器资源的 Web 浏览器等，都可称为客 户端（client），当然客户端并不都是浏览器，还有 app 啊，微信什么的。</blockquote><h2><b>什么是 HTTP？</b></h2><p>我们输入一个 URL，然后展现页面加载数据，这里面遵循了什么样的协议呢？就是 HTTP。</p><p>Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从<b>客户端</b>到<b>服务器端</b>等一系列运作流 程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。</p><blockquote>总之，HTTP是一个基于 TCP/IP 通信协议的，用于从万维网服务器传输超文本到本地浏览器的传送协议。</blockquote><h2><b>什么是 URL？</b></h2><p>Uniform Resource Locator（统一资源定位符），属于两种 URI（统一资源标志符）的一种，也就是我们平常输入的网络地址，它的格式是：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c3e9ca98b01a5d1b41edc2414601d406_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"546\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb\" width=\"546\" data-original=\"https://pic3.zhimg.com/v2-c3e9ca98b01a5d1b41edc2414601d406_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;546&#39; height=&#39;111&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"546\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"546\" data-original=\"https://pic3.zhimg.com/v2-c3e9ca98b01a5d1b41edc2414601d406_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c3e9ca98b01a5d1b41edc2414601d406_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>URI 相比于 URL 概念更加的宽泛，比如它可以定位到 FTP 上的资源、邮件资源、电话，已经超出了网页的范畴。<br/>URL 则是专门用于定位网页资源。</blockquote><h2><b>简单了解 TCP/IP 四层模型</b></h2><p>TCP/IP 模型分为<b>应用层</b>、<b>传输层</b>、<b>网络层</b>、<b>数据链路层</b>四层。每一个应用层协议一般都会使用到传输层协议 TCP 和 UDP 协议之一：</p><p>我们依然是去想象一个场景：</p><blockquote>二年级的小明想写信给在国外的小朋友亨利，他<b>按照信的标准格式写好了一封信</b>。然后小明不会寄信，他求助于他的爸爸，他爸帮他寄信。<br/>为什么小明会认识亨利呢？因为他们俩的父亲是好朋友，寄信前小明父亲会向亨利父亲确认亨利家没搬家，也就是信是可以寄到的，<b>连接是存在的（三次握手）</b>，然后因为是小明给亨利的，所以备注送到亨利的房间（端口号）。<br/>小明父亲将信给邮差，由邮差填写<b>亨利家的街道地址和邮编（IP 地址）</b><br/>最后邮差将信封放进邮筒，信的<b>尺寸</b>肯定要能放进邮筒，不然寄不出去。<br/><br/>当然别忘了贴邮票（交网费，没网你访问个啥？）</blockquote><p>这个场景就和 TCP/IP 传输协议类似了，我们分别看一下：</p><ul><li><b>应用层</b>：大多数网络相关程序为了通过网络与其他程序通信所使用的层，一般都会使用 TCP 或者 UDP 协议。</li><li><b>传输层</b>：解决诸如端到端的可靠性，保证数据按照正确的顺序到达这样的问题。</li><li><b>网络层</b>：解决在一个单一网络上传输数据包的问题，IP 协议是网络层协议。</li><li><b>数据链路层</b>：是数据包从一个设备的网络层传输到另外一个设备的网络层的方法。</li></ul><p><b>HTTP 在应用层（也就是信的格式），是运行在 TCP 协议上的协议。</b></p><p>由上面可简单了解到 IP 协议负责传输，TCP 协议确保可靠性，还有一个 DNS 负责域名解析。</p><h2><b>什么是 DNS？</b></h2><p>Domain Name System，域名系统,和 HTTP 协议一样位于应用层的 协议,它提供域名到 IP 地址之间的解析服务。</p><p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅 长处理一长串数字。</p><p>为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务。</p><ul><li>输入域名</li><li>输出 IP</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">  nslookup baidu.com\n  ping baidu.com</code></pre></div><p><code>nslookup baidu.com</code> 会访问电信，解析目标地址的 IP，告诉你地址的服务员，就是 DNS，解析服务器。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-80972069debf1e67b66219f5a65e1f7c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"667\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb\" width=\"667\" data-original=\"https://pic1.zhimg.com/v2-80972069debf1e67b66219f5a65e1f7c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;667&#39; height=&#39;349&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"667\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"667\" data-original=\"https://pic1.zhimg.com/v2-80972069debf1e67b66219f5a65e1f7c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-80972069debf1e67b66219f5a65e1f7c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>HTTP 的一些特点</b></h2><ul><li><b>简单快速</b>：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li><b>灵活</b>：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li><b>无连接</b>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><b>无状态</b>：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li><b>支持 B/S 及 C/S 模式。</b></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>HTTP 内容</b></h2><h2><b>服务器与浏览器的交互</b></h2><ul><li>浏览器负责发起请求</li><li>服务器在 80 端口接收请求</li><li>服务器负责返回内容（响应）</li><li>浏览器负责下载响应内容</li></ul><p>HTTP 的作用是指导浏览器和服务器如何进行沟通。                               </p><h2><b>curl 命令</b></h2><p>curl 是一个编程用的函数库，也是是一个无比有用的网站开发工具。</p><h2><b>URL访问</b></h2><ol><li>直接在curl命令后加上网址，就可以看到网页源码。<br/> $ curl <a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a></li><li>使用 <code>-L</code> 参数来重定向追踪<br/> $ curl -L <a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a></li><li>使用 <code>-o</code> 参数将页面源码保存到本地<br/> $ curl -o [文件名] <a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a></li><li>添加 <code>-i</code> 或 <code>--include</code> 参数查看访问页面<br/> $ curl -i <a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a><br/>添加 <code>-i</code> 参数后，页面响应头会和页面源码（响应体）一块返回。如果只想查看响应头，可以使用 <code>-I</code> 或 <code>--head</code> 参数。</li></ol><h2><b>表单提交</b></h2><ol><li>全用 <code>GET</code> 提交表单数据，数据被附加到请求的 URL 后面<br/> $ curl http://example.com/form.cgi?data=xxx</li><li><code>POST</code> 方法必须把数据和网址分开，curl 就要用到 <code>--data</code> 参数<br/> $ curl -X POST --data &#34;data=xxx&#34; http://example.com/form.cgi</li><li>如果你的数据没有经过表单编码，还可以让 curl 编码，参数是 <code>--data-urlencode</code><br/> $ curl -X POST --data-urlencode &#34;date=April 1&#34; http://example.com/form.cgi</li><li>使用 <code>-X</code> 使用其他的 HTTP 动词（默认 <code>GET</code>）<br/> $ curl -X DELETE http://www.example.com</li></ol><h2><b>文件上传</b></h2><ol><li>使用 <code>-T</code> 或者 <code>--upload-file</code> 参数<br/> $ curl -T ./index.html <a href=\"https://link.zhihu.com/?target=http%3A//www.uploadhttp.com/receive.cgi\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">uploadhttp.com/receive.</span><span class=\"invisible\">cgi</span><span class=\"ellipsis\"></span></a></li></ol><h2><b>显示通信过程</b></h2><ol><li>使用 <code>-v</code> 显示一次 http 通信的整个过程，包括端口连接和 http request 头信息<br/> $ curl -v <a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a></li></ol><h2><b>Coocie</b></h2><ol><li>通过 <code>--cookie</code> 参数指定发送请求时的 <code>Cookie</code> 值，或通过 <code>-b [文件名]</code> 指定一个存储了 <code>Cookie</code> 值的本地文件<br/> $ curl -b stored_cookies_in_file <a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a></li><li>通过 <code>-c</code> 参数指定存储服务器返回 <code>Cookie</code> 值的存储文件<br/> $ curl -b cookies.txt -c newcookies.txt <a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a></li></ol><h2><b>添加请求头</b></h2><ol><li>通过 <code>-H</code> 或者 <code>--header</code> 参数来指定请求头，可以多次使用<br/> $ curl -H &#34;Content-Type:application/json&#34; http://example.com</li></ol><h2><b>报文内容</b></h2><p>我们打开 <code>https://xiedaimala.com/tasks/9b3be6e2-3ad0-43cf-b102-9de9da718074</code> 在检查中的 Network 里面可以使用 <code>copy request headers</code> <code>copy response headers</code> 获得请求和响应报文：</p><p><b>request headers</b>：</p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  </span><span class=\"nf\">GET</span> <span class=\"nn\">/tasks/9b3be6e2-3ad0-43cf-b102-9de9da718074</span> <span class=\"kr\">HTTP</span><span class=\"o\">/</span><span class=\"m\">1.1</span>\n  <span class=\"l\">Host: xiedaimala.com</span>\n  <span class=\"l\">Connection: keep-alive</span>\n  <span class=\"l\">Pragma: no-cache</span>\n  <span class=\"l\">Cache-Control: no-cache</span>\n  <span class=\"l\">Upgrade-Insecure-Requests: 1</span>\n  <span class=\"l\">User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1</span>\n  <span class=\"l\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span>\n  <span class=\"l\">Referer: https://xiedaimala.com/courses/ec3a5e28-02da-47d6-9226-927db23e82a2</span>\n  <span class=\"l\">Accept-Encoding: gzip, deflate, br</span>\n  <span class=\"l\">Accept-Language: zh-CN,zh;q=0.9</span>\n  <span class=\"l\">Cookie: UM_distinctid=1690d821f9413c-0dd5cee0b282e8-5d1f3b1c-1fa400-1690d821f9561d; CNZZDATA1271340636=1197645923-1550709159-https%253A%252F%252Fwww.google.com%252F%7C1550724880; _task_center_session=SnFCMGF2WmZ6d2hUS3djY1NZb0UxTnh3R2pDeHVwNUx1czBYeXlVT0JSTzZtc2pZWldLc0s2WHR5Z3V6ZFAzM3ZaU1IwMkNod3lIVytuS01Bbm03TWtaRnhuaEt3V2diUlZLdE92bXpSU1krRGpHT2xDZGIyRWJOdm95Z2xyMEV6MldqUXlsR3ZwQWtCeGFDTWpFc2FBPT0tLWNheDJ3TGVadWNUQ2l1NnFGbXFxOEE9PQ%3D%3D--7717d40d5d746ff64508d247581a356f4ab90880</span>\n  <span class=\"l\">​</span></code></pre></div><p><b>response headers</b>：</p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  </span><span class=\"kr\">HTTP</span><span class=\"o\">/</span><span class=\"m\">1.1</span> <span class=\"m\">200</span> <span class=\"ne\">OK</span>\n  <span class=\"l\">Server: nginx/1.4.6 (Ubuntu)</span>\n  <span class=\"l\">Date: Thu, 21 Feb 2019 06:10:33 GMT</span>\n  <span class=\"l\">Content-Type: text/html; charset=utf-8</span>\n  <span class=\"l\">Transfer-Encoding: chunked</span>\n  <span class=\"l\">Connection: keep-alive</span>\n  <span class=\"l\">X-Frame-Options: SAMEORIGIN</span>\n  <span class=\"l\">X-XSS-Protection: 1; mode=block</span>\n  <span class=\"l\">X-Content-Type-Options: nosniff</span>\n  <span class=\"l\">Cache-Control: max-age=0, private, must-revalidate</span>\n  <span class=\"l\">Set-Cookie: _task_center_session=SDJiMWpDNFhLNndaT0sxb3lELzJBalYxSXpnQThjWUdKakhoV2dhUXYrc3FMY2VPQjEyVEo2bUlGcGl4U3hQbXZ0SEJudkk5TjRjWUVheFYzdmxROGh1YXJrV0NCZll4emNIKzlyUlBNazJNdXBNR05LU0V3aTJDR29NbjlNMnJ6MjlZcHgxQWY5dXFmMkpKRUtFNWNRPT0tLVZtenZLakdKMmZRVGN4aG1xWFpQK1E9PQ%3D%3D--34bc79c0107efb6ef4f174ded40f6171158ec4d6; path=/; secure; HttpOnly</span>\n  <span class=\"l\">X-Request-Id: 026b247b-b03c-4c42-9fa1-f01dff1306d5</span>\n  <span class=\"l\">X-Runtime: 0.032906</span>\n  <span class=\"l\">Strict-Transport-Security: max-age=15552000; includeSubDomains</span>\n  <span class=\"l\">Strict-Transport-Security: max-age=15768000</span>\n  <span class=\"l\">Content-Encoding: gzip</span>\n  <span class=\"l\">​</span></code></pre></div><p>就好像我们之前的小故事一样，<code>request</code> 是发送出去的信，<code>response</code> 是回复的信。</p><p>请求有请求的规矩，响应有响应的规矩，HTTP 就是请求与响应的规矩。不遵循 HTTP 规矩的请求与响应就会处理报错。</p><h2><b>报文结构</b></h2><h2><b>请求的格式</b></h2><p>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段 和内容实体构成的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ff1eaf12285d37060f36196a35acc3f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"299\" class=\"origin_image zh-lightbox-thumb\" width=\"611\" data-original=\"https://pic3.zhimg.com/v2-ff1eaf12285d37060f36196a35acc3f6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;611&#39; height=&#39;299&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"299\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"611\" data-original=\"https://pic3.zhimg.com/v2-ff1eaf12285d37060f36196a35acc3f6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ff1eaf12285d37060f36196a35acc3f6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们使用 <code>curl</code> 语句来创造一个请求：</p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  curl -s -v -H &#34;Frank: xxx&#34; -- &#34;https://www.baidu.com&#34;</span></code></pre></div><p>请求的内容为：</p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  </span><span class=\"nf\">GET</span> <span class=\"nn\">/</span> <span class=\"kr\">HTTP</span><span class=\"o\">/</span><span class=\"m\">1.1</span>\n  <span class=\"l\">Host: www.baidu.com</span>\n  <span class=\"l\">User-Agent: curl/7.54.0</span>\n  <span class=\"l\">Accept: */*</span>\n  <span class=\"l\">Frank: xxx</span></code></pre></div><p>添加 -X POST 参数：</p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  curl -X POST -s -v -H &#34;Frank: xxx&#34; -- &#34;https://www.baidu.com&#34;</span></code></pre></div><p>请求的内容为：</p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  </span><span class=\"nf\">POST</span> <span class=\"nn\">/</span> <span class=\"kr\">HTTP</span><span class=\"o\">/</span><span class=\"m\">1.1</span>\n  <span class=\"l\">Host: www.baidu.com</span>\n  <span class=\"l\">User-Agent: curl/7.54.0</span>\n  <span class=\"l\">Accept: */*</span>\n  <span class=\"l\">Frank: xxx</span></code></pre></div><p>添加 -d “1234567890” 参数：</p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  curl -X POST -d &#34;1234567890&#34; -s -v -H &#34;Frank: xxx&#34; -- &#34;https://www.baidu.com&#34;</span></code></pre></div><p>请求的内容为：</p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  </span><span class=\"nf\">POST</span> <span class=\"nn\">/</span> <span class=\"kr\">HTTP</span><span class=\"o\">/</span><span class=\"m\">1.1</span>\n  <span class=\"l\">Host: www.baidu.com</span>\n  <span class=\"l\">User-Agent: curl/7.54.0</span>\n  <span class=\"l\">Accept: */*</span>\n  <span class=\"l\">Frank: xxx</span>\n  <span class=\"l\">Content-Length: 10</span>\n  <span class=\"l\">Content-Type: application/x-www-form-urlencoded</span>\n  <span class=\"l\">​</span>\n  <span class=\"l\">1234567890</span></code></pre></div><p>客户端发送一个 HTTP 请求到服务器的请求消息包括以下内容：</p><ul><li>请求行（request line）：动词 路径 协议/版本</li><li>请求头部（header）：说明服务器要使用的附加信息</li><li>空行：即使第四部分的请求数据为空，也必须有空行</li><li>请求数据：就是请求数据咯</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8e0f139751cba97c02fd2b59bf9114f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb\" width=\"466\" data-original=\"https://pic3.zhimg.com/v2-8e0f139751cba97c02fd2b59bf9114f6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;466&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"466\" data-original=\"https://pic3.zhimg.com/v2-8e0f139751cba97c02fd2b59bf9114f6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8e0f139751cba97c02fd2b59bf9114f6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>用 Chrome 调试请求</b></h2><ol><li>打开 Network</li><li>地址栏输入网址</li><li>在 Network 点击，查看 request，点击「view source」</li><li>点击「view source」</li><li>可以看到请求的前三部分了</li><li>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>响应的格式</b></h2><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p><p>响应是由状态行、消息头部、空行和响应正文组成。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-56a1c2366c5f14a7c15c921af6cf46a3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb\" width=\"527\" data-original=\"https://pic4.zhimg.com/v2-56a1c2366c5f14a7c15c921af6cf46a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;527&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"527\" data-original=\"https://pic4.zhimg.com/v2-56a1c2366c5f14a7c15c921af6cf46a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-56a1c2366c5f14a7c15c921af6cf46a3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面的三个响应分别为：</p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  curl -s -v -H &#34;Frank: xxx&#34; -- &#34;https://www.baidu.com&#34;\n</span><span class=\"err\">  </span><span class=\"kr\">HTTP</span><span class=\"o\">/</span><span class=\"m\">1.1</span> <span class=\"m\">200</span> <span class=\"ne\">OK</span>\n  <span class=\"l\">Accept-Ranges: bytes</span>\n  <span class=\"l\">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span>\n  <span class=\"l\">Connection: Keep-Alive</span>\n  <span class=\"l\">Content-Length: 2443</span>\n  <span class=\"l\">Content-Type: text/html</span>\n  <span class=\"l\">Date: Tue, 10 Oct 2017 09:14:05 GMT</span>\n  <span class=\"l\">Etag: &#34;5886041d-98b&#34;</span>\n  <span class=\"l\">Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT</span>\n  <span class=\"l\">Pragma: no-cache</span>\n  <span class=\"l\">Server: bfe/1.0.8.18</span>\n  <span class=\"l\">Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span>\n  <span class=\"l\">​</span>\n  <span class=\"l\">&lt;!DOCTYPE html&gt;</span>\n  <span class=\"l\">......</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  curl -X POST -s -v -H &#34;Frank: xxx&#34; -- &#34;https://www.baidu.com&#34;\n</span><span class=\"err\">  </span><span class=\"kr\">HTTP</span><span class=\"o\">/</span><span class=\"m\">1.1</span> <span class=\"m\">302</span> <span class=\"ne\">Found</span>\n  <span class=\"l\">Connection: Keep-Alive</span>\n  <span class=\"l\">Content-Length: 17931</span>\n  <span class=\"l\">Content-Type: text/html</span>\n  <span class=\"l\">Date: Tue, 10 Oct 2017 09:19:47 GMT</span>\n  <span class=\"l\">Etag: &#34;54d9749e-460b&#34;</span>\n  <span class=\"l\">Server: bfe/1.0.8.18</span>\n  <span class=\"l\">​</span>\n  <span class=\"l\">&lt;html&gt;</span>\n  <span class=\"l\">......</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  curl -X POST -d &#34;1234567890&#34; -s -v -H &#34;Frank: xxx&#34; -- &#34;https://www.baidu.com&#34;\n</span><span class=\"err\">  </span><span class=\"kr\">HTTP</span><span class=\"o\">/</span><span class=\"m\">1.1</span> <span class=\"m\">302</span> <span class=\"ne\">Found</span>\n  <span class=\"l\">Connection: Keep-Alive</span>\n  <span class=\"l\">Content-Length: 17931</span>\n  <span class=\"l\">Content-Type: text/html</span>\n  <span class=\"l\">Date: Thu, 21 Feb 2019 07:11:28 GMT</span>\n  <span class=\"l\">Etag: &#34;54d9749e-460b&#34;</span>\n  <span class=\"l\">Server: bfe/1.0.8.18</span>\n  <span class=\"l\">​</span>\n  <span class=\"l\">&lt;html&gt;</span>\n  <span class=\"l\">......</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>服务端发送一个 HTTP 响应到客户端的响应消息包括以下内容：</p><ul><li>状态行：协议/版本 状态码 状态消息</li><li>消息头部：说明客户端要使用的一些附加信息</li><li>空行：空行，消息报头后面的空行是必须的</li><li>响应正文：服务器返回给客户端的文本信息</li></ul><p><b>状态码及对应状态消息</b>：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4cf8b212120c24c85a44943b721efc75_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb\" width=\"522\" data-original=\"https://pic2.zhimg.com/v2-4cf8b212120c24c85a44943b721efc75_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;522&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"522\" data-original=\"https://pic2.zhimg.com/v2-4cf8b212120c24c85a44943b721efc75_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4cf8b212120c24c85a44943b721efc75_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>用 Chrome 调试响应</b></h2><ol><li>打开 Network</li><li>输入网址</li><li>选中第一个响应</li><li>查看 Response Headers，点击「view source</li><li>你会看到响应的前两部分</li><li>查看 Response 或者 Preview，你会看到响应的第 4 部分</li></ol><h2><b>总结一下报文结构</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9feef566988005b37b9e83e6e55fd5e2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"599\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"599\" data-original=\"https://pic3.zhimg.com/v2-9feef566988005b37b9e83e6e55fd5e2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;599&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"599\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"599\" data-original=\"https://pic3.zhimg.com/v2-9feef566988005b37b9e83e6e55fd5e2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9feef566988005b37b9e83e6e55fd5e2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>常见 HTTP 方法及应用场景</b></h2><h2><b>常见 HTTP 方法</b></h2><h2><b>GET（获取资源）</b></h2><blockquote>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保 持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接 口）那样的程序，则返回经过执行后的输出结果。</blockquote><p>告诉服务器我要要东西。</p><h2><b>POST（传输实体主体）</b></h2><blockquote>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。</blockquote><p>告诉服务器我要给东西。</p><h2><b>PUT（传输文件）</b></h2><blockquote>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。<br/>但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。</blockquote><p>告诉服务器我要更新。</p><h2><b>HEAD（获得报文首部）</b></h2><blockquote>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。</blockquote><h2><b>DELETE（删除文件）</b></h2><blockquote>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。 但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。</blockquote><h2><b>OPTIONS（询问支持的方法）</b></h2><blockquote>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</blockquote><h2><b>CONNECT（要求用隧道协议连接代理）</b></h2><blockquote>方法要求在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接 层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容 加 密后经网络隧道传输。</blockquote><h2><b>TRACE（追踪路径）</b></h2><blockquote>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方 法。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 后接收到请求的服务器端则返回状态码 200 OK 的响应。 客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理 中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。 但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>GET 和 POST 区别</b></h2><p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</p><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-779ff2f4e3dcec3c9eaea5dc866b20a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"731\" data-original=\"https://pic3.zhimg.com/v2-779ff2f4e3dcec3c9eaea5dc866b20a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;731&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"731\" data-original=\"https://pic3.zhimg.com/v2-779ff2f4e3dcec3c9eaea5dc866b20a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-779ff2f4e3dcec3c9eaea5dc866b20a6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>本质上它们都是 TCP 链接，因为它们是 HTTP 协议中的两种发送请求的方式，底层都是 TCP/IP。</p><blockquote><code>GET</code> 的语义是请求获取指定的资源。<br/> <code>GET</code> 方法是安全、幂等、可缓存的（除非有 <code>Cache-ControlHeader</code> 的约束）<br/> <code>GET</code> 方法的报文主体没有任何语义<br/><code>POST</code> 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。<br/> <code>POST</code> 不安全，不幂等，（大部分实现）不可缓存<br/> 为了针对其不可缓存性，有一系列的方法来进行优化</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>HTTP 持久化连接</b></h2><div class=\"highlight\"><pre><code class=\"language-http\"><span class=\"err\">  Connection: keep-alive</span></code></pre></div><p>以上就是 <b>持久连接节省通信量</b> 的字段。</p><p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。</p><p>以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使 这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的 情况多了起来。 比如，使用浏览器浏览一个包含多张图片的 HTML页面时，在发送 请求访问 HTML页面资源的同时，也会请求该 HTML页面里包含的 其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断 开，增加通信量的开销。</p><h2><b>持久连接</b></h2><p>为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了 持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。</p><p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相 应提高了。 </p><p>在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并 未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接， 但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客 户端也需要支持持久连接。</p><h2><b>管线化</b></h2><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p><h2><b>Cookie 状态管理</b></h2><p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p><p>不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然 可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是 因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。</p><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入 了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。 </p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出 去。</p><p> 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>HTTP 缓存控制</b></h2><p>浏览器在请求已经访问过的URL的时候，会判断是否使用缓存,。</p><p>判断是否使用缓存，主要通过判断缓存是否在<b>有效期</b>内, 通过两个字段来判断：</p><ol><li><b>Expires</b>，有效期，返回的是一个GMT时间，但是使用的是<b>客户端时间</b>，与服务器时间存在一定时间差。</li><li><b>Cache-Control =&gt; max-age</b>，最大有效时间，单位是s，优先级比 expires 高，为了解决 expires 时间差的问题而出现的。</li></ol><p>缓存过期后，浏览器不会直接去服务器上拿缓存，而是判断缓存是否有更新，能否继续使用，判断的方法有两种：</p><ol><li><b>Last-Modified / If-Modified-Since</b>：服务器会响应一个Last-Modified 字段，表示最近一次修改缓存的时间，当缓存过期后，浏览器就会把这个时间放在 If-Modified-Since 去请求服务器，判断缓存是否有更新。</li><li><b>Etag / If-None-Match</b>：服务器会响应一个 Etag 字段，一个表示文件唯一的字符串, 一旦文件更新，Etag也会跟着更改；缓存过期后，浏览器会把这个字符串放在 If-None-Match 去请求服务器，判断是否有更新，Etag的优先级比Last-Modified 的更高, Etag 的出现, 是为了解决一个缓存文件在短时间内被多次修改的问题, 因为 Last-Modified 只能精确到秒。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>HTTP 工作流程</b></h2><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求Web页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><h2><b>HTTP 请求/响应的步骤</b></h2><h2><b>1、客户端连接到Web服务器</b></h2><p>一个 HTTP 客户端（通常是浏览器）与 Web 服务器的HTTP端口（默认 80）建立一个TCP套接字连接。</p><h2><b>2、发送HTTP请求</b></h2><p>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文。</p><h2><b>3、服务器接受请求并返回 HTTP 响应</b></h2><p>Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。</p><h2><b>4、释放连接 TCP 连接</b></h2><p>若 <code>connection</code> 模式为 <code>close</code>，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP 连接；若 <code>connection</code> 模式为 <code>keepalive</code>，则该连接会保持一段时间，在该时间内可以继续接收请求；</p><h2><b>5、客户端浏览器解析HTML内容</b></h2><p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。</p><h2><b>生活中常见例子</b></h2><p>在浏览器中输入 URL 地址，回车后：</p><p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址 </p><p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接</p><p>3、浏览器发出读取文件（URL 中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文数据发送给服务器;</p><p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p><p>5、释放 TCP 连接</p><p>6、浏览器将该 html 文本并显示内容;</p>", 
            "topic": [
                {
                    "tag": "HTTP", 
                    "tagLink": "https://api.zhihu.com/topics/19588535"
                }, 
                {
                    "tag": "网络协议", 
                    "tagLink": "https://api.zhihu.com/topics/19779985"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": [
                {
                    "userName": "123", 
                    "userLink": "https://www.zhihu.com/people/f6882567959ea38f3666f94ffea40ff4", 
                    "content": "<p>Nice!</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57708282", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 3, 
            "title": "命令行基础", 
            "content": "<h2>这么多年了，为啥一直没支持 markdown 的表格呢。。。。</h2><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>为什么要学命令行</b></h2><ol><li>命令行是啥</li><li>哪些系统提供了命令行<br/></li><ol><li>Windows 的命令提示符和 Git Bash 是命令行</li><li>Linux（如 Ubuntu）的终端也是命令行</li><li>Unix（如 macOS）的终端也是命令行</li></ol><li>为什么要学<br/></li><ol><li>因为现代的前端工具，都没有提供图形界面，只有命令行界面，所以从实用角度出发，命令行必学</li><li>包括 Gulp、Webpack、SASS、Node、Vue、React、Angular</li><li>你不学命令行捞不捞？多捞哦</li></ol></ol><h2><b>命令行难吗</b></h2><p>实际上命令行很简单，你觉得难是因为你在命令行上待的时间还不足 24 小时，而你在 Windows 上待的时间已经超过了 20 年！</p><p>你跟我说 Windows 简单？简单你怎么还学 Windows 学了那么多年？</p><p>其实 Linux 才是更简单的。</p><h2><b>如何学习</b></h2><p>首先背单词：</p><p><b>英文翻译</b>directory目录、文件夹file文件make新建remove删除move移动copy复制list罗列link链接find查找echo发出回音、重复touch触摸change改变</p><p>背下来了嘛？每个单词都很短，应该不难背。好的，你已经基本学会命令行了。接下来看一下缩写。</p><h2><b>缩写</b></h2><p><b>命令全写缩写</b>创建目录make directorymkdir删除removerm移动 / 重命名movemv复制copycp罗列listls改变目录change directory</p><p>缩写规则就是：删掉元音字幕（A E I O U），保留前 2 到 3 个辅音字母</p><p>好了，你已经学会 50% 了，接下来我们来试试。</p><h2><b>常见的自带命令</b></h2><p><b>操作命令</b>进入目录cd显示当前目录pwd创建目录mkdir 目录名创建目录mkdir -p 目录路径我是谁whoami----查看路径ls 路径查看路径ls -a 路径查看路径ls -l 路径查看路径ls -al 路径----创建文件echo &#39;1&#39; &gt; 文件路径强制创建文件echo &#39;1&#39; &gt;! 文件路径追加文件内容echo &#39;1&#39; &gt;&gt; 文件路径创建文件touch 文件名改变文件更新时间touch 文件名----复制文件cp 源路径 目标路径复制目录cp -r 源路径 目标路径----移动节点mv 源路径 目标路径----删除文件rm 文件路径强制删除文件rm -f 文件路径删除目录rm -r 目录路径强制删除目录rm -rf 目录路径----查看目录结构tree建立软链接ln -s 真实文件 链接----下载文件curl -L <a href=\"https://link.zhihu.com/?target=https%3A//www.baidu.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://www.baidu.com</a> &gt; baidu.html拷贝网页wget -p -H -e robots=off <a href=\"https://link.zhihu.com/?target=https%3A//www.baidu.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://www.baidu.com</a> (Windows 不支持 wget)磁盘占用df -kh当前目录大小du -sh .各文件大小du -h</p><blockquote>如何学习我目前还没有掌握的命令？</blockquote><p>Google: Linux 查看文件内容章 4 命令行 - 作业 1<br/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面我将介绍：</p><ol><li>ls</li><li>cat</li><li>mv</li><li>touch</li></ol><p> 以及如何使用 <a href=\"https://link.zhihu.com/?target=https%3A//explainshell.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">explainshell.com</a> 这个网站<br/> </p><h2>目录</h2><p>[TOC]</p><h2>常用命令 - ls</h2><blockquote> 用途：用来打印出当前（或者指定）目录的清单，不仅可以查看文件夹包含的文件，而且可以查看文件权限（包括目录、文件夹、文件权限）、查看目录信息等等。 <br/> </blockquote><p>| 命令 | 全写 | 缩写 | | ---- | ---- | ---- | | 罗列 | List | ls   |</p><h2>命令格式</h2><div class=\"highlight\"><pre><code class=\"language-text\">ls [选项] [目录名]</code></pre></div><h2>常用参数</h2><p>| 参数           | 释义                                                         | | -------------- | ------------------------------------------------------------ | | -a             | 显示所有档案及目录，包括以 <code>.</code> 开头的隐含文件                | | -A             | 同 <code>-a</code>，但是不显示 <code>.</code> （当前目录）和 <code>..</code> （当前目录）     | | -c             | <code>-clt</code>显示列表并且以ctime（文件状态最后改变时间）排序。<code>-cl</code> 显示ctime并且以文件名排序 | | -C             | 多列显示输出结果，这是默认选项                               | | -d             | 仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表 | | -f             | 此参数的效果和同时指定 <code>aU</code> 参数相同，并关闭 <code>lst</code> 参数的效果 | | -i             | 显示文件索引节点号（inode）。一个索引节点代表一个文件        | | -k             | 以 KB（千字节）为单位显示文件大小                            | | -l             | 以长格式显示目录下的内容列表。左到右依次输出文件名、文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等 | | -m             | 用 <code>，</code> 号区隔每个文件和目录的名称                           | | -n             | 以用户识别码和群组识别码替代其名称                           | | -r             | 以文件名反序排列并输出目录内容列表                           | | -s             | 显示文件和目录的大小，以区块为单位                           | | -t             | 用文件和目录的更改时间排序                                   | | -L             | 如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录 | | -R             | 递归处理，将指定目录下的所有文件及子目录一并处理             | | --full-time    | 列出完整的日期与时间                                         | | --color[=WHEN] | 使用不同的颜色高亮显示不同类型的                             |</p><h2>示例</h2><p>列出根目录 \\ 下的所有目录：</p><div class=\"highlight\"><pre><code class=\"language-text\"># ls /\nbin               dev   lib         media  net   root     srv  upload  www\nboot              etc   lib64       misc   opt   sbin     sys  usr\nhome  lost+found  mnt    proc  selinux  tmp  var</code></pre></div><p>列出目前工作目录下所有名称是 s 开头的文件，越新的排越后面 :</p><div class=\"highlight\"><pre><code class=\"language-text\">ls -ltr s*</code></pre></div><p>将 /bin 目录以下所有目录及文件详细资料列出 :</p><div class=\"highlight\"><pre><code class=\"language-text\">ls -lR /bin</code></pre></div><p>列出目前工作目录下所有文件及目录；目录于名称后加 &#34;/&#34;, 可执行档于名称后加 &#34;*&#34; :</p><div class=\"highlight\"><pre><code class=\"language-text\">ls -AF</code></pre></div><h2>常用命令</h2><p>| 操作     | 命令          | | -------- | ------------- | | 查看路径 | ls [路径]     | | 查看路径 | ls -a [路径]  | | 查看路径 | ls -l [路径]  | | 查看路径 | ls -al [路径] |</p><blockquote> 其余的就自己对着表挨个试着玩吧...本人一般也就用用 <code>ls -l</code> 看一下文件信息。<br/> </blockquote><h2>常用命令 - cat</h2><blockquote> 用途：连接文件或标准输入并打印。常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示。<br/> </blockquote><p>| 命令 | 全写        | 缩写 | | ---- | ----------- | ---- | | 串联 | Concatenate | cat  |</p><h2>主要功能</h2><ol><li>一次显示整个文件：<code>cat filename</code></li><li>从键盘创建一个文件：<code>cat &gt; filename</code> （只能创建新文件，不能编辑已有文件）</li><li>将几个文件合并为一个文件：<code>cat file1 file2 &gt; file</code></li></ol><h2>命令格式</h2><div class=\"highlight\"><pre><code class=\"language-text\">cat [选项] [文件名]</code></pre></div><h2>常用参数</h2><p>| 参数 | 释义                                               | | ---- | -------------------------------------------------- | | -A   | 等价于 <code>-vET</code>                                      | | -b   | 和 <code>-n</code> 相似，只不过对于空白行不编号               | | -n   | 由 1 开始对所有输出的行数编号                      | | -e   | 等价于 <code>-vE</code>                                       | | -E   | 每行结束处显示 $                                   | | -s   | 当遇到有连续两行以上的空白行，就代换为一行的空白行 | | -t   | 与 <code>-vT</code> 等价                                      | | -T   | 将 TAB 字符显示为 <code>^I</code>                             | | -v   | 使用 <code>^</code> 和 <code>M-</code> 符号，除了 LFD 和 TAB 之外        |</p><h2>示例</h2><p>把 file1 的文档内容加上行号后输入 file2 这个文档里：</p><div class=\"highlight\"><pre><code class=\"language-text\">cat -n file1 &gt; file2</code></pre></div><p>把 file1 和 file2 的文档内容加上行号（空白行不加）之后将内容附加到 file3 文档里：</p><div class=\"highlight\"><pre><code class=\"language-text\">cat -b file1 file2 &gt;&gt; file3</code></pre></div><p>清空 /etc/file.txt 文档内容：</p><div class=\"highlight\"><pre><code class=\"language-text\">cat /dev/null &gt; /etc/file.txt</code></pre></div><p>制作软盘的镜像文件：</p><div class=\"highlight\"><pre><code class=\"language-text\">cat /dev/fd0 &gt; OUTFILE</code></pre></div><p>把 file 写到软盘：</p><div class=\"highlight\"><pre><code class=\"language-text\">cat IMG_FILE &gt; /dev/fd0</code></pre></div><blockquote> 其余的就自己对着表挨个试着玩吧...本人一般也就用用 <code>cat file</code> 输出一下文件信息。<br/> </blockquote><h2>常用命令 - mv</h2><blockquote> 用途：可以用来移动文件或者将文件改名，经常用来备份文件或者目录。<br/> </blockquote><p>| 命令 | 全写 | 缩写 | | ---- | ---- | ---- | | 移动 | Move | mv   |</p><h2>命令格式</h2><div class=\"highlight\"><pre><code class=\"language-text\">mv [选项] [源文件或目录] [目标文件或目录]</code></pre></div><h2>常用参数</h2><p>| 参数 | 释义                                                 | | ---- | ---------------------------------------------------- | | -b   | 若需覆盖文件，则覆盖前先行备份                       | | -f   | 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 | | -i   | 若目标文件已经存在，就会询问是否覆盖                 | | -u   | 若目标文件已经存在，且 source 比较新，才会更新       |</p><h2>示例</h2><p>将文件 aaa 更名为 bbb :</p><div class=\"highlight\"><pre><code class=\"language-text\">mv aaa bbb</code></pre></div><p>将 a 目录放入 x 目录中，如果 x 目录不存在，则该命令将 a 改名为 x：</p><div class=\"highlight\"><pre><code class=\"language-text\">mv a/ x</code></pre></div><p>再如将 /usr/test 下的所有文件和目录移到当前目录下，命令行为：</p><div class=\"highlight\"><pre><code class=\"language-text\">mv /usr/test/*  .</code></pre></div><h2>常用命令</h2><p>| 操作     | 命令               | | -------- | ------------------ | | 移动节点 | mv 源路径 目标路径 |</p><blockquote> 其余的就自己对着表挨个试着玩吧...本人一般也就用用 <code>mv a b</code> 对文件重命名，或者 <code>mv a /b/c/d/</code> 移动文件<br/> </blockquote><h2>常用命令 - touch</h2><blockquote> 用途：用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。<br/> </blockquote><h2>命令格式（好长啊......）</h2><div class=\"highlight\"><pre><code class=\"language-text\">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</code></pre></div><h2>常用参数</h2><p>| 参数        | 释义                                                         | | ----------- | ------------------------------------------------------------ | | -a          | 改变档案的读取时间记录                                       | | -c          | 假如目的档案不存在，不会建立新的档案。与 <code>--no-create</code> 的效果一样 | | -d          | 设定时间与日期，可以使用各种不同的格式                       | | -f          | 不使用，是为了与其他 unix 系统的相容性而保留                 | | -m          | 改变档案的修改时间记录                                       | | -r          | 使用参考档的时间记录，与 <code>--file</code> 的效果一样                 | | -t          | 设定档案的时间记录，格式与 date 指令相同                     | | --no-create | 不会建立新档案                                               | | --help      | 列出指令格式                                                 | | --version   | 列出版本讯息                                                 |</p><h2>示例</h2><p>使用指令 <code>touch</code> 修改文件 <code>file</code> 的时间属性为当前系统时间：</p><div class=\"highlight\"><pre><code class=\"language-text\">$ touch file</code></pre></div><p>新建文件 :</p><div class=\"highlight\"><pre><code class=\"language-text\">$ touch file</code></pre></div><h2>常用命令</h2><p>| 操作             | 命令           | | ---------------- | -------------- | | 创建文件         | touch [文件名] | | 改变文件更新时间 | touch [文件名] |</p><blockquote> 其余的就自己对着表挨个试着玩吧...挺简单的，没什么要说的。<br/> </blockquote><h2><a href=\"https://link.zhihu.com/?target=https%3A//explainshell.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">explainshell.com</a> 的使用</h2><blockquote> <a href=\"https://link.zhihu.com/?target=http%3A//explainshell.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">explainshell.com</span><span class=\"invisible\"></span></a> 是一个用来查看命令行释义的工具站<br/> </blockquote><h2>使用流程</h2><ol><li>输入框输入 <code>ls -alt</code> ，点击 <code>Explain</code>  搜索 <code>ls -alt</code> 的用法：</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>我们可以看到命令的概括及结构：</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>我们点开其中一个段落：</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>可以获得详细的释义~</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "命令行控制", 
                    "tagLink": "https://api.zhihu.com/topics/19597109"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57706841", 
            "userName": "绅士喵呜", 
            "userLink": "https://www.zhihu.com/people/b2f0a145ee56ffab2105969db9145a8d", 
            "upvote": 3, 
            "title": "Git（1）- 快速入门", 
            "content": "<h2><b>配置 GitHub</b></h2><ol><li>进入 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/settings/keys\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/settings/key</span><span class=\"invisible\">s</span><span class=\"ellipsis\"></span></a></li><li>如果页面里已经有一些 key，就点「delete」按钮把这些 key 全删掉。如果没有，就往下看</li><li>点击 New SSH key，你需要输入 Title 和 Key，但是你现在没有 key，往下看</li><li>打开 Git Bash</li><li>复制并运行 <code>rm -rf ~/.ssh/*</code> 把现有的 ssh key 都删掉，这句命令行如果你多打一个空格，可能就要重装系统了，建议复制运行。</li><li>运行 <code>ssh-keygen -t rsa -b 4096 -C &#34;你的邮箱&#34;</code>，注意填写你的邮箱！</li><li>按回车三次</li><li>运行 <code>cat ~/.ssh/id_rsa.pub</code>，得到一串东西，完整的复制这串东西</li><li>回到上面第 3 步的页面，在 Title 输入「我的第一个 key」</li><li>在 Key 里粘贴刚刚你你复制的那串东西</li><li>点击 Add SSH key</li><li>回到 Git Bash</li><li>运行 <code>ssh -T git@github.com</code>，你可能会看到这样的提示，输入 yes</li><li>然后如果你看到 <code>Permission denied (publickey).</code> 就说明你失败了，请回到第 1 步重来，是的，回到第 1 步重来；如果你看到 <code>Hi FrankFang! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code> 就说明你成功了！</li></ol><h2><b>配置 Git</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">// 英文名，不需要跟 GitHub 保持一致\ngit config --global user.name\n// 邮箱，不需要跟 GitHub 保持一致\ngit config --global user.email\ngit config --global push.default matching\ngit config --global core.quotepath false\ngit config --global core.editor &#34;vim&#34;</code></pre></div><h2><b>在 GitHub 创建一个仓库，然后下载到本地</b></h2><blockquote><b>当然你也可以选择本地仓库上传到 GitHub，不过还要新建一个空仓库，不如直接建一个有初始信息的仓库，更方便些</b></blockquote><ol><li>在GitHub 上新建一个仓库 git-demo-2，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建。</li><li>这样一来，这个仓库就会自动拥有三个文件。</li><li>这三个文件的作用请自行了解：</li></ol><a href=\"https://link.zhihu.com/?target=http%3A//gitbook.liuhui998.com/4_1.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Git Book 中文版 - 忽略某些文件</a><p>、</p><a href=\"https://link.zhihu.com/?target=http%3A//www.jianshu.com/p/94406f5d9b46\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">README.md 的作用</a><p> 以及 </p><a href=\"https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-656b835531df31df56db58b42485c9de_180x120.jpg\" data-image-width=\"800\" data-image-height=\"500\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">如何选择开源许可证？ - 阮一峰的网络日志</a><p>现在远程仓库已经创建好了，怎么下载到我们的本地（也就是我们的电脑上）呢？答案是使用 git clone 命令.</p><p>点击页面中唯一的绿色按钮「clone or download」，会看到一个弹出层。</p><p>打开 Git Bash，找一个安全的目录，比如 ~/Desktop 桌面目录就很安全：<code>cd ~/Desktop</code>。运行。</p><p>运行 <code>git clone 你刚才得到的以git@github.com开头的地址</code>，运行完了你就会发现，桌面上多出一个 git-demo-2 目录。</p><p><b>进入这个多出来的目录</b>，进行一些基本的 Git 操作。</p><h2><b>git init</b></h2><p>创建一个空的 Git 仓库或重新初始化一个现有仓库。</p><p>其实就是通过创建版本库（.git）文件，告知 git 此文件夹已经处于 git 的版本控制之下。</p><p>git 获得目标文件夹的所有权，对其进行 add、commit、pull 等一些列操作。</p><div class=\"highlight\"><pre><code class=\"language-bash\">  <span class=\"c1\"># 打开文件夹</span>\n  <span class=\"nb\">cd</span> <span class=\"nb\">test</span>\n  <span class=\"c1\"># 初始化</span>\n  git init\n  <span class=\"c1\"># 查看是否有 .git 文件夹</span>\n  ls -a</code></pre></div><h2><b>git add</b></h2><p>将修改的文件提交到 <b>暂存区</b>，此时，暂存库（stage）中会存有之前 add 的文件。</p><p>执行 git add 命令的时候，通过hash函数算出文件名对应的sha-1值，这个值是一个32位的16进制数。</p><p>git 会取这个值的前两位作为文件夹名在 .git/objects 文件夹中创建一个文件夹，取值的后30位作为文件名，在.git/objects/文件夹中创建一个文件，git会将原文件内容通过一定的压缩保存在这个文件中。</p><div class=\"highlight\"><pre><code class=\"language-bash\">  <span class=\"c1\"># 改动文件</span>\n  start test.txt\n  <span class=\"c1\"># 查看变动（文件前？）</span>\n  git status -sb\n  <span class=\"c1\"># 添加单个文件</span>\n  git add test.txt\n  <span class=\"c1\"># 添加所有改动文件</span>\n  git add .\n  <span class=\"c1\"># 查看变动（文件前 A）</span>\n  git status -sb</code></pre></div><h2><b>git commit -m</b></h2><p>上面我们将文件添加到暂存区，现在我们使用 git commit -m 将文件提交到缓存区。</p><p><code>git commit --message &lt;msg&gt;</code> msg为本次提交操作的注释信息。</p><p>在将文件 <code>git add &lt;file&gt;</code> 操作后，我在进行<code>git commit &lt;file&gt;</code>操作时，事实上是先对<code>add</code> 进 <code>Staged Snapshot</code> 来的文件进行拍照（快照），然后提交给 <code>Commit History</code>。</p><div class=\"highlight\"><pre><code class=\"language-bash\">  <span class=\"c1\"># 查看变动（文件前红 A）</span>\n  git status -sb\n  <span class=\"c1\"># 提交所有改动文件到缓存区</span>\n  git commit -m <span class=\"s2\">&#34;test&#34;</span> \n  <span class=\"c1\"># 查看变动（文件前绿 A）</span>\n  git status -sb</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Git", 
                    "tagLink": "https://api.zhihu.com/topics/19557710"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1079018824824664064"
}
