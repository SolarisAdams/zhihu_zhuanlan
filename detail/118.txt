{
    "title": "算法与数据结构", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/ha-lou-mo-tuo-54", 
        "https://www.zhihu.com/people/wu-kan-54", 
        "https://www.zhihu.com/people/kangao-1", 
        "https://www.zhihu.com/people/lian-tong-fa-shi-gun-hui-pi-zhan-73", 
        "https://www.zhihu.com/people/Xzavier", 
        "https://www.zhihu.com/people/grammy-jiang", 
        "https://www.zhihu.com/people/zy-wang-95", 
        "https://www.zhihu.com/people/kangzl", 
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/kaivis", 
        "https://www.zhihu.com/people/liu-jian-ming-18", 
        "https://www.zhihu.com/people/chen-jie-54-55", 
        "https://www.zhihu.com/people/luo-jia-yu-57", 
        "https://www.zhihu.com/people/la-fei-er-67-22", 
        "https://www.zhihu.com/people/zhu-yi-chen-55", 
        "https://www.zhihu.com/people/shi-ling-64", 
        "https://www.zhihu.com/people/zheng-jian-yang-56", 
        "https://www.zhihu.com/people/sharker-49", 
        "https://www.zhihu.com/people/gu-haojie", 
        "https://www.zhihu.com/people/anysys66", 
        "https://www.zhihu.com/people/mozhutang", 
        "https://www.zhihu.com/people/lao-guo-2-44", 
        "https://www.zhihu.com/people/li-yi-heng-60-80", 
        "https://www.zhihu.com/people/chen-yao-ming-60", 
        "https://www.zhihu.com/people/li-xiao-ming-7-85", 
        "https://www.zhihu.com/people/xu-shu-88", 
        "https://www.zhihu.com/people/zhou-ji-yu-92-74", 
        "https://www.zhihu.com/people/vman-47", 
        "https://www.zhihu.com/people/wang-da-diao-3", 
        "https://www.zhihu.com/people/ringed-51", 
        "https://www.zhihu.com/people/dong-fei-fei-52", 
        "https://www.zhihu.com/people/liang-yu-yun-29", 
        "https://www.zhihu.com/people/pi-li-zi-lei", 
        "https://www.zhihu.com/people/cj-irving", 
        "https://www.zhihu.com/people/li-tao-24-80-62", 
        "https://www.zhihu.com/people/ma-xin-8-7", 
        "https://www.zhihu.com/people/lin-yang-4-82", 
        "https://www.zhihu.com/people/huan-gan-bu-gan", 
        "https://www.zhihu.com/people/tony437200", 
        "https://www.zhihu.com/people/maxwell-11-62", 
        "https://www.zhihu.com/people/mht-82", 
        "https://www.zhihu.com/people/lu-newping", 
        "https://www.zhihu.com/people/shao-da-ke-95", 
        "https://www.zhihu.com/people/ying-huo-chong-fei-ba", 
        "https://www.zhihu.com/people/zhang-jia-min-80", 
        "https://www.zhihu.com/people/wang-yi-89-96-28", 
        "https://www.zhihu.com/people/adiljan4", 
        "https://www.zhihu.com/people/li-xi-bei-53", 
        "https://www.zhihu.com/people/AI_Technology", 
        "https://www.zhihu.com/people/yi-felisa", 
        "https://www.zhihu.com/people/shurato-wang", 
        "https://www.zhihu.com/people/michael-12-76", 
        "https://www.zhihu.com/people/you-you-kan-kan", 
        "https://www.zhihu.com/people/liu-ke-jiang-35", 
        "https://www.zhihu.com/people/jin-qian-16", 
        "https://www.zhihu.com/people/gao-da-68", 
        "https://www.zhihu.com/people/willwinworld", 
        "https://www.zhihu.com/people/Eudaimonia.", 
        "https://www.zhihu.com/people/ming-tian-52-30-63", 
        "https://www.zhihu.com/people/xiao-bang-dan-bu-chu-de-you-shang", 
        "https://www.zhihu.com/people/chen-yu-60-37-64", 
        "https://www.zhihu.com/people/li-xi-9-80", 
        "https://www.zhihu.com/people/wang-chen-54-25", 
        "https://www.zhihu.com/people/ding-yun-yi-16", 
        "https://www.zhihu.com/people/ying-lu-15", 
        "https://www.zhihu.com/people/wang-wan-wei-34", 
        "https://www.zhihu.com/people/da-da-91-15", 
        "https://www.zhihu.com/people/xin-ba-33-19", 
        "https://www.zhihu.com/people/yang-gang-69-84", 
        "https://www.zhihu.com/people/jiu-ye-20-63", 
        "https://www.zhihu.com/people/dianyu-zhu"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/76735034", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 0, 
            "title": "阿里国际化中台事业部校招啦", 
            "content": "<p>我们是阿里国际化中台事业部，全球化是阿里巴巴经济体的核心战略之一，也是阿里商业操作系统的重要组成部分。</p><p>在阿里有很多的国际化战场，包括东南亚电商Lazada，以及全球卖的速卖通AliExpress，同时还有Daraz等众多电商市场。未来通过中台的能力建设，帮助业务和业务之间更好的互通，实现技术研发的网络与规模效应，收敛国际化业务核心系统链路，确保核心链路的稳定，性能和体验，通过中台更快，更好的支持国际新业务接入以及国内业务出海。</p><p>我们的业务遍布全球各个角落，我们的系统涉及到电商的所有核心链路：交易，商品，商家，还有国际的支付，国际的物流，我们的团队有各个办公地点，各个国家的小伙伴，我们的市场和业务之间通过中台的力量也会产生更多的化学反应。</p><p>我们的远方是星辰大海，但是我们遇到的挑战也非常巨大，相比较国内成熟的电商环境，友善的政策支持和完善的基础设施，国际化中各个国家的政策，国际化的物流，国际化的支付，海量的用户，全球的时区，语言的障碍，都会对我们的产品和技术产生重大的挑战。 我们需要优秀的你一起加入，共建阿里的国际化中台！</p><p>if not you, who!  if not now, when!</p><p>本次招聘面向<b>2020</b>年毕业的学生，投递简历请发私信～</p><p>开放岗位：  </p><ul><li>Java工程师</li><li>测试工程师</li><li>前端工程师</li><li>iOS/Android工程师</li></ul>", 
            "topic": [
                {
                    "tag": "阿里巴巴集团", 
                    "tagLink": "https://api.zhihu.com/topics/19551577"
                }, 
                {
                    "tag": "校园招聘", 
                    "tagLink": "https://api.zhihu.com/topics/19563240"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/34999011", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 3, 
            "title": "从二叉树到红黑树(二)", 
            "content": "<p>二叉查找树在最坏情况下的时间复杂度为N，为了避免这种情况，接下来咱们来了解一种新的树结构：2-3树。</p><p>首先，咱们先来看看2-3树的定义：</p><ul><li>每个节点要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素（节点内是有序的）</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-220763b83ea4700bfd65e66cc57539c6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"694\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb\" width=\"694\" data-original=\"https://pic3.zhimg.com/v2-220763b83ea4700bfd65e66cc57539c6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;694&#39; height=&#39;336&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"694\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"694\" data-original=\"https://pic3.zhimg.com/v2-220763b83ea4700bfd65e66cc57539c6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-220763b83ea4700bfd65e66cc57539c6_b.jpg\"/></figure><ul><li>叶子节点没有孩子，并且有1个或2个数据元素</li><li>所有叶子节点都在统一层上</li></ul><p>下面是2-3树的示例图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c1d5c0129f8873abb03a827e50981238_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2002\" data-rawheight=\"1522\" class=\"origin_image zh-lightbox-thumb\" width=\"2002\" data-original=\"https://pic1.zhimg.com/v2-c1d5c0129f8873abb03a827e50981238_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2002&#39; height=&#39;1522&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2002\" data-rawheight=\"1522\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2002\" data-original=\"https://pic1.zhimg.com/v2-c1d5c0129f8873abb03a827e50981238_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c1d5c0129f8873abb03a827e50981238_b.jpg\"/></figure><p>同时，2-3树添加新节点的新逻辑也和二叉树不一样：</p><ol><li>将新节点添加到相应的叶子节点里面</li><li>如果插入后有三个值四个子节点，则<b>向上分裂</b></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bafa3dda3191a953accee893bdfc23af_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2024\" data-rawheight=\"1438\" class=\"origin_image zh-lightbox-thumb\" width=\"2024\" data-original=\"https://pic4.zhimg.com/v2-bafa3dda3191a953accee893bdfc23af_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2024&#39; height=&#39;1438&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2024\" data-rawheight=\"1438\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2024\" data-original=\"https://pic4.zhimg.com/v2-bafa3dda3191a953accee893bdfc23af_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bafa3dda3191a953accee893bdfc23af_b.jpg\"/></figure><hr/><p>看完2-3树的思想，咱们再来2-3树的实现。在这里，我们是用二叉树来实现 2-3 树（通过给当前节点添加相应颜色来代表与父节点之间的关系，从而实现 2-3 树结构），因为添加的颜色是红色或者黑色，所以这种二叉树，也叫红黑树：</p><ol><li>黑色节点：当前节点与上级节点是父子节点</li><li>红色节点：当前节点与上级节点属于同一节点</li></ol><p>根据 2-3 树的定义（向上分裂的逻辑）可确定两个规则：</p><ol><li>每个红色节点的两个子节点都是黑色节点（红黑树的所有路径上不能有两个连续的红色节点）</li><li>红色节点只存在于左节点（因为向上分裂时是中间的元素向上分裂）</li></ol><p>下面是示例图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-95132ee46f927e63bc39c8d1922eaedb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1932\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb\" width=\"1932\" data-original=\"https://pic4.zhimg.com/v2-95132ee46f927e63bc39c8d1922eaedb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1932&#39; height=&#39;462&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1932\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1932\" data-original=\"https://pic4.zhimg.com/v2-95132ee46f927e63bc39c8d1922eaedb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-95132ee46f927e63bc39c8d1922eaedb_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8226b0c8509816984dfaefcf5af27e8c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2122\" data-rawheight=\"736\" class=\"origin_image zh-lightbox-thumb\" width=\"2122\" data-original=\"https://pic1.zhimg.com/v2-8226b0c8509816984dfaefcf5af27e8c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2122&#39; height=&#39;736&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2122\" data-rawheight=\"736\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2122\" data-original=\"https://pic1.zhimg.com/v2-8226b0c8509816984dfaefcf5af27e8c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8226b0c8509816984dfaefcf5af27e8c_b.jpg\"/></figure><hr/><p>从叶子节点里添加新节点时无可避免的会出现异常红色节点，这时候需要对二叉树进行维护。二叉树维护操作有三个：左旋转、右旋转、向上分裂</p><ul><li>左旋转：</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0dea8d3d31f3f20480d1314ad2c4319f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"790\" class=\"origin_image zh-lightbox-thumb\" width=\"1062\" data-original=\"https://pic4.zhimg.com/v2-0dea8d3d31f3f20480d1314ad2c4319f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1062&#39; height=&#39;790&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"790\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1062\" data-original=\"https://pic4.zhimg.com/v2-0dea8d3d31f3f20480d1314ad2c4319f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0dea8d3d31f3f20480d1314ad2c4319f_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c4d691c3193b8b98dba1a12c90af22e8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1126\" data-rawheight=\"782\" class=\"origin_image zh-lightbox-thumb\" width=\"1126\" data-original=\"https://pic1.zhimg.com/v2-c4d691c3193b8b98dba1a12c90af22e8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1126&#39; height=&#39;782&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1126\" data-rawheight=\"782\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1126\" data-original=\"https://pic1.zhimg.com/v2-c4d691c3193b8b98dba1a12c90af22e8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c4d691c3193b8b98dba1a12c90af22e8_b.jpg\"/></figure><ul><li>右旋转：</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e743fbe2983b29b6a597cc10fac916fc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"874\" data-rawheight=\"728\" class=\"origin_image zh-lightbox-thumb\" width=\"874\" data-original=\"https://pic1.zhimg.com/v2-e743fbe2983b29b6a597cc10fac916fc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;874&#39; height=&#39;728&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"874\" data-rawheight=\"728\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"874\" data-original=\"https://pic1.zhimg.com/v2-e743fbe2983b29b6a597cc10fac916fc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e743fbe2983b29b6a597cc10fac916fc_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3adce5db261e325f630b098b237557c7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1014\" data-rawheight=\"724\" class=\"origin_image zh-lightbox-thumb\" width=\"1014\" data-original=\"https://pic4.zhimg.com/v2-3adce5db261e325f630b098b237557c7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1014&#39; height=&#39;724&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1014\" data-rawheight=\"724\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1014\" data-original=\"https://pic4.zhimg.com/v2-3adce5db261e325f630b098b237557c7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3adce5db261e325f630b098b237557c7_b.jpg\"/></figure><ul><li>向上分裂：</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6ceae6149eed2e15703b05fd565aa304_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"808\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-6ceae6149eed2e15703b05fd565aa304_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;808&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"808\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-6ceae6149eed2e15703b05fd565aa304_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6ceae6149eed2e15703b05fd565aa304_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f5ab306144d06e571d595171f4c7a311_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1256\" data-rawheight=\"748\" class=\"origin_image zh-lightbox-thumb\" width=\"1256\" data-original=\"https://pic2.zhimg.com/v2-f5ab306144d06e571d595171f4c7a311_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1256&#39; height=&#39;748&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1256\" data-rawheight=\"748\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1256\" data-original=\"https://pic2.zhimg.com/v2-f5ab306144d06e571d595171f4c7a311_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f5ab306144d06e571d595171f4c7a311_b.jpg\"/></figure><hr/><p>从叶子节点里添加新节点的维护操作保证了有效红黑树的平衡性：</p><ul><li>当前节点的右子节点是红色节点的时候：左旋转</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9138df8bbfdc07b97ae9498f194b9366_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1104\" data-rawheight=\"1022\" class=\"origin_image zh-lightbox-thumb\" width=\"1104\" data-original=\"https://pic3.zhimg.com/v2-9138df8bbfdc07b97ae9498f194b9366_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1104&#39; height=&#39;1022&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1104\" data-rawheight=\"1022\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1104\" data-original=\"https://pic3.zhimg.com/v2-9138df8bbfdc07b97ae9498f194b9366_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9138df8bbfdc07b97ae9498f194b9366_b.jpg\"/></figure><ul><li>当出现两个连续的红色节点时</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3e4c80ac9e247c64b950475b96244dde_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2114\" data-rawheight=\"1278\" class=\"origin_image zh-lightbox-thumb\" width=\"2114\" data-original=\"https://pic3.zhimg.com/v2-3e4c80ac9e247c64b950475b96244dde_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2114&#39; height=&#39;1278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2114\" data-rawheight=\"1278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2114\" data-original=\"https://pic3.zhimg.com/v2-3e4c80ac9e247c64b950475b96244dde_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3e4c80ac9e247c64b950475b96244dde_b.jpg\"/></figure><hr/><p>红黑树添加新节点示例：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4cea2f168909686be1753a9bc2c396bb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2110\" data-rawheight=\"948\" class=\"origin_image zh-lightbox-thumb\" width=\"2110\" data-original=\"https://pic4.zhimg.com/v2-4cea2f168909686be1753a9bc2c396bb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2110&#39; height=&#39;948&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2110\" data-rawheight=\"948\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2110\" data-original=\"https://pic4.zhimg.com/v2-4cea2f168909686be1753a9bc2c396bb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4cea2f168909686be1753a9bc2c396bb_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6390f9f51085c8259c9748bd074f6b0f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2116\" data-rawheight=\"916\" class=\"origin_image zh-lightbox-thumb\" width=\"2116\" data-original=\"https://pic4.zhimg.com/v2-6390f9f51085c8259c9748bd074f6b0f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2116&#39; height=&#39;916&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2116\" data-rawheight=\"916\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2116\" data-original=\"https://pic4.zhimg.com/v2-6390f9f51085c8259c9748bd074f6b0f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6390f9f51085c8259c9748bd074f6b0f_b.jpg\"/></figure><hr/><p>最后是实现代码：</p><ul><li>节点 (Node) 的数据结构：</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1ff562c13fc1cdc39271df584adb8d35_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"932\" data-rawheight=\"456\" class=\"origin_image zh-lightbox-thumb\" width=\"932\" data-original=\"https://pic2.zhimg.com/v2-1ff562c13fc1cdc39271df584adb8d35_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;932&#39; height=&#39;456&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"932\" data-rawheight=\"456\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"932\" data-original=\"https://pic2.zhimg.com/v2-1ff562c13fc1cdc39271df584adb8d35_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1ff562c13fc1cdc39271df584adb8d35_b.jpg\"/></figure><ul><li>红黑树的API：</li><ul><li>put：添加一个新节点</li><li>get：查找对应节点</li><li>delete：删除对应节点（太过复杂，跳过）</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4473202d77fef86b49e4e89c38dc1bdb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"427\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb\" width=\"427\" data-original=\"https://pic4.zhimg.com/v2-4473202d77fef86b49e4e89c38dc1bdb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;427&#39; height=&#39;542&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"427\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"427\" data-original=\"https://pic4.zhimg.com/v2-4473202d77fef86b49e4e89c38dc1bdb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4473202d77fef86b49e4e89c38dc1bdb_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-735a46bb19003f44e225ca76d8b9ae27_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"306\" data-rawheight=\"470\" class=\"content_image\" width=\"306\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;306&#39; height=&#39;470&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"306\" data-rawheight=\"470\" class=\"content_image lazy\" width=\"306\" data-actualsrc=\"https://pic4.zhimg.com/v2-735a46bb19003f44e225ca76d8b9ae27_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/34692245", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 0, 
            "title": "从二叉树到红黑树(一)", 
            "content": "<p>首先，咱们先来看一下二叉树的定义：</p><ul><li>普通二叉树：普通二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d6f7c085ad871cec30df2123d8f0f937_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"395\" data-rawheight=\"236\" class=\"content_image\" width=\"395\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;395&#39; height=&#39;236&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"395\" data-rawheight=\"236\" class=\"content_image lazy\" width=\"395\" data-actualsrc=\"https://pic4.zhimg.com/v2-d6f7c085ad871cec30df2123d8f0f937_b.jpg\"/></figure><ul><li>二叉查找树：二叉查找树，也称二叉搜索树、有序二叉树，是指一棵空树或者具有下列性质的二叉树：</li><ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点</li></ul></ul><hr/><p>了解了二叉查找树的定义之后，咱们再来分析一下它的API：get，put，delete</p><ul><li><b><i>get：查找对应节点</i></b></li><ul><li>逻辑：二分查找</li><ul><li>把要插入的值与当前根节点进行比较</li><ul><li>等于当前节点：返回当前节点</li><li>大于当前节点：与右子树的根节点进行比较，如果为空则返回空</li><li>小于当前节点：与左子树的根节点进行比较，如果为空则返回空</li></ul></ul><li>实现代码：</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-09bc6ea4f535cfdcafcbe17b212bb470_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-09bc6ea4f535cfdcafcbe17b212bb470_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;496&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-09bc6ea4f535cfdcafcbe17b212bb470_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-09bc6ea4f535cfdcafcbe17b212bb470_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b><i>put：添加一个新节点</i></b></li><ul><li>逻辑：</li><ul><li>把要插入的值与当前根节点进行比较</li><ul><li>等于当前节点：更新节点</li><li>大于当前节点：与右子树的根节点进行比较，如果为空则添加一个新节点</li><li>小于当前节点：与左子树的根节点进行比较，如果为空则添加一个新节点</li></ul></ul><li>图例：</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1fdaff0fa61caf158fe80caff1b0e69f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"818\" data-rawheight=\"1234\" class=\"origin_image zh-lightbox-thumb\" width=\"818\" data-original=\"https://pic4.zhimg.com/v2-1fdaff0fa61caf158fe80caff1b0e69f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;818&#39; height=&#39;1234&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"818\" data-rawheight=\"1234\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"818\" data-original=\"https://pic4.zhimg.com/v2-1fdaff0fa61caf158fe80caff1b0e69f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1fdaff0fa61caf158fe80caff1b0e69f_b.jpg\"/></figure><ul><ul><li>实现代码：</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3cd34d1498b0a20be5f4428e4aa22b29_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb\" width=\"756\" data-original=\"https://pic2.zhimg.com/v2-3cd34d1498b0a20be5f4428e4aa22b29_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;756&#39; height=&#39;628&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"756\" data-original=\"https://pic2.zhimg.com/v2-3cd34d1498b0a20be5f4428e4aa22b29_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3cd34d1498b0a20be5f4428e4aa22b29_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b><i>delMin：删除最小节点（因为完整的逻辑稍微有点复杂，需调整已有二叉树，所以我们先从简单的开始，即删除最小节点）</i></b></li><ul><li>逻辑：</li><ul><li>递归查找当前节点的左子树直到当前节点的左子树为空</li><li>用当前节点的右子树替换当前节点</li></ul><li>图例：</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9f20bed15d987a25841a361954ab4bf6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"596\" data-rawheight=\"1084\" class=\"origin_image zh-lightbox-thumb\" width=\"596\" data-original=\"https://pic3.zhimg.com/v2-9f20bed15d987a25841a361954ab4bf6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;596&#39; height=&#39;1084&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"596\" data-rawheight=\"1084\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"596\" data-original=\"https://pic3.zhimg.com/v2-9f20bed15d987a25841a361954ab4bf6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9f20bed15d987a25841a361954ab4bf6_b.jpg\"/></figure><ul><ul><li>实现代码：</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cde1ecb89cd37d3b11bfb424bc98889b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"544\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb\" width=\"544\" data-original=\"https://pic4.zhimg.com/v2-cde1ecb89cd37d3b11bfb424bc98889b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;544&#39; height=&#39;262&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"544\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"544\" data-original=\"https://pic4.zhimg.com/v2-cde1ecb89cd37d3b11bfb424bc98889b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cde1ecb89cd37d3b11bfb424bc98889b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b><i>delete：删除对应节点</i></b></li><ul><li>逻辑：</li><ul><li>找到要删除的节点</li><li>删除该节点</li><ul><li>如果该节点的左子树为空：直接用该节点的右子树替换该节点（与delMin相同）</li><li>如果该节点的右子树为空：直接用该节点的左子树替换该节点</li></ul></ul></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-666dcd0d68cd5c71aa284bf8b819933d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1060\" data-rawheight=\"562\" class=\"origin_image zh-lightbox-thumb\" width=\"1060\" data-original=\"https://pic2.zhimg.com/v2-666dcd0d68cd5c71aa284bf8b819933d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1060&#39; height=&#39;562&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1060\" data-rawheight=\"562\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1060\" data-original=\"https://pic2.zhimg.com/v2-666dcd0d68cd5c71aa284bf8b819933d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-666dcd0d68cd5c71aa284bf8b819933d_b.jpg\"/></figure><ul><ul><ul><ul><li>如果该节点的左右子树都不为空：用该节点的右子树的最小节点替换掉该节点</li></ul></ul></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1fd54e09a519b6c7b2cfddac70520e05_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1294\" data-rawheight=\"748\" class=\"origin_image zh-lightbox-thumb\" width=\"1294\" data-original=\"https://pic2.zhimg.com/v2-1fd54e09a519b6c7b2cfddac70520e05_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1294&#39; height=&#39;748&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1294\" data-rawheight=\"748\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1294\" data-original=\"https://pic2.zhimg.com/v2-1fd54e09a519b6c7b2cfddac70520e05_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1fd54e09a519b6c7b2cfddac70520e05_b.jpg\"/></figure><ul><ul><li>实现代码：</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-287d79763e690167b3ed5b7dd2b5b296_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"1270\" class=\"origin_image zh-lightbox-thumb\" width=\"724\" data-original=\"https://pic3.zhimg.com/v2-287d79763e690167b3ed5b7dd2b5b296_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;724&#39; height=&#39;1270&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"1270\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"724\" data-original=\"https://pic3.zhimg.com/v2-287d79763e690167b3ed5b7dd2b5b296_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-287d79763e690167b3ed5b7dd2b5b296_b.jpg\"/></figure><hr/><p>最后，咱们来看一下二叉查找树里 get 和 put 的时间复杂度：</p><ul><li>best case：logN</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-10a824450e6df4c0996592abb8e326c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"590\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb\" width=\"590\" data-original=\"https://pic1.zhimg.com/v2-10a824450e6df4c0996592abb8e326c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;590&#39; height=&#39;394&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"590\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"590\" data-original=\"https://pic1.zhimg.com/v2-10a824450e6df4c0996592abb8e326c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-10a824450e6df4c0996592abb8e326c0_b.jpg\"/></figure><ul><li>worst case：N</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-43ba5f1ff16ea757503eb76049f457e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb\" width=\"466\" data-original=\"https://pic1.zhimg.com/v2-43ba5f1ff16ea757503eb76049f457e0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;466&#39; height=&#39;470&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"466\" data-original=\"https://pic1.zhimg.com/v2-43ba5f1ff16ea757503eb76049f457e0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-43ba5f1ff16ea757503eb76049f457e0_b.jpg\"/></figure><hr/><p>思考：如何避免产生最坏情况下的二叉查找树？</p>", 
            "topic": [
                {
                    "tag": "树（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/19680489"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31866486", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 0, 
            "title": "浅谈排序算法（六）：堆排序", 
            "content": "<p>堆排序，是一种依赖于堆实现的排序算法。在这里，咱们会先基于堆来实现<a href=\"https://zhuanlan.zhihu.com/p/31864417\" class=\"internal\">优先队列</a>，再基于优先队列来实现对排序，具体代码实现可以看<a href=\"mailto:git@github.com\">git@github.com</a>:zmbeta/algorithm.git（BinaryHeapPQ里面的sort方法）。以下是具体实现逻辑（设有 N 个元素需要排序）：</p><ol><li>遍历 N 个元素构建优先队列</li><li>重复对优先队列执行出队操作直至队列为空</li><li>完成堆排序：优先队列所在数组即为堆排序结果</li></ol><hr/><p>时间复杂度分析：</p><ol><li>遍历 N 个元素构建优先队列： <img src=\"https://www.zhihu.com/equation?tex=log1%2Blog2%2Blog3%2B...%2BlogN%3Dlog%281%2A2%2A3%2A...%2AN%29%3CNlogN\" alt=\"log1+log2+log3+...+logN=log(1*2*3*...*N)&lt;NlogN\" eeimg=\"1\"/> </li><li>重复对优先队列执行出队操作直至队列为空： <img src=\"https://www.zhihu.com/equation?tex=logN%2Blog%28N-1%29%2B...%2Blog1%3Dlog%5BN%2A%28N-1%29%2A...%2A1%5D%3CNlogN\" alt=\"logN+log(N-1)+...+log1=log[N*(N-1)*...*1]&lt;NlogN\" eeimg=\"1\"/> </li></ol><p>所以，堆排序在最坏情况下的时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=2NlogN\" alt=\"2NlogN\" eeimg=\"1\"/> 。</p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31864417", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 0, 
            "title": "优先队列", 
            "content": "<p>今天咱们来讨论一种数据结构，优先队列。</p><p>虽然同是队列，但优先队列和先进先出（FIFO）的普通队列不同，它是具有最高优先级的元素先出（first in，largest out）。</p><p>在本文实现的代码里，优先队列具有以下几个API：</p><ol><li>isEmpty：队列是否为空</li><li>size：返回队列内包含的元素总数</li><li>insert：插入一个元素</li><li>max：返回队列里最大的元素</li><li>delMax：删除队列里最大的元素并返回</li></ol><p>而对于优先队列，咱们期望达到的时间复杂度是：</p><ol><li>insert：logN</li><li>max：logN</li><li>delMax：logN</li></ol><p>现在，大体框架已经定了，咱们可以来讨论优先队列的具体实现了。对于任何一种数据结构来说，它都可以有多种实现方式。而在这里，咱们会用三种不同的方式来实现优先队列，并分析不同实现方式下的时间复杂度。三种实现方式分别是：</p><ol><li>无序数组实现</li><li>有序数组实现</li><li>堆实现</li></ol><p>由于代码较多，以下实现就不贴代码了，需要代码的可以看<a href=\"mailto:git@github.com\">git@github.com</a>:zmbeta/algorithm.git</p><p>先说无序数组实现，这种实现最简单，直接把新元素加在数组最后面就可以了，出队的时候再遍历整个数据找到其中最大的元素即可。简单的实现相应带来的是高昂的时间复杂度：</p><ol><li>insert：1</li><li>max：N（遍历整个队列）</li><li>delMax：N（遍历整个队列）</li></ol><p>很明显，这时间复杂度还远远达不到咱们的期望值。所以，看完无序数组实现，咱们再来看有序数组实现。</p><p>有序数组实现跟无序数组实现不同的地方在于它每次入队的时候都会对队列内的元素进行一次重排序（插入排序），所以 insert 操作的成本会比较高，但是由于队列内的元素都是有序的，所以出队操作的成本会低很多：</p><ol><li>insert：N</li><li>max：1</li><li>delMax：1</li></ol><p>下面是无序数组和有序数组的实现示例图<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-83f2e149ab1d4c754c0c5e3b9c47b18d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2150\" data-rawheight=\"996\" class=\"origin_image zh-lightbox-thumb\" width=\"2150\" data-original=\"https://pic2.zhimg.com/v2-83f2e149ab1d4c754c0c5e3b9c47b18d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2150&#39; height=&#39;996&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2150\" data-rawheight=\"996\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2150\" data-original=\"https://pic2.zhimg.com/v2-83f2e149ab1d4c754c0c5e3b9c47b18d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-83f2e149ab1d4c754c0c5e3b9c47b18d_b.jpg\"/></figure><p>最后，咱们来看堆实现。本文的堆实现，用的是二叉堆。（二叉堆就是完全二叉树或者近似完全二叉树，它是一种特殊的堆）</p><p>在堆实现里面，根节点就是最大元素。所以，堆实现有两个关键的操作，一个是 insert 的时候需要重建堆（即确保添加新元素后根节点仍然是最大元素），还有就是 delMax 的时候也需要重建堆（即最大元素出堆后根节点仍然是最大元素）</p><p>跟上面两种实现类似，咱们在这里用数组来实现二叉堆。一个数组实现的二叉堆大体来说如下图所示（由于索引位置跟节点位置关联，为了便于计算，数组首位置空）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-96ac4c815a13c806029ceb408815a33d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1034\" data-rawheight=\"912\" class=\"origin_image zh-lightbox-thumb\" width=\"1034\" data-original=\"https://pic2.zhimg.com/v2-96ac4c815a13c806029ceb408815a33d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1034&#39; height=&#39;912&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1034\" data-rawheight=\"912\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1034\" data-original=\"https://pic2.zhimg.com/v2-96ac4c815a13c806029ceb408815a33d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-96ac4c815a13c806029ceb408815a33d_b.jpg\"/></figure><p>而在这实现下，咱们会通过以下操作来添加新元素（insert）：</p><ol><li>把新元素添加到数组的最后面，即至于二叉树的叶子节点</li><li>设新元素所在位置为X</li><li>对 X 进行以下判断：</li><ol><li>X 没有父节点（即 X 为根节点）：完成添加操作</li><li>X 有父节点：</li><ol><li>X 小于等于父节点：完成添加操作</li><li>X 大于父节点：交换 X 与父节点，设父节点所在位置为X，重新执行步骤3（对 X 进行判断）</li></ol></ol></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-147d6c6c5ebecdd4d153e85145ce7a00_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"872\" data-rawheight=\"1214\" class=\"origin_image zh-lightbox-thumb\" width=\"872\" data-original=\"https://pic1.zhimg.com/v2-147d6c6c5ebecdd4d153e85145ce7a00_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;872&#39; height=&#39;1214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"872\" data-rawheight=\"1214\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"872\" data-original=\"https://pic1.zhimg.com/v2-147d6c6c5ebecdd4d153e85145ce7a00_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-147d6c6c5ebecdd4d153e85145ce7a00_b.jpg\"/></figure><p>因为是完全二叉树，所以从叶子节点到根节点最多只需要 logN 次比较，时间复杂度为 logN。</p><p>说完 insert 操作，咱们再来说说 delMax 操作：</p><ol><li>交换数组中的根节点与最后一位的叶子节点</li><li>获得最大元素，数组长度减一</li><li>设根节点所在位置为X，开始重建堆：</li><ol><li>X 没有子节点：结束调整</li><li>X 有子节点：</li><ol><li>比较两个子节点，设较大的子节点所在位置为 Y</li><li>比较 X 和 Y：</li><ol><li>X &gt;= Y ：结束调整</li><li>X &lt; Y ：交换 X 和 Y 的值，设 Y 所在位置为 X，重新对 X 进行判断（步骤3.1）</li></ol></ol></ol><li>返回最大元素</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ed052b678d3e4e993218ea7436386fbd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"994\" data-rawheight=\"1218\" class=\"origin_image zh-lightbox-thumb\" width=\"994\" data-original=\"https://pic2.zhimg.com/v2-ed052b678d3e4e993218ea7436386fbd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;994&#39; height=&#39;1218&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"994\" data-rawheight=\"1218\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"994\" data-original=\"https://pic2.zhimg.com/v2-ed052b678d3e4e993218ea7436386fbd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ed052b678d3e4e993218ea7436386fbd_b.jpg\"/></figure><p>与 insert 类似，从根节点到叶子节点最多只需要 logN 次比较，时间复杂度为 logN。</p><p>所以，从整体来说，堆排序的时间复杂度为：</p><ol><li>insert：logN</li><li>max：1</li><li>delMax：logN</li></ol><p>对比上述三种实现，优先队列明显更优，所以优先队列一般用堆来实现。</p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31627812", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 15, 
            "title": "浅谈排序算法（五）：快速排序", 
            "content": "<p>快速排序，主要有两个操作，一个是切割操作，一个是递归操作。快速排序就是通过这两个操作的组合来完成的。那么这两个操作又都是怎么执行的呢？</p><p>先说切割操作：</p><ol><li>计算当前队列的元素个数，小于等于 1 个时不进行切割操作</li><li>以队列首位为基准，遍历整个队列</li><ol><li>大于基准的放到基准右边</li><li>小于基准的放到基准左边</li></ol><li>以基准为切割线，把遍历后的队列切割成一大一小两个子队列（两个子队列均不包含基准）</li></ol><p>接着再说递归操作：</p><ol><li>对队列进行切割操作，得到A和B两个子队列（如果元素个数小于等于 1 个则不进行切割操作，退出递归）</li><li>对A队列执行步骤一</li><li>对B队列执行步骤一</li></ol><p>所以，总体来说，快速排序就是对队列不断递归执行切割操作，当递归完成，排序也就完成了。</p><p>从另一个角度来说，也可以理解成利用递归的思想确定每个元素在队列中的位置，以此来完成排序。（因为每次切割操作都会确定基准元素在队列中的位置）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>快速排序的算法实现如下（Java语言实现）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-78c3e5894e18991204c2f20c6de3dd55_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"976\" data-rawheight=\"918\" class=\"origin_image zh-lightbox-thumb\" width=\"976\" data-original=\"https://pic2.zhimg.com/v2-78c3e5894e18991204c2f20c6de3dd55_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;976&#39; height=&#39;918&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"976\" data-rawheight=\"918\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"976\" data-original=\"https://pic2.zhimg.com/v2-78c3e5894e18991204c2f20c6de3dd55_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-78c3e5894e18991204c2f20c6de3dd55_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>算法的执行轨迹大体示意图如下</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-717394651b7762931e7c32755965f9ab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2116\" data-rawheight=\"1370\" class=\"origin_image zh-lightbox-thumb\" width=\"2116\" data-original=\"https://pic4.zhimg.com/v2-717394651b7762931e7c32755965f9ab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2116&#39; height=&#39;1370&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2116\" data-rawheight=\"1370\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2116\" data-original=\"https://pic4.zhimg.com/v2-717394651b7762931e7c32755965f9ab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-717394651b7762931e7c32755965f9ab_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>因为快速排序有两个主要操作，所以分析时间复杂度的时候咱们也是从这两个操作着手。</p><p>首先是切割操作，对于长度为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> 的队列，切割操作有两种可能：</p><ol><li><img src=\"https://www.zhihu.com/equation?tex=N+%3C%3D+1\" alt=\"N &lt;= 1\" eeimg=\"1\"/> ：不执行切割操作，所以时间复杂度为常数 1</li><li><img src=\"https://www.zhihu.com/equation?tex=N%3E1\" alt=\"N&gt;1\" eeimg=\"1\"/> ：执行切割操作，因为 <img src=\"https://www.zhihu.com/equation?tex=N+%3C%3D+1\" alt=\"N &lt;= 1\" eeimg=\"1\"/> 次比较，所以时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=+N-1\" alt=\" N-1\" eeimg=\"1\"/> </li></ol><p>接着是递归操作，设对于长度为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> 的队列递归操作的时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=C%28N%29\" alt=\"C(N)\" eeimg=\"1\"/> ，执行切割操作后其中一个子队列的长度为 <img src=\"https://www.zhihu.com/equation?tex=K\" alt=\"K\" eeimg=\"1\"/> 。</p><p>那么根据递归操作的逻辑，咱们可以得出递归操作的时间复杂度计算公式：</p><p><img src=\"https://www.zhihu.com/equation?tex=C%28N%29+%3D+%28N-1%29+%2B+C%28N-K-1%29+%2B+C%28K%29\" alt=\"C(N) = (N-1) + C(N-K-1) + C(K)\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>分析完两个主要操作的时间复杂度之后，咱们就可以开始从整体上分析快排的时间复杂度了。快排的时间复杂度分析分三种情况：最坏、最好和平均。</p><ol><li>最坏：每次都只切割出一个子队列，即 <img src=\"https://www.zhihu.com/equation?tex=K%3D0\" alt=\"K=0\" eeimg=\"1\"/> 。这时候每次递归操作的时间复杂度 <img src=\"https://www.zhihu.com/equation?tex=C%28N%29%3D%28N-1%29+%2B+C%28N-1%29+%2B+1+%3D+N%2BC%28N-1%29\" alt=\"C(N)=(N-1) + C(N-1) + 1 = N+C(N-1)\" eeimg=\"1\"/> ，所以对于长度为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> 的队列来说，快排最坏情况下的时间复杂度 <img src=\"https://www.zhihu.com/equation?tex=C%28N%29%3DN+%2B+%28N-1%29+%2B+%28N-2%29+%2B+...+%2B+1\" alt=\"C(N)=N + (N-1) + (N-2) + ... + 1\" eeimg=\"1\"/> ，即 <img src=\"https://www.zhihu.com/equation?tex=O%28N%5E2%29\" alt=\"O(N^2)\" eeimg=\"1\"/> </li><li>最好：每次都对半切割，即 <img src=\"https://www.zhihu.com/equation?tex=K%3D%5Cfrac%7BN%7D%7B2%7D\" alt=\"K=\\frac{N}{2}\" eeimg=\"1\"/> ，总共会执行 <img src=\"https://www.zhihu.com/equation?tex=logN\" alt=\"logN\" eeimg=\"1\"/> 次递归。这时候每次递归操作的时间复杂度 <img src=\"https://www.zhihu.com/equation?tex=C%28N%29%3D%28N-1%29+%2B+C%28N-%5Cfrac%7BN%7D%7B2%7D-1%29+%2B+C%28%5Cfrac%7BN%7D%7B2%7D%29%3C%28N-1%29%2B2C%28%5Cfrac%7BN%7D%7B2%7D%29\" alt=\"C(N)=(N-1) + C(N-\\frac{N}{2}-1) + C(\\frac{N}{2})&lt;(N-1)+2C(\\frac{N}{2})\" eeimg=\"1\"/> ，而 <img src=\"https://www.zhihu.com/equation?tex=C%28%5Cfrac%7BN%7D%7B2%7D%29%3C%28%5Cfrac%7BN%7D%7B2%7D-1%29+%2B+2C%28%5Cfrac%7BN%7D%7B4%7D%29\" alt=\"C(\\frac{N}{2})&lt;(\\frac{N}{2}-1) + 2C(\\frac{N}{4})\" eeimg=\"1\"/> ，代入 <img src=\"https://www.zhihu.com/equation?tex=C%28N%29\" alt=\"C(N)\" eeimg=\"1\"/> 可得 <br/><img src=\"https://www.zhihu.com/equation?tex=C%28N%29%3C%28N-1%29+%2B+2C%28%5Cfrac%7BN%7D%7B2%7D%29\" alt=\"C(N)&lt;(N-1) + 2C(\\frac{N}{2})\" eeimg=\"1\"/> <img src=\"https://www.zhihu.com/equation?tex=%3C%28N-1%29+%2B+%28N-2%29+%2B+4C%28%5Cfrac%7BN%7D%7B4%7D%29\" alt=\"&lt;(N-1) + (N-2) + 4C(\\frac{N}{4})\" eeimg=\"1\"/> <img src=\"https://www.zhihu.com/equation?tex=%3C%28N-1%29+%2B+%28N-2%29+%2B+%28N-4%29+%2B+8C%28%5Cfrac%7BN%7D%7B8%7D%29\" alt=\"&lt;(N-1) + (N-2) + (N-4) + 8C(\\frac{N}{8})\" eeimg=\"1\"/> <br/>           ……<br/>           <img src=\"https://www.zhihu.com/equation?tex=%3CNlogN-%282%5E%7BlogN%7D-1%29\" alt=\"&lt;NlogN-(2^{logN}-1)\" eeimg=\"1\"/> <img src=\"https://www.zhihu.com/equation?tex=%3CNlogN\" alt=\"&lt;NlogN\" eeimg=\"1\"/> <br/>所以最好情况下快排的时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=O%28NlogN%29\" alt=\"O(NlogN)\" eeimg=\"1\"/> </li><li>平均：每次都随机切割，即 <img src=\"https://www.zhihu.com/equation?tex=K%3D%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D0%7D%5E%7BN-1%7Di\" alt=\"K=\\frac{1}{N}\\sum_{i=0}^{N-1}i\" eeimg=\"1\"/> 。这时候每次递归操作的时间复杂度<br/><img src=\"https://www.zhihu.com/equation?tex=C%28N%29%3D%28N-1%29+%2B+%5Cfrac%7B1%7D%7BN%7D%5Csum_%7BK%3D0%7D%5E%7BN-1%7D%5BC%28N-K-1%29%2BC%28K%29%5D\" alt=\"C(N)=(N-1) + \\frac{1}{N}\\sum_{K=0}^{N-1}[C(N-K-1)+C(K)]\" eeimg=\"1\"/> <img src=\"https://www.zhihu.com/equation?tex=%3D%28N-1%29%2B%5Cfrac%7B2%7D%7BN%7D%5Csum_%7BK%3D0%7D%5E%7BN-1%7DC%28K%29\" alt=\"=(N-1)+\\frac{2}{N}\\sum_{K=0}^{N-1}C(K)\" eeimg=\"1\"/> ，最后得出时间复杂度约为 <img src=\"https://www.zhihu.com/equation?tex=2NlnN\" alt=\"2NlnN\" eeimg=\"1\"/> 。</li></ol>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "Clean-91", 
                    "userLink": "https://www.zhihu.com/people/f0670c12bc827bd06aace45962484140", 
                    "content": "exchange方法呢？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "Ming", 
                            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
                            "content": "<p>贴漏了，完整源码在这 <a href=\"http://link.zhihu.com/?target=https%3A//github.com/zmbeta/algorithm/blob/master/src/main/java/com/ming/sort/QuickSort.java\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://http://github.com/zmbeta/algorithm/blob/master/src/main/java/com/ming/sort/QuickSort.java</a></p>", 
                            "likes": 0, 
                            "replyToAuthor": "Clean-91"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31497069", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 2, 
            "title": "浅谈排序算法（四）：归并排序", 
            "content": "<p>归并排序是一种创建在归并操作上的排序算法。</p><p>那归并操作又是什么呢？所谓归并操作就是指将两个排序好的对列合并成一个对列的操作，它的基本逻辑如下：</p><ol><li>将游标 <img src=\"https://www.zhihu.com/equation?tex=A%E3%80%81B\" alt=\"A、B\" eeimg=\"1\"/> 置于两个队列首位元素，重复执行以下步骤直到遍历完其中一个队列：</li><ol><li>比较 <img src=\"https://www.zhihu.com/equation?tex=A%E3%80%81B\" alt=\"A、B\" eeimg=\"1\"/> 两个元素，将其中较小的元素 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 放置到新队列中</li><li>移动游标 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 至队列下一位（假设 <img src=\"https://www.zhihu.com/equation?tex=A%3CB\" alt=\"A&lt;B\" eeimg=\"1\"/> ）</li></ol><li>直接遍历游标 <img src=\"https://www.zhihu.com/equation?tex=B\" alt=\"B\" eeimg=\"1\"/> 剩下的所有元素并复制到新队列中（假设遍历完其中一个队列的游标是 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> ）</li></ol><p>由上可得归并操作的时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> ，空间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=2N\" alt=\"2N\" eeimg=\"1\"/> （ <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> 为两个原始队列的长度总和）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>而归并排序就是基于归并操作的排序算法，它的大体思想如下：</p><ol><li>把长度为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> 的队列切割成 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> 个子队列，每个子队列的元素个数为 1</li><ol><li>子队列个数为<img src=\"https://www.zhihu.com/equation?tex=M\" alt=\"M\" eeimg=\"1\"/> ： <img src=\"https://www.zhihu.com/equation?tex=M%3DN\" alt=\"M=N\" eeimg=\"1\"/> </li><li>每个子队列的元素个数为 <img src=\"https://www.zhihu.com/equation?tex=K\" alt=\"K\" eeimg=\"1\"/> ： <img src=\"https://www.zhihu.com/equation?tex=K%3D1\" alt=\"K=1\" eeimg=\"1\"/> </li><li>队列长度为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> ： <img src=\"https://www.zhihu.com/equation?tex=N%3DM%2AK\" alt=\"N=M*K\" eeimg=\"1\"/> </li></ol><li>对当前 <img src=\"https://www.zhihu.com/equation?tex=M\" alt=\"M\" eeimg=\"1\"/> 个子队列（每个子队列有 <img src=\"https://www.zhihu.com/equation?tex=K\" alt=\"K\" eeimg=\"1\"/> 个元素）循环执行以下操作直至 <img src=\"https://www.zhihu.com/equation?tex=K%3E%3DN\" alt=\"K&gt;=N\" eeimg=\"1\"/> ：</li><ol><li>从第一个子队列开始，对相邻的两个子队列进行归并操作</li><li>步骤一的归并操作完成后：</li><ol><li>子队列个数 <img src=\"https://www.zhihu.com/equation?tex=M+%3D+%5Cfrac%7BM%7D%7B2%7D\" alt=\"M = \\frac{M}{2}\" eeimg=\"1\"/> </li><li>每个子队列的元素个数 <img src=\"https://www.zhihu.com/equation?tex=K+%3D+K%2A2\" alt=\"K = K*2\" eeimg=\"1\"/> </li></ol></ol></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>它的算法实现如下（Java 语言实现，因使用递归，具体执行步骤与上述思想稍有出入）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d1f081fc784a9d1a7d3627352a65cc33_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"750\" class=\"origin_image zh-lightbox-thumb\" width=\"525\" data-original=\"https://pic4.zhimg.com/v2-d1f081fc784a9d1a7d3627352a65cc33_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;525&#39; height=&#39;750&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"750\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"525\" data-original=\"https://pic4.zhimg.com/v2-d1f081fc784a9d1a7d3627352a65cc33_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d1f081fc784a9d1a7d3627352a65cc33_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上述算法的大体示例图如下</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4ca716bc96910e43db2e45728194cd1c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb\" width=\"572\" data-original=\"https://pic1.zhimg.com/v2-4ca716bc96910e43db2e45728194cd1c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;572&#39; height=&#39;428&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"572\" data-original=\"https://pic1.zhimg.com/v2-4ca716bc96910e43db2e45728194cd1c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4ca716bc96910e43db2e45728194cd1c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于长度为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> 的队列，由于不论原始队列排序如何，归并排序都必须进行 <img src=\"https://www.zhihu.com/equation?tex=logN\" alt=\"logN\" eeimg=\"1\"/> 次循环，每次循环的时间复杂度都为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> ，所以归并排序的时间复杂度是 <img src=\"https://www.zhihu.com/equation?tex=O%28NlogN%29\" alt=\"O(NlogN)\" eeimg=\"1\"/> ，空间复杂度是 <img src=\"https://www.zhihu.com/equation?tex=2N\" alt=\"2N\" eeimg=\"1\"/> 。</p><ol><li>为什么是 <img src=\"https://www.zhihu.com/equation?tex=logN\" alt=\"logN\" eeimg=\"1\"/> 次循环？<br/>因为子队列元素个数初始为 <img src=\"https://www.zhihu.com/equation?tex=1%EF%BC%88%E5%8D%B32%5E0%EF%BC%89\" alt=\"1（即2^0）\" eeimg=\"1\"/> ，第一次循环后子队列元素个数为 <img src=\"https://www.zhihu.com/equation?tex=2%5E1\" alt=\"2^1\" eeimg=\"1\"/> ，第二次循环为 <img src=\"https://www.zhihu.com/equation?tex=2%5E2\" alt=\"2^2\" eeimg=\"1\"/>，... ，第 <img src=\"https://www.zhihu.com/equation?tex=logN\" alt=\"logN\" eeimg=\"1\"/> 次循环为 <img src=\"https://www.zhihu.com/equation?tex=2%5E%7BlogN%7D\" alt=\"2^{logN}\" eeimg=\"1\"/> （即此时子队列的元素个数为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> ，只有一个子队列），所以是 <img src=\"https://www.zhihu.com/equation?tex=logN\" alt=\"logN\" eeimg=\"1\"/> 次循环</li><li>为什么每次循环的时间复杂度都是 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> ？<br/>因为每次循环时每个子队列的元素个数为 <img src=\"https://www.zhihu.com/equation?tex=K\" alt=\"K\" eeimg=\"1\"/> ，子队列个数为 <img src=\"https://www.zhihu.com/equation?tex=M\" alt=\"M\" eeimg=\"1\"/> ，即会有 <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7BM%7D%7B2%7D\" alt=\"\\frac{M}{2}\" eeimg=\"1\"/> 次归并操作，每次归并操作的时间复杂度都为 <img src=\"https://www.zhihu.com/equation?tex=2K\" alt=\"2K\" eeimg=\"1\"/> ，所以最终的时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%282K%29%2A%28%5Cfrac%7BM%7D%7B2%7D%29\" alt=\"(2K)*(\\frac{M}{2})\" eeimg=\"1\"/> ，即 <img src=\"https://www.zhihu.com/equation?tex=K%2AM\" alt=\"K*M\" eeimg=\"1\"/> ，也就是 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> </li></ol>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31173825", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 6, 
            "title": "浅谈排序算法（三）：希尔排序", 
            "content": "<p>在谈希尔排序之前，咱们先回过头来再谈一谈选择排序和插入排序。虽然选择排序和插入排序的最坏时间复杂度都是 <img src=\"https://www.zhihu.com/equation?tex=N%5E2\" alt=\"N^2\" eeimg=\"1\"/> ，但仔细对比起来这两个的 <img src=\"https://www.zhihu.com/equation?tex=N%5E2\" alt=\"N^2\" eeimg=\"1\"/> 还是有区别的。</p><p>选择排序的时间复杂度是固定的，无论数组内各个元素的初始顺序如何，选择排序的时间复杂度永远都是 <img src=\"https://www.zhihu.com/equation?tex=N%5E2\" alt=\"N^2\" eeimg=\"1\"/> ；而插入排序则不同，对于乱序数组来说插入排序的时间复杂度确实是 <img src=\"https://www.zhihu.com/equation?tex=N%5E2\" alt=\"N^2\" eeimg=\"1\"/> ，但对于已经排序好的数组来说它的时间复杂度只有 N。所以针对插入排序的这个特性，对插入排序进行改进优化，从而有了希尔排序。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>希尔排序，是插入排序的一种更高效的改进版本。它的具体算法逻辑如下：</p><ol><li>为要排序的数组选择合适的增量序列，根据数组长度计算出最大增量（最大增量必须小于数组长度）</li><li>从最大增量开始，重复执行以下步骤：</li><ol><li>根据增量序列的逻辑逆推出当前增量 K</li><li>根据数组长度 N 和增量 K 把数组分割成多个子数组：</li><ol><li>子数组个数：min(K, N-K)</li><li>每个子数组的元素个数： <img src=\"https://www.zhihu.com/equation?tex=%28%5Cfrac%7BN%7D%7BK%7D%2B1%29\" alt=\"(\\frac{N}{K}+1)\" eeimg=\"1\"/> </li></ol><li>分别对每个子数组进行插入排序</li></ol></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>当数组长度为 11，增量序列为 (3x+1) 时，希尔排序的执行示意图如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4e0db3891c3c3aa7ed973154bf3a94cf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2098\" data-rawheight=\"1446\" class=\"origin_image zh-lightbox-thumb\" width=\"2098\" data-original=\"https://pic4.zhimg.com/v2-4e0db3891c3c3aa7ed973154bf3a94cf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2098&#39; height=&#39;1446&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2098\" data-rawheight=\"1446\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2098\" data-original=\"https://pic4.zhimg.com/v2-4e0db3891c3c3aa7ed973154bf3a94cf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4e0db3891c3c3aa7ed973154bf3a94cf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>算法实现如下（Java语言实现）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fd49fd25aef1618453d335aa34a72a5e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"432\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb\" width=\"432\" data-original=\"https://pic3.zhimg.com/v2-fd49fd25aef1618453d335aa34a72a5e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;432&#39; height=&#39;403&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"432\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"432\" data-original=\"https://pic3.zhimg.com/v2-fd49fd25aef1618453d335aa34a72a5e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-fd49fd25aef1618453d335aa34a72a5e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>希尔排序的时间复杂度受增量序列影响，不同的增量序列会有不同时间复杂度：N 为数组长度，K 为当前增量</p><ol><li>当增量序列 <img src=\"https://www.zhihu.com/equation?tex=K+%3D+2%5Ex\" alt=\"K = 2^x\" eeimg=\"1\"/> 时，时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=O%28N%5E2%29\" alt=\"O(N^2)\" eeimg=\"1\"/> </li><li>当增量序列 <img src=\"https://www.zhihu.com/equation?tex=K%3D%283x%2B1%29\" alt=\"K=(3x+1)\" eeimg=\"1\"/> 时，时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=O%28N%5E%5Cfrac%7B3%7D%7B2%7D%29\" alt=\"O(N^\\frac{3}{2})\" eeimg=\"1\"/> </li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>当数组长度为 N，增量序列为 <img src=\"https://www.zhihu.com/equation?tex=K+%3D+2%5Ex\" alt=\"K = 2^x\" eeimg=\"1\"/> 时，希尔排序的时间复杂度 <img src=\"https://www.zhihu.com/equation?tex=O%28N%5E2%29\" alt=\"O(N^2)\" eeimg=\"1\"/> 计算如下：</p><ol><li>因为增量为 <img src=\"https://www.zhihu.com/equation?tex=K\" alt=\"K\" eeimg=\"1\"/> 时，子数组个数为 <img src=\"https://www.zhihu.com/equation?tex=K\" alt=\"K\" eeimg=\"1\"/> （假设 <img src=\"https://www.zhihu.com/equation?tex=K%3C%3DN-K\" alt=\"K&lt;=N-K\" eeimg=\"1\"/> ），每个子数组的元素个数为 <img src=\"https://www.zhihu.com/equation?tex=%28%5Cfrac%7BN%7D%7BK%7D%2B1%29\" alt=\"(\\frac{N}{K}+1)\" eeimg=\"1\"/> ，每个子数组都进行一次插入排序，时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7BN%5E2%7D%7BK%5E2%7D\" alt=\"\\frac{N^2}{K^2}\" eeimg=\"1\"/> ，所以每个增量所需时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7BN%5E2%7D%7BK%7D\" alt=\"\\frac{N^2}{K}\" eeimg=\"1\"/> </li><li>因为 <img src=\"https://www.zhihu.com/equation?tex=K%3C%3DN\" alt=\"K&lt;=N\" eeimg=\"1\"/> ，所以 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 的最大值为 <img src=\"https://www.zhihu.com/equation?tex=logN\" alt=\"logN\" eeimg=\"1\"/> ，即会有 <img src=\"https://www.zhihu.com/equation?tex=logN\" alt=\"logN\" eeimg=\"1\"/> 个增量，进行 <img src=\"https://www.zhihu.com/equation?tex=logN\" alt=\"logN\" eeimg=\"1\"/> 次插入排序</li><li>所以，整个希尔排序的时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bx%3D0%7D%5E%7BlogN%7D%5Cfrac%7BN%5E2%7D%7B2%5Ex%7D\" alt=\"\\sum_{x=0}^{logN}\\frac{N^2}{2^x}\" eeimg=\"1\"/> ，最后解得 <img src=\"https://www.zhihu.com/equation?tex=O%28N%5E2%29\" alt=\"O(N^2)\" eeimg=\"1\"/> </li></ol>", 
            "topic": [
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31173779", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 0, 
            "title": "浅谈排序算法（二）：插入排序", 
            "content": "<p>插入排序是一种基本的排序算法，它的基本思想就是依次把一个个新元素插入到一个已经排序好的队列，形成一个排序好的新队列。具体算法逻辑如下：</p><ol><li>将游标定位到当前队列首位，游标左边是已排序好的队列，右边是尚未排序的元素</li><li>将游标所在位置的元素插入到左边已经排序好队列中：</li><li>在已经排序好的队列里面找到适合新元素的位置，插入新元素</li><li>位置左边的元素都小于等于新元素</li><li>位置右边的元素都大于新元素</li><li>将游标右移一位，重复步骤2，直至队列结束</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>算法实现如下（Java语言实现）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b3fbefe4393c136df0e94348f806a029_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic2.zhimg.com/v2-b3fbefe4393c136df0e94348f806a029_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;462&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic2.zhimg.com/v2-b3fbefe4393c136df0e94348f806a029_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b3fbefe4393c136df0e94348f806a029_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>根据上面的时间代码，我们可以计算出插入排序在最坏情况下的时间复杂度：</p><ol><li>总共会有 N 次插入操作（队列扩展）</li><li>每次插入操作所需要遍历的元素数量都会依次递增：</li><li>第一次插入操作需要遍历 0 个元素</li><li>第二次插入操作需要遍历 1 个元素</li><li>第三次插入操作需要遍历 2 个元素</li><li>......</li><li>第 N 次插入操作需要遍历 N-1 个元素</li></ol><p>所以，我们得出以下计算公式：</p><p><img src=\"https://www.zhihu.com/equation?tex=T%28n%29+%3D+0+%2B+1+%2B+2+%2B+...+%2B+%28n-1%29\" alt=\"T(n) = 0 + 1 + 2 + ... + (n-1)\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=+%3D+%5Cfrac%7B%28n-1%29%2An%7D%7B2%7D\" alt=\" = \\frac{(n-1)*n}{2}\" eeimg=\"1\"/>  </p><p><img src=\"https://www.zhihu.com/equation?tex=+%3D+O%28n%5E2%29\" alt=\" = O(n^2)\" eeimg=\"1\"/></p><p>即最后得出的时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=O%28n%5E2%29\" alt=\"O(n^2)\" eeimg=\"1\"/> </p>", 
            "topic": [
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31173724", 
            "userName": "Ming", 
            "userLink": "https://www.zhihu.com/people/0741ac502d5f2af2c8fd4e21d0ad543b", 
            "upvote": 1, 
            "title": "浅谈排序算法（一）：选择排序", 
            "content": "<p>选择排序是一种简单直观的排序算法，它的算法逻辑很简单：找出当前队列长度 N，将游标定位到队列首位，然后将以下步骤重复 N 次：</p><ol><li>找到当前队列最小值的位置（当前队列范围：从游标所在位置开始，直到队列结束）</li><li>交换元素：交换游标所在位置与最小值位置上的元素</li><li>游标位置加一</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>算法实现如下（Java语言实现）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-82b0b13b48dcf85ab37a6731680cb6e2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"560\" class=\"origin_image zh-lightbox-thumb\" width=\"626\" data-original=\"https://pic3.zhimg.com/v2-82b0b13b48dcf85ab37a6731680cb6e2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;626&#39; height=&#39;560&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"560\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"626\" data-original=\"https://pic3.zhimg.com/v2-82b0b13b48dcf85ab37a6731680cb6e2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-82b0b13b48dcf85ab37a6731680cb6e2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>根据上面的实现代码，我们可以计算出选择排序的时间复杂度：</p><ol><li>会有 N 次查找最小值的操作</li><li>查找最小值操作所需遍历的元素会依次递减</li><li>第一次遍历 N 个（ N 次比较操作）</li><li>第二次遍历 N-1 个（ N-1 次比较操作）</li><li>第三次遍历 N-2 个（ N -2 次比较操作）</li><li>......</li><li>第 N 次遍历 1 个（ 1 次比较操作）</li></ol><p>所以，我们得出以下计算公式：</p><p><img src=\"https://www.zhihu.com/equation?tex=+T%28n%29+%3D+n+%2B+%28n-1%29+%2B+%28n-2%29+%2B+...+%2B+1\" alt=\" T(n) = n + (n-1) + (n-2) + ... + 1\" eeimg=\"1\"/></p><p><img src=\"https://www.zhihu.com/equation?tex=+%3D+%5Cfrac%7B%28n%2B1%29+%2A+n%7D%7B2%7D\" alt=\" = \\frac{(n+1) * n}{2}\" eeimg=\"1\"/></p><p><img src=\"https://www.zhihu.com/equation?tex=+%3D+O%28n%5E2%29\" alt=\" = O(n^2)\" eeimg=\"1\"/></p><p>即最后得出的时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=O%28n%5E2%29\" alt=\"O(n^2)\" eeimg=\"1\"/> </p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_141058904"
}
