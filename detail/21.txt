{
    "title": "程序设计入微探索", 
    "description": "Programming Design：A Caller's Perspective", 
    "followers": [
        "https://www.zhihu.com/people/yang-zhi-51-93-18", 
        "https://www.zhihu.com/people/yuan-xin-87-76", 
        "https://www.zhihu.com/people/zhang-zi-cheng-81", 
        "https://www.zhihu.com/people/roc-xie-gz", 
        "https://www.zhihu.com/people/liangge-8", 
        "https://www.zhihu.com/people/jamesr", 
        "https://www.zhihu.com/people/fang-hu-zhong-liu", 
        "https://www.zhihu.com/people/shui-yu-53-18", 
        "https://www.zhihu.com/people/dawnsx", 
        "https://www.zhihu.com/people/ye-ling-ye-83", 
        "https://www.zhihu.com/people/ben-benbb", 
        "https://www.zhihu.com/people/dgjihb", 
        "https://www.zhihu.com/people/xue-hao-gao-shu-xian-dai-ccao", 
        "https://www.zhihu.com/people/likelxl", 
        "https://www.zhihu.com/people/mai-wen-jun", 
        "https://www.zhihu.com/people/liu-lin-qi-78", 
        "https://www.zhihu.com/people/xiao-wen-55-60", 
        "https://www.zhihu.com/people/zzemu", 
        "https://www.zhihu.com/people/yi-lu-huan-ge-59", 
        "https://www.zhihu.com/people/cser-62", 
        "https://www.zhihu.com/people/xing-yun-xun-zong", 
        "https://www.zhihu.com/people/li-yi-xing-29", 
        "https://www.zhihu.com/people/geogre-wu", 
        "https://www.zhihu.com/people/lei-she-66-87", 
        "https://www.zhihu.com/people/wu-xian-3-53", 
        "https://www.zhihu.com/people/xxf09th", 
        "https://www.zhihu.com/people/itachi-yao", 
        "https://www.zhihu.com/people/yongge-89", 
        "https://www.zhihu.com/people/ku-sa-46", 
        "https://www.zhihu.com/people/gate-tomas", 
        "https://www.zhihu.com/people/yuan-lai-suo-yi", 
        "https://www.zhihu.com/people/feng-zheng-yang-98", 
        "https://www.zhihu.com/people/cpm-81", 
        "https://www.zhihu.com/people/octa-octa-36", 
        "https://www.zhihu.com/people/wu-tao-76", 
        "https://www.zhihu.com/people/zhu-forrest", 
        "https://www.zhihu.com/people/huo-hao-97", 
        "https://www.zhihu.com/people/hu-yue-sheng", 
        "https://www.zhihu.com/people/xu-ze-fan-37", 
        "https://www.zhihu.com/people/ykgarfield", 
        "https://www.zhihu.com/people/lian-zhi-wen", 
        "https://www.zhihu.com/people/kyle-chen-15", 
        "https://www.zhihu.com/people/plutolove", 
        "https://www.zhihu.com/people/shasr-lee", 
        "https://www.zhihu.com/people/lovecraft", 
        "https://www.zhihu.com/people/bill_wu", 
        "https://www.zhihu.com/people/yang-zhe-42-74", 
        "https://www.zhihu.com/people/yao-yi-zheng-84", 
        "https://www.zhihu.com/people/hlhl", 
        "https://www.zhihu.com/people/arthur-37-27-72", 
        "https://www.zhihu.com/people/chanme", 
        "https://www.zhihu.com/people/xiaofeng-ji", 
        "https://www.zhihu.com/people/swduan", 
        "https://www.zhihu.com/people/wu-la-gui-20", 
        "https://www.zhihu.com/people/en-si-jie-tuo-66", 
        "https://www.zhihu.com/people/zhang-yi-bo-6", 
        "https://www.zhihu.com/people/stony-wang", 
        "https://www.zhihu.com/people/zhao-xiao-zheng-99", 
        "https://www.zhihu.com/people/ying-san-ling-luan", 
        "https://www.zhihu.com/people/poloumi", 
        "https://www.zhihu.com/people/1802110130", 
        "https://www.zhihu.com/people/tian-ma-xing-kong-15-20-30", 
        "https://www.zhihu.com/people/ze-ze-ze-34-85", 
        "https://www.zhihu.com/people/henrywang0121", 
        "https://www.zhihu.com/people/tuo-hai-79", 
        "https://www.zhihu.com/people/fu-wu-jia-93", 
        "https://www.zhihu.com/people/wanglar-47", 
        "https://www.zhihu.com/people/zhu-you-jun-24", 
        "https://www.zhihu.com/people/li-xu-dong-67-29", 
        "https://www.zhihu.com/people/zhuo-ji-23-72", 
        "https://www.zhihu.com/people/jiangyongshui", 
        "https://www.zhihu.com/people/pang-nan-3", 
        "https://www.zhihu.com/people/feng-lan-53", 
        "https://www.zhihu.com/people/nick-black", 
        "https://www.zhihu.com/people/xuhai-wang", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/cai-yu-jie-12", 
        "https://www.zhihu.com/people/tan-kui-kui", 
        "https://www.zhihu.com/people/yansongtw", 
        "https://www.zhihu.com/people/yin-ruo-yun-38", 
        "https://www.zhihu.com/people/lai-qing-song", 
        "https://www.zhihu.com/people/bai-da-35", 
        "https://www.zhihu.com/people/afterlook", 
        "https://www.zhihu.com/people/kitty-19-61", 
        "https://www.zhihu.com/people/heng-heng-1234", 
        "https://www.zhihu.com/people/dgwangqiang", 
        "https://www.zhihu.com/people/chen-jin-bin-24", 
        "https://www.zhihu.com/people/fx-moon", 
        "https://www.zhihu.com/people/long-wen-yu-65", 
        "https://www.zhihu.com/people/jokerjf", 
        "https://www.zhihu.com/people/yu--an", 
        "https://www.zhihu.com/people/tianrui007", 
        "https://www.zhihu.com/people/tdivwkl", 
        "https://www.zhihu.com/people/bert-38-63", 
        "https://www.zhihu.com/people/cao-you-wei-12", 
        "https://www.zhihu.com/people/advstock", 
        "https://www.zhihu.com/people/zhang-xu-dong-22-32", 
        "https://www.zhihu.com/people/shallow-75-50", 
        "https://www.zhihu.com/people/lan-tian-89", 
        "https://www.zhihu.com/people/cocoasprite", 
        "https://www.zhihu.com/people/stephen-wang-29", 
        "https://www.zhihu.com/people/chen-zhi-wei-37-90", 
        "https://www.zhihu.com/people/li-jian-19-95", 
        "https://www.zhihu.com/people/xinyaping", 
        "https://www.zhihu.com/people/joyfond", 
        "https://www.zhihu.com/people/xiao-shi-tou-li", 
        "https://www.zhihu.com/people/liao-bu-qi-de-yan-ke-xia", 
        "https://www.zhihu.com/people/ji-xiao-mi-16", 
        "https://www.zhihu.com/people/sun-ke-ke-84", 
        "https://www.zhihu.com/people/shuai-qi-60-70", 
        "https://www.zhihu.com/people/jhb-22-72", 
        "https://www.zhihu.com/people/hrchan", 
        "https://www.zhihu.com/people/panovr", 
        "https://www.zhihu.com/people/luoweisong", 
        "https://www.zhihu.com/people/dong-wei-mian", 
        "https://www.zhihu.com/people/ni-cai-3-78-92", 
        "https://www.zhihu.com/people/jian-zhi-jiu-tian-22", 
        "https://www.zhihu.com/people/alpha00021", 
        "https://www.zhihu.com/people/chi-yu-de-mao-22", 
        "https://www.zhihu.com/people/wang-song-77-47", 
        "https://www.zhihu.com/people/lei-luo-55-82", 
        "https://www.zhihu.com/people/chu-sheng-du-niu", 
        "https://www.zhihu.com/people/shen-yiyang-de-ren-75", 
        "https://www.zhihu.com/people/forever-37-67", 
        "https://www.zhihu.com/people/heyang-36", 
        "https://www.zhihu.com/people/sheng-zhu-77", 
        "https://www.zhihu.com/people/cuudnwill", 
        "https://www.zhihu.com/people/xu-xiao-sheng-18", 
        "https://www.zhihu.com/people/ba-tian-hu-3", 
        "https://www.zhihu.com/people/sha-qi-zhi-yun", 
        "https://www.zhihu.com/people/lyer-38", 
        "https://www.zhihu.com/people/kennel2009", 
        "https://www.zhihu.com/people/jiahai-wu", 
        "https://www.zhihu.com/people/DiXinkai", 
        "https://www.zhihu.com/people/jiang-wei-hao-65-26", 
        "https://www.zhihu.com/people/zhi-yu-tuo", 
        "https://www.zhihu.com/people/liang-deng-yu-86", 
        "https://www.zhihu.com/people/runningmantong", 
        "https://www.zhihu.com/people/dong-dong-46-64", 
        "https://www.zhihu.com/people/yu-hai-long-22", 
        "https://www.zhihu.com/people/ni-lei-lei-9", 
        "https://www.zhihu.com/people/leon-von", 
        "https://www.zhihu.com/people/xuanxuan-zhu", 
        "https://www.zhihu.com/people/quan-bo-mian", 
        "https://www.zhihu.com/people/mdzz.fish", 
        "https://www.zhihu.com/people/ceng-zhu-26", 
        "https://www.zhihu.com/people/wang-bing-cao", 
        "https://www.zhihu.com/people/666666-29-3", 
        "https://www.zhihu.com/people/chen-kai-7-76", 
        "https://www.zhihu.com/people/huang-wei-55", 
        "https://www.zhihu.com/people/zhi-hu-zhe-ye-25-5", 
        "https://www.zhihu.com/people/yan-feng-ba-lang", 
        "https://www.zhihu.com/people/li-bin-19-39", 
        "https://www.zhihu.com/people/nurenok-91", 
        "https://www.zhihu.com/people/damieng", 
        "https://www.zhihu.com/people/guo-zhong-ming-26", 
        "https://www.zhihu.com/people/mi-ke-er-29-5", 
        "https://www.zhihu.com/people/cr-lient", 
        "https://www.zhihu.com/people/parker-51", 
        "https://www.zhihu.com/people/qin-lian-ke", 
        "https://www.zhihu.com/people/justinhan", 
        "https://www.zhihu.com/people/frandy-cheng", 
        "https://www.zhihu.com/people/ming-chuan-9", 
        "https://www.zhihu.com/people/renjia33", 
        "https://www.zhihu.com/people/tan-xiao-59-91", 
        "https://www.zhihu.com/people/qian-xiao-qiang-78-94", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/740576774-81-36", 
        "https://www.zhihu.com/people/ludo-1", 
        "https://www.zhihu.com/people/vivian8725118", 
        "https://www.zhihu.com/people/xxt-44", 
        "https://www.zhihu.com/people/cy-sentry", 
        "https://www.zhihu.com/people/kevin.kang", 
        "https://www.zhihu.com/people/cherry-panda", 
        "https://www.zhihu.com/people/wannaxenon", 
        "https://www.zhihu.com/people/7heaven", 
        "https://www.zhihu.com/people/wan-qu-bing", 
        "https://www.zhihu.com/people/wei-zhang-52-25", 
        "https://www.zhihu.com/people/wang-peng-cheng-97-49", 
        "https://www.zhihu.com/people/hou-zong-zhi", 
        "https://www.zhihu.com/people/chaomai", 
        "https://www.zhihu.com/people/ling-lin-21-32", 
        "https://www.zhihu.com/people/raineastgam", 
        "https://www.zhihu.com/people/kinglong-29", 
        "https://www.zhihu.com/people/hanlin-yang-74", 
        "https://www.zhihu.com/people/jiang-jin-yue-14-4", 
        "https://www.zhihu.com/people/sjmy", 
        "https://www.zhihu.com/people/liumen", 
        "https://www.zhihu.com/people/sfn-28", 
        "https://www.zhihu.com/people/qiao-hai-jun", 
        "https://www.zhihu.com/people/feng-yu-99-15", 
        "https://www.zhihu.com/people/zhang-wei-13-8-26", 
        "https://www.zhihu.com/people/nianhua-tumu", 
        "https://www.zhihu.com/people/tan-lei-13-5", 
        "https://www.zhihu.com/people/ou-yang-44-9", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/san-shen-59", 
        "https://www.zhihu.com/people/ma-shan-50-1", 
        "https://www.zhihu.com/people/he-wen-kun", 
        "https://www.zhihu.com/people/wang-zhi-qiang-30-55", 
        "https://www.zhihu.com/people/kevin-wan-74", 
        "https://www.zhihu.com/people/he1a2s0", 
        "https://www.zhihu.com/people/ye-xiao-1-61", 
        "https://www.zhihu.com/people/yang-jian-feng-85-30", 
        "https://www.zhihu.com/people/japhy-98", 
        "https://www.zhihu.com/people/zheng-xiao-long-97", 
        "https://www.zhihu.com/people/liu-yan-hua-85", 
        "https://www.zhihu.com/people/tang-wen-7-58", 
        "https://www.zhihu.com/people/next-29", 
        "https://www.zhihu.com/people/angel69devil", 
        "https://www.zhihu.com/people/sphinx-myst", 
        "https://www.zhihu.com/people/bihuchao", 
        "https://www.zhihu.com/people/zhao-qing-5-36", 
        "https://www.zhihu.com/people/yu_xi", 
        "https://www.zhihu.com/people/struct-78", 
        "https://www.zhihu.com/people/zhu-hong-rui-64-54", 
        "https://www.zhihu.com/people/mast-22", 
        "https://www.zhihu.com/people/ju-shang-gong-yin", 
        "https://www.zhihu.com/people/jiu-qian-shi-wen", 
        "https://www.zhihu.com/people/rain-john", 
        "https://www.zhihu.com/people/7a57a5a743894a0e", 
        "https://www.zhihu.com/people/chen-chun-sheng-39-24", 
        "https://www.zhihu.com/people/yang-xa", 
        "https://www.zhihu.com/people/plm900", 
        "https://www.zhihu.com/people/whatyour-name", 
        "https://www.zhihu.com/people/jack-break", 
        "https://www.zhihu.com/people/fu-wen-chuan"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/88237533", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 2, 
            "title": "C|计算机网络|Transport Layer", 
            "content": "<p>Network Layer无法保证</p><ul><li>延迟</li><li>到达顺序</li><li>确认到达</li><li>准确内容</li><li>正确地址</li></ul><p>CSE中的E2E层表示经典层次中的Transport Layer和Application Layer。这里主要讲的是TCP。</p><hr/><h2>Transport Protocol</h2><p>UDP(User Datagram Protocol)</p><p>适合传输简单应用的数据，不提供其他机制</p><p>TCP (Transmission Control Protocol)</p><p>适合不适合丢包的场景，提供重传、错误检测、保证顺序</p><p>RTP (Real-time Transport Protocol)</p><p>强调速度，适合流媒体（基于UDP，对丢包比较宽容）</p><p>一般我们使用TCP处理Network Layer可能发生的错误，解决的问题如下</p><ul><li>Assurance of at-least-once delivery</li><li>Assurance of at-most-once delivery</li><li>Assurance of data integrity</li><li>Assurance of stream order &amp; closing of connections</li><li>Assurance of jitter control</li><li>Assurance of authenticity and privacy</li><li>Assurance of end-to-end performance</li></ul><hr/><p><b>Assurance of At-least-once Delivery（重传）</b></p><p>RTT (Round-trip time，往返时延)      </p><p>to_time + process_time + back_time (ack)</p><p>包中附带随机的nonce，ack时回传nonce，如果超时，则重传（同样的nonce）。那么，超时的阈值作为多少呢？</p><p><b>Fixed Timer</b></p><p>超时多少则是Trade-off，过长则丢包处理时间太久，过短则可能没有必要。如果写成固定的值则有风险，一旦对方无法提供服务，会造成大量的轮询。（查Wisconsin Time Server Meltdown）。</p><p><b>Adaptive Timer</b></p><p>为了处理这种情况，必须根据实际情况（RTT）进行调整，但是RTT是波动的，因此必须给出一定的余量作为Timeout。</p><p>Linux Kernel中使用这段代码进行迭代。（RTT期望不是真的数学期望，1/8只是个magic number）</p><ol><li>rtt_avg将当前一次的RTT和之前的RTT期望进行加权，算出目前的RTT期望。</li><li>dev表示波动值</li><li>rtt_dev将当前一次的RTT波动和之前的波动进行加权，算出目前的波动。</li><li>Timeout将RTT期望增加一定余量</li></ol><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">rtt_avg</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">rtt_sample</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">rtt_avg</span><span class=\"p\">;</span> <span class=\"cm\">/* a = 1/8 */</span> \n<span class=\"n\">dev</span> <span class=\"o\">=</span> <span class=\"n\">absolute</span><span class=\"p\">(</span><span class=\"n\">rtt_sample</span> <span class=\"err\">–</span> <span class=\"n\">rtt_avg</span><span class=\"p\">);</span> \n<span class=\"n\">rtt_dev</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">*</span><span class=\"n\">dev</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">rtt_dev</span><span class=\"p\">;</span> <span class=\"cm\">/* b = 1/4 */</span> \n<span class=\"n\">Timeout</span> <span class=\"o\">=</span> <span class=\"n\">rtt_avg</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">rtt_dev</span></code></pre></div><p><b>NAK (Negative AcKnowledgment)</b></p><p>否定应答，由接受者检测包的丢失，回传给发送者，由发送方重发丢失的包，而不用Timer机制。</p><p><b>Assurance of At-most-once Delivery（处理重复重传）</b></p><p><b>1.维护nonce表：空间浪费+时间浪费</b></p><p><b>2.允许重复请求（要求幂等）：时间浪费</b></p><p>这个问题没有完美的解法，因为接收方不知道发送方是否还会重传，这些nonce表必须保留，导致无止境增长。一种方法是超过一定时间后失效（但是会导致可能发生at-least-once错误），另一种是每次重启后清空表。</p><p>所以幂等性很重要！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Assurance of data integrity（校验码）</h2><p>Checksum</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Assurance of stream order &amp; closing of connections（处理乱序）</h2><p>Segment contains ID for where it fits</p><p>–E.g., &#34;message 914, segment 3 of 7&#34;</p><p>按序收包，乱序则存在buffer里，buffer满了则丢弃</p><p><b>滑动窗口</b></p><p>每个时刻只接受顺序在一定范围内的包，超范围则丢弃。如果最前的包收到了，那么窗口后移</p><h2>Assurance of jitter control(延迟抖动）</h2><p>方法：延迟所有到达的segment，作为缓冲。Dheadway是平均延迟，也就是说，池子中的segment，能支撑最大的抖动（Dlong并不是最大，但是超过99%）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-543af0000fbca68f2549ab13f44ad110_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"479\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb\" width=\"479\" data-original=\"https://pic1.zhimg.com/v2-543af0000fbca68f2549ab13f44ad110_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;479&#39; height=&#39;82&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"479\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"479\" data-original=\"https://pic1.zhimg.com/v2-543af0000fbca68f2549ab13f44ad110_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-543af0000fbca68f2549ab13f44ad110_b.jpg\"/></figure><p>Assurance of authenticity and privacy（加密）</p><p>使用公钥和私钥，对称密钥加密技术，公钥加密的只有使用私钥才能解读（由我READ），私钥加密的只有公钥才能解读（由我WRITE）</p><h2>Assurance of end-to-end performance(握手）</h2><p>并不等待所有包都传输完成，而是包成功传输后，窗口就进行滑动。注意，如果窗口开头的包传送失败，那么窗口不会向前滑动，而是等待这个包重传成功。</p><p>例如传送2-6,2失败，那么会等待2传送完后，直接跳到7-11，以保证其连续性</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f4be57351f480269752f72611fec720e_b.jpg\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb\" width=\"654\" data-original=\"https://pic3.zhimg.com/v2-f4be57351f480269752f72611fec720e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;654&#39; height=&#39;376&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"654\" data-original=\"https://pic3.zhimg.com/v2-f4be57351f480269752f72611fec720e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f4be57351f480269752f72611fec720e_b.jpg\"/><figcaption>Fixed Window VS Sliding Window</figcaption></figure><p>window size ≥ RTT × bottleneck data rate以确保性能</p><h2><b>TCP Congestion Control</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-416b93ad7201517b96f526b0e0409fb2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"588\" data-rawheight=\"385\" class=\"origin_image zh-lightbox-thumb\" width=\"588\" data-original=\"https://pic3.zhimg.com/v2-416b93ad7201517b96f526b0e0409fb2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;588&#39; height=&#39;385&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"588\" data-rawheight=\"385\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"588\" data-original=\"https://pic3.zhimg.com/v2-416b93ad7201517b96f526b0e0409fb2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-416b93ad7201517b96f526b0e0409fb2_b.jpg\"/></figure><p>由于堵塞时，重传次数会增加，性能会更加下降。因此window不能太大，否则重传会导致window卡住很久。</p><p>window size ≤ min(RTT x bottleneck data rate, Receiver buffer)以防止堵塞</p><p>TCP使用下面的算法迭代window size</p><p><b>AIMD (Additive Increase, Multiplicative Decrease)</b></p><p>每一次成功，window size ++（注意刚开始避免增速太慢使用*=2）</p><p>每一次丢包， window size / = 2</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1e4be3b9dc9ed499a1ae642bd0f2ba1f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb\" width=\"843\" data-original=\"https://pic4.zhimg.com/v2-1e4be3b9dc9ed499a1ae642bd0f2ba1f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;843&#39; height=&#39;372&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"843\" data-original=\"https://pic4.zhimg.com/v2-1e4be3b9dc9ed499a1ae642bd0f2ba1f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1e4be3b9dc9ed499a1ae642bd0f2ba1f_b.jpg\"/></figure><p>使用这种算法能够快速收敛到Fairness，也就是相同RTT两者的资源占用量尽可能公平</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d45c7678848026b4bae0d0aed30f4676_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"692\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb\" width=\"692\" data-original=\"https://pic3.zhimg.com/v2-d45c7678848026b4bae0d0aed30f4676_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;692&#39; height=&#39;419&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"692\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"692\" data-original=\"https://pic3.zhimg.com/v2-d45c7678848026b4bae0d0aed30f4676_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d45c7678848026b4bae0d0aed30f4676_b.jpg\"/></figure><p>但是如果丢包频率高（信号不好时），尽管receiver没什么问题，window仍然会很小，导致性能受限，因此有很多新的协议。</p>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "计算机网络", 
                    "tagLink": "https://api.zhihu.com/topics/19572894"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/86919946", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 6, 
            "title": "SOSP|文件系统|OptFS:Opt Journal", 
            "content": "<blockquote>本文为CSE课程reading homework，如有口胡，纯属乱说。这篇文章好长啊吐血了。<br/>                                           Optimistic Crash Consistency <br/>Vijay Chidambaram, Thanumalayan Sankaranarayana Pillai, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau <br/>           Department of Computer Sciences University of Wisconsin, Madison <br/>                             {vijayc, madthanu, dusseau, remzi}@<a href=\"https://link.zhihu.com/?target=http%3A//cs.wisc.edu\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">cs.wisc.edu</span><span class=\"invisible\"></span></a></blockquote><a data-draft-node=\"block\" data-draft-type=\"link-card\" href=\"https://link.zhihu.com/?target=https%3A//research.cs.wisc.edu/adsl/Publications/optfs-sosp13.pdf\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">research.cs.wisc.edu/ad</span><span class=\"invisible\">sl/Publications/optfs-sosp13.pdf</span><span class=\"ellipsis\"></span></a><p><b>摘要</b></p><p>optimisitic crash consistency指的是乐观的维持文件系统崩溃一致性的方法，在已有的journal机制中进行优化。</p><p>作者对于Linux ext4进行了修改，称之为OptFS，并引入两个interface（primitive），osync和dsync，将order和durability进行了解耦。</p><p>保证了以下三点。</p><ul><li>consistency</li><li>performance</li><li>application demand for file system and database</li></ul><hr/><h2><b>                                                背景</b></h2><p><b>pre1：cache</b></p><p>磁盘具有cache，对磁盘读写并不会实时写入硬盘</p><p><b>pre2：durability</b></p><p>为了保证数据能够持久化写入磁盘（cache断电就会消失），磁盘有flush api，强制将所有cache中的数据写入磁盘。</p><p><b>pre3：journal</b></p><p>现代的文件系统使用journal机制用于进行crash的恢复。简单来说就是在磁盘中专门分一段区域存放日志，写入data后，并不会直接跟着写入metadata，而是要求先写入journal日志记录这次操作的全部信息，日志写完后再写入一个commit，等commit写完后再写入metadata。</p><p>如果发生了crash，那么文件系统可以根据最后一个journal来进行重复操作。例如data被更改，而metadata还没被修改，那么通过journal我们就可以让metadata恢复一致性。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-77103878d952e61b1ad96f01c882a033_b.jpg\" data-rawwidth=\"801\" data-rawheight=\"601\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"801\" data-original=\"https://pic4.zhimg.com/v2-77103878d952e61b1ad96f01c882a033_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;801&#39; height=&#39;601&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"801\" data-rawheight=\"601\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"801\" data-original=\"https://pic4.zhimg.com/v2-77103878d952e61b1ad96f01c882a033_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-77103878d952e61b1ad96f01c882a033_b.jpg\"/></figure><p>如上图，我们必须保证JC写入前，Data和JM 都已经被写入磁盘。 同时保证Metadata写入前，JC被写入磁盘。过去的程序往往使用flush强制cache写入磁盘，从而保证顺序。（如果数据都在cache里，那么无法得知谁先被写入）</p><p>问题在于，flush的开销极大，是对整个cache的操作，其他不需要实时写入的数据也会被刷入。此时durability 和 order被强制耦合了。</p><p>论文不再使用flush保证order，而是引入了新的接口，来提供async durability notification。即在写入时保证操作的有序，并且无需刷新cache。</p><p><b>pre4： novel technique</b></p><p>监测data/metadata一致性的checksum</p><p>避免空悬指针的延迟block reuse</p><p>正确处理block覆写的data journal技巧</p><hr/><h2><b>                                        悲观的崩溃一致性</b></h2><h2><b>磁盘接口</b></h2><p>cache flush命令在ATA驱动中，称为flush cache，在SCSI驱动中称为sync cache，他们都强制cache中的脏写被写入surface。flush可以独立，也可以作为write的一部分，强制写入前flush所有的cache。</p><p>细粒度的操作如force unit access（FUA）命令，使得写操作可以越过cache直接进surface，通常和flush合作。例如在A写入后，在B写入时同时使用flush与FUA，可以保证A全部被先写入，随后B直接进surface。</p><h2><b>悲观日志</b></h2><p>作者以Linux ext3和ext4的ordered mode作为讨论基础，ordered mode下，只journal metadata，而不会journal data，因为后者需要将数据完全拷贝一份，造成了双倍写负载。</p><p><b>事务内依赖关系</b></p><p>最早的依赖顺序为 <img src=\"https://www.zhihu.com/equation?tex=D%5Crightarrow+JM+%5Crightarrow+JC+%5Crightarrow+M\" alt=\"D\\rightarrow JM \\rightarrow JC \\rightarrow M\" eeimg=\"1\"/> 。</p><p>由于即使Data没有写入完全，根据JM也能恢复， 优化为<img src=\"https://www.zhihu.com/equation?tex=D+%7CJM+%5Crightarrow+JC+%5Crightarrow+M\" alt=\"D |JM \\rightarrow JC \\rightarrow M\" eeimg=\"1\"/> 。</p><p>此外，可以通过对于事务metadata产生checksum并存入JC，根据JC中的checksum判断JM是否被写入完全，优化为<img src=\"https://www.zhihu.com/equation?tex=D%5Crightarrow+JM%7CJC%5Crightarrow+M\" alt=\"D\\rightarrow JM|JC\\rightarrow M\" eeimg=\"1\"/> 。</p><p>但是，这两种优化不能共存，因为如果D没有写入就crash了，那么即使JM和JC校验正确也没用（除非你对整个D进行checksum，但是不现实）。</p><p><b>事务间依赖关系</b></p><p>上文的依赖顺序是事务内部的，但是事务间仍需保证顺序。如果T1释放了block A，T2中重用。如果T2commit后T1commit前crash了，那么A被分配给了两个文件。</p><p><b>悲观本质</b></p><ul><li>整个cache都会被flush，而实际上只有少部分cache真正需要进行flush。</li><li>磁盘写入的顺序可能是正确的，并不需要我们使用flush保证顺序。</li><li>我们使用flush付出了很大代价，但是所处理的crash情况却极为少见。</li></ul><h2><b>flush 性能影响</b></h2><p>作者在ext4下运行Varmail。进行了throughput的实验。结果很明显。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-bfc260a538d51f2954c79416ac0cb650_b.jpg\" data-rawwidth=\"438\" data-rawheight=\"198\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"438\" data-original=\"https://pic1.zhimg.com/v2-bfc260a538d51f2954c79416ac0cb650_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;438&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"438\" data-rawheight=\"198\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"438\" data-original=\"https://pic1.zhimg.com/v2-bfc260a538d51f2954c79416ac0cb650_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-bfc260a538d51f2954c79416ac0cb650_b.jpg\"/></figure><hr/><h2>                                             概率的崩溃一致性</h2><p>由于flush的性能开销，某些时候程序员会放弃绝对正确的做法，牺牲一定情况下的崩溃一致性。然而，某些情况下，跳过flush命令似乎并不会导致不一致性。Linux内核开发者Theodore Ts&#39;o猜测</p><blockquote>I suspect the real reason why we get away with it so much with ext3 is that the journal is usually contiguous on disk, hence, when you write to the journal, it’s highly unlikely that commit block will be written and the blocks before the commit block have not. ... The most important reason, though, is that the blocks which are dirty don’t get flushed out to disk right away!</blockquote><p><img src=\"https://www.zhihu.com/equation?tex=JM+%5Crightarrow+JC\" alt=\"JM \\rightarrow JC\" eeimg=\"1\"/> </p><p>因为JM和JC是连续的，因此JC被写入，而JM未被写入的概率是极小的。（和磁盘调度器和布局有关）</p><p><img src=\"https://www.zhihu.com/equation?tex=JC+%5Crightarrow+M\" alt=\"JC \\rightarrow M\" eeimg=\"1\"/> </p><p>由于JC写入后没有使用flush，metadata（脏block）很久之后才被刷入硬盘，变相维护了顺序。</p><p>我们称之为<b>概率的一致性</b>。典型的操作可能会也可能不会导致reorder从而导致不一致性。尽管他不保证一致性，但是很多开发者仍然喜欢使用，因为不用flush导致很大性能提升。</p><h2>量化概率一致性</h2><p>为了阐明问题，作者通过使用仿真的方法量化不一致性发生的概率。作者禁用了ext4的flush并且提取出ext4在不同workload下block-level的行为轨迹，并在一台模拟机DiskSim上运行。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e4560522fe9b0312eec2780ee5ea636c_b.jpg\" data-rawwidth=\"451\" data-rawheight=\"308\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"451\" data-original=\"https://pic1.zhimg.com/v2-e4560522fe9b0312eec2780ee5ea636c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;451&#39; height=&#39;308&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"451\" data-rawheight=\"308\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"451\" data-original=\"https://pic1.zhimg.com/v2-e4560522fe9b0312eec2780ee5ea636c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e4560522fe9b0312eec2780ee5ea636c_b.jpg\"/><figcaption>其实没啥用...感觉文字挺清晰的</figcaption></figure><p>输出结果是由于reorder导致vulnerable to inconsistency（易产生不一致性）的窗口期。例如，如果A应该在B前写入，而实际上B在A之前写入，那么A和B写入之间的时间就是窗口期。一旦crash了，那么就会导致不一致性。计算窗口期所占的比例即可判断其脆弱性。</p><h2>影响因子</h2><p><b>workload</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d97cef422275e67b96d2e93ab539fd54_b.jpg\" data-rawwidth=\"431\" data-rawheight=\"467\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"431\" data-original=\"https://pic1.zhimg.com/v2-d97cef422275e67b96d2e93ab539fd54_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;431&#39; height=&#39;467&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"431\" data-rawheight=\"467\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"431\" data-original=\"https://pic1.zhimg.com/v2-d97cef422275e67b96d2e93ab539fd54_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d97cef422275e67b96d2e93ab539fd54_b.jpg\"/></figure><p>以读为主的workload下，没有write cahce，Pinc肯定少。</p><p>以写为主的workload下，随意访问或者强制写入磁盘（fsync）都会导致较高的Pinc。</p><p>此外，还存在一定的混沌性，少数的reorder可能导致Pinc很大的不同。</p><p>极端情况下，Pinc也不会达到100%。</p><p>作者将所有的Pinc分为了几种，如early commit (commit提前写入), early checkpoint (Metadata提前写入), transaction misorder (事务间乱序), and mixed (多种错误同时发生)，不同workload和不同category如上图。可以看出，主要问题在于early commit。</p><p><b>queue size</b></p><p>作者研究了varmail，因为它的错误种类最多。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a89d33b34b4d27828ac182eb33d9d277_b.jpg\" data-rawwidth=\"424\" data-rawheight=\"244\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"424\" data-original=\"https://pic4.zhimg.com/v2-a89d33b34b4d27828ac182eb33d9d277_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;424&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"424\" data-rawheight=\"244\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"424\" data-original=\"https://pic4.zhimg.com/v2-a89d33b34b4d27828ac182eb33d9d277_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a89d33b34b4d27828ac182eb33d9d277_b.jpg\"/></figure><p>横轴为SPTF磁盘调度器队列长度（如果学过cpu调度器的应该知道，调度器决定哪个进程先执行，同理，磁盘调度器决定哪个事务先执行）。纵轴分别为Pinc和IO时间。</p><p>Qsize为1时，不可能发生乱序。（如果使用FIFO调度器那么同理）</p><p>Qsize很小（8）时，就会导致很大的不一致性。与此同时，也造成了很大的性能提升，约百分之30。</p><p><b>journal layout</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a97d5e3c397a063f25c219d9f061b4ed_b.jpg\" data-rawwidth=\"443\" data-rawheight=\"303\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"443\" data-original=\"https://pic2.zhimg.com/v2-a97d5e3c397a063f25c219d9f061b4ed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;443&#39; height=&#39;303&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"443\" data-rawheight=\"303\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"443\" data-original=\"https://pic2.zhimg.com/v2-a97d5e3c397a063f25c219d9f061b4ed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a97d5e3c397a063f25c219d9f061b4ed_b.jpg\"/></figure><p>作者还研究了journal布局造成的影响。增大journal和data的距离主要减少了 <img src=\"https://www.zhihu.com/equation?tex=D+%5Crightarrow+JC\" alt=\"D \\rightarrow JC\" eeimg=\"1\"/> 发生reorder的概率（上文中提到了主要问题是early commit）。同时，增大距离并不能一直减少Pinc，也会导致一定的性能开销。</p><hr/><h2>                                             乐观的崩溃一致性</h2><p>传统方法只能通过悲观flush解决，因此用户不得不舍弃一定的一致性保证性能，从而变成概率的一致性。而在不同的workload下，没有万灵药能保证概率的一致性始终保持较高的水准。由于硬件实力越来越精妙，可以处理很多先进的请求，不一致性发生的概率变得更高了。因此，在概率的一致性之上（完全抛弃flush），系统应该有机制避免不一致性并且能够在不一致发生时检测和恢复。因此作者提出了乐观崩溃一致性。</p><p>乐观一致性的目标是，能够像悲观一致性那样保证绝对的一致性，同时又能保证几乎和概率一致性对等的性能，通过optimistic journaling进行实现。达成这个目标只需要在磁盘接口、和文件系统的journal层做一些改动。</p><p>两个基本点</p><ol><li>checksum能取消write的order需求，一旦checksum校验不上，直接丢弃JM</li><li>asynchronous durability notification用于延迟transaction的checkpoint直到commit</li></ol><p>加上之前pre4的三点中后两者，就是OptFS的改动了。</p><ul><li>监测data/metadata一致性的checksum</li><li>避免空悬指针的延迟block reuse（overwrite）</li><li>正确处理block覆写的data journal技巧</li></ul><h2>Asynchronous Durability Notification（异步持久性通知，简ADN）</h2><p>实际的写入顺序和持久化其实并没有什么影响，只有发生crash才有意义，因此现在的磁盘接口其实限制了IO性能。如果磁盘不再关注读写顺序，就在common case下优化了性能。</p><p>在取消了顺序后，为了保持一致性和持久性，作者建议磁盘添加一个最小拓展，ADN，通知上级特定的写请求已经完成并且持久化。</p><p>写请求时，采用ADN进行异步通知；</p><p>持久化写如FUA时，则提供同步通知，当持久化完成时发出。Tagged Queuing（中间插入command叫TCQ）也允许有限的请求在指定的时间点被处理。（SCSI支持上面的TCQ和FUA，但是很多驱动不支持，TCQ资料好难查，原文链接过期了好像）。</p><p>尽管FUA和TQ足够实现乐观一致性，但是作者认为解耦 请求确认 和 持久化能够实现更好的IO并发性。</p><h2>乐观一致性性质</h2><p>尽管不要求磁盘以一定的顺序写，但是仍然能保证一致性。作者进行了一定的假设，block在事务之间没有被reuse（在其后会解决）。具体流程示例如下所示，</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3f315452714f28ba2b7bbbfabcccf62c_b.jpg\" data-rawwidth=\"429\" data-rawheight=\"408\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"429\" data-original=\"https://pic1.zhimg.com/v2-3f315452714f28ba2b7bbbfabcccf62c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;429&#39; height=&#39;408&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"429\" data-rawheight=\"408\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"429\" data-original=\"https://pic1.zhimg.com/v2-3f315452714f28ba2b7bbbfabcccf62c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3f315452714f28ba2b7bbbfabcccf62c_b.jpg\"/></figure><p>图中存在着四个事务，0123，以:n表示。方形表示已经得到了通知，云表示开始写，但是还没通识，原表示内存的数据。虚线表示依赖关系，实线表示metadata可能引用datablock。</p><p>对事务0，文件系统已经得到了Tx：0（D：0，JM：0，JC：0）持久化通知，因此正将M：0指向检查点（可能是D：0）。当M：0检查点完成后，可以通知文件系统删除相关的Journal。中途即使crash，由于Journal已持久化，Tx：0会再次进行，并且恢复。</p><p>对事务1，此时D：1还没有被持久化，因此M1不应该被checkpoint。如果在此时M1进行了checkpoint，并发生crash，M:1会指向垃圾数据，从而与Ck（D:1,M:1）不匹配，不再执行Tx:1。这样仅仅是D:1被覆写错误数据。</p><p>对事务2，可以与D：1并行，由于JC:2还没有持久化，crash后仍然可以轻松的检测出不匹配。</p><p>对事务3, 尽管D：3，JM：3，JC：3都是持久化的，但由于M：3所依赖的JC：2，D：1没有持久化，M：3仍然无法被checkpoint。</p><h2>乐观技术</h2><p>上述过程依赖于几个技术</p><ul><li>inorder journal recovery and release</li><li>checksum </li><li>background writes after notification</li><li>reuse after notification</li><li>selective data journaling</li></ul><p><b>in-order journal recovery</b></p><p>顺序遍历所有事务journal，依次校验直到第一个没有通过校验的事务，并丢弃之后的所有事务。</p><p><b>in-order journal release</b></p><p>必须确保所有相关metadata的checkpoint write都持久化后才能释放journal。仅当此时文件系统才知道这个事务不会需要重演。为了确保后一个事务应后于前一个事务持久化（recovery丢弃的前提），free的时候也应该按照顺序。</p><p><b>data transactional checksumming</b></p><p>作者不止使用metadata生成checksum（metadata transactional checksumming），还额外使用data。即优化为<img src=\"https://www.zhihu.com/equation?tex=D%7C+JM%7CJC%5Crightarrow+M\" alt=\"D| JM|JC\\rightarrow M\" eeimg=\"1\"/> 。为了这个目的在JC中加入了D的地址。从而确保了在D写入前，metadata不会被checkpoint。</p><p><b>background write after notification</b></p><p>直到D、JM、JC都写入后才能出现M的checkpoint，因为如果写入了M，那么我们认为这个事务有效且可以重播。为了确保Tx:i如果无法replay，M:i+1一定没有持久化（否则recoveryu丢弃的时候会留下脏的Metadata），M:i+1必须推迟到前面所有事务都持久化后才能被写入，但它并不需要等待M：i，因为如果之前的事务已经持久化了，通过JM我们可以replay生成M:i。</p><p>这里比较重要的操作在于检查点等待，但是由于这是<b>异步操作</b>，可以放在后台进行，因此效率上并不会有什么影响。相比于使用传统的flush方法限制顺序，可以推迟跨事务的检查点写入，并且给磁盘提供更多的灵活性，供磁盘缓存或者调度。</p><p>JC+JM+D这三件套如果没依赖可以直接随意进行，反正只要事务都持久化了，M可以随便recover；而如果没有持久化，在没有M的情况下只不过是多了点可以删除的脏数据。而对M的写入可以并行于事务的持久化进行。（给我的感觉有点像是super scalar那里）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b154770cc3f9dbd19b59fa766af196f9_b.jpg\" data-rawwidth=\"550\" data-rawheight=\"606\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic2.zhimg.com/v2-b154770cc3f9dbd19b59fa766af196f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;606&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"550\" data-rawheight=\"606\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic2.zhimg.com/v2-b154770cc3f9dbd19b59fa766af196f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b154770cc3f9dbd19b59fa766af196f9_b.jpg\"/><figcaption>事务之间没有依赖的话类似于这样</figcaption></figure><blockquote>一个小问题：为什么下面一个说是前面的全部持久化，一个只说了Tx:i持久化？个人感觉Tx:i是错的。<br/>optimistic journaling explicitly postpones the checkpoint write of metadata M until it has been notified that all previous transactions have been durably completed. <br/>We note that M:i+1 does not need to wait for M:i to complete, but must instead wait for the responsible transaction T x:i to be durable</blockquote><p><b>Reuse after Notification</b></p><p>问题在于，之后写入的D可能被之前的metadata引用。例如上文，如果Tx1释放了block A，Tx2中重用并写入B。如果后者先写入的话，那么Tx1实际上free了B。</p><p>作者定义只有free的事务写入完全后，block才是durably free的，而allocate操作时只能复用durably free的block（通过ADN判断）。这样必须留出一定的空余磁盘空间作为缓冲，否则是无法找到durably free的block的。</p><p>也就是说，在异步操作仍在进行的时候，ADN给block上了一道锁，避免了其他事务进行reuse。</p><p><b>Selective Data Journaling</b></p><p>某些时候后面的数据会覆写之前的block，造成无法恢复。</p><p>可行的做法是，分配新的durably free的block，并修改metadata，这种思想来自于COW（copy on write），然而也会相比于update-in-place丧失一些locality。</p><p>新技术顾名思义，就是把data放到journal里，但是仅当overwrite时才会进行。不过规则不同，变成了 <img src=\"https://www.zhihu.com/equation?tex=JD%7CJM%7CJC%5Crightarrow+D%7CM\" alt=\"JD|JM|JC\\rightarrow D|M\" eeimg=\"1\"/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d95b2a6620f6bc4ca80a3a8f0be3a47a_b.jpg\" data-rawwidth=\"663\" data-rawheight=\"482\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic3.zhimg.com/v2-d95b2a6620f6bc4ca80a3a8f0be3a47a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;482&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"663\" data-rawheight=\"482\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic3.zhimg.com/v2-d95b2a6620f6bc4ca80a3a8f0be3a47a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d95b2a6620f6bc4ca80a3a8f0be3a47a_b.jpg\"/></figure><p>事务1-避免指向垃圾数据：M先持久化，crash，指向垃圾数据，但是通过JD可以恢复</p><p>事务2/3-只有之前已经全部overwrite，后续才能overwrite：</p><p>这个和M类似，只不过变成了D和M必须在前面所有的事务都持久化后才能持久化。也就是说前面的JD都存了下来。即使当前事务失败，根据之前的事务也能恢复overwrite。</p><h2>Durability vs. Consistency</h2><p>为了解耦durability和consistency，作者进行了一定的接口设计，称为osync和dsync，o意为order，d意为durability。osync应该就是ADN来实现的，后面的write等前者持久化通知后再进行。</p><p>进行n次写操作 W1,...,Wn</p><p>每次写后不使用sync：完全乱序</p><p>每次写后使用dsync：恢复至W1,...Wi（如果Wi后crash）</p><p>每次写后使用osync：恢复至W1,...Wi-k（如果Wi后crash），后k次写没有持久化（异步），但是仍然保持一致性。</p><hr/><h2><br/>实现 <br/>评估<br/>实例研究</h2><p>略，感兴趣自行见原文。这论文字数真多，大脑在颤抖，不说了，写作业去了</p>", 
            "topic": [
                {
                    "tag": "文件系统", 
                    "tagLink": "https://api.zhihu.com/topics/19560370"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87160968", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 4, 
            "title": "C++|编译器|活动记录（栈帧）", 
            "content": "<p>活动记录（Activation  Record），常称栈帧（stack frame）。需要注意的是，在支持闭包的语言中，活动记录未必在栈上，因为函数返回仍需访问其中的变量，因此活动记录应作为环境保存下来。</p><h2>Activation Record</h2><p>过程的调用是过程的一次活动，当过程语句（及其调用）结束后，活动生命周期结束。</p><p>变量的生命周期为其从被定义后有效存在的时间。（dynamic，和scope不同，比如每次调函数都会创建一个新的生命周期）</p><p>为了正确地管理一个过程的活动，我们需要活动记录存储相关信息。内存布局如下：</p><p>Prev Frame Pointer-&gt;——————————————</p><p>                                 上一个栈帧传入的参数</p><p>                                  返回地址(可能在寄存器里，如RISC）</p><p>Frame Pointer（%rbp-&gt; —————————————</p><p>                                    callee-save的寄存器（保护先前寄存器的值）</p><p>                                    局部变量、临时变量（RISC将前六个局部变量放在寄存器）</p><p>                                     返回值（多返回值的情况）</p><p>              静态链（支持嵌套函数，内层持有外层栈帧的指针，以调用外部函数的变量）</p><p>Stack Pointer（%rsp）-&gt; —————————————</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这些活动记录应当尽可能放在寄存器里，以减少内存访问。</p><hr/><h2>Call</h2><p>l-value，左值，如x=y+1的x，我们关心x的地址</p><p>r-value，右值，如x=y+1的y+1，我们关心y+1的字面值</p><p><b>Call-by-Value</b></p><p>形参作为local name，活动记录中存储形参，caller只是计算实参的右值，并且将值传入形参的地址。</p><p><b>Call-by-Reference</b></p><p>如果实参（变量or表达式）为左值，传递左值本身。</p><p>如果实参（表达式）为右值，那么在一个地方求值后传递地址。</p><p><b>Call-by-Restore</b></p><p>传入的时候传入右值，返回时把结果的右值全部倒回之前的左值里（想起了辣鸡Matlab的语法）</p><p><b>Call-by-Name</b></p><p>如宏。意思是这个参数并不是开始就求值，而是在函数的每次实际调用再进行解析。</p><p>找了个Scala的博客<a href=\"https://link.zhihu.com/?target=http%3A//blog.sina.com.cn/s/blog_521e9ecc0102xpcg.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">blog.sina.com.cn/s/blog</span><span class=\"invisible\">_521e9ecc0102xpcg.html</span><span class=\"ellipsis\"></span></a> ,by name每次调用时，表达式都会被重复执行一次（造成了多次side effect，98765递减5次，而4只减了1次）</p><div class=\"highlight\"><pre><code class=\"language-scala\"><span class=\"k\">def</span> <span class=\"n\">printByName</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"k\">:</span> <span class=\"o\">=&gt;</span> <span class=\"nc\">Int</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Unit</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"k\">&lt;-</span> <span class=\"mi\">0</span> <span class=\"n\">until</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n      <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"k\">def</span> <span class=\"n\">printByValue</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"k\">:</span> <span class=\"kt\">Int</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Unit</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"k\">&lt;-</span> <span class=\"mi\">0</span> <span class=\"n\">until</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n      <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">printByName</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">)</span> <span class=\"c1\">//9 8 7 6 5 \n</span><span class=\"c1\"></span>  <span class=\"n\">printByValue</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">)//</span> <span class=\"mi\">4</span> <span class=\"mi\">4</span> <span class=\"mi\">4</span> <span class=\"mi\">4</span> <span class=\"mi\">4</span> </code></pre></div><blockquote>简单说来就是一个是将未计算的参数表达式直接应用到函数内部， 一个是计算参数表达式的值，传入函数计算。<br/>This indicates that the argument is not evaluated at the point of function application, but instead is evaluated at each use within the function. That is, the argument is evaluated using call-by-name.</blockquote><p><b>Callee-saved Register</b></p><p>Callee在占用寄存器前，先存入栈，执行完成后再恢复。尽管看起来到头来参数还是要入内存，但是在执行过程中，参数的使用是通过寄存器进行的。</p><p><b>In-register Parameter</b></p><p>以下情况参数必须进内存(variable escape)</p><ul><li>需要取址</li><li>传引用</li><li>被嵌套的函数调用</li></ul><p>以下情况参数在特定环境下必须进内存，并不能断定</p><ul><li>参数大小大于寄存器大小</li><li>register有特殊需求不能被占用（例如汇编要求占用寄存器）</li><li>局部变量数量多于可用寄存器数目</li></ul><p>在C中，某些可变参数函数（printf）需要所有的参数都是连续分配的，那么不能使得某些参数在寄存器，某些在内存。很多现代标准中，caller会为寄存器变量仍然分配内存空间，只有callee需要时才会把值真正填进去。</p><hr/><h2>嵌套过程</h2><p><b>静态链（Static Link)</b></p><p>嵌套函数中，内部函数调用的栈帧可见外部函数调用的栈帧中的变量。</p><p>以frame pointer作为第一个参数（不一定是当前的栈帧，而是callee的上层）传递给callee作为static link，可以通过static link回溯上一层、上上层的栈帧，最终获得外部的变量。（隐式链表）</p><p>类似于对象第一个参数隐式<b>传this指针</b>，因此类的方法能够访问类的field，但是这个原理又大相径庭，这个其实是建立了一个栈帧链表。</p><p>当前过程和nonlocal变量的嵌套深度差，是所需link的次数。编译期已知。</p><p>如果儿子1调用儿子2，那么事实上儿子1是通过父亲访问到的儿子2，因此不能直接传儿子1的栈帧，而是先回溯到父亲的栈帧，再把父亲的栈帧指针作为第一个参数传递给儿子2.</p><p><b>嵌套层次显示表（Display）</b></p><p>嵌套层次显示表是帧指针组成的数组，下标为深度。元素Di指向最近被调用的嵌套深度为i的函数（听起来所有的函数公用一张表）</p><p>执行嵌套深度为i的函数时，对Di进行callee-save 并且更新Di。</p><p>入口出口由于callee-save需要的指令更多，但是由于采用数组而不是链表，在随机访问上则更占据优势。</p><p><b><i><img src=\"https://www.zhihu.com/equation?tex=%5Clambda\" alt=\"\\lambda\" eeimg=\"1\"/></i> 提升（Lambda Lifting）</b></p><p>将父函数中每一个被子函数（或者孙子、曾孙...）访问的变量作为额外的参数按引用传递给子函数。听起来就属于<img src=\"https://www.zhihu.com/equation?tex=%5Clambda\" alt=\"\\lambda\" eeimg=\"1\"/>演算的术语，适合函数式编程，如果父函数中的变量都是unmutable，函数都是pure function就好办了，直接传值就行了。</p><p>难点在于语义分析时还得找出函数访问的上层变量，实现的时候未必简单。</p><hr/><h2>Implementation</h2><p><b>Frame</b></p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">F_frame_</span> <span class=\"o\">*</span><span class=\"n\">F_frame</span> <span class=\"p\">;</span>\n<span class=\"n\">F_frame</span> <span class=\"nf\">F_newFrame</span><span class=\"p\">(</span><span class=\"n\">Temp_label</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">U_boolList</span> <span class=\"n\">formals</span><span class=\"p\">);</span></code></pre></div><p>虎书上没有给出具体实现，而是给出了ADT，避免机器依赖。（emmm，好像lab要我们写实现）</p><p>newFrame第一个参数表示函数名，第二个是一个bool链表，T表示逃逸（在存储器中）。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">struct</span> <span class=\"n\">F_access_</span> <span class=\"p\">{</span>\n\t<span class=\"k\">enum</span> <span class=\"p\">{</span><span class=\"n\">inFrame</span><span class=\"p\">,</span> <span class=\"n\">inReg</span><span class=\"p\">}</span> <span class=\"n\">kind</span><span class=\"p\">;</span>\n\t<span class=\"k\">union</span> <span class=\"p\">{</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">offset</span><span class=\"p\">;</span>\t\t<span class=\"cm\">/* InFrame */</span>\n\t\t<span class=\"n\">Temp_temp</span> <span class=\"n\">reg</span><span class=\"p\">;</span>\t\t<span class=\"cm\">/* InReg */</span>\n\t<span class=\"p\">}</span> <span class=\"n\">u</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">Temp_temp_</span> <span class=\"p\">{</span><span class=\"kt\">int</span> <span class=\"n\">num</span><span class=\"p\">;};</span>\n<span class=\"k\">static</span> <span class=\"n\">F_access</span> <span class=\"nf\">Inframe</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">offset</span><span class=\"p\">);</span>   <span class=\"k\">static</span> <span class=\"n\">F_access</span> <span class=\"nf\">InReg</span><span class=\"p\">(</span><span class=\"n\">Temp_temp</span> <span class=\"n\">reg</span><span class=\"p\">);</span>\n\n<span class=\"n\">F_accessList</span> <span class=\"nf\">F_formals</span><span class=\"p\">(</span><span class=\"n\">F_frame</span> <span class=\"n\">f</span><span class=\"p\">);</span>\n<span class=\"n\">F_access</span> <span class=\"nf\">F_allocLocal</span><span class=\"p\">(</span><span class=\"n\">F_frame</span> <span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"kt\">bool</span> <span class=\"n\">escape</span><span class=\"p\">);</span></code></pre></div><p><b>F_access</b>则描述栈或者寄存器中的形参和局部变量，里面存了变量相对于栈帧指针的偏移量或者临时变量编号(间接层，由寄存器分配器处理，一方面方便优化使用尽可能少的寄存器，一方面寄存器不足时分配到内存里）。</p><p><b>F_allocLocal</b>在栈帧上分配局部变量。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">struct</span> <span class=\"n\">F_accessList_</span> <span class=\"p\">{</span> <span class=\"n\">F_access</span> <span class=\"n\">head</span><span class=\"p\">;</span> <span class=\"n\">F_accessList</span> <span class=\"n\">tail</span><span class=\"p\">};</span>\n<span class=\"n\">F_accessList</span> <span class=\"nf\">F_formals</span><span class=\"p\">(</span><span class=\"n\">F_frame</span> <span class=\"n\">f</span><span class=\"p\">);</span></code></pre></div><p><b>F_formals </b>传回所有的参数，需要注意，这里的F_access是针对callee而言的（caller把static link 放进寄存器，callee把他放进内存，两者视角不同，称为<b>View Shift</b>）</p><p>因此newFrame需要进行额外的工作处理View Shift（machine dependent）</p><ul><li>处理参数在函数内部的布局</li><li>实现指令（例如frame pointer + offset作为内存地址）</li><li>过程入口frame pointer &lt;- stacck pointer</li></ul><p>存储以下信息</p><ul><li>formal的位置</li><li>实现view shift的指令</li><li>局部变量数目</li><li>机器码开始处的标签</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">Formals</span>\n<span class=\"err\">–</span><span class=\"n\">InFrame</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">)</span>\n<span class=\"err\">–</span><span class=\"n\">InFrame</span><span class=\"p\">(</span><span class=\"mi\">12</span><span class=\"p\">)</span>\n<span class=\"err\">–</span><span class=\"n\">InFrame</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">)</span>\n<span class=\"n\">View</span> <span class=\"n\">Shift</span>\n<span class=\"err\">–</span><span class=\"n\">pushl</span> <span class=\"o\">%</span><span class=\"n\">ebp</span>\n<span class=\"err\">–</span><span class=\"n\">movl</span> <span class=\"o\">%</span><span class=\"n\">esp</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"n\">ebp</span>\n<span class=\"err\">–</span><span class=\"n\">subl</span> <span class=\"err\">$</span><span class=\"n\">K</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"n\">esp</span></code></pre></div><p><b>Local</b></p><ul><li>寄存器中的变量会优化，尽可能使用少的寄存器</li><li>Frame中的变量会优化，两个变量可能先后共用同一个槽</li><li>由于嵌套block，可能某个变量多次声明在不同block中，可以为变量声明保留专门的槽，只在block结束后遗忘关联。</li></ul><p><b>Escape</b></p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">EscapeEntry</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">escape</span><span class=\"p\">))</span></code></pre></div><p>一开始所有的变量均设为 not escape，记录其嵌套深度，如果某个变量被嵌套的函数所访问（需要通过静态链去内存找），则成为escape</p><p>Tiger没有寻址，如果有寻址操作也escape</p><p><b>Label</b></p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">struct</span> <span class=\"n\">Temp_temp_</span> <span class=\"p\">{</span><span class=\"kt\">int</span> <span class=\"n\">num</span><span class=\"p\">;};</span>\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">Temp_temp_</span> <span class=\"o\">*</span><span class=\"n\">Temp_temp</span><span class=\"p\">;</span>\n<span class=\"n\">Temp_temp</span> <span class=\"nf\">Temp_newTemp</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">);</span><span class=\"c1\">// from  set\n</span><span class=\"c1\"></span><span class=\"k\">typedef</span> <span class=\"n\">S_symbol</span> <span class=\"n\">Temp_label</span><span class=\"p\">;</span> \n<span class=\"n\">Temp_label</span> <span class=\"nf\">Temp_newlabel</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">);</span><span class=\"c1\">// from  set\n</span><span class=\"c1\"></span><span class=\"n\">Temp_label</span> <span class=\"nf\">Temp_namedlabel</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">);</span>\n<span class=\"n\">string</span> <span class=\"nf\">Temp_labelstring</span><span class=\"p\">(</span><span class=\"n\">Temp_label</span><span class=\"p\">);</span></code></pre></div><p>由于要知道具体的地址或者寄存器可用情况很难，先用抽象指代其位置。new生成新的标号。</p><p>Temp 局部变量抽象名（以后映射到寄存器或内存）</p><p>Label 存储器地址抽象名（生成机器代码地址的标号）</p><p><b>环境</b></p><p>栈帧本身并不负责跟踪level，这个应该是语义分析阶段的事。</p><p>在环境中需要跟踪level信息</p><p>如果发现了函数声明，那么Tr_newLevel()更新level存入entry，并且在newlevel中调用newFrame，且将static link作为第一个参数。</p><p>如果发现了局部变量声明，那么Tr_allocLocal(lev, esc) 在lev层alloc变量，并且Tr_access保存分配入口。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">struct</span> <span class=\"n\">Tr_level_</span> <span class=\"p\">{</span> <span class=\"n\">F_frame</span> <span class=\"n\">f</span><span class=\"p\">;</span> <span class=\"kt\">int</span> <span class=\"n\">level</span><span class=\"p\">;</span> <span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">Tr_access_</span> <span class=\"p\">{</span> <span class=\"n\">Tr_level</span> <span class=\"n\">level</span><span class=\"p\">;</span> <span class=\"n\">F_access</span> <span class=\"n\">access</span><span class=\"p\">;</span> <span class=\"p\">};</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">E_enventry_</span> <span class=\"p\">{</span>\n <span class=\"k\">enum</span> <span class=\"p\">{</span><span class=\"n\">E_varEntry</span><span class=\"p\">,</span> <span class=\"n\">E_funEntry</span><span class=\"p\">}</span> <span class=\"n\">kind</span><span class=\"p\">;</span>\n <span class=\"k\">union</span> <span class=\"p\">{</span>\n <span class=\"k\">struct</span> <span class=\"p\">{</span><span class=\"n\">Tr_access</span> <span class=\"n\">access</span><span class=\"p\">;</span> <span class=\"n\">Ty_ty</span> <span class=\"n\">ty</span><span class=\"p\">;</span> <span class=\"p\">}</span> <span class=\"n\">var</span> <span class=\"p\">;</span>\n <span class=\"k\">struct</span> <span class=\"p\">{</span><span class=\"n\">Tr_level</span> <span class=\"n\">level</span><span class=\"p\">;</span> <span class=\"n\">Temp_label</span> <span class=\"n\">label</span><span class=\"p\">;</span>\n  <span class=\"n\">Ty_tyList</span> <span class=\"n\">formals</span><span class=\"p\">;</span> <span class=\"n\">Ty_ty</span> <span class=\"n\">result</span><span class=\"p\">;</span> <span class=\"p\">}</span> <span class=\"n\">fun</span> <span class=\"p\">;</span>\n <span class=\"p\">}</span> <span class=\"n\">u</span> <span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "编译器", 
                    "tagLink": "https://api.zhihu.com/topics/19608032"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87102231", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 1, 
            "title": "C|计算机网络|Network Layer-路由层", 
            "content": "<blockquote>All from CSE course in IPADS SE SJTU</blockquote><h2>Background</h2><p><b>Network(Router): IP address</b></p><p>负责next hop。每个路由有route table，根据路由协议（防止呈环），逐渐找到正确的地址。</p><p><b>Feature</b></p><ul><li>Discard Packet</li></ul><p>IP地址是best-effort网络（尽力），因此如果无法dispatch，会丢包。</p><p>另一种是store-and-forward network（Guaranteed-delivery），这种网络追踪所有的消息并进行出错处理，以确保消息没有丢失（一般是一整条消息，而不是某个包）</p><p>后者一般在更高的层次进行处理，而IP地址只保证尽力。</p><ul><li>Duplicate Packet</li></ul><p>超时重发，这导致用户必须处理多次重复的request和response，根据实际情况决定如何处理</p><h2>Network Layer</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d5d725731c25fc55f4a90196bcd2c80c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"363\" data-rawheight=\"311\" class=\"content_image\" width=\"363\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;363&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"363\" data-rawheight=\"311\" class=\"content_image lazy\" width=\"363\" data-actualsrc=\"https://pic1.zhimg.com/v2-d5d725731c25fc55f4a90196bcd2c80c_b.jpg\"/></figure><p><b>Router</b></p><p>当包进来时，路由器根据路由表，决定包的下一个网口出口。路由表通常放在cache里，以确保查表的效率。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-584d49ac1df92c29233b6eb389e33b34_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"356\" class=\"origin_image zh-lightbox-thumb\" width=\"603\" data-original=\"https://pic1.zhimg.com/v2-584d49ac1df92c29233b6eb389e33b34_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;603&#39; height=&#39;356&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"356\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"603\" data-original=\"https://pic1.zhimg.com/v2-584d49ac1df92c29233b6eb389e33b34_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-584d49ac1df92c29233b6eb389e33b34_b.jpg\"/></figure><p>由于网络的多变，不能使用静态的Route Table。路由器需要计算资源进行下面这些事，从而实现适应性的路由。</p><ul><li>计算最佳路径</li><li>链接改变时重新计算表</li><li>链接失败时重新计算表</li><li>堵塞时进行适配</li></ul><p>可以把路由的职责分为两部分。读表称为Data-plane，根据规则决定数据如何转发。写表称为Control-plane，决定如何建立路由表，定义规则。</p><h2>Data Plane - packet forwarding</h2><p><b>API</b></p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">struct</span> <span class=\"n\">packet</span> <span class=\"p\">{</span>\n <span class=\"n\">bit_string</span> <span class=\"n\">source</span> <span class=\"c1\">//起点\n</span><span class=\"c1\"></span> <span class=\"n\">bit_string</span> <span class=\"n\">destination</span> <span class=\"c1\">//终点\n</span><span class=\"c1\"></span> <span class=\"n\">bit_string</span> <span class=\"n\">end_protocol</span> <span class=\"c1\">//上层协议\n</span><span class=\"c1\"></span> <span class=\"n\">bit_string</span> <span class=\"n\">payload</span> <span class=\"c1\">//包\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n\n<span class=\"n\">NETWORK_SEND</span> <span class=\"p\">(</span><span class=\"n\">segment_buffer</span><span class=\"p\">,</span> <span class=\"n\">destnation</span><span class=\"p\">,</span> <span class=\"n\">network_protocol</span><span class=\"p\">,</span> <span class=\"n\">end_layer_protocol</span><span class=\"p\">){</span>\n<span class=\"n\">packet</span> <span class=\"n\">instance</span> <span class=\"n\">outgoing_packet</span> \n<span class=\"n\">outgoing_packet</span><span class=\"p\">.</span><span class=\"n\">payload</span> <span class=\"err\">←</span> <span class=\"n\">segment_buffer</span> \n<span class=\"n\">outgoing_packet</span><span class=\"p\">.</span><span class=\"n\">end_protocol</span> <span class=\"err\">←</span> <span class=\"n\">end_protocol</span> \n<span class=\"n\">outgoing_packet</span><span class=\"p\">.</span><span class=\"n\">source</span> <span class=\"err\">←</span> <span class=\"n\">MY_NETWORK_ADDRES</span> \n<span class=\"n\">outgoing_packet</span><span class=\"p\">.</span><span class=\"n\">destination</span> <span class=\"err\">←</span> <span class=\"n\">destination</span> \n<span class=\"n\">NETWORK_HANDLE</span> <span class=\"p\">(</span><span class=\"n\">outgoing_packet</span><span class=\"p\">,</span> <span class=\"n\">net_protocol</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">NETWORK_HANDLE</span> <span class=\"p\">(</span><span class=\"n\">packet</span><span class=\"p\">,</span> <span class=\"n\">network_protocol</span><span class=\"p\">){</span>\n<span class=\"n\">packet</span> <span class=\"n\">instance</span> <span class=\"n\">net_packet</span> \n    <span class=\"k\">if</span> <span class=\"n\">net_packet</span><span class=\"p\">.</span><span class=\"n\">destination</span> <span class=\"o\">!=</span> <span class=\"n\">MY_NETWORK_ADDRESS</span> <span class=\"n\">then</span>\n        <span class=\"n\">next_hop</span> <span class=\"err\">←</span> <span class=\"n\">LOOKUP</span> <span class=\"p\">(</span><span class=\"n\">net_packet</span><span class=\"p\">.</span><span class=\"n\">destination</span><span class=\"p\">,</span> <span class=\"n\">forwarding_table</span><span class=\"p\">)</span>\n        <span class=\"n\">LINK_SEND</span> <span class=\"p\">(</span><span class=\"n\">net_packet</span><span class=\"p\">,</span> <span class=\"n\">next_hop</span><span class=\"p\">,</span> <span class=\"n\">link_protocol</span><span class=\"p\">,</span> <span class=\"n\">net_protocol</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span>\n        <span class=\"n\">GIVE_TO_END_LAYER</span> <span class=\"p\">(</span><span class=\"n\">net_packet</span><span class=\"p\">.</span><span class=\"n\">payload</span><span class=\"p\">,</span> \n                          <span class=\"n\">net_packet</span><span class=\"p\">.</span><span class=\"n\">end_protocol</span><span class=\"p\">,</span> <span class=\"n\">net_packet</span><span class=\"p\">.</span><span class=\"n\">source</span><span class=\"p\">)</span>\n<span class=\"p\">}</span></code></pre></div><p>这里的send会调用handle，因为handle本身也存在着转发的职责，相当于handle处理了本地机器让你发出的信息、其他路由让你转发的信息、给本地机器的信息。</p><p>如果路由是终点，那么就GIVE_TO_END_LAYER，由上层进行处理（如TDP）。</p><p>否则先LOOKUP next hop（找不到就丢包），更新TTL（为0丢包）和header的checksum，再通过网口交由Link Layer进行转发。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>NAT（Network Address Translation）</b></p><p>对于私有网络,公开的路由无法进行内网的路由，导致丢包。</p><p>如下图，Send时，NAT可以把原始的地址+端口翻译成临时的公网地址（端口to端口的映射），由路由器记住这种对应关系，Receive时再翻译回去。</p><p><b>缺陷 </b></p><ul><li>某些e2e协议在payload放了IP（解包后就尴尬了hhh）</li><li>翻译可能是瓶颈（端口数有限塞不下）</li><li>多个私网无法合并</li><li>违背了分层原则（暴露了port给network层）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bf93857a9d18ba608c7e0dea3c34bf36_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"956\" data-rawheight=\"498\" class=\"origin_image zh-lightbox-thumb\" width=\"956\" data-original=\"https://pic3.zhimg.com/v2-bf93857a9d18ba608c7e0dea3c34bf36_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;956&#39; height=&#39;498&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"956\" data-rawheight=\"498\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"956\" data-original=\"https://pic3.zhimg.com/v2-bf93857a9d18ba608c7e0dea3c34bf36_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bf93857a9d18ba608c7e0dea3c34bf36_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>INTERNET/ETHERNET MAPPING</b></p><p>以太网使用MAC物理地址，目前作为局域网</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cf78ec71a30ab12e3a960b3a5957f68d_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"869\" data-rawheight=\"66\" class=\"origin_image zh-lightbox-thumb\" width=\"869\" data-original=\"https://pic2.zhimg.com/v2-cf78ec71a30ab12e3a960b3a5957f68d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;869&#39; height=&#39;66&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"869\" data-rawheight=\"66\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"869\" data-original=\"https://pic2.zhimg.com/v2-cf78ec71a30ab12e3a960b3a5957f68d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cf78ec71a30ab12e3a960b3a5957f68d_b.png\"/></figure><p>经典的以太网使用CSMA/CD监听信道冲突。 </p><p><b>Hub</b></p><p>线上只能同时发一个包，发包前需要监听信道，确认空闲后才能发包。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-51281f5a5a85b0404f449006c9ffd856_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"824\" data-rawheight=\"120\" class=\"origin_image zh-lightbox-thumb\" width=\"824\" data-original=\"https://pic3.zhimg.com/v2-51281f5a5a85b0404f449006c9ffd856_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;824&#39; height=&#39;120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"824\" data-rawheight=\"120\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"824\" data-original=\"https://pic3.zhimg.com/v2-51281f5a5a85b0404f449006c9ffd856_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-51281f5a5a85b0404f449006c9ffd856_b.png\"/></figure><p><b>ETHERNET_SEND</b></p><p>直接把包发到Hub上</p><p><b>ETHERNET_HANDLE</b></p><p>私播（地址单个）/组播（多个MAC组成一个组）/广播（所有设备均可接受，特定的ID）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-40936f2e1917ea6221095cd9584ab722_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"763\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb\" width=\"763\" data-original=\"https://pic3.zhimg.com/v2-40936f2e1917ea6221095cd9584ab722_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;763&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"763\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"763\" data-original=\"https://pic3.zhimg.com/v2-40936f2e1917ea6221095cd9584ab722_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-40936f2e1917ea6221095cd9584ab722_b.jpg\"/></figure><p>在以太网之间可以直接进行RPC。如果要发到其他以太网（比如E），那么以太网地址应该为Router（19），再由Router通过IP网络发出去。所以跨以太网发包时，包中的MAC地址会经常发生变化。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-92fe60f2ccbd56560e193da96e7bef57_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"281\" data-rawheight=\"193\" class=\"content_image\" width=\"281\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;281&#39; height=&#39;193&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"281\" data-rawheight=\"193\" class=\"content_image lazy\" width=\"281\" data-actualsrc=\"https://pic4.zhimg.com/v2-92fe60f2ccbd56560e193da96e7bef57_b.jpg\"/></figure><p><b>ARP (Address Resolution Protocol)</b></p><p>主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p>如果在同一局域网下，可以不经由路由直接通过以太网通信。<br/><b>NETWORK_SEND</b> (data, length, RPC, INTERNET, N)</p><p><b>NETWORK_SEND</b> (data, length, RPC, ENET, 18)</p><p>RARP则是反过来，由MAC映射到IP。</p><p><b>ARP Spoofing</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-37f30eacbb0870fa41d3b477dcb851e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"864\" data-rawheight=\"546\" class=\"origin_image zh-lightbox-thumb\" width=\"864\" data-original=\"https://pic1.zhimg.com/v2-37f30eacbb0870fa41d3b477dcb851e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;864&#39; height=&#39;546&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"864\" data-rawheight=\"546\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"864\" data-original=\"https://pic1.zhimg.com/v2-37f30eacbb0870fa41d3b477dcb851e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-37f30eacbb0870fa41d3b477dcb851e4_b.jpg\"/></figure><p>但是，ARP协议的前提是同一局域网下，所有的主机之间都是可信的，完全信任其他主机发出的包。如果Hacker连入以太网，伪造ARP响应，污染A和B的ARP cache，从而使得他们对A/B的包都变为给C，这样C成为了A，B间的路由，从而可以随意劫持包。（Man-in-the-Middle Attack）。</p><p>一种防御方式是：使用静态的ARP条目。</p><p>另一种防御方式则是检测行为模式，发掘可疑行为。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Control Plane - routing protocol</h2><p>路由器的职责在于，建立一个routing table，寻找到目的IP的最小开销路径（通常latency）。</p><ol><li>先通过Hello Protocol获得邻居路由器</li><li>通过广告获得其他可达的路由器</li><li>计算已知的最短路径</li></ol><p><b>两种小范围协议</b></p><p>P1: Link-state</p><p>对<b>所有路由</b>广告自己和邻居路由的通信延迟。使用Dijkstra最短路径算法。</p><p>P2:Distance-vector</p><p>对<b>邻居路由</b>广告自己和认识路由的通信延迟。使用Bellman-Ford最短路径算法<b>。</b></p><p>P1要求所有路由都了解整个拓扑结构，scalability是很大的难题。</p><p>P2则认为路由并不需要知道全局，只需要知道next hop（也就是传给哪个邻居）。但是由于不知道拓扑结构，错误处理很难。</p><p><b>P2迭代过程</b></p><p>X接受邻居Y的广告， 为dst:Ycost键值对。 XY为XY间的latency。Ycost，Xcost为到dst的latency。</p><p>X如果正在使用Y到达dst，那么更新Xcost为Ycost + XY。</p><p>X如果没有使用Y到达dst，那么更新Xcost为min（Xcost ， Ycost+XY），并根据路径更新到dst的next hop。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cde3c7a1a6ccb6329de6169b0fb6ba0b_b.jpg\" data-size=\"normal\" data-rawwidth=\"842\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"842\" data-original=\"https://pic4.zhimg.com/v2-cde3c7a1a6ccb6329de6169b0fb6ba0b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;842&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"842\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"842\" data-original=\"https://pic4.zhimg.com/v2-cde3c7a1a6ccb6329de6169b0fb6ba0b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cde3c7a1a6ccb6329de6169b0fb6ba0b_b.jpg\"/><figcaption>本来应该由B通信C，但是因为BC发生了一次丢包，B试图通过A通信C，形成了死循环</figcaption></figure><p><b>Advance</b></p><p>Path-vector Routing</p><p>广播中加入路径，防止呈环</p><p>Hierarchy of Routing</p><p>一组Router作为一个region，内部使用小范围协议，外部使用Path-vector Routing</p><p>Topological Addressing</p><p>连续的IP作为一个region，CIDR Notation（CIDR: Classless Inter Domain Routing）</p><p>例如18.0.0.0/24子网掩码，代表只关注前24位，其后的IP可以随意改变。直接把整个子网掩码放在routing table里节约空间。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>BGP（Border Gateway Protocol）</h2><p>现在的路由协议一般为BGP，分为多Tier，上层的Region之间寻址极快（10-15个），而下层的Region向上层支付费用。T1之间互为Peer。</p><p><b>Customer/provider</b></p><p>customer向provider支付path的费用</p><p><b>Peer</b></p><p>peer之间共享customer</p><p>上层的Region的很大一部分盈利用于购买其他的Region的通行费，最终所有Region基本能互联。</p><p>这个协议在抽象角度很简单，但是由于彼此的广告和本地的路由表没有办法验证，事实上并不安全。例如某个路由作为其他路由的中间路径的话，可以对于这些流量进行劫持、读取（一般是misconfiguration）。</p>", 
            "topic": [
                {
                    "tag": "路由器", 
                    "tagLink": "https://api.zhihu.com/topics/19561099"
                }, 
                {
                    "tag": "计算机网络", 
                    "tagLink": "https://api.zhihu.com/topics/19572894"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/86741212", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 2, 
            "title": "C|计算机网络|DNS", 
            "content": "<blockquote>本文为上海交通大学软件学院CSE课程笔记，Copyright by IPADS</blockquote><p>从隔壁文章迁移过来，手贱打了和谐软件被建议修改了。吐血。</p><h2>Content Distribution Newwork</h2><p>尽管上篇文章讲的FS都已经做到了一定的scalability，但单个数据中心依然无法存放大量数据，因此必须进行content distribution。</p><p><b>Client Side</b></p><p>cache 本地副本</p><ul><li>browser cache file</li><li>proxy cache url</li><li>DNS resolver cache record（URL-&gt;IP）</li><li>NFS client cache data</li></ul><p><b>Server Side</b></p><p><b>CDN+DNS</b></p><p>网站提供商将数据push到CDN，而DNS（Domain Name Service）会找最近的CDN，由这些CDN提供服务（同一个host name根据位置指向不同的server）。（例如谷歌的服务器基本遍布全球）</p><h2>DNS Design</h2><p>DNS实现了IP和域名的绑定</p><p><b>Why Domain Name？</b></p><ul><li>IP是结构化的，以特定规则进行组织。无法自定义，而域名可以有自然语义。</li><li>IP不够用户友好，难以记忆。</li><li>增加间接层，方便redirect（一个IP有多个域名，一个域名对应多个IP），例如上海使用上海服务器的ip.均摊压力。</li></ul><p>我们需要存储这些映射关系。</p><p><b>本地存储-</b>每个机器都有hosts.txt（没钱买和谐软件的时候就去博客找找改host，懂得都懂，然而大部分都是过期的IP哭了）。这种做法不具备scalability。</p><p><b>网络存储-</b>伯克利本科生开发的BIND</p><p>由于域名的数量很大，因此我们使用分级委托（顺序从小到大，英文地址喜欢这么玩）。root不具有名称，因此这个.可以省略。</p><p>e.g.</p><p><a href=\"https://link.zhihu.com/?target=http%3A//xxx.sjtu.edu.cn\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">xxx.sjtu.edu.cn</span><span class=\"invisible\"></span></a>，root - cn - edu - sjtu</p><p><a href=\"https://link.zhihu.com/?target=http%3A//zhuhu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">zhuhu.com</span><span class=\"invisible\"></span></a>，root - com</p><p>实际查找时，从root处询问cn的IP，然后向cn询问edu的IP，以此类推。因此一旦上层dns崩溃，那么所有依赖的域名都会失效。因此一般同一个名称会对应多个NDS服务器，进行冗余备份。</p><p><b>解析顺序</b></p><ul><li>直接找IP /etc/hosts</li><li>找对应的DNS /etc/resolv.conf</li><li>问root服务器</li></ul><p><b>Recursion</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b3aec00a7f58775f35bdba4ba4567375_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"826\" data-rawheight=\"450\" class=\"origin_image zh-lightbox-thumb\" width=\"826\" data-original=\"https://pic2.zhimg.com/v2-b3aec00a7f58775f35bdba4ba4567375_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;826&#39; height=&#39;450&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"826\" data-rawheight=\"450\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"826\" data-original=\"https://pic2.zhimg.com/v2-b3aec00a7f58775f35bdba4ba4567375_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b3aec00a7f58775f35bdba4ba4567375_b.jpg\"/></figure><p>递归实现减少了Client开销，但是也对name server的算力提出了要求。</p><p><b>Cache</b></p><p>Client和Server都会对name的IP进行缓存，并设置了一个TTL（Time To Live），一旦超时，那么cache失效。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>DNS Security</h2><p><b>DNS 污染</b></p><p>通过使用错误的数据包，让DNS存储错误的cache，DNS服务器就会将域名解析到错误的ID，称为DNS缓存污染（GFW）。由于DNS本质是中心化的，如果对中心服务器进行了控制，就可以对域名解析进行篡改。例如把google网页重定向为交大官网，交大官网马上就会扑该。</p><p>这也是改hosts的原理，因为上文的解析顺序，我们可以通过改hosts越过原本的DNS服务器。不过不同于先前的DNS阻断，现在的GFW已经升级到了IP阻断，也就是说路由在寻址的时候就被终止，因此现在一些简单的改hosts已经凉了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>DNS DDOS</b></p><a href=\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/5.19DNS%25E5%25A4%25A7%25E8%25A7%2584%25E6%25A8%25A1%25E6%2594%25BB%25E5%2587%25BB%25E4%25BA%258B%25E4%25BB%25B6/5632703%3Ffr%3Daladdin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-a64774de231eee7f3449f6649c9cdaef_180x120.jpg\" data-image-width=\"320\" data-image-height=\"105\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">5.19DNS大规模攻击事件_百度百科</a><p></p>", 
            "topic": [
                {
                    "tag": "DNS", 
                    "tagLink": "https://api.zhihu.com/topics/19581904"
                }, 
                {
                    "tag": "计算机网络", 
                    "tagLink": "https://api.zhihu.com/topics/19572894"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/86733701", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 1, 
            "title": "EE|计算机网络|Link Layer-链路层", 
            "content": "<h2>网络协议栈</h2><p>整体呈漏斗型，Network只使用IP，因为对于网络而言，使用的用户数，会造成平方级别的链接，因此单个网络的人数越多越好。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b82208cfec450b4c6c0da3e4925961d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"432\" data-rawheight=\"297\" class=\"origin_image zh-lightbox-thumb\" width=\"432\" data-original=\"https://pic1.zhimg.com/v2-b82208cfec450b4c6c0da3e4925961d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;432&#39; height=&#39;297&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"432\" data-rawheight=\"297\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"432\" data-original=\"https://pic1.zhimg.com/v2-b82208cfec450b4c6c0da3e4925961d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b82208cfec450b4c6c0da3e4925961d8_b.jpg\"/></figure><p>send时层层加包，recieve时层层解包。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e474eb9e049cb012a83f2136a459deb0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb\" width=\"553\" data-original=\"https://pic1.zhimg.com/v2-e474eb9e049cb012a83f2136a459deb0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;553&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"553\" data-original=\"https://pic1.zhimg.com/v2-e474eb9e049cb012a83f2136a459deb0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e474eb9e049cb012a83f2136a459deb0_b.jpg\"/></figure><p><b>Application(B/S)： URL</b></p><p>负责基本数据</p><p><b>Transport(Proxy, Firework)： Port number</b></p><p>TCP维护Seq Ack等数据，用于验证（防止传输错误），因此有所谓三次握手。</p><p>负责传输失败时进行重传。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4a308abbb90dd4bcf15bddb91a3265a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"782\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb\" width=\"782\" data-original=\"https://pic3.zhimg.com/v2-4a308abbb90dd4bcf15bddb91a3265a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;782&#39; height=&#39;438&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"782\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"782\" data-original=\"https://pic3.zhimg.com/v2-4a308abbb90dd4bcf15bddb91a3265a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4a308abbb90dd4bcf15bddb91a3265a6_b.jpg\"/></figure><p><b>Network(Router): IP address</b></p><p>负责next hop。每个路由有route table，根据路由协议（防止呈环），逐渐找到正确的地址。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f3b366155a625166b0c40e3944d7b9e7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb\" width=\"603\" data-original=\"https://pic4.zhimg.com/v2-f3b366155a625166b0c40e3944d7b9e7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;603&#39; height=&#39;320&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"603\" data-original=\"https://pic4.zhimg.com/v2-f3b366155a625166b0c40e3944d7b9e7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f3b366155a625166b0c40e3944d7b9e7_b.jpg\"/></figure><p><b>Link&amp;Physical（Line）</b></p><p>负责物理传输，错误检测。（电路容易出错）</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>Link Layer</h2><p>链路层的目的是物理上将两个位置的数据进行直接传输。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>•物理传输</h2><p><br/>并行-单位时间位数为n，由于需要等待所有线同步传输，实际效率未必高</p><p>串行-单位时间位数为1，不需要等待response</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-178c81bee5783ff356257b431b471038_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"642\" data-rawheight=\"113\" class=\"origin_image zh-lightbox-thumb\" width=\"642\" data-original=\"https://pic1.zhimg.com/v2-178c81bee5783ff356257b431b471038_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;642&#39; height=&#39;113&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"642\" data-rawheight=\"113\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"642\" data-original=\"https://pic1.zhimg.com/v2-178c81bee5783ff356257b431b471038_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-178c81bee5783ff356257b431b471038_b.jpg\"/></figure><p>如果共享时钟的话，可以先商量好传输多少次data，而不需要每次都进行一次请求。根据传递的data的频率，在B通过VCO（Voltage Controlled Oscillator）我们可以将时钟周期与A同步。然而如果全是0的话，看起来信号就会一值不变。因此引入曼彻斯特编码，0-&gt;10,1-&gt;01,减少速度传输效率，从而让VCO正确运转。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-173ee8be411da83b57778959a728bc1e_b.jpg\" data-size=\"normal\" data-rawwidth=\"658\" data-rawheight=\"166\" class=\"origin_image zh-lightbox-thumb\" width=\"658\" data-original=\"https://pic3.zhimg.com/v2-173ee8be411da83b57778959a728bc1e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;658&#39; height=&#39;166&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"658\" data-rawheight=\"166\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"658\" data-original=\"https://pic3.zhimg.com/v2-173ee8be411da83b57778959a728bc1e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-173ee8be411da83b57778959a728bc1e_b.jpg\"/><figcaption>Manchester Code</figcaption></figure><hr/><h2>•多路传输+数据组织</h2><p><b>同步通信 (telephone communication)</b></p><p>–Switch需要进行统筹</p><p>–需要建立和拆卸连接（因此需要保存状态）</p><p>每个电话建立的连接固定64kb带宽，固定了size和间距</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4bc6b54514e25c72191ef80c3cb3a852_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"190\" class=\"origin_image zh-lightbox-thumb\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-4bc6b54514e25c72191ef80c3cb3a852_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;660&#39; height=&#39;190&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"190\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-4bc6b54514e25c72191ef80c3cb3a852_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4bc6b54514e25c72191ef80c3cb3a852_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9176ee6779c944739254fbdef657668c_b.jpg\" data-size=\"normal\" data-rawwidth=\"696\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb\" width=\"696\" data-original=\"https://pic1.zhimg.com/v2-9176ee6779c944739254fbdef657668c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;696&#39; height=&#39;126&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"696\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"696\" data-original=\"https://pic1.zhimg.com/v2-9176ee6779c944739254fbdef657668c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9176ee6779c944739254fbdef657668c_b.jpg\"/><figcaption>电话的包会被拆分成多个frame</figcaption></figure><p><b>异步通信 (data communication)</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8e6a257510a748666d95299d3f4eb871_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"770\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb\" width=\"770\" data-original=\"https://pic2.zhimg.com/v2-8e6a257510a748666d95299d3f4eb871_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;770&#39; height=&#39;251&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"770\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"770\" data-original=\"https://pic2.zhimg.com/v2-8e6a257510a748666d95299d3f4eb871_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8e6a257510a748666d95299d3f4eb871_b.jpg\"/></figure><p>–<b>Message</b>: 突发的、不适合固定大小和间距</p><p>–无需建立连接, 异步</p><p>frame长度任意，可以在任意link空闲时传输。由于无需connection，stateless</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0507ec51bdace57e8a57c53d79032ed7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb\" width=\"573\" data-original=\"https://pic4.zhimg.com/v2-0507ec51bdace57e8a57c53d79032ed7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;573&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"573\" data-original=\"https://pic4.zhimg.com/v2-0507ec51bdace57e8a57c53d79032ed7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0507ec51bdace57e8a57c53d79032ed7_b.jpg\"/></figure><p><br/><b>Multiplexing / Demultiplexing</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cddabe9867921813fc7c5e6dd3c4749a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"702\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb\" width=\"702\" data-original=\"https://pic3.zhimg.com/v2-cddabe9867921813fc7c5e6dd3c4749a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;702&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"702\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"702\" data-original=\"https://pic3.zhimg.com/v2-cddabe9867921813fc7c5e6dd3c4749a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cddabe9867921813fc7c5e6dd3c4749a_b.jpg\"/></figure><p>信息的传递使用队列，在Demultiplex时通过header中的目的地，与switch中的forwarding table进行下一步传递。</p><p>可以选择一个简单的序列作为frame的定界符（如7个1，为了避免数据中出现，则打包时所有的6个1后添加0，解包时1111110后删去0）</p><h2>•错误检测</h2><p>常见的冗余编码，通过最终的码是否仍符合规则，判断什么位传输出了问题。</p><p>这里之所以插入在1,2，4位，是因为看表，下标相加即可。</p><p>把理论的P367推出的编码和实际的编码比较，根据Not Match的位置，即可判断哪一位传输错误。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-219e7fcd2d6644af0dc0c3594b4f1ac4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"291\" data-rawheight=\"412\" class=\"content_image\" width=\"291\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;291&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"291\" data-rawheight=\"412\" class=\"content_image lazy\" width=\"291\" data-actualsrc=\"https://pic1.zhimg.com/v2-219e7fcd2d6644af0dc0c3594b4f1ac4_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "计算机网络", 
                    "tagLink": "https://api.zhihu.com/topics/19572894"
                }, 
                {
                    "tag": "软件", 
                    "tagLink": "https://api.zhihu.com/topics/19551718"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }
            ], 
            "comments": [
                {
                    "userName": "吃咖啡喝方糖", 
                    "userLink": "https://www.zhihu.com/people/7f2a5f7d697682f89030c316544dcc37", 
                    "content": "……你这文章咋越写越思维导图了", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "<p>就是个引论部分，具体内容是后面那堆。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "吃咖啡喝方糖"
                        }, 
                        {
                            "userName": "吃咖啡喝方糖", 
                            "userLink": "https://www.zhihu.com/people/7f2a5f7d697682f89030c316544dcc37", 
                            "content": "向大佬低头", 
                            "likes": 0, 
                            "replyToAuthor": "朝闻君"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/86229194", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 5, 
            "title": "C++|编译器|语义分析-符号表", 
            "content": "<blockquote>Reference： Compilers in IPADS SE SJTU + Tiger book</blockquote><p>通过词法分析和语法分析，我们可以将程序转换为一棵抽象语法树，根节点为statement，并递归子节点为statement或者expression，叶节点为terminal（如&#39;A&#39;）。然而，我们并不仅仅需要语法本身，同时要考虑语法的实际含义。编译器进入语义分析阶段。</p><p><b>语义分析</b>- 将变量的定义与各个使用联系起来，type check，并且将抽象语法转换为更简单的适合生成机器代码表示。</p><h2>符号表</h2><p>符号表是由一组绑定组成的集合（又称环境environment），例如{g-&gt;string,a-&gt;int},每一个绑定都具有一定的作用域。新增的绑定会覆盖先前的绑定。（这个很容易实现，只要你新增的绑定先于旧的被找到就行）</p><p>为了实现符号表的改变，存在两种风格</p><p><b>函数式风格</b>- 在每次符号表改变时，并不改变原符号表，保持数据unmutable。</p><p><b>命令式风格- </b>共用一个environment，符号表改变会破坏性更新原符号表，但是提供给一个撤销栈（存储撤销破坏性更新的信息). 环境中添加符号时，同时也会加入撤销栈中，在作用域结束点，撤销栈弹出符号并且删除绑定，恢复到之前的符号表。</p><p>在某些语言中，可以同时存在多个活跃的环境，module/class/record各自拥有自己的符号表</p><p><b>命令式风格符号表实现</b></p><p>需求1：查找迅速- hash</p><p>需求2:  易撤销</p><p>open hashing： 拉链法（我们选择链表，容易实现作用域的删除）</p><p>closed hashing： 开放寻址法（数组中你玩delete不是在作死么, 舍弃）</p><p>新增的binding加入链表头，如果要撤销，删除第一个binding就行。</p><p><b>HINT</b></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">pop</span><span class=\"p\">(</span><span class=\"n\">string</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n <span class=\"p\">{</span>\n <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">SIZE</span> <span class=\"p\">;</span>\n <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n</code></pre></div><blockquote><b>我们可能会奇怪，上面的代码为什么直接删除index处的首节点而不是第一个找到的key节点。难道不会出现我pop（&#34;a&#34;）而实际上pop了一个key为“c”的节点么。</b><br/><b>因为有了撤销栈作为辅助，我们在撤销时，pop的key必定是该索引处最后加入的key，因此首节点也就是第一个找到的key节点。</b></blockquote><p><b>函数式风格符号表实现</b></p><p>原先的表不变，新增的部分链接到之前的表的首节点（避免拷贝之前的表的开销）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-18ee17105950155daf26e412a43359b8_b.jpg\" data-size=\"normal\" data-rawwidth=\"813\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"813\" data-original=\"https://pic1.zhimg.com/v2-18ee17105950155daf26e412a43359b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;813&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"813\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"813\" data-original=\"https://pic1.zhimg.com/v2-18ee17105950155daf26e412a43359b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-18ee17105950155daf26e412a43359b8_b.jpg\"/><figcaption>由于所有数据都是unmutable的，可以放心地进行引用</figcaption></figure><p>我们还可以使用二分查找树加速查找，这样的话，如果新增的binding深度为d，那么我们需要复制向上的d个节点，但不需要复制整棵树（logn），插入和查找开销相同。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5afb0b5e80db0745e46dd3280546cdbc_b.jpg\" data-size=\"normal\" data-rawwidth=\"757\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb\" width=\"757\" data-original=\"https://pic1.zhimg.com/v2-5afb0b5e80db0745e46dd3280546cdbc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;757&#39; height=&#39;434&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"757\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"757\" data-original=\"https://pic1.zhimg.com/v2-5afb0b5e80db0745e46dd3280546cdbc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5afb0b5e80db0745e46dd3280546cdbc_b.jpg\"/><figcaption>在新表中插入Mouse的binding</figcaption></figure><p><b>撤销栈</b></p><p>除了hash自带的链表之外，另外存在着一个链表top处理作用域。下文binder_的prevtop就是按照插入顺序对于所有节点进行了链接。沿着prevtop遍历我们可以得到FILO的撤销栈。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">struct</span> <span class=\"n\">binder_</span> <span class=\"p\">{</span>\n <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">key</span><span class=\"p\">;</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">value</span><span class=\"p\">;</span>  <span class=\"cm\">/* a binding */</span>\n <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">prevtop</span><span class=\"p\">;</span> <span class=\"cm\">/* to implement a stack */</span>\n <span class=\"n\">binder</span> <span class=\"n\">next</span><span class=\"p\">;</span>  <span class=\"cm\">/* imperative style */</span>\n<span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">TAB_table_</span> <span class=\"p\">{</span>\n\t<span class=\"n\">binder</span> <span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">TABSIZE</span><span class=\"p\">];</span> \n\t<span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">top</span><span class=\"p\">;</span> \t\n<span class=\"p\">};</span>\n</code></pre></div><p>在TAB表中我们通过top指针可以获取撤销栈的栈顶。我们用ADT S_table进行一些接口的封装。</p><p>当新的作用域开始时，不会插入binder，而是插入一个特殊的marker哨兵。</p><p>当作用域结束时，沿着top不断进行pop，直到pop最顶端的哨兵。这样一来整个作用域中新增的符号就全部被撤销了。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">S_enter</span><span class=\"p\">(</span><span class=\"n\">S_table</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">S_symbol</span> <span class=\"n\">sym</span><span class=\"p\">,</span> <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">TAB_enter</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">sym</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">);</span> \n<span class=\"p\">}</span>\n<span class=\"kt\">void</span> <span class=\"nf\">S_beginScope</span><span class=\"p\">(</span><span class=\"n\">S_table</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">S_enter</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">marksym</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span> \n<span class=\"p\">}</span>\n<span class=\"kt\">void</span> <span class=\"nf\">S_endScope</span><span class=\"p\">(</span><span class=\"n\">S_table</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"n\">S_symbl</span> <span class=\"n\">s</span><span class=\"p\">;</span>\n<span class=\"k\">do</span> <span class=\"n\">s</span><span class=\"o\">=</span><span class=\"n\">TAB_pop</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">);</span> <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">!=</span> <span class=\"o\">&amp;</span><span class=\"n\">marksym</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><b>type environment//value environment</b></p><p>在程序中，绑定的不仅是类型，还有值。因此作用域中同时存在两个S_table。类型中通过使用&lt;field,type*&gt;指针，可以实现嵌套的类型，例如结构体和类。</p><p>需要注意的是，在程序中写的type本身就是symbol，而不是实际的type，因此我们需要在venv中先获取typename（如果一个变量的类型是type，例如typedef？），再根据typename在t_env获取对应的实际的type。（这段有点不太清晰，得复习下）</p><p><b>base environment</b></p><p>初始化built-in环境</p><p></p>", 
            "topic": [
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "语义分析", 
                    "tagLink": "https://api.zhihu.com/topics/19632473"
                }, 
                {
                    "tag": "编译器", 
                    "tagLink": "https://api.zhihu.com/topics/19608032"
                }
            ], 
            "comments": [
                {
                    "userName": "吃咖啡喝方糖", 
                    "userLink": "https://www.zhihu.com/people/7f2a5f7d697682f89030c316544dcc37", 
                    "content": "小猪重构龙书ing", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "<p>虎书</p>", 
                            "likes": 0, 
                            "replyToAuthor": "吃咖啡喝方糖"
                        }, 
                        {
                            "userName": "吃咖啡喝方糖", 
                            "userLink": "https://www.zhihu.com/people/7f2a5f7d697682f89030c316544dcc37", 
                            "content": "这不都llvm了嘛，前端现在还有啥用…", 
                            "likes": 0, 
                            "replyToAuthor": "朝闻君"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85880645", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 5, 
            "title": "C|分布式|RPC&NFS", 
            "content": "<blockquote>本文为上海交通大学软件学院CSE课程笔记，Copyright by IPADS</blockquote><h2>Intro</h2><p>随着单机性能进入瓶颈，storage与serve的压力与日俱增，因此，这两个职责被分布在不同服务器上。由于原本单机的文件访问变为跨服务器，因此NFS（Network File System）诞生了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3f3e9cb05a918c65d87d8eb669b23a27_b.jpg\" data-size=\"normal\" data-rawwidth=\"287\" data-rawheight=\"253\" class=\"content_image\" width=\"287\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;287&#39; height=&#39;253&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"287\" data-rawheight=\"253\" class=\"content_image lazy\" width=\"287\" data-actualsrc=\"https://pic4.zhimg.com/v2-3f3e9cb05a918c65d87d8eb669b23a27_b.jpg\"/><figcaption>大存储服务器负责文件系统，应用服务器负责响应客户端</figcaption></figure><p>但是，如果我不想进行原本代码的修改，而想让通过网络进行的文件访问看起来如同之前本地的访问一样呢？我们现在一般使用RPC（Remote Procedure Call）在原有的单机文件系统上进行一层封装，使之成为NFS.程序员所面对的编程接口依然和往常的接口相同，而变化的仅仅是底层实现。</p><h2>RPC</h2><blockquote>允许进程在远端执行而无需编码交互细节</blockquote><p>我们使用Stub中间件隐藏通信的交互细节，真正的RPC通过Stub进行，而用户代码毫无察觉。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f302e1d3e70bf430bdf5dd1519cb7190_b.jpg\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"378\" class=\"origin_image zh-lightbox-thumb\" width=\"768\" data-original=\"https://pic1.zhimg.com/v2-f302e1d3e70bf430bdf5dd1519cb7190_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;768&#39; height=&#39;378&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"378\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"768\" data-original=\"https://pic1.zhimg.com/v2-f302e1d3e70bf430bdf5dd1519cb7190_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f302e1d3e70bf430bdf5dd1519cb7190_b.jpg\"/><figcaption>Stub隐藏了通信的细节，使得上层的调用无需修改</figcaption></figure><p><b>Client stub</b></p><ul><li>request中放置参数</li><li>send requset to server</li><li>等待response</li></ul><p><b>Service stub</b></p><ul><li>等待message</li><li>获取request参数</li><li>进程调用</li><li>response中放置结果与状态（success?/accecpted?）</li><li>send respones to client</li></ul><p>问题在于，message中应该放置什么，以下是一些比较重要的信息</p><p>当前的call的标识-Transaction ID</p><p>调用什么方法–Service ID (e.g., function ID)</p><p>身份认证-Auth Stuff</p><p>使用什么参数–Service parameter (e.g., function parameter)</p><p>由于引用失效，参数的再编排–Using marshal / unmarshal</p><p>//跨地址空间引用失效，因此需要进行序列化/反序列化（及处理网络通信的大小端）</p><p><b>Components</b></p><p>为了搭建一个RPC框架，我们需要</p><p>1.RPC格式标准（UDP or TCP or HTTP2？）</p><p>2.marshal / unmarshal工具库</p><p>3.Stub Generator：产生Stub</p><p>Client：marshal arguments, call, wait, unmarshal reply</p><p>Server：unmarshal arguments, call real function, marshal reply</p><p>4.Framework:</p><p>Client:  </p><p>正确分发message到对应的server stub</p><p>跟踪所有发出去的请求</p><p>将收到的响应匹配到对应的call</p><p>多个caller共用一个socket</p><p>请求超时、重传的处理</p><p>Server: </p><p>对每个thread/callback正确分发reply（每个请求分配一个线程，或者请求多时维护线程池）</p><p>5.Binding：Client如何找到对应的Server</p><p>6.网络传输（如socket）</p><p><b>网络通信导致的Trade-off</b></p><p>1.性能开销（但不是传文本可以不用HTTP，会快些）</p><p>2.超时造成的额外问题</p><p>一旦发生超时，有这么几种解决方案，一般RPC使用第一或者第二</p><p>At Least Once：</p><p>重复resend，直到收到响应（但是可能会收到一堆响应）-&gt;要求调用无副作用</p><p>At Most Once：</p><p>重复resend, Server只保留一个request而忽略重复进行处理 -&gt; 要求幂等性，多次调用如一</p><p>Exactly Once：</p><p>难以实现（没学）</p><p>3.错误隔离（C/S崩溃不影响彼此）</p><hr/><h2>NFS</h2><blockquote>eg: mount –t nfs 10.131.250.6:/nfs/dir /mnt/nfs/dir</blockquote><p>在应用程序调用文件系统接口时，NFS的所有调用如下。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3edac1c85d633b4f5e60c5536a2d1962_b.jpg\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb\" width=\"846\" data-original=\"https://pic3.zhimg.com/v2-3edac1c85d633b4f5e60c5536a2d1962_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;846&#39; height=&#39;389&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"846\" data-original=\"https://pic3.zhimg.com/v2-3edac1c85d633b4f5e60c5536a2d1962_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3edac1c85d633b4f5e60c5536a2d1962_b.jpg\"/><figcaption>NFS顺序图</figcaption></figure><p>值得注意的几点</p><p><b>fd&lt;--&gt;fh (file handler)</b></p><p>和下面Server无状态有关，而fd在Client内存中。因此传递对Server有用的fh，内含：</p><ul><li>file system ID</li><li>inode number（path name可能会被rename）</li><li>generation number-维护一致性（如果inode被删除后，又被复用number）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>NFS Server并没有open/close</b></p><p>Server stateless，状态由Client维护（即使Server崩溃重启，由于无状态，依然能处理request）</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>回传file attributes</b></p><p>维护Client上的metadata</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Cache</b></p><p><b>Server Reply Cache：</b></p><p>由于网络传输延迟或丢包，Client可能重复request，因此根据Transaction ID建立Cache。这样重复的request可以返回相同的响应。</p><p><b>Client  Cache：</b></p><p>存储一些最近使用的vnode（virtual node），attributes，blocks。减少RPC延迟。</p><p><b>Cache coherence ：</b></p><p>Read/write：</p><p>与单机不同，无法保证获取最新数据，自行负责解决</p><p>Close-to-open：</p><p>open时获取modified time，与cache中进行比较，更新到最新数据。</p><p>close时写回（类似于cache被淘汰时写回内存）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3d4e4f35524090cc4cb2ceb2c87abe48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"830\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb\" width=\"830\" data-original=\"https://pic1.zhimg.com/v2-3d4e4f35524090cc4cb2ceb2c87abe48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;830&#39; height=&#39;286&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"830\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"830\" data-original=\"https://pic1.zhimg.com/v2-3d4e4f35524090cc4cb2ceb2c87abe48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3d4e4f35524090cc4cb2ceb2c87abe48_b.jpg\"/></figure><p>左图中：C2open时能获取最新的数据</p><p>右图中：C2open时，由于C1未close，因此open时没有更新，因此read脏数据。</p><p>由于上述情况，一般需要另外进行并发的处理，例如对文件加锁。</p><p><b>Vnode</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-137875764c3e15d4fc0a060cdd429ccb_b.jpg\" data-size=\"normal\" data-rawwidth=\"871\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb\" width=\"871\" data-original=\"https://pic4.zhimg.com/v2-137875764c3e15d4fc0a060cdd429ccb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;871&#39; height=&#39;369&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"871\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"871\" data-original=\"https://pic4.zhimg.com/v2-137875764c3e15d4fc0a060cdd429ccb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-137875764c3e15d4fc0a060cdd429ccb_b.jpg\"/><figcaption>虚拟化</figcaption></figure><p>把文件属于local还是remote抽象化，左侧的箭头可以指向NFS client，也可能指向Local file system，从而让程序员忽视了实现细节。</p><hr/><h2>GFS(Google FS）</h2><p>随着规模的增大，单文件服务器也无法承受了。为了scalable，GFS使用一个服务器作为转发，多个文件服务器进行数据传输。这里的核心架构在于，将控制流和数据流解耦。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c9cb9d48c4c47013dbbd2ed931e94f2e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"971\" data-rawheight=\"387\" class=\"origin_image zh-lightbox-thumb\" width=\"971\" data-original=\"https://pic3.zhimg.com/v2-c9cb9d48c4c47013dbbd2ed931e94f2e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;971&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"971\" data-rawheight=\"387\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"971\" data-original=\"https://pic3.zhimg.com/v2-c9cb9d48c4c47013dbbd2ed931e94f2e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c9cb9d48c4c47013dbbd2ed931e94f2e_b.jpg\"/></figure><p><b>Flat Namespace</b></p><p>尽管namespace看起来有树形结构，实际上并没有directory，而是把整个路径映射到chunk上（因为目录访问需要多次访问chunk，而网络传输的开销远高于硬盘）</p><p><b>GFS Cluster</b></p><p>Single Master</p><p>内存中维护metadata（没有inode，没有symlink，没有hard link）</p><p>使用前缀编码进行压缩（每个entry小于64bytes）</p><ul><li>namespace</li><li>访问控制</li><li>映射表</li><li>chunk的位置</li></ul><p>Multiple Chunkserver</p><p>存储数据（chunk64mb）</p><p>传送heartbeat信息（如果崩溃了，需要让master保持同步）</p><p><br/><b>Cache</b></p><p>Client和Chunkserver没有数据的cache（因为chunk的容量很大），但是Client有chunkserver的cache，下次访问可以不通过master。</p><p>（由master进行lease，进行临时的权限移交）</p><p><b>Fault Tolerance</b></p><p><b>Chunkserver</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-52216ee16abda57355d47979a6ef5002_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"578\" data-rawheight=\"535\" class=\"origin_image zh-lightbox-thumb\" width=\"578\" data-original=\"https://pic3.zhimg.com/v2-52216ee16abda57355d47979a6ef5002_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;578&#39; height=&#39;535&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"578\" data-rawheight=\"535\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"578\" data-original=\"https://pic3.zhimg.com/v2-52216ee16abda57355d47979a6ef5002_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-52216ee16abda57355d47979a6ef5002_b.jpg\"/></figure><p>在这里使用三备份，当三个备份都写入完成后再进行response。三个buffer一般不会同时崩溃，所以写入buffer后就可以视为写入完成。</p><p>对于每个chunk产生32bit的checksum</p><p>定期扫描罕用文件，检查一致性</p><p><b>Master</b></p><ul><li><b>对于所有metadata修改log</b></li><li><b>shadow master</b></li><li><b>状态在多机器冗余存储</b></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Typical Workload</b></p><p><b>搜索引擎特点</b></p><p>大的流读取+小的随机读取（因此适合这种大chunk）</p><p>大量顺序写操作（append），先前爬取的数据较少修改</p><p>多client同时append一个文件（因此没有什么对已有内容的修改，写方面不追求效率）</p>", 
            "topic": [
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }, 
                {
                    "tag": "RPC框架", 
                    "tagLink": "https://api.zhihu.com/topics/20086162"
                }
            ], 
            "comments": [
                {
                    "userName": "超级大豆腐", 
                    "userLink": "https://www.zhihu.com/people/81751b1c4e23a3fa2035a147f57a7b91", 
                    "content": "朝闻君太快了吧！", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84675580", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 22, 
            "title": "C|文件系统|FFS:Fast File System", 
            "content": "<blockquote>本文阅读资料：SJTU-SE-CSE课程作业的课后阅读，此处为阅读笔记，赶紧赶作业，整理以后再说</blockquote><a href=\"https://link.zhihu.com/?target=https%3A//ipads.se.sjtu.edu.cn/courses/cse/paper/paper-2.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CSE Reading 2</a><a href=\"https://link.zhihu.com/?target=http%3A//pages.cs.wisc.edu/~remzi/OSTEP/file-ffs.pdf\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OSTEP-FFS</a><a href=\"https://link.zhihu.com/?target=https%3A//inst.cs.berkeley.edu/~cs162/sp10/hand-outs/FFS84.pdf\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Paper</a><h2><b>                                                   摘要</b></h2><p>我们描述了UNIX文件系统的一种新实现，通过使用更灵活的allocation policy，提供了更好的locality of reference，并且可以适配于不同处理器和外设，大大提升了throughput。新文件系统聚集了被序列访问的数据，提供了两种block size，加速了大文件的访问同时不浪费小文件的空间，相比于旧系统提高了10倍的文件访问速度。</p><p>新文件系统讨论了对于长期需求的编程接口的改进，包括：</p><ul><li>文件的咨询锁机制（advisory lock）</li><li>跨文件系统名称空间拓展（name space across file system）</li><li>长文件名使用</li><li>资源利用的管理权限（administrative control of resource usage）</li></ul><p><b>关键词： UNIX，文件系统组织，文件系统性能，文件系统设计，API</b></p><h2>旧文件系统</h2><p>在贝尔实验室的传统文件系统中，磁盘被分为几个分区，每一个分区都容纳一个文件系统，且不会跨分区。文件系统用superblock描述，包含基本参数：block数，最大文件数，free list指针。</p><p>文件系统中包含着文件，部分作为目录，其中的指针指向着同时也可能是目录的文件。文件用inode进行描述，其中包含了所有权，时间戳，block索引数组。</p><p>在这里我们假设，inode中直接存储了file的前八个block，更多的block通过引用间接访问，类似于页表的分级索引，512-byte的文件系统中每级都会指向128个下一级block。</p><p>150M的文件系统中，4M inode和146M data被隔离，因此通过inode访问data需要一个long seek。同时，目录中的inode也不是连续的，因此操作目录也不是locality。</p><p>block的分配也不最优，传统的文件系统每次磁盘传输都不超过512byte，通常下一个block也不会在同一个cylinder上，因此每次都必须再次寻道。小的block size，有限的read-ahead，过度的寻道，都限制了系统的throughput。</p><p>此前，伯克利曾经翻倍了block size从而提升throughput，但是就文件系统仍然只能发挥磁盘百分之四的传输速率。主要问题在由于文件的创建和移除，free list被迅速抢占，最终几乎完全随机，文件的block被随机分配，强制了每次访问都需要寻道。因此文件系统在一段时间后性能迅速下降，并且除了重置，无法恢复性能。另一种方式是定期地重新组织数据，整理磁盘，恢复其locality。</p><h2>新文件系统组织</h2><h2>Cylinder Group</h2><p>新文件系统同样使用superblock，这些block一旦丢失会导致灾难性的损失，因此它们都是创建后即只读的。一旦某些磁盘错误发生破坏了这些superblock，副本才会被引用。</p><p>为了减少间接访问的层级，block size被加倍到4096 byte，或者4096×任意二的幂。block size在superblock中记录，文件系统可以同时访问不同size的block。</p><p>一个分区被分为几个cylinder group，每个cylinder group包括了几个连续的cylinder。cylinder group包含了 bookkeeping information（距离头部不同偏移量，防止在同一个platter，出了问题全家暴毙，通常每个group递增一个track，也就是说在空间上螺旋向下排列）：</p><ul><li>superblock的冗余副本</li><li>inode空间（默认为每2K空间在开始时分配一个inode，假设绰绰有余）</li><li>可分配空间的bit map（取代了free list）</li><li>block利用的概况</li></ul><p>EX: </p><p>需要注意，第一个group的位置不一定一直确定，因为磁盘最开始有8K的bootstrap程序，由于需要对齐block size，因此block size超过8K时，第一个group的位置必须先读取sblock size才能确定。</p><h2><b>Block Size</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-79b7a749f41350da46fbcf14585ca05a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb\" width=\"672\" data-original=\"https://pic3.zhimg.com/v2-79b7a749f41350da46fbcf14585ca05a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;672&#39; height=&#39;254&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"672\" data-original=\"https://pic3.zhimg.com/v2-79b7a749f41350da46fbcf14585ca05a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-79b7a749f41350da46fbcf14585ca05a_b.jpg\"/></figure><p>block size 1048 -&gt; 4096, 磁盘事务四倍效率。但是小文件则会浪费大量空间，典型trade-off。为了避免浪费，一个block被分为几个fragment（2、4、8），并且可以寻址，最小可以设置为512byte（sector size）。bit map在fragment level记录了空间是否可用。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4cc0b1c5d5914f8cdb624feebb27b4e8_b.jpg\" data-size=\"normal\" data-rawwidth=\"677\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb\" width=\"677\" data-original=\"https://pic1.zhimg.com/v2-4cc0b1c5d5914f8cdb624feebb27b4e8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;677&#39; height=&#39;134&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"677\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"677\" data-original=\"https://pic1.zhimg.com/v2-4cc0b1c5d5914f8cdb624feebb27b4e8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4cc0b1c5d5914f8cdb624feebb27b4e8_b.jpg\"/><figcaption>block size/fragment size = 4096/1024</figcaption></figure><p>fragment需要对齐，跨block的fragment不能被当做整体使用。上图中O表示可用，X表示占用，则只有12-15fragment才能被当做一个整体的block。</p><p>当要分配文件时，零头优先分配不完整的block，如果找不到，再分配给完整的block，然后剩余空间留给其他文件分配。（a）</p><p>让写文件时，如果已分配空间不足，则需要再分配。</p><ol><li>原文件不含fragmented block：先把之前的full block全部填满，remainder data按block分配，零头同策略（a）</li><li>原文件包含了fragmented block：先把之前的full block全部填满，remainder data+fragment data合起来，分配一个full block，先填fragment data（并释放之前的fragment），然后填remainder data，如果remainder data空间不足，则按照上述策略1</li></ol><p>可以看出，含了fragment的file必须copy很多次才能拓展为full block，因此用户程序每次写一整个block可以最小化这种代价。</p><p>block size增大减少了大文件的索引信息，同时小文件保持不变，但同时也需要更多的空间使用bit追踪free block。最终来看，磁盘的利用率几乎没变。为了保证再分配的效率，文件系统预留了一定的空间（根据空间浪费，给出合理的值），从而保证一定的free space。一旦空间不足，locality会迅速下降，但是通过删除文件从而给出足够的空间并且移动数据还是能够恢复性能。（感觉和他说的旧版本没啥区别，都是得重排）</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>File System Parameterization   </h2><p>对于没有IOchannel的处理器，中断机制导致几次磁盘访问必须存在一定间隔。磁盘的物理性质可以计算出一个跳过block所需的时间，处理器的特性可以计算出处理中断并进行下一次磁盘访问的时间，这样我们可以计算出，当处理器恰好进行下次从磁盘访问时，跳过的block个数。这样的block在物理上不连续，但是逻辑上是连续的。</p><p>cylinder group summary information存储了不同旋转位置下，可用block的数目。（例如跳过6个，k，k+1，...，k+5构成一共六组连续）</p><p>superblock还包含了一组旋转布局表，使用旋转位置索引，从中可以获取该旋转位置下所有block的block map。</p><p>在找到可用block不为0的旋转位置后，文件系统将会在这些逻辑连续的block上进行分配。</p><p>这些参数都是可以动态修改的，所以根据合适的磁盘或处理器设置对应的参数，就可以针对性地进行优化。</p><h2>Layout Policies </h2><p>global policy</p><blockquote>use file system wide summary information to make decisions regarding the placement of new inodes and data blocks</blockquote><p>通过这些信息计算最佳的旋转布局（上文），确定什么时候开辟在新的cylinder group</p><p>local allocation</p><blockquote>Below the global policy routines are the local allocation routines that use a locally optimal scheme to lay out data blocks.</blockquote><ul><li>increase the locality of reference to minimize seek latency</li><li>improve the layout of data to make larger transfers possible</li></ul><p>全局布局聚集相关信息，对于superblock，inode，data的访问在同一cylinder group进行。过度的局部性可能导致单cylinder group无法储存为被迫分散；也可能导致某个cylinder group中存放大量的数据退化成旧文件系统。</p><p>大量命令都涉及目录，例如ls file就需求对同一目录下连续访问，因此目录和子节点放在同一cylinder groupcylinder group。</p><p>分配directory时，新目录放在free inode较多的cylinder group，这样做的目的主要为了便于进行inode的聚集。</p><p>inode block分配使用next-free策略（参考next-fit类似），尽管位置随机，但是仍然可以视作固定时间（一个cylinder group的inode数目不多，本身就限制了）。</p><p>data block则采取上文的rotationally optimal position，但是有一个顾虑在于，大文件会很快占据所有的空间，也会导致其他的inode无法存储，从而不得不溢出。</p><p>一种启发式算法是，文件超过48kb则分配到不同的cylinder，每 1mb就再分配一次，分配的策略是从free block较多的group里随便挑个。这样每1mb的访问仍然能保证一定的locality。</p><p>全局策略会指定一个block，当全局策略不成功时，局部策略生效，</p><p>1.下一个旋转最近的block</p><p>2.如果没有的话，同group的block</p><p>3.满了的话，把当前的group number 进行hash二次探查寻找另一个block</p><p>4.hash失败，全局搜索</p><h2>API拓展</h2><h2>Long File Names  </h2><p>主要是先在entry里存了字符串的大小，这样字符串就可变长</p><h2>File Locking</h2><p>emmm，建立了一个sys call级别的互斥锁和共享锁。之前是必须使用文件进行加锁。</p><p>主要是弥补三个痛点</p><ol><li>轮询浪费CPU</li><li>系统挂了锁作为文件没处理干净</li><li>管理员可以随意操控文件</li></ol><h2>Symbolic Links</h2><p>用文件存pathname建立link，如果是绝对地址就不会翻译，否则这个file会翻译到对应的path上去。这样做通过pathname一层，而不是直接进行inode的alias，有利于跨文件系统。</p><h2>Rename</h2><p>过去的rename不是原子性的，先创建临时文件指向同一个inode，然后改名，然后删原文件的link，一旦崩溃那么会导致临时文件存留而且没有变成新名字。现在改用单个sys call。</p><h2>Quotas  </h2><p>对于用户进行限额，防止某个用户使用过多的inode或者block</p>", 
            "topic": [
                {
                    "tag": "文件系统", 
                    "tagLink": "https://api.zhihu.com/topics/19560370"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74819806", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 20, 
            "title": "C|内存管理|Memory Allocation", 
            "content": "<p>本文续上文，其中提到new在malloc之外做了额外的工作。在这里我们继续深入malloc/free。</p><hr/><p>本文内容为ICS笔记，杠精退散</p><a data-draft-node=\"block\" data-draft-type=\"link-card\" href=\"https://zhuanlan.zhihu.com/p/53875602\" class=\"internal\">朝闻君：C++|内存管理|数组内存分配机制</a><h2>SBRK（break）</h2><p>从某种意义上来说，heap和stack很接近，也有一个sbrk标识堆顶。在没有free的情况下，sbrk的行为和rsp很接近，每次申请一块内存，sbrk增大，增大的部分作为分配的内存。然而，由于free由用户控制，<b>释放内存不像栈一样始终在栈顶</b>，这就造成了复杂度。<b>新分配的内存可能在sbrk附近，也有可能在已经被释放的内存上。</b>因此，我们malloc时会先寻找是否有已经存在的被释放的内存，如果没有，再增加sbrk。</p><h2><b>Fragmentation</b></h2><p>External Fragmentation</p><p>释放了五个单位的空间，又申请了四个单位的空间，则原空间只能分配一个单位，而不能被更大的分配需求利用。</p><p><b>Internal Fragmentation</b></p><p>记录的额外空间或者内存对齐，导致零碎的空间产生。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>Mechanism</b></h2><p>我们把每一个分配的区块以及其中的信息称为一个chunk,在表头我们需要记录这些信息</p><p>记录分配空间的大小:  size（word）</p><p>记录是否被分配： allocation bit（由于size后三位必定为0（word对齐）,因此可以放在size末位）</p><p>分配时额外的信息：payload</p><p>通过head指针和offset可以计算出下一个chunk，因此堆实际上是隐式链表。通过遍历并求其中的allocation bit，我们可以获得其中未被分配的内存。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>Starategy</b></h2><p><b>First Fit</b></p><p>从头开始，第一个空间足够的chunk直接分配:</p><p>缺陷： 头部碎片化</p><p><b>Next Fit</b></p><p>从上次搜索的地址开始，第一个空间足够的chunk直接分配：</p><p>缺陷: 效率更糟糕</p><p><b>Best Fit</b></p><p>整个列表中空间足够且最小的chunk分配。</p><p>缺陷：固定的线性时间</p><h2>Free</h2><p>假设我们free了一块内存，由于malloc造成的碎片化，因此我们需要在free时进行<b>反碎片化</b>，例如附近有未分配的空间，我们应该把未分配的空间合并到一起。由于存储了size，我们很容易后遍历，但是向前遍历就难了。</p><p>因此，我们需要额外的信息，让他成为双向链表，在chunk的最后也存储一份size+allocation的信息，这样下一个chunk头的前一个word就能反查上一个chunk了。</p><p>需要注意的是，这里是不需要考虑循环的，因为free本身保证了free的空间连续，因此只需要考虑上下一块即可。（参见数学归纳）</p><p>如果free的内存在sbrk附近（表尾），那么直接收缩堆。</p><h2><b>Malloc</b></h2><p>遍历寻找可分配的chunk，然后找到size大于需求的，直接修改size+allocation bit即可。这时我们要注意，分配完之后，剩余的空间可能能容纳一个chunk，也可能不能，如果不能的话，我们直接把整块空间都给malloc，以充分利用空间。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Extension</p><p>很明显，为了避免碎片化，Best Fit是最好的，但是线性遍历开销太大。那么我们自然地想到了查找的数据结构，hash。我们可以把free chunk根据size映射到不同的链表，每次free都插入表头，下次malloc时根据size直接能查到。如此一来，查找的时间变为常数。</p><p>不过，由于不再是彼此连续的chunk，原本的size之外又得存储指针，这也算是典型的时空交换了。</p>", 
            "topic": [
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }, 
                {
                    "tag": "内存管理", 
                    "tagLink": "https://api.zhihu.com/topics/19579205"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": [
                {
                    "userName": "王霄池", 
                    "userLink": "https://www.zhihu.com/people/7ef99db689fc93693173e068f6428f83", 
                    "content": "<p>Next Fit 效率不差劲，比best fit好</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "老师原话emmm，best fit的确是最慢的 和他比没意思，大概是next fit和first fit相比吧。", 
                            "likes": 0, 
                            "replyToAuthor": "王霄池"
                        }
                    ]
                }, 
                {
                    "userName": "兔哥", 
                    "userLink": "https://www.zhihu.com/people/fedb528e6bd842b01d42e15478a18831", 
                    "content": "<p>讲malloc不说哪个库都是刷流氓,讲堆不说对应哪个操作系统版本也是刷流氓.</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "本来就是CSAPP，你要我说啥呢。我当然讲的是基础版本，你没看到后面说的内容里现代的实现？", 
                            "likes": 0, 
                            "replyToAuthor": "兔哥"
                        }, 
                        {
                            "userName": "freeRanger", 
                            "userLink": "https://www.zhihu.com/people/5250b3f1e166793473bf23fa02375f49", 
                            "content": "<p>malloc是应用层面的函数，有很多不同实现。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "朝闻君"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74186095", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 3, 
            "title": "Assemble|并行计算|SuperScalar", 
            "content": "<blockquote>A super scalar processor is a <a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Central_processing_unit\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CPU</a> that implements a form of <a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Parallel_computer\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">parallelism</a> called <a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Instruction-level_parallelism\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">instruction-level parallelism</a> within a single processor.</blockquote><p><b>超标量</b>（superscalar）架构是指在一颗处理器内核中实行了指令级并行的一类并行运算。这种技术能够在相同的CPU主频下实现更高的CPU吞吐率（throughput）。</p><p>我们暂时先不管这种技术如何实现，总而言之，他能够在单核CPU中依靠不同执行单元同时执行一系列没有依赖关系的指令。</p><p>了解这种技术有助于在代码中触发这种优化。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>前置：</p><p>本文附图类似于甘特图，横向可以并行计算，纵向则必须顺序执行，高度代表执行时间，每个重复单元代表一次迭代。</p><h2>Naive Mode</h2><p>以下是一段标准的累乘操作，每一次*=都需要上一次乘法的结果作为operand，因此构成了数据依赖。</p><p>由于Super Scalar的存在，i++这个add指令和[i]这个load指令和mul指令不存在依赖关系，可以并行，此时执行总时间近似为每次循环执行1次乘法。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-caacf92004d3cf6ce765d5f352378cae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1046\" data-rawheight=\"728\" class=\"origin_image zh-lightbox-thumb\" width=\"1046\" data-original=\"https://pic3.zhimg.com/v2-caacf92004d3cf6ce765d5f352378cae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1046&#39; height=&#39;728&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1046\" data-rawheight=\"728\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1046\" data-original=\"https://pic3.zhimg.com/v2-caacf92004d3cf6ce765d5f352378cae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-caacf92004d3cf6ce765d5f352378cae_b.jpg\"/></figure><h2>Iteration Unrolling</h2><p>这次我们迭代的步长增加，add的次数减少了一半，load次数不变。然而，由于在循环体内，两次乘法仍然存在依赖关系，无法并行，最终我们的执行时间不变。（减少的部分是跳转、自增，但是乘法时间较长因此最终时间没有减少，如果换成整数加法就会有一定减少）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1844db9fa7b7df8af3258fdb7ed70afd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1249\" data-rawheight=\"737\" class=\"origin_image zh-lightbox-thumb\" width=\"1249\" data-original=\"https://pic2.zhimg.com/v2-1844db9fa7b7df8af3258fdb7ed70afd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1249&#39; height=&#39;737&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1249\" data-rawheight=\"737\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1249\" data-original=\"https://pic2.zhimg.com/v2-1844db9fa7b7df8af3258fdb7ed70afd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1844db9fa7b7df8af3258fdb7ed70afd_b.jpg\"/></figure><h2>Divide and Conquer</h2><p>这次我们使用分治，由不同变量处理不同部分的累乘，最终将结果相乘。由于不同变量的累乘彼此独立，因此SuperScalar被触发，两个乘法可以并行计算。最终，通过扩大一倍步长，我们节约了一半的执行时间。随着步长递增，执行时间也会减少。</p><p><b>Hint:</b></p><p>由于计算资源有限，并行计算过多时，寄存器可能无法存下操作数，存入内存，导致减缓；此外，本身执行单元的数目有限。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-01f9fb10bfc8491cfea9e5e89268e4c5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1168\" data-rawheight=\"881\" class=\"origin_image zh-lightbox-thumb\" width=\"1168\" data-original=\"https://pic2.zhimg.com/v2-01f9fb10bfc8491cfea9e5e89268e4c5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1168&#39; height=&#39;881&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1168\" data-rawheight=\"881\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1168\" data-original=\"https://pic2.zhimg.com/v2-01f9fb10bfc8491cfea9e5e89268e4c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-01f9fb10bfc8491cfea9e5e89268e4c5_b.jpg\"/></figure><h2><b>Associative</b></h2><p>我们这次把和结果相乘的operand先相乘，然后和结果相乘，由于前者并不涉及res，因此彼此之间无依赖关系，可以并行计算。而后者必须顺序执行。最终，通过扩大一倍步长，我们节约了一半的执行时间。随着步长递增，执行时间也会减少。</p><p>与上面方法的效果类似，但是显然实现更加简单。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0e8e98a6379f20b33ab85595c192baca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1138\" data-rawheight=\"837\" class=\"origin_image zh-lightbox-thumb\" width=\"1138\" data-original=\"https://pic3.zhimg.com/v2-0e8e98a6379f20b33ab85595c192baca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1138&#39; height=&#39;837&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1138\" data-rawheight=\"837\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1138\" data-original=\"https://pic3.zhimg.com/v2-0e8e98a6379f20b33ab85595c192baca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0e8e98a6379f20b33ab85595c192baca_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "中央处理器 (CPU)", 
                    "tagLink": "https://api.zhihu.com/topics/19553309"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }, 
                {
                    "tag": "并行计算", 
                    "tagLink": "https://api.zhihu.com/topics/19582194"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70779813", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 5, 
            "title": "C|内存管理|COW in Linux", 
            "content": "<h2>简介</h2><p>众所周知，在fork时，属于进程private的内存页将会进行COW机制。所谓COW，就是一个资源如果需要值拷贝，在读时不创建出副本，仅当写时再创建。这样的话，就可以方便地判断出什么资源需要真的进行拷贝，而能够共享则无需拷贝，从而减少了复制的开销。</p><p>这个流程分为两部分：</p><h2>Fork</h2><p>设置父子进程的所有内存页的标志为write protected，</p><p>而在mmap中被标识为shared的内存则会通过<b><i>wp_page_reuse</i></b>标记为wriable</p><p>因为谁先写不知道，所以两者都应该是wp，都能进行COW机制。</p><p>这里产生了一个问题：</p><p>假如父子进程都使用COW，那么在子进程已经copy过的情况下，父进程再copy一次就会造成浪费。（此时原本的一个物理页会对应三个物理页，copy两次）</p><p>而且父子同时使用副本的话，原页在没有进程使用的情况下应该如何释放？如果使用计数的话，我们可以知道这个页在cnt==0时应该gc，但是假如我们已经知道了计数，我们完全可以在cnt==1时就不再复制。（此时原本的一个物理页会对应两个物理页，copy1次）</p><p>Linux中，也的确很节省地使用了这样的方式。</p><h2>COW</h2><p>首先和常识相同，write这些页会触发page fault：</p><p><b><i>handle_pte _fault</i></b></p><p>linux使用<i>handle_pte_fault</i>函数处理：</p><p>如果vma是writable但是却触发了write fault，则调用<i>do_wp_page</i>（write protect）</p><p><b><i>do_wp_page</i></b></p><p>在这个函数里，kernel将会根据物理页遍历所有对应的虚拟页（使用链表）求map cnt，如果map cnt为1，说明当前物理页仅被一个进程使用，不需要COW。（这个过程加锁，防止cnt不同步）。这种情况下，则调用 wp_<i>page_reuse 。</i></p><p><b><i>wp_page_reuse </i></b></p><p>这个函数会在两种情况下调用，要么是上述map cnt==1，要么是mmap里声明为shared（VM_SHARED），原本write_protect的页会直接被标识为writable，即跳过copy。</p><h2>总结</h2><p>COW机制下，父子进程的页都会被标记为write protect</p><ul><li>父子进程均有可能进行copy</li><li>最后一个写的进程不会进行copy，而是直接使用原本的物理页。</li></ul><p>致谢TA，及群内发起的讨论，时间过短，暂时先记录结论。</p>", 
            "topic": [
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70612694", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 9, 
            "title": "C|并发编程|基于Linux\\Futex的互斥锁实现", 
            "content": "<p>OSTEP中有一段Linux下的互斥锁源代码没有很细研读，今日被tdl，ldl一阵教诲，有所醍醐灌顶。以此笔记。</p><a data-draft-node=\"block\" data-draft-type=\"link-card\" href=\"https://zhuanlan.zhihu.com/p/68750396\" class=\"internal\">朝闻君：C|并发编程|互斥锁实现</a><div class=\"highlight\"><pre><code class=\"language-c\"> <span class=\"kt\">void</span> <span class=\"nf\">mutex_lock</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"kt\">int</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n <span class=\"cm\">/* Bit 31 was clear, we got the mutex (the fastpath) */</span>\n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_bit_test_set</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mi\">31</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n <span class=\"k\">return</span><span class=\"p\">;</span>\n <span class=\"n\">atomic_increment</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_bit_test_set</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mi\">31</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">atomic_decrement</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n <span class=\"k\">return</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n <span class=\"cm\">/* We have to waitFirst make sure the futex value\n</span><span class=\"cm\"> we are monitoring is truly negative (locked). */</span>\n\n<span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">;</span>\n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n <span class=\"k\">continue</span><span class=\"p\">;</span>\n\n <span class=\"n\">futex_wait</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">);</span>\n <span class=\"p\">}</span>\n <span class=\"p\">}</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">mutex_unlock</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"cm\">/* Adding 0x80000000 to counter results in 0 if and\n</span><span class=\"cm\"> only if there are not other interested threads */</span>\n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_add_zero</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mh\">0x80000000</span><span class=\"p\">))</span>\n <span class=\"k\">return</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* There are other threads waiting for this mutex,\n</span><span class=\"cm\"> wake one of them up. */</span>\n <span class=\"n\">futex_wake</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n <span class=\"p\">}</span></code></pre></div><p>上述代码采用了Two-Phase互斥锁，具体原理看之前的文章，不多赘述。</p><hr/><h2>Lock</h2><div class=\"highlight\"><pre><code class=\"language-c\"> <span class=\"cm\">/* Bit 31 was clear, we got the mutex (the fastpath) */</span>\n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_bit_test_set</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mi\">31</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n <span class=\"k\">return</span><span class=\"p\">;</span></code></pre></div><p>这一段就是First-Phase，简单的一次自旋。</p><p>然后我们进入Second-Phase，进入等待模式。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">atomic_increment</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span></code></pre></div><p>维护等待队列的长度。</p><div class=\"highlight\"><pre><code class=\"language-c\"> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_bit_test_set</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mi\">31</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">atomic_decrement</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n <span class=\"k\">return</span><span class=\"p\">;</span>\n <span class=\"p\">}</span></code></pre></div><p>在unlock进行了前半截后，任何醒着的等待线程都有机会拿锁。（不一定是刚刚唤醒的）。</p><p>这也会导致一个问题：<b>有可能unlock唤醒的线程并没有拿到刚刚被释放的锁，而是给正在进行lock的锁做了嫁衣。这样的话，刚刚被唤醒的线程会重新回到沉睡状态，同时由队首变为队尾，导致starvation。</b></p><div class=\"highlight\"><pre><code class=\"language-c\"> <span class=\"cm\">/* We have to waitFirst make sure the futex value\n</span><span class=\"cm\"> we are monitoring is truly negative (locked). */</span>\n\n<span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">;</span>\n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n <span class=\"k\">continue</span><span class=\"p\">;</span>\n<span class=\"c1\">//变相continue\n</span><span class=\"c1\"></span> <span class=\"n\">futex_wait</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">);</span>\n <span class=\"p\">}</span></code></pre></div><p>这里有两次校验，<b>第一次校验是为了防止v=*mutex前已经被unlock；第二次校验是为了防止v=*mutex后被unlock。（仅mutex==v时才会wait）</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样的选择会修复一个致命的bug，同时也带来一个缺点。</p><p><b>Bug描述：睡美人！</b></p><p>设当前拿锁线程为C，等待队列中无线程。</p><p>线程B申请拿锁，在执行到上述代码段时，C恰好unlock，此时由于等待队列中无线程，不会唤醒任何线程。<b>然后B进入等待，从此不会被唤醒。（睡美人）</b></p><p>这个问题的原因在于当等待队列为空并且解锁时，B应该直接拿锁而不是进入等待。<b>因此上述代码使用continue让B自己拿锁。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>缺点：回笼觉！</b></p><p>设当前拿锁线程为C，等待队列中有线程B。</p><p>线程A申请拿锁，在执行到上述代码段时，C恰好unlock，此时由于等待队列中有线程B，线程B被唤醒。然后A由于mutex被unlock，continue。</p><p>此时AB两线程同时处于</p><div class=\"highlight\"><pre><code class=\"language-c\"> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_bit_test_set</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mi\">31</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">atomic_decrement</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n <span class=\"k\">return</span><span class=\"p\">;</span>\n <span class=\"p\">}</span></code></pre></div><p><b>因此A线程也有可能拿到锁，导致B线程刚醒来又进入沉睡，产生Starvation。（回笼觉）</b></p><p>如果不continue的话，A可能进入沉睡，这时等待队列中B在A前。这样的话，<b>不会出现之前A先于B拿到锁的情况</b>。</p><p><b>然而，如果B先被唤醒，并且始终运行，在A沉睡前就已经unlock，那么就产生了上面的Bug。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>总之，为了正确性考虑，我们只能牺牲可怜的B进程，哪怕他不停地回笼觉。（不过如果刚唤醒的线程通过调度算法能优先执行就能避免）</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Unlock</b></p><div class=\"highlight\"><pre><code class=\"language-c\"> <span class=\"kt\">void</span> <span class=\"nf\">mutex_unlock</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"cm\">/* Adding 0x80000000 to counter results in 0 if and\n</span><span class=\"cm\"> only if there are not other interested threads */</span>\n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_add_zero</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mh\">0x80000000</span><span class=\"p\">))</span>\n <span class=\"k\">return</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* There are other threads waiting for this mutex,\n</span><span class=\"cm\"> wake one of them up. */</span>\n <span class=\"n\">futex_wake</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n <span class=\"p\">}</span></code></pre></div><p>这段代码的一个问题在于，锁的释放和线程的唤醒不是原子性的。</p><ul><li>运气好，被唤醒的线程不参与竞争直接拿锁；</li><li>运气中等，被唤醒的线程和正在进行lock的线程一起竞<br/>争拿锁；</li><li>运气背，被唤醒的线程还没有醒来，锁已经被别人拿走了。</li></ul><hr/><h2><b>Extension</b></h2><p>为什么要用mutex的前31位存当前等待线程的数目？</p><p>如果把队列信息放在用户态，而不是在futex_wake里判断，那么就能有效减少sys call导致的开销。</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "并发", 
                    "tagLink": "https://api.zhihu.com/topics/19757794"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69145530", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 3, 
            "title": "C|进程调度|公平调度Lottery&CFS", 
            "content": "<p>除了上一篇文章提到的MLFQ外，另一种调度名为proportional-share/fair-share，这种调度policy的目标是控制每个进程占用CPU时间的比例。这种policy的一种早期实现名为lottery scheduling，意思是应该运行更久的进程会更有机会获得lottery（彩票中奖，喻CPU使用）。linux内部则使用CFS作为另一种实现。</p><blockquote>How can we design a scheduler to share the CPU in a proportional manner? What are the key mechanisms for doing so? How effective are they？</blockquote><hr/><h2>基本概念：票券=份额</h2><p>进程所持有的Ticket，用于表征进程所应有的资源份额（share of resource）。</p><p>调度器将会随机选出一则中奖券，拥有中奖券的进程就被调度。尽管抽取的过程是随机的，但是大数定律表明在长期运行的情况下，被调度概率将会趋近于ticket的比例。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Mechanism</h2><p><b>Ticket Currency（货币）</b></p><p>不同User可以分发自己手头的货币给自己的job，这些货币最后会折算成全局的Ticket。</p><p><b>Ticket Transfer（转移）</b></p><p>进程可以暂时地转移自己的票券给另一个进程，以处理突发的需求（如server突然处理信息）</p><p><b>Ticket Inflation（通胀/通缩）</b></p><p>进程可以暂时地增加或减少自己的票券，通常用于一组互相信任的进程之间，这样资源短期分配改变就无需通信了。</p><h2>Implementation</h2><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"c1\">//伪代码\n</span><span class=\"c1\">// counter: used to track if we’ve found the winner yet\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">counter</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// winner: use some call to a random number generator to\n</span><span class=\"c1\">// get a value, between 0 and the total # of tickets\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">winner</span> <span class=\"o\">=</span> <span class=\"n\">getrandom</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">totaltickets</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// current: use this to walk through the list of jobs\n</span><span class=\"c1\"></span><span class=\"n\">node_t</span> <span class=\"o\">*</span><span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">current</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"n\">counter</span> <span class=\"o\">=</span> <span class=\"n\">counter</span> <span class=\"o\">+</span> <span class=\"n\">current</span><span class=\"o\">-&gt;</span><span class=\"n\">tickets</span><span class=\"p\">;</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">counter</span> <span class=\"o\">&gt;</span> <span class=\"n\">winner</span><span class=\"p\">)</span>\n<span class=\"k\">break</span><span class=\"p\">;</span> <span class=\"c1\">// found the winner\n</span><span class=\"c1\"></span><span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">current</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"o\">//</span> <span class=\"err\">’</span><span class=\"n\">current</span><span class=\"err\">’</span> <span class=\"n\">is</span> <span class=\"n\">the</span> <span class=\"nl\">winner</span><span class=\"p\">:</span> <span class=\"n\">schedule</span> <span class=\"n\">it</span><span class=\"p\">...</span></code></pre></div><p>就是单纯生成一个随机数...然后遍历所有进程，看随机数处于哪个进程里面。</p><p>但是，计算机生成的随机数在取模到某个区间后是不均匀分布的，所以需要其他算法，如。</p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/2509679/how-to-generate-a-random-integer-number-from-within-a-range\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-2d47e939feed796bcf7483d306661c88_ipico.jpg\" data-image-width=\"316\" data-image-height=\"316\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How to generate a random integer number from within a range</a><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"c1\">// Assumes 0 &lt;= max &lt;= RAND_MAX\n</span><span class=\"c1\">// Returns in the closed interval [0, max]\n</span><span class=\"c1\"></span><span class=\"kt\">long</span> <span class=\"nf\">random_at_most</span><span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"n\">max</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span>\n    <span class=\"c1\">// max &lt;= RAND_MAX &lt; ULONG_MAX, so this is okay.\n</span><span class=\"c1\"></span>    <span class=\"n\">num_bins</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span><span class=\"p\">)</span> <span class=\"n\">max</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"n\">num_rand</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span><span class=\"p\">)</span> <span class=\"n\">RAND_MAX</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"n\">bin_size</span> <span class=\"o\">=</span> <span class=\"n\">num_rand</span> <span class=\"o\">/</span> <span class=\"n\">num_bins</span><span class=\"p\">,</span>\n    <span class=\"n\">defect</span>   <span class=\"o\">=</span> <span class=\"n\">num_rand</span> <span class=\"o\">%</span> <span class=\"n\">num_bins</span><span class=\"p\">;</span>\n\n  <span class=\"kt\">long</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n  <span class=\"k\">do</span> <span class=\"p\">{</span>\n   <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// This is carefully written not to overflow\n</span><span class=\"c1\"></span>  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">num_rand</span> <span class=\"o\">-</span> <span class=\"n\">defect</span> <span class=\"o\">&lt;=</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span><span class=\"p\">)</span><span class=\"n\">x</span><span class=\"p\">);</span>\n\n  <span class=\"c1\">// Truncated division is intentional\n</span><span class=\"c1\"></span>  <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"o\">/</span><span class=\"n\">bin_size</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>为了尽可能减少遍历链表的次数，应该把ticket多的进程放在表前，因此链表最好有序。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Ticket Assignment</h2><p>依赖于具体实现，如何allocate这些ticket</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Stride Scheduling</h2><p>假设一共100张票，ABC分别为10/5/25,那么stride步长为10/20/4（名为stride）</p><p>同时维护另一个变量，每次进程运行，计数器将会自增（名为pass）</p><p>调度方法：</p><p>每次挑pass最小的进程，自增量为stride。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">curr</span> <span class=\"o\">=</span> <span class=\"n\">remove_min</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">);</span> <span class=\"c1\">// pick client with min pass\n</span><span class=\"c1\"></span><span class=\"n\">schedule</span><span class=\"p\">(</span><span class=\"n\">curr</span><span class=\"p\">);</span> <span class=\"c1\">// run for quantum\n</span><span class=\"c1\"></span><span class=\"n\">curr</span><span class=\"o\">-&gt;</span><span class=\"n\">pass</span> <span class=\"o\">+=</span> <span class=\"n\">curr</span><span class=\"o\">-&gt;</span><span class=\"n\">stride</span><span class=\"p\">;</span> <span class=\"c1\">// update pass using stride\n</span><span class=\"c1\"></span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">,</span> <span class=\"n\">curr</span><span class=\"p\">);</span> <span class=\"o\">//</span> <span class=\"k\">return</span> <span class=\"n\">curr</span> <span class=\"n\">to</span> <span class=\"n\">queue</span></code></pre></div><p>然而，这样虽然减少了生成随机数的开销，但是pass值就很尴尬，假如加入新的进程，那么pass的值就不好设置了。因此这种策略不容易实现。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>The Linux Completely Fair Scheduler (CFS)</h2><p>Linux使用了CFS作为调度算法，为了按比例分配CPU，它使用了基于计数的virtual runtime技巧。</p><p>正常情况，进程vruntime增长将会和物理时间增长速度成正比，操作系统将会选择vruntime最小的进程进行调度，并对每个进程划分相应的time slice。但这也导致了一个问题，什么时候切换出去呢？有这样几个参数。</p><p><b>sched latency</b></p><p>进程应该跑多久（通常48ms/进程数）</p><p><b>min granularity</b></p><p>进程最小的time slice</p><p>由于使用了time counter，因此这些运行时间将会和中断周期成整数倍。尽管实际运行时间不一定是整数倍，但是因为vruntime的存在，记录的时间还是精确的。</p><h2>weighting（Niceness）</h2><p>每个进程的nice值从-19到20，并被映射到不同的权重。然后按比例分配time slice即可。注意这里的比例基本是近似于等比增长</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">prio_to_weight</span><span class=\"p\">[</span><span class=\"mi\">40</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n<span class=\"cm\">/* -20 */</span> <span class=\"mi\">88761</span><span class=\"p\">,</span> <span class=\"mi\">71755</span><span class=\"p\">,</span> <span class=\"mi\">56483</span><span class=\"p\">,</span> <span class=\"mi\">46273</span><span class=\"p\">,</span> <span class=\"mi\">36291</span><span class=\"p\">,</span>\n<span class=\"cm\">/* -15 */</span> <span class=\"mi\">29154</span><span class=\"p\">,</span> <span class=\"mi\">23254</span><span class=\"p\">,</span> <span class=\"mi\">18705</span><span class=\"p\">,</span> <span class=\"mi\">14949</span><span class=\"p\">,</span> <span class=\"mi\">11916</span><span class=\"p\">,</span>\n<span class=\"cm\">/* -10 */</span> <span class=\"mi\">9548</span><span class=\"p\">,</span> <span class=\"mi\">7620</span><span class=\"p\">,</span> <span class=\"mi\">6100</span><span class=\"p\">,</span> <span class=\"mi\">4904</span><span class=\"p\">,</span> <span class=\"mi\">3906</span><span class=\"p\">,</span>\n<span class=\"cm\">/* -5 */</span> <span class=\"mi\">3121</span><span class=\"p\">,</span> <span class=\"mi\">2501</span><span class=\"p\">,</span> <span class=\"mi\">1991</span><span class=\"p\">,</span> <span class=\"mi\">1586</span><span class=\"p\">,</span> <span class=\"mi\">1277</span><span class=\"p\">,</span>\n<span class=\"cm\">/* 0 */</span> <span class=\"mi\">1024</span><span class=\"p\">,</span> <span class=\"mi\">820</span><span class=\"p\">,</span> <span class=\"mi\">655</span><span class=\"p\">,</span> <span class=\"mi\">526</span><span class=\"p\">,</span> <span class=\"mi\">423</span><span class=\"p\">,</span>\n<span class=\"cm\">/* 5 */</span> <span class=\"mi\">335</span><span class=\"p\">,</span> <span class=\"mi\">272</span><span class=\"p\">,</span> <span class=\"mi\">215</span><span class=\"p\">,</span> <span class=\"mi\">172</span><span class=\"p\">,</span> <span class=\"mi\">137</span><span class=\"p\">,</span>\n<span class=\"cm\">/* 10 */</span> <span class=\"mi\">110</span><span class=\"p\">,</span> <span class=\"mi\">87</span><span class=\"p\">,</span> <span class=\"mi\">70</span><span class=\"p\">,</span> <span class=\"mi\">56</span><span class=\"p\">,</span> <span class=\"mi\">45</span><span class=\"p\">,</span>\n<span class=\"cm\">/* 15 */</span> <span class=\"mi\">36</span><span class=\"p\">,</span> <span class=\"mi\">29</span><span class=\"p\">,</span> <span class=\"mi\">23</span><span class=\"p\">,</span> <span class=\"mi\">18</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">,</span>\n<span class=\"p\">};</span>\n</code></pre></div><h2>R-B Tree</h2><p>linux使用红黑树存储所有正在运行的进程的节点（不包含sleeping进程），目的是可以在找到vruntime最小的进程并调度后，插入时仍然可以 <img src=\"https://www.zhihu.com/equation?tex=O%28log%28n%29%29\" alt=\"O(log(n))\" eeimg=\"1\"/> 。</p><p>为了防止苏醒的进程的vruntime远远落后于其他进程而导致starvation，当进程苏醒之后，vruntime将会是树中最小的vruntime。当然这会牺牲一定的公平性。</p><p>此外，还有更多的性质，这里暂且跳过（书上让你read more）</p>", 
            "topic": [
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }, 
                {
                    "tag": "调度算法", 
                    "tagLink": "https://api.zhihu.com/topics/19795728"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69122146", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 1, 
            "title": "Python|函数式编程|公式约束器实现", 
            "content": "<p><img src=\"https://www.zhihu.com/equation?tex=Fahrenheit%3D32%E2%84%89%2B9%2F5Celsius\" alt=\"Fahrenheit=32℉+9/5Celsius\" eeimg=\"1\"/> </p><p>这个公式很简单，写成函数的话，用最简单的一个return即可。然而，如果我想要让他推广，输入华氏度也能求出摄氏度，甚至更广，一个公式里，只要其他的n-1个变量已知，就能自动补全公式，该怎么做呢？</p><blockquote>代码非原创，我只能对着大佬源码膜拜一番</blockquote><h2>运行范例</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a4f6415be5aaf5771943acf384e932df_b.jpg\" data-rawwidth=\"506\" data-rawheight=\"532\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"506\" data-original=\"https://pic4.zhimg.com/v2-a4f6415be5aaf5771943acf384e932df_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;506&#39; height=&#39;532&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"506\" data-rawheight=\"532\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"506\" data-original=\"https://pic4.zhimg.com/v2-a4f6415be5aaf5771943acf384e932df_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a4f6415be5aaf5771943acf384e932df_b.jpg\"/><figcaption>运行结果</figcaption></figure><p>在上述代码中，对celsius的改变使得华氏度也发生了改变。</p><p>我们首先划分代码的架构，一共三个模块</p><p>connector（连接器） 高级的变量，可以通过约束发出通知和接受通知。</p><p>由于全程使用FP，因此OOP中的方法目前使用字典key进行调用。如celsius[&#39;forget&#39;]意为celsius.forget。</p><p>contraint （约束） 公式的约束，可以对connector之间进行连接，连接之后通过约束就能对connector进行通知了。</p><p>converter （转换器）负责装配公式中的所有连接器和约束</p><h2>Constraint Part</h2><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">def</span> <span class=\"nf\">make_ternary_constraint</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">,</span><span class=\"n\">ab</span><span class=\"p\">,</span><span class=\"n\">ca</span><span class=\"p\">,</span><span class=\"n\">cb</span><span class=\"p\">):</span>\n   <span class=\"c1\">#三元约束</span>\n    <span class=\"k\">def</span> <span class=\"nf\">new_value</span><span class=\"p\">():</span>\n        <span class=\"c1\">#通用计算公式,求出第三者连接器</span>\n        <span class=\"n\">av</span><span class=\"p\">,</span><span class=\"n\">bv</span><span class=\"p\">,</span><span class=\"n\">cv</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">connector</span><span class=\"p\">[</span><span class=\"s1\">&#39;has_val&#39;</span><span class=\"p\">]()</span><span class=\"k\">for</span> <span class=\"n\">connector</span> <span class=\"ow\">in</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">)]</span>\n        <span class=\"k\">if</span> <span class=\"n\">av</span> <span class=\"ow\">and</span> <span class=\"n\">bv</span><span class=\"p\">:</span>\n            <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;set_val&#39;</span><span class=\"p\">](</span><span class=\"n\">constraint</span><span class=\"p\">,</span><span class=\"n\">ab</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">],</span><span class=\"n\">b</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">]))</span>\n        <span class=\"k\">elif</span> <span class=\"n\">av</span> <span class=\"ow\">and</span> <span class=\"n\">cv</span><span class=\"p\">:</span>\n            <span class=\"n\">b</span><span class=\"p\">[</span><span class=\"s1\">&#39;set_val&#39;</span><span class=\"p\">](</span><span class=\"n\">constraint</span><span class=\"p\">,</span><span class=\"n\">ca</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">],</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">]))</span>\n        <span class=\"k\">elif</span> <span class=\"n\">bv</span> <span class=\"ow\">and</span> <span class=\"n\">cv</span><span class=\"p\">:</span>\n            <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"s1\">&#39;set_val&#39;</span><span class=\"p\">](</span><span class=\"n\">constraint</span><span class=\"p\">,</span><span class=\"n\">cb</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">],</span><span class=\"n\">b</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">]))</span>\n    <span class=\"k\">def</span> <span class=\"nf\">forget_value</span><span class=\"p\">():</span>\n        <span class=\"c1\">#对abc三个连接器均使用forget函数</span>\n        <span class=\"k\">for</span> <span class=\"n\">connector</span> <span class=\"ow\">in</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">):</span>\n            <span class=\"n\">connector</span><span class=\"p\">[</span><span class=\"s1\">&#39;forget&#39;</span><span class=\"p\">](</span><span class=\"n\">constraint</span><span class=\"p\">)</span>\n    <span class=\"c1\">#constraint为调用dictionary,传递message给连接器</span>\n    <span class=\"n\">constraint</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;new_val&#39;</span><span class=\"p\">:</span><span class=\"n\">new_value</span><span class=\"p\">,</span><span class=\"c1\">#表示连接到约束的连接器有了新的值</span>\n                <span class=\"s1\">&#39;forget&#39;</span><span class=\"p\">:</span><span class=\"n\">forget_value</span><span class=\"p\">}</span><span class=\"c1\">#表示连接到约束的连接器需要忘掉它的值</span>\n    <span class=\"k\">for</span> <span class=\"n\">connector</span> <span class=\"ow\">in</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">):</span>\n        <span class=\"c1\">#令abc三个连接器均加入约束</span>\n        <span class=\"n\">connector</span><span class=\"p\">[</span><span class=\"s1\">&#39;connect&#39;</span><span class=\"p\">](</span><span class=\"n\">constraint</span><span class=\"p\">)</span>\n    <span class=\"c1\">#返回三元约束</span>\n    <span class=\"k\">return</span> <span class=\"n\">constraint</span></code></pre></div><p>在上述函数中，a,b,c是参与约束的三个连接器，ab，ca，cb则是操作符，意思是知道其中两者的情况下，使用对应的操作符可以得到第三者。</p><p><b>Constraint Method</b></p><p><b>new_value()：</b></p><p>先通过has_val观察是否存在已知变量，如果已知变量为n-1个，就能求出未知变量。</p><p><b>forget_value()</b>：</p><p>调用连接器中的forget函数清空其值，此后forget会对所有参与的约束都发出清空通知（因为一个连接器可能参与多个约束，例如方程组），相当于链式反应。</p><p>此后，所有连接器都加入这个约束，最后返回。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">from</span> <span class=\"nn\">operator</span> <span class=\"k\">import</span> <span class=\"n\">add</span><span class=\"p\">,</span><span class=\"n\">sub</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">adder</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">):</span>\n    <span class=\"c1\">#加法公式的三元约束</span>\n    <span class=\"k\">return</span> <span class=\"n\">make_ternary_constraint</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">,</span><span class=\"n\">add</span><span class=\"p\">,</span><span class=\"n\">sub</span><span class=\"p\">,</span><span class=\"n\">sub</span><span class=\"p\">)</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">operator</span> <span class=\"k\">import</span> <span class=\"n\">mul</span><span class=\"p\">,</span><span class=\"n\">truediv</span>\n<span class=\"k\">def</span> <span class=\"nf\">multiplier</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">):</span>\n    <span class=\"c1\">#乘法公式的三元约束</span>\n    <span class=\"k\">return</span> <span class=\"n\">make_ternary_constraint</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">,</span><span class=\"n\">mul</span><span class=\"p\">,</span><span class=\"n\">truediv</span><span class=\"p\">,</span><span class=\"n\">truediv</span><span class=\"p\">)</span></code></pre></div><p>通过上面的高阶函数，我们可以建立这样的约束工具不断地减少参数数目，从而实现更好的抽象层次划分。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Connector Part</h2><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\">#Connector part</span>\n<span class=\"k\">def</span> <span class=\"nf\">make_connector</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"c1\">#接受来自约束的消息,name为变量连接器的名称</span>\n    <span class=\"n\">informant</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"c1\">#存储此connector的用户设置约束</span>\n    <span class=\"n\">constraints</span><span class=\"o\">=</span><span class=\"p\">[]</span><span class=\"c1\">#存储连接器所参与的所有约束(包含公式得出的匿名约束)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">set_value</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">,</span><span class=\"n\">value</span><span class=\"p\">):</span>\n        <span class=\"k\">nonlocal</span> <span class=\"n\">informant</span>\n        <span class=\"n\">val</span><span class=\"o\">=</span><span class=\"n\">connector</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">]</span>\n        <span class=\"k\">if</span> <span class=\"n\">val</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"c1\">#若不存在值,则设置其为value,informant设置为约束(通过用户设置的约束)</span>\n            <span class=\"n\">informant</span><span class=\"p\">,</span><span class=\"n\">connector</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"n\">source</span><span class=\"p\">,</span><span class=\"n\">value</span>\n            <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span><span class=\"s1\">&#39;=&#39;</span><span class=\"p\">,</span><span class=\"n\">value</span><span class=\"p\">)</span>\n            <span class=\"c1\">#对所有约束均调用new_value</span>\n            <span class=\"n\">inform_all_except</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">,</span><span class=\"s1\">&#39;new_val&#39;</span><span class=\"p\">,</span><span class=\"n\">constraints</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\">#若传入了不同的值,则发生矛盾</span>\n            <span class=\"k\">if</span> <span class=\"n\">val</span><span class=\"o\">!=</span><span class=\"n\">value</span><span class=\"p\">:</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Contradiction detected:&#39;</span><span class=\"p\">,</span><span class=\"n\">val</span><span class=\"p\">,</span><span class=\"s1\">&#39;vs&#39;</span><span class=\"p\">,</span><span class=\"n\">value</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">forget_value</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">):</span>\n        <span class=\"k\">nonlocal</span> <span class=\"n\">informant</span>\n        <span class=\"k\">if</span> <span class=\"n\">informant</span><span class=\"o\">==</span><span class=\"n\">source</span><span class=\"p\">:</span>\n            <span class=\"c1\">#若informant和约束名称相同(即密码正确且此前未被forget),则将informant和值归0</span>\n            <span class=\"n\">informant</span><span class=\"p\">,</span><span class=\"n\">connector</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span><span class=\"kc\">None</span>\n            <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span><span class=\"s1\">&#39;is forgotten&#39;</span><span class=\"p\">)</span>\n            <span class=\"c1\">#对所有约束调用forget_value</span>\n            <span class=\"n\">inform_all_except</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">,</span><span class=\"s1\">&#39;forget&#39;</span><span class=\"p\">,</span><span class=\"n\">constraints</span><span class=\"p\">)</span>\n    <span class=\"n\">connector</span> <span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">:</span><span class=\"kc\">None</span><span class=\"p\">,</span><span class=\"c1\">#当前值</span>\n                <span class=\"s1\">&#39;set_val&#39;</span><span class=\"p\">:</span><span class=\"n\">set_value</span><span class=\"p\">,</span><span class=\"c1\">#表示source请求连接器将当前值设置为该值</span>\n                <span class=\"s1\">&#39;forget&#39;</span><span class=\"p\">:</span><span class=\"n\">forget_value</span><span class=\"p\">,</span><span class=\"c1\">#告诉连接器，source请求它忘掉当前值</span>\n                <span class=\"s1\">&#39;has_val&#39;</span><span class=\"p\">:</span><span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"n\">connector</span><span class=\"p\">[</span><span class=\"s1\">&#39;val&#39;</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">,</span><span class=\"c1\">#返回连接器是否已经有了一个值</span>\n                <span class=\"s1\">&#39;connect&#39;</span><span class=\"p\">:</span><span class=\"k\">lambda</span> <span class=\"n\">source</span><span class=\"p\">:</span><span class=\"n\">constraints</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">)}</span><span class=\"c1\">#告诉连接器参与新的约束source</span>\n    <span class=\"c1\">#连接器 字典 key:string literal, value: function</span>\n    <span class=\"k\">return</span> <span class=\"n\">connector</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">inform_all_except</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">,</span><span class=\"n\">message</span><span class=\"p\">,</span><span class=\"n\">constraints</span><span class=\"p\">):</span>\n    <span class=\"c1\">#通知约束来改变所有连接器</span>\n    <span class=\"k\">for</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"n\">constraints</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">c</span><span class=\"o\">!=</span><span class=\"n\">source</span><span class=\"p\">:</span>\n            <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"n\">message</span><span class=\"p\">]()</span></code></pre></div><p>在上述函数中，我们为一个连接器取名为name（或者匿名）<br/><b>Connector Method</b></p><p><b>set_val(source,value)</b></p><p>由某个来源（这个来源可以是任何东西，比如上文中的‘user’手动添加，也可以是约束本身自动添加），设置连接器变量的值，并且存储来源（目的是使得forget必须要由设置者来进行）</p><p>如果先前已经有值，则发生冲突不予改变。</p><p>如果先前为空，则调用new_value尝试对整个公式进行补全。</p><p><b>forget(source)</b></p><p>如果来源正确，那么就清空connector的值，并且向所有参与的约束都发出清空通知</p><p><b>has_val()</b></p><p>返回当前是否有值</p><p><b>connect(source)</b></p><p>连接器参与约束</p><p><b>Connector Data Member</b> </p><p><b>informant</b></p><p>存储此connector的用户设置约束(如果是人工设置的话，只要是身份标识即可）</p><p><b>constraints</b></p><p>存储连接器所参与的所有约束(包含公式得出的匿名约束)</p><p><b>Normal Function</b></p><p><b>inform_all_except(source,message,constraints)</b></p><p>链式反应，发出信息，注意source，不能回发给自己</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Converter Part</h2><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">def</span> <span class=\"nf\">make_converter</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span><span class=\"n\">f</span><span class=\"p\">):</span>\n    <span class=\"c1\">#装配连接器和约束条件</span>\n    <span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">v</span><span class=\"p\">,</span><span class=\"n\">w</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">make_connector</span><span class=\"p\">()</span><span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)]</span><span class=\"c1\">#五个匿名连接器,9*c=5*(f-32)</span>\n    <span class=\"n\">multiplier</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span><span class=\"n\">w</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">)</span><span class=\"c1\">#c*9=u</span>\n    <span class=\"n\">multiplier</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">)</span><span class=\"c1\">#v*5=u</span>\n    <span class=\"n\">adder</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"c1\">#v+32=f</span>\n    <span class=\"c1\">#根据此连接器,c,f可相互转换</span>\n    <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">,</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"c1\">#w:9</span>\n    <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"c1\">#x:5</span>\n    <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"mi\">32</span><span class=\"p\">)</span><span class=\"c1\">#y:32</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">constant</span><span class=\"p\">(</span><span class=\"n\">connector</span><span class=\"p\">,</span><span class=\"n\">value</span><span class=\"p\">):</span>\n    <span class=\"c1\">#不施加约束,仅设置连接器的值</span>\n    <span class=\"n\">constraint</span><span class=\"o\">=</span><span class=\"p\">{}</span>\n    <span class=\"n\">connector</span><span class=\"p\">[</span><span class=\"s1\">&#39;set_val&#39;</span><span class=\"p\">](</span><span class=\"n\">constraint</span><span class=\"p\">,</span><span class=\"n\">value</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">constraint</span></code></pre></div><p>我们这里把不施加约束（｛｝）的connector作为常量，因为这样在forget时就不受影响了。因此我们特意用了一个函数来设置。</p><p><img src=\"https://www.zhihu.com/equation?tex=Fahrenheit%3D32%E2%84%89%2B9%2F5Celsius\" alt=\"Fahrenheit=32℉+9/5Celsius\" eeimg=\"1\"/></p><p>这个公式需要翻译一下才能变成我们已经有的三元约束。（9和5分开可能是因为作者想增加一点难度）</p><div class=\"highlight\"><pre><code class=\"language-python3\">    <span class=\"n\">multiplier</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span><span class=\"n\">w</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">)</span><span class=\"c1\">#c*9=u</span>\n    <span class=\"n\">multiplier</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">)</span><span class=\"c1\">#v*5=u</span></code></pre></div><p><img src=\"https://www.zhihu.com/equation?tex=c%5Ctimes9%3Du\" alt=\"c\\times9=u\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=v%5Ctimes5%3Du\" alt=\"v\\times5=u\" eeimg=\"1\"/> </p><p>这两个公式，实际上就是使得v代表9/5Celsius，从而让两个connector连接到一个上。</p><div class=\"highlight\"><pre><code class=\"language-python3\">    <span class=\"n\">adder</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"n\">f</span><span class=\"p\">)</span></code></pre></div><p><img src=\"https://www.zhihu.com/equation?tex=9%2F5c%2B32%3Df\" alt=\"9/5c+32=f\" eeimg=\"1\"/> </p><p>这个公式实际上就是最后的公式。</p><p>通过这样几个约束，我们成功搭建了最后的公式。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-411796f702b5f75eb6e099717a216012_b.jpg\" data-rawwidth=\"757\" data-rawheight=\"528\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"757\" data-original=\"https://pic3.zhimg.com/v2-411796f702b5f75eb6e099717a216012_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;757&#39; height=&#39;528&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"757\" data-rawheight=\"528\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"757\" data-original=\"https://pic3.zhimg.com/v2-411796f702b5f75eb6e099717a216012_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-411796f702b5f75eb6e099717a216012_b.jpg\"/><figcaption>Converter 网络</figcaption></figure><p>通过构建的约束网络，我们使得C上的信息通过三层约束的传播到达F，反之亦然，这样子的架构比起单纯的函数映射提供了更多的便利性，同时改变公式的复杂度也只需要构造更大的网络即可。</p><p>这一段代码我认为是SICP第二章最精彩的部分，因此复习了一番，也全了我心中的困惑。</p><a data-draft-node=\"block\" data-draft-type=\"link-card\" href=\"https://link.zhihu.com/?target=https%3A//www.gitbook.com/book/wizardforcel/sicp-in-python/details\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SICP in Python · GitBook (Legacy)</a><p>这本书大一看的英文版，后来才发现民间译者是我院学长 <a class=\"member_mention\" href=\"https://www.zhihu.com/people/6d1a164af570b03f27b5f58534f7557e\" data-hash=\"6d1a164af570b03f27b5f58534f7557e\" data-hovercard=\"p$b$6d1a164af570b03f27b5f58534f7557e\">@飞龙</a>，多谢资源。</p>", 
            "topic": [
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }, 
                {
                    "tag": "函数式编程", 
                    "tagLink": "https://api.zhihu.com/topics/19585411"
                }, 
                {
                    "tag": "《计算机程序的构造和解释》（SICP）", 
                    "tagLink": "https://api.zhihu.com/topics/19620884"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69096771", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 2, 
            "title": "C|进程调度|单核CPU调度", 
            "content": "<p>CPU调度，决定了CPU执行进程的策略，好的调度policy需要兼顾进程首次被调度的等待时间和进程结束执行的等待时间，因此在算法设计上极其精妙。本章完全Copy自OSTEP，介绍了基础的调度算法。</p><a href=\"https://link.zhihu.com/?target=http%3A//pages.cs.wisc.edu/~remzi/OSTEP\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OSTEP</a><h2>初始条件：</h2><p>我们先简化条件，从理想情况开始，再逐步去除限制</p><ol><li>Each job runs for the same amount of time. </li><li>All jobs arrive at the same time. </li><li>Once started, each job runs to completion. </li><li>All jobs only use the CPU (i.e., they perform no I/O) </li><li>The run-time of each job is known.</li></ol><h2>Metric I</h2><p>进程结束所等待的时间</p><p><img src=\"https://www.zhihu.com/equation?tex=T_%7Bturnaround%7D+%3D+T_%7Bcompletion%7D+%E2%88%92+T_%7Barrival%7D+\" alt=\"T_{turnaround} = T_{completion} − T_{arrival} \" eeimg=\"1\"/> </p><h2>条件一</h2><p>假设条件1取消，进程ABC用时分别为100/10/10</p><p><b>FIFO</b></p><p>总用时100/110/120</p><p><b>SJF</b></p><p>因此我们将<b>队列变为优先队列</b>，Shortest Job First，总用时10/20/120</p><h2>条件二</h2><p>假设条件2取消，进程BC延迟10秒到达，总用时100/110/120</p><p>由于不能Switch，因此A执行后必须执行到底，无法优化</p><h2>条件三</h2><p>假设条件3取消，可以进行Process Switch</p><p><b>Shortest Time-to-Completion First （STCF）</b></p><p>每次新job进入，重新进行调度，按照剩余时间进行调度（可以看作把job分割）</p><h2>Metric II</h2><p>首次被调度等待的时间</p><p><img src=\"https://www.zhihu.com/equation?tex=T_%7Bresponse+%7D%3DT_%7Bfirstturn%7D-T_%7Barrival%7D\" alt=\"T_{response }=T_{firstturn}-T_{arrival}\" eeimg=\"1\"/> </p><p><b>Round Robin</b></p><p>时间切片，每次切片都轮换所有进程。这样避免了长时间进程过长等待，但是会带来更多Switching Cost(Context,flush TLB &amp; pipeline)</p><h2>条件四</h2><p>假设条件4取消，可以进行I/O</p><p>当进程A进行I/O时，由于I/O速度比CPU更慢，因此CPU需要等待I/O完成，此时CPU处于闲置，因此可以Switch给其他进程。</p><p>按耗时占比可以分为I/O-intensive 和 CPU-intensive</p><h2>条件五</h2><p>假设条件5取消，在开始进程前进程时间未知</p><p><b>Multi-Level Feedback Queue（MLFQ）</b></p><p>最小化 <img src=\"https://www.zhihu.com/equation?tex=T_%7Bresponse%7D\" alt=\"T_{response}\" eeimg=\"1\"/> ,尽可能优化 <img src=\"https://www.zhihu.com/equation?tex=T_%7Bturnarround%7D\" alt=\"T_{turnarround}\" eeimg=\"1\"/> </p><p>以历史预测未来（这个思想在很多算法中都有使用，隔壁线性分配的内存再分配算法里也用了</p><a href=\"https://zhuanlan.zhihu.com/p/68657294\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/equation.jpg\" class=\"internal\">朝闻君：TAOCP|基本算法|顺序分配</a><p>，此外还有cache，hardware branch)。但是假如历史并不能很好预测未来或者预测了相反的未来，那么反而引起误导。</p><p><b>Basic Rules</b></p><p>划分优先级，每个优先级都有独立的队列</p><p>Rule 1：</p><p>同优先级，Round Robin</p><p>Rule 2：</p><p>不同优先级，执行高优先级的进程（减少切换开销）</p><p>Rule 3：</p><p>新进程优先级最高（这样减少了response time）</p><p>Rule 4a：</p><p>单次执行一次完整time slice，优先级减少一级（这样运行时间长的自然就低优先级了）</p><p>Rule 4b：</p><p>如果执行了I/O，优先级不变（I-O intensive，可以高优先级处理，反正大部分时间都是空闲的）</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>问题：</b></p><p>1.starvation </p><p>大量I/O-intensive 挤占高优先级，导致CPU-intensive无法执行。</p><p>2.Gaming scheduler attack</p><p>故意进行短I/O，不降级（CPU-intensive 伪装成I/O-intensive欺诈）</p><p>3. 程序行为改变</p><p>前期主要使用CPU，后期主使用I/O，然而优先级无法逆转</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Extra Rules</b></p><p>Rule 5：</p><p>定期将所有进程全部移动至最高优先级（处理程序行为改变）</p><p>change Rule 4：</p><p>累积执行一定时间限额后降级（处理attack和starvation）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>问题：</p><p>如何确定参数，如优先级，time slice长度，多久重置一次优先级。</p><p>考虑typical workload 下的最佳参数（黑盒炼丹</p><p>一般而言，训练的结果是：</p><p>高优先级给的slice短</p><p>低优先级给的slice长</p><p>但是这种训练方法肯定没办法处理所有情况，因此可以用一个配置文件，让管理员作为调参侠，手动调节。</p><hr/><h2>疑惑</h2><p>首次被调度等待的时间</p><p><img src=\"https://www.zhihu.com/equation?tex=T_%7Bresponse+%7D%3DT_%7Bfirstturn%7D-T_%7Barrival%7D\" alt=\"T_{response }=T_{firstturn}-T_{arrival}\" eeimg=\"1\"/> </p><h2>Round Robin</h2><p>时间切片，每次都轮换所有进程。这样避免了长时间进程过长等待，但是会带来更多Switching Cost(Context,flush TLB &amp; pipeline)</p><p><b>？讲道理，如果metric只是first turn的话，那我直接每次新进来进程做个round r</b>o<b>bin，让新进程first turn很短，然后切回正常的优先队列就好了。</b></p><p><b>我认为这里的Metric应该是</b></p><p><img src=\"https://www.zhihu.com/equation?tex=T_%7Bwait%7D%3DT_%7Bthis-turn-begin%7D+-+T_%7Blast-turn-end%7D\" alt=\"T_{wait}=T_{this-turn-begin} - T_{last-turn-end}\" eeimg=\"1\"/> </p><p>也就是<b>不能让一个进程被闲置太久</b>，而不是只看第一次response的时间。</p><hr/><p class=\"ztext-empty-paragraph\"><br/></p><p>由于现代PC都是多核处理器，因此等我之后有时间再发多核版本。可见</p><a href=\"https://link.zhihu.com/?target=http%3A//pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-multi.pdf\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Multi CPU Processing</a><blockquote>Reference:OSTEP</blockquote>", 
            "topic": [
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }, 
                {
                    "tag": "调度算法", 
                    "tagLink": "https://api.zhihu.com/topics/19795728"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": [
                {
                    "userName": "毛毛大王", 
                    "userLink": "https://www.zhihu.com/people/1267494666497def633b2e6d130e4efa", 
                    "content": "ics笔记", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68750396", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 6, 
            "title": "C|并发编程|互斥锁实现", 
            "content": "<blockquote>OS:Three Easy Pieces</blockquote><a href=\"https://link.zhihu.com/?target=http%3A//pages.cs.wisc.edu/~remzi/OSTEP/threads-locks.pdf\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Lock</a><h2><b>导语</b></h2><p>锁Lock，正如现实中的锁一样，决定了对于资源的访问权。在并发编程中，由于资源共享的缘故，一个线程中的write操作有可能影响到另一个线程的read操作。</p><p>部分严格的程序员为了杜绝这种side effect，选择了<b>Functional Programming</b>，以确保完全的Thread Safety。而在正常的结构化编程中，程序员倾向于使用锁，防止意料之外的Side Effect。</p><p>锁控制了一个资源只能被一个线程同时访问，因此有效避免了多线程情况下的读写导致的异常输出。</p><hr/><h2>自旋Spinning锁</h2><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">__lock_t</span> <span class=\"p\">{</span> <span class=\"kt\">int</span> <span class=\"n\">flag</span><span class=\"p\">;</span> <span class=\"p\">}</span> <span class=\"n\">lock_t</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"c1\">// 0 -&gt; lock is available, 1 -&gt; held\n</span><span class=\"c1\"></span> <span class=\"n\">mutex</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">lock</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">// TEST the flag   Line a\n</span><span class=\"c1\"></span> <span class=\"p\">;</span> <span class=\"c1\">// spin-wait (do nothing)\n</span><span class=\"c1\"></span> <span class=\"n\">mutex</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">// now SET it!             Line b\n</span><span class=\"c1\"></span> <span class=\"p\">}</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">mutex</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n</code></pre></div><p>这是一个最基本的版本，当flag置1时，锁被获得，而flag置0时，锁被释放。而当锁没有被释放时，程序将会不断检测flag，而不做任何实际事情，因此被称作<b>自旋。</b></p><p><b>原子性Atomicity</b></p><p>这个版本存在着一个致命的bug，因为CPU调度并不保证Line a与Line b之间不会插入其他线程的代码。如果在line a之后其他线程已经获得了锁，那么line ba仍然会被执行，也就是说flag的检测和设置被分开了，导致同时有两个线程持有这把锁。</p><p>我们一般使用atomic exchange来保证获取锁会是原子性操作，要么同时完成flag的检测和设置，要么什么都不做。这里C代码形式如下(TestAndSet）:</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"nf\">TestAndSet</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">old_ptr</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">new</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"kt\">int</span> <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">old_ptr</span><span class=\"p\">;</span> <span class=\"c1\">// fetch old value at old_ptr\n</span><span class=\"c1\"></span><span class=\"o\">*</span><span class=\"n\">old_ptr</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">;</span> <span class=\"c1\">// store ’new’ into old_ptr\n</span><span class=\"c1\"></span><span class=\"k\">return</span> <span class=\"n\">old</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">__lock_t</span> <span class=\"p\">{</span>\n<span class=\"kt\">int</span> <span class=\"n\">flag</span><span class=\"p\">;</span>\n<span class=\"p\">}</span> <span class=\"n\">lock_t</span><span class=\"p\">;</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">lock</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"c1\">// 0: lock is available, 1: lock is held\n</span><span class=\"c1\"></span> <span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">lock</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">lock</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">TestAndSet</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">;</span> <span class=\"c1\">// spin-wait (do nothing)\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">lock</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><p>而另一种形式为（CompareAndSwap），作用类似，但比TestAndSet更为泛用</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"nf\">CompareAndSwap</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">expected</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">new</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"kt\">int</span> <span class=\"n\">original</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">original</span> <span class=\"o\">==</span> <span class=\"n\">expected</span><span class=\"p\">)</span>\n <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">;</span>\n <span class=\"k\">return</span> <span class=\"n\">original</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n<span class=\"kt\">void</span> <span class=\"nf\">lock</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">lock</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">CompareAndSwap</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n <span class=\"p\">;</span> <span class=\"c1\">// spin\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p><b>饥饿Starvation</b></p><p>由于CPU调度并不保证先试图获取锁的必定能先获得，可能出现某个线程很久无法获得锁的情况。一个简单的想法就是使用队列，保证FIFO。</p><p>我们先以FetchAndAdd作为原子性的后置++操作。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"nf\">FetchAndAdd</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"kt\">int</span> <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"n\">old</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n <span class=\"k\">return</span> <span class=\"n\">old</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">__lock_t</span> <span class=\"p\">{</span>\n <span class=\"kt\">int</span> <span class=\"n\">ticket</span><span class=\"p\">;</span>\n <span class=\"kt\">int</span> <span class=\"n\">turn</span><span class=\"p\">;</span>\n <span class=\"p\">}</span> <span class=\"n\">lock_t</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">lock_init</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">lock</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">ticket</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n <span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">turn</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">lock</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">lock</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"kt\">int</span> <span class=\"n\">myturn</span> <span class=\"o\">=</span> <span class=\"n\">FetchAndAdd</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">ticket</span><span class=\"p\">);</span>\n <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">turn</span> <span class=\"o\">!=</span> <span class=\"n\">myturn</span><span class=\"p\">)</span>\n<span class=\"p\">;</span> <span class=\"c1\">// spin\n</span><span class=\"c1\"></span> <span class=\"p\">}</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">lock</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">turn</span> <span class=\"o\">=</span> <span class=\"n\">lock</span><span class=\"o\">-&gt;</span><span class=\"n\">turn</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n <span class=\"p\">}</span></code></pre></div><p>正如同餐厅叫号，turn表示当前的号码，ticket表示手中的号码，每一个顾客（线程）用完之后就呼叫下一个号码。</p><h2>Sleeping锁</h2><p>由于自旋锁导致每个线程都在执行while操作，空转造成了极大浪费，因此一种改进思路是：在没有获得锁之前，令线程直接沉睡。而当释放锁时，再唤醒下一个线程。同理，我们使用queue作为数据结构，但是维护一个显式的链表。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">__lock_t</span> <span class=\"p\">{</span>\n <span class=\"kt\">int</span> <span class=\"n\">flag</span><span class=\"p\">;</span>\n <span class=\"kt\">int</span> <span class=\"n\">guard</span><span class=\"p\">;</span>\n <span class=\"n\">queue_t</span> <span class=\"o\">*</span><span class=\"n\">q</span><span class=\"p\">;</span>\n <span class=\"p\">}</span> <span class=\"n\">lock_t</span><span class=\"p\">;</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">lock_init</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n <span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">guard</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n <span class=\"n\">queue_init</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">q</span><span class=\"p\">);</span>\n <span class=\"p\">}</span></code></pre></div><p>lock_t: </p><p>这里的flag表示锁有没有被线程需求，锁可以同时被多个线程所等候，仅当没有线程等候时才会置0。</p><p>而guard是lock和unlock过程的一个自旋锁。在过程结束后自动释放。(basically as a spin-lock around the flag and queue manipulations the lock is using)</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">void</span> <span class=\"nf\">lock</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">TestAndSet</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">guard</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n <span class=\"p\">;</span> <span class=\"c1\">//acquire guard lock by spinning\n</span><span class=\"c1\"></span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">// lock is acquired\n</span><span class=\"c1\"></span> <span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">guard</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n <span class=\"n\">queue_add</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">gettid</span><span class=\"p\">());</span>\n <span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">guard</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n <span class=\"n\">park</span><span class=\"p\">();</span>\n <span class=\"p\">}</span>\n <span class=\"p\">}</span></code></pre></div><p>lock:</p><p>当锁中队列为空时: 置flag为1,即flag锁被占用</p><p>当锁中队列不为空时: 入队，使用park操作令线程休眠等待唤醒。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">void</span> <span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"n\">lock_t</span> <span class=\"o\">*</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">TestAndSet</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">guard</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n <span class=\"p\">;</span> <span class=\"c1\">//acquire guard lock by spinning\n</span><span class=\"c1\"></span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">queue_empty</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">q</span><span class=\"p\">))</span>\n <span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c1\">// let go of lock; no one wants it\n</span><span class=\"c1\"></span> <span class=\"k\">else</span>\n <span class=\"n\">unpark</span><span class=\"p\">(</span><span class=\"n\">queue_remove</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">q</span><span class=\"p\">));</span> <span class=\"c1\">// hold lock\n</span><span class=\"c1\">// (for next thread!)\n</span><span class=\"c1\"></span> <span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">guard</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span></code></pre></div><p>unlock:</p><p>当锁中队列为空时：置flag为0，即此锁闲置</p><p>当锁中队列不为空时：出队，使用unpark操作唤醒下一个线程并释放锁</p><p><b>Buggy</b></p><div class=\"highlight\"><pre><code class=\"language-c\"> <span class=\"n\">queue_add</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">gettid</span><span class=\"p\">());</span>\n <span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">guard</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>             <span class=\"n\">Line</span> <span class=\"n\">a</span>   \n <span class=\"nf\">park</span><span class=\"p\">();</span>                   <span class=\"n\">Line</span> <span class=\"n\">b</span></code></pre></div><p>假如在line a和line b之间正好有一个线程unlock了，那么将会唤醒当前正在加锁的线程，然后再运行line b使得当前线程进入休眠，而队列中当前线程却已经出队。这样一来，陷入休眠的当前线程就不再可以被唤醒了。</p><p>为了解决这个问题，如果能直接让ab原子性就好了，然而实际情况却很难做到。</p><p>我们可以特异性针对上面的问题处理，例如某种实现中，setpark函数可以令程序进入准备park的状态，<b>如果在park之前进程已经被unpark，那么park将直接返回</b>。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">queue_add</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">gettid</span><span class=\"p\">());</span>\n<span class=\"n\">setpark</span><span class=\"p\">();</span>\n<span class=\"n\">m</span><span class=\"o\">-&gt;</span><span class=\"n\">guard</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>                \n<span class=\"n\">park</span><span class=\"p\">();</span>                  </code></pre></div><h2>Two-phase锁</h2><p>实际操作系统中，互斥锁的实现综合了以上两种锁的实现。以下是Linux的Mutex实现机制。</p><p><b>膜这段代码！！！</b></p><div class=\"highlight\"><pre><code class=\"language-c\"> <span class=\"kt\">void</span> <span class=\"nf\">mutex_lock</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"kt\">int</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n <span class=\"cm\">/* Bit 31 was clear, we got the mutex (the fastpath) */</span>\n<span class=\"c1\">//自旋锁！\n</span><span class=\"c1\"></span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_bit_test_set</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mi\">31</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n <span class=\"k\">return</span><span class=\"p\">;</span>\n<span class=\"c1\">//维护等待队列长度！\n</span><span class=\"c1\"></span> <span class=\"n\">atomic_increment</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n<span class=\"c1\">//这里存在一个问题，假如后面setpark部分continue，那么会存在两个醒着的线程抢夺锁。如果刚刚被唤醒的线程抢不到的话\n</span><span class=\"c1\">//原本的队首又得重新进队尾了，那就很迷。可能需要调度算法，保证刚刚唤醒的线程能先执行？\n</span><span class=\"c1\"></span> <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"c1\">//被unlock唤醒了！！获取锁然后维护等待队列长度\n</span><span class=\"c1\"></span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_bit_test_set</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mi\">31</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"n\">atomic_decrement</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n <span class=\"k\">return</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n <span class=\"cm\">/* We have to waitFirst make sure the futex value\n</span><span class=\"cm\"> we are monitoring is truly negative (locked). */</span>\n\n<span class=\"c1\">//类似setpark!防止v = *mutex;前面被插入unlock\n</span><span class=\"c1\"></span><span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">;</span>\n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n <span class=\"k\">continue</span><span class=\"p\">;</span>\n\n<span class=\"c1\">//类似setpark!防止v = *mutex;后面被插入unlock\n</span><span class=\"c1\"></span> <span class=\"n\">futex_wait</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">);</span>\n <span class=\"p\">}</span>\n <span class=\"p\">}</span>\n\n <span class=\"kt\">void</span> <span class=\"nf\">mutex_unlock</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">mutex</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n <span class=\"cm\">/* Adding 0x80000000 to counter results in 0 if and\n</span><span class=\"cm\"> only if there are not other interested threads */</span>\n<span class=\"c1\">//解锁，如果等待队列长度是0就不用唤醒！不把这个逻辑放futex_wake是为了减少sys call的开销。\n</span><span class=\"c1\"></span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">atomic_add_zero</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">,</span> <span class=\"mh\">0x80000000</span><span class=\"p\">))</span>\n <span class=\"k\">return</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* There are other threads waiting for this mutex,\n</span><span class=\"cm\"> wake one of them up. */</span>\n<span class=\"c1\">//唤醒队首线程！\n</span><span class=\"c1\"></span> <span class=\"n\">futex_wake</span> <span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n <span class=\"p\">}</span></code></pre></div><p>Two-phase 锁意识到对于那些将会马上被释放的锁，使用自旋锁更有益处。而唤醒等操作需要使用更多的sys-call，因此会增大开销。</p><p>futex_wait和futex_wake会在内核态维护一个mutex对应的队列。</p><p>在第一阶段，线程将会自旋若干次，试图获取锁。</p><p>一旦第一阶段没有完成，则会进入第二阶段，线程沉睡，直到锁被释放后将线程唤醒。</p><p>上述linux的实现只自旋了一次，但是也可以使用有固定自旋次数的循环。</p><p><b>注意：</b></p><p><b>这里setpark的原因和上面不同，因为这里不会出现先入队列再沉睡的情况。</b></p><p><b>Special case： Queue Empty</b></p><p><b>假如没有v&gt;=0的判断，</b></p><p><b>假如B lock中间插入C unlock,由于队列为空，lock位变为0，不wake下一个线程。此时B wait，则无法被唤醒。</b></p><p><b>但是如果continue，B就能直接拿锁，而不会wait。</b></p><h2>联想</h2><p>我个人其实是把这个和轮询/中断类比的，</p><p>以IO为例，轮询需要CPU不断访问IO，而中断则是仅当IO发生改变时CPU才进行访问。</p><p>同理，Spin其实就是CPU不断判断锁，而Sleep则是仅当锁被释放时才唤醒下一个线程。</p><p>尽管所处的抽象层次不同，但是这种思想确实有共通之处。</p><p>再往上，其实观察者模式也类似，查询其他对象是否发生改变很困难，因为在不知情的情况下，每时每刻都有可能发生改变。但改变的当事人想通知查询者就很容易，只需要在改变的同时发出消息即可。</p><p><b>猜想或者归纳一下，或许这种现象是由于信息隔离导致的。正是因为信息交流的双方信息的不对等，才导致传递这种信息所需要的代价截然不同。</b></p>", 
            "topic": [
                {
                    "tag": "并发", 
                    "tagLink": "https://api.zhihu.com/topics/19757794"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }, 
                {
                    "tag": "操作系统", 
                    "tagLink": "https://api.zhihu.com/topics/19552686"
                }
            ], 
            "comments": [
                {
                    "userName": "热带", 
                    "userLink": "https://www.zhihu.com/people/68fd643a9d554d7aeddbf63738d5b842", 
                    "content": "我看 test and set 那里感觉还是不能保证原子性的呀？私以为原子性要靠硬件来保证的。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "<p>这是作者为了说明意图提供的伪代码，你说的没错。这些都是本身指令集的一部分。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "热带"
                        }, 
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "<p>所以说了只是C代码形式，希望不会影响理解。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "热带"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68657294", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 2, 
            "title": "TAOCP|基本算法|顺序分配", 
            "content": "<p>传说中的计算机圣经TAOCP，虽然我自己啃完这套书不太现实，但是还是先记录自己读书的历程。本文主要记载了顺序分配的线性表的能力与局限。</p><hr/><p>在计算机中维护线性表，最简单最自然的方法是表项存放在连续位置。 (Array)</p><p><img src=\"https://www.zhihu.com/equation?tex=LOC%28X%5Bj%5D%29%3DL_0%2Bcj\" alt=\"LOC(X[j])=L_0+cj\" eeimg=\"1\"/></p><p> 其中 <img src=\"https://www.zhihu.com/equation?tex=L_0\" alt=\"L_0\" eeimg=\"1\"/> 是常量，称作基址， 是人为假定的节点X[0]的位置（实际索引从1开始）,<img src=\"https://www.zhihu.com/equation?tex=c\" alt=\"c\" eeimg=\"1\"/> 是每个节点的字数（c&gt;1时，另一种方法是把单个表划分成若干平行表，节点的每个字存在不同平行表的相同索引处）。</p><p>这种表示线性表的技术一目了然而又众所周知，但是我们不妨先考察这种简单情况。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>栈</b></p><p>维护栈指针变量T，当栈空时，T=0，</p><p>push Y<b>：</b> <img src=\"https://www.zhihu.com/equation?tex=T%5Cleftarrow+T%2B1%3B+++X%5BT%5D%5Cleftarrow+Y%EF%BC%9B\" alt=\"T\\leftarrow T+1;   X[T]\\leftarrow Y；\" eeimg=\"1\"/> </p><p>pop Y： <img src=\"https://www.zhihu.com/equation?tex=Y%5Cleftarrow+X%5BT%5D%3BT%5Cleftarrow+T-1%3B\" alt=\"Y\\leftarrow X[T];T\\leftarrow T-1;\" eeimg=\"1\"/> </p><p>(在计算机内部最有效的方法是维护cT而不是T，我们这里按c=1讨论）</p><p><b>队列</b></p><p>维持两个指针F和R，当队列为空时，F=R=0，</p><p>enqueue Y： <img src=\"https://www.zhihu.com/equation?tex=R%5Cleftarrow+R%2B1%3B+X%5BR%5D%5Cleftarrow+Y\" alt=\"R\\leftarrow R+1; X[R]\\leftarrow Y\" eeimg=\"1\"/> </p><p>dequeue Y： <img src=\"https://www.zhihu.com/equation?tex=F%5Cleftarrow+F%2B1%3B+Y%5Cleftarrow+X%5BF%5D+\" alt=\"F\\leftarrow F+1; Y\\leftarrow X[F] \" eeimg=\"1\"/> ，若 <img src=\"https://www.zhihu.com/equation?tex=F%3DR\" alt=\"F=R\" eeimg=\"1\"/> ,则置 <img src=\"https://www.zhihu.com/equation?tex=F%5Cleftarrow+R+%5Cleftarrow+0\" alt=\"F\\leftarrow R \\leftarrow 0\" eeimg=\"1\"/> </p><p>然而，如果R始终在F前（队列始终非空）,所用表项将会是无穷，因此这种方法只有在经常清空队列的情况下可行。</p><p>为了避免队列过度使用内存，可以预留M个节点，隐式安排为一个环。构成循环队列。</p><p>若 <img src=\"https://www.zhihu.com/equation?tex=R%3DM%3B+R%5Cleftarrow1\" alt=\"R=M; R\\leftarrow1\" eeimg=\"1\"/> </p><p>若 <img src=\"https://www.zhihu.com/equation?tex=F%3DM%3BF%5Cleftarrow1\" alt=\"F=M;F\\leftarrow1\" eeimg=\"1\"/> </p><p><b>溢出</b></p><p>然而，这些讨论都不太现实，因为假定不会出错，例如删除时假定至少有一个节点，插入时假定存在可容纳的内存空间。因此在限定队列长度的情况下，我们假定超过队列长度为OVERFLOW,小于等于0为UNDERFLOW，此时F和R的初始值应该为1。此时伪代码变为：</p><ul><li><img src=\"https://www.zhihu.com/equation?tex=X%5CLeftarrow+Y\" alt=\"X\\Leftarrow Y\" eeimg=\"1\"/> （入栈） <img src=\"https://www.zhihu.com/equation?tex=T%5Cleftarrow+T%2B1%3BT%3EM%2COVERFLOW%3BX%5BT%5D%5Cleftarrow+Y\" alt=\"T\\leftarrow T+1;T&gt;M,OVERFLOW;X[T]\\leftarrow Y\" eeimg=\"1\"/> </li><li><img src=\"https://www.zhihu.com/equation?tex=Y%5CLeftarrow+X\" alt=\"Y\\Leftarrow X\" eeimg=\"1\"/> （出栈） <img src=\"https://www.zhihu.com/equation?tex=T%3D0%2CUNDERFLOW%3BY%5Cleftarrow+X%5BT%5D%3BT%5Cleftarrow+T-1%3B\" alt=\"T=0,UNDERFLOW;Y\\leftarrow X[T];T\\leftarrow T-1;\" eeimg=\"1\"/> </li><li><img src=\"https://www.zhihu.com/equation?tex=X%5CLeftarrow+Y\" alt=\"X\\Leftarrow Y\" eeimg=\"1\"/> （入队）</li></ul><p><img src=\"https://www.zhihu.com/equation?tex=R%3DM%2CR%5Cleftarrow1%3BR%5Cne+M%2CR%5Cleftarrow+R%2B1%3B\" alt=\"R=M,R\\leftarrow1;R\\ne M,R\\leftarrow R+1;\" eeimg=\"1\"/></p><p><img src=\"https://www.zhihu.com/equation?tex=+R%3DF%2COVERFLOW%3B\" alt=\" R=F,OVERFLOW;\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=X%5BR%5D%5Cleftarrow+Y\" alt=\"X[R]\\leftarrow Y\" eeimg=\"1\"/> </p><ul><li><img src=\"https://www.zhihu.com/equation?tex=Y%5CLeftarrow++X\" alt=\"Y\\Leftarrow  X\" eeimg=\"1\"/> （出队）</li></ul><p><img src=\"https://www.zhihu.com/equation?tex=F%3DR%EF%BC%8CUNDERFLOW%3B\" alt=\"F=R，UNDERFLOW;\" eeimg=\"1\"/><br/> <img src=\"https://www.zhihu.com/equation?tex=++F%3DM%2CF%5Cleftarrow1%3BF%5Cne+M%2CF%5Cleftarrow+F%2B1%3B\" alt=\"  F=M,F\\leftarrow1;F\\ne M,F\\leftarrow F+1;\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=+Y%5Cleftarrow+X%5BF%5D\" alt=\" Y\\leftarrow X[F]\" eeimg=\"1\"/> <br/> </p><p><b>溢出发生，应该怎么办？</b></p><p>我们经常遇见涉及大小动态变化的站的程序，在这种情况下，我们并不想对每个栈的容量设定最大值，因为该值通常难以预测。即使设置，也很难遇到所有栈同时填满的情况。</p><p>如果只有两个变长表，让这两个 表迎面增长，则它们可以很好地共存。然而，容易发现，没有办法在内存中存放更多的变长表，使得两个性质都得到满足：</p><p>(a)仅当所有表的总容量超过总空间时，才出现OVERFLOW</p><p>(b)每个表的底元素都有固定的位置。</p><p>如果希望满足(a），那么必须放弃条件(b），即上文中的基址不再是常数。</p><p>一个重要的特例是，变长表都是栈，由于我们只关注栈顶元素，因此完全可以像之前一样高效处理。即使发生overflow，我们也可以重新分配内存，从其他位置腾出空间。</p><p><b>最简单的方法</b></p><p>假设有n个栈，TOP[i]存储第i个栈的栈顶，BASE[i]存储第i个栈的栈底。所有的栈处于同一存储区，有 <img src=\"https://www.zhihu.com/equation?tex=L\" alt=\"L\" eeimg=\"1\"/> 个位置， <img src=\"https://www.zhihu.com/equation?tex=L_0%3CL%5Cleq+L_%5Cinfty\" alt=\"L_0&lt;L\\leq L_\\infty\" eeimg=\"1\"/> </p><p>for <img src=\"https://www.zhihu.com/equation?tex=1%5Cleq+j+%5Cleq+n\" alt=\"1\\leq j \\leq n\" eeimg=\"1\"/> ,<img src=\"https://www.zhihu.com/equation?tex=BASE%5Bj%5D%3DTOP%5Bj%5D%3D+L_0\" alt=\"BASE[j]=TOP[j]= L_0\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=BASE%5Bn%2B1%5D%3DL_%5Cinfty\" alt=\"BASE[n+1]=L_\\infty\" eeimg=\"1\"/> 作为哨兵</p><p>当栈 <img src=\"https://www.zhihu.com/equation?tex=i+\" alt=\"i \" eeimg=\"1\"/> 发生overflow时：</p><p>(a)存在k,满足 <img src=\"https://www.zhihu.com/equation?tex=i%3Ck%5Cleq+n%3B+TOP%5Bk%5D%3CBASE%5Bk%2B1%5D\" alt=\"i&lt;k\\leq n; TOP[k]&lt;BASE[k+1]\" eeimg=\"1\"/> （即上方存在空位）,找出最小的k，然后将 <img src=\"https://www.zhihu.com/equation?tex=BASE%5Bi%2B1%5D\" alt=\"BASE[i+1]\" eeimg=\"1\"/> 到 <img src=\"https://www.zhihu.com/equation?tex=TOP%5Bk%5D\" alt=\"TOP[k]\" eeimg=\"1\"/> 的内容全部上移一格</p><p>(b)存在k,满足 <img src=\"https://www.zhihu.com/equation?tex=1%5Cleq+k+%3Ci%3B+TOP%5Bk%5D%3CBASE%5Bk%2B1%5D\" alt=\"1\\leq k &lt;i; TOP[k]&lt;BASE[k+1]\" eeimg=\"1\"/> （即下方存在空位）,找出最大的k，然后将 <img src=\"https://www.zhihu.com/equation?tex=BASE%5Bk%2B1%5D\" alt=\"BASE[k+1]\" eeimg=\"1\"/> 到 <img src=\"https://www.zhihu.com/equation?tex=TOP%5Bi%5D\" alt=\"TOP[i]\" eeimg=\"1\"/> 的内容全部下移一格</p><p>(c)所有的 <img src=\"https://www.zhihu.com/equation?tex=k%5Cne+i\" alt=\"k\\ne i\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=TOP%5Bk%5D%3DBASE%5Bk%2B1%5D\" alt=\"TOP[k]=BASE[k+1]\" eeimg=\"1\"/> ,则放弃。</p><p><b>改进方法</b></p><p><b>每次重新分配内存时为多个新项腾出空间，根据上一次内存重新分配以来每个栈的改变情况，进行全面的重新分配</b>。扬·加威克使用了 <img src=\"https://www.zhihu.com/equation?tex=OLDTOP\" alt=\"OLDTOP\" eeimg=\"1\"/> 来记录历史信息。</p><p>算法大意如下：</p><p>计算 <img src=\"https://www.zhihu.com/equation?tex=SUM\" alt=\"SUM\" eeimg=\"1\"/> 为剩余可用内存量， <img src=\"https://www.zhihu.com/equation?tex=INC\" alt=\"INC\" eeimg=\"1\"/> 为内存增长量， <img src=\"https://www.zhihu.com/equation?tex=D\" alt=\"D\" eeimg=\"1\"/> 为栈增长量的数组</p><p><img src=\"https://www.zhihu.com/equation?tex=%CE%B1%5Cleftarrow+0.1%5Ctimes+SUM%2Fn%3B%CE%B2%5Cleftarrow0.9%5Ctimes+SUM%2FINC\" alt=\"α\\leftarrow 0.1\\times SUM/n;β\\leftarrow0.9\\times SUM/INC\" eeimg=\"1\"/> </p><p><b>10%的内存被所有表平分，其余90%则根据上次分配后表的增长量按比例划分。</b></p><p>所有的栈计算新的基址，然后重新分配内存。顺序表的重定位过程太繁琐，暂时略过。</p><p>上述算法的平均性能还没有理论能够计算，但经验表明，存储只有半满载时，很少需要用算法来重新安排这些表，但几乎满载时，内存的上溢会非常频繁，因此当 <img src=\"https://www.zhihu.com/equation?tex=SUM%3CS_%7Bmin%7D\" alt=\"SUM&lt;S_{min}\" eeimg=\"1\"/> 时，应该停止上述算法，其中阈值由程序员指定。</p><hr/><p><b>习题(等我自己先做几道再说）</b></p><p><b>1.[15] 在给定的队列操作（OVERFLOW版）中，一次可以插入多少项而不会上溢</b></p><p><b>2.[22] 推广队列操作，使之可以用于任意双端队列</b></p><p><b>3.[26]解释对于一个或多个循环队列表而非栈，如何修改插入/删除/重新分配算法</b></p><p><b>4.[M27]针对第一个算法，初始空间均给第n个栈，证明期望的平均移动次数为</b> <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B2%7D%281-%5Cfrac%7B1%7D%7Bn%7D%29C%28m%2C2%29\" alt=\"\\frac{1}{2}(1-\\frac{1}{n})C(m,2)\" eeimg=\"1\"/> </p><p>5.[M30] 证明扬·加威克算法对于任意m次插入/删除序列，时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=O%EF%BC%88m%2Bn%5Csum_%7Bk%3D1%7D%5E%7Bm%7D%7Ba_k%2F%281-a_k%29%7D%29\" alt=\"O（m+n\\sum_{k=1}^{m}{a_k/(1-a_k)})\" eeimg=\"1\"/></p><p>6.[16] 改写算法，使得下标以0为起始。</p>", 
            "topic": [
                {
                    "tag": "计算机程序设计艺术（TAOCP）", 
                    "tagLink": "https://api.zhihu.com/topics/19652765"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68192859", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 23, 
            "title": "Python|数学建模|排队论仿真", 
            "content": "<p>数模准备过程中，写了这种运筹学仿真的代码，虽然自己选了C题没有用到，但考虑到市面上存在的仿真代码较少，聊以为分享。</p><h2>文档介绍</h2><p>本文档使用了Python的离散事件仿真库对于排队论模型进行了仿真</p><p>仿真的主要目的是提供个性化定制，如对分布的设定，对排队规则的设定等。通过蒙特卡洛模拟得到复杂规则下难以得到的数值解。</p><p>本文档提供了： </p><p>基础排队模型仿真</p><p>Erlang分布实现</p><p>通用分布函数适配器</p><hr/><h2>工具库</h2><p><b>库依赖</b></p><div class=\"highlight\"><pre><code class=\"language-text\">from numpy.random import *\nfrom simpy import *</code></pre></div><p><b>高阶函数随机数生成器</b></p><p>输入：分布函数，单一参数(多参数请柯里化)<br/>输出：随机数</p><div class=\"highlight\"><pre><code class=\"language-text\">def rng(dis,param):\n    &#34;&#34;&#34;random number generator&#34;&#34;&#34;\n    def generate():\n        return dis(lam=param,size=1)[0]\n    return generate</code></pre></div><p><b>Erlang分布函数：</b></p><p>输入：阶数</p><p>输出：k阶erlang分布函数</p><div class=\"highlight\"><pre><code class=\"language-text\">def erlang(k):\n    &#34;&#34;&#34;由k个指数分布拟合&#34;&#34;&#34;\n    def exp2erlang(lam,size):\n        res=[]\n        for n in range(size):\n            k_poisson= exponential(lam/k,size=k)\n            sum=0\n            for x in k_poisson:\n                sum = sum + x\n            res.append(sum)\n        return res\n    return exp2erlang</code></pre></div><p><br/>测试，计算分布期望 </p><div class=\"highlight\"><pre><code class=\"language-text\">x=rng(erlang(10),10)\nsum=0\nfor i in range(10000):\n    sum= sum+x()\nprint(sum/10000)</code></pre></div><p>结果为9.99565983119657，说明函数正确</p><h2>FIFO队列模型</h2><div class=\"highlight\"><pre><code class=\"language-text\">#典型银行模型：FIFO\ndef bankSample(X,Y,Z,A,B,EX):\n    &#34;&#34;&#34;\n银行排队服务例子\n\n情景:\n  一个柜台对客户进行服务, 服务耗时, 客户等候过长会离开柜台\n    %X 表示时间间隔分布\n    %Y 表示服务时间的分布\n    %Z 表示服务台的个数\n    %A 表示系统的容量,此处特殊化为客户的耐心时间分布\n    %B 表示顾客数\n    %以上参数必须有界，受到计算机精度限制，可以使用大常数近似无穷\n    %C 表示服务规则,请修改函数\n    %EX 传递了银行储蓄额的分布\n  &#34;&#34;&#34;\n    #加入随机种子是为了对比模型的变化\n    seed(2)\n    def source(env, number, interval,counter):\n        &#34;&#34;&#34;生成客户&#34;&#34;&#34;\n        for i in range(number):\n            c = customer(env, &#39;客户%04d&#39; % i, counter, time_in_bank=Y(),account=EX())\n            env.process(c)\n            yield env.timeout(interval)\n    #成功服务的客户\n    SUCC=0\n    #成功客户等待时间\n    WAIT=0\n    #成功客户逗留时间\n    STAY=0\n    #业务额\n    AMT=0\n    def customer(env, name, counter, time_in_bank,account):\n        nonlocal WAIT\n        nonlocal SUCC\n        nonlocal STAY\n        nonlocal AMT\n        &#34;&#34;&#34;顾客服务与离开仿真&#34;&#34;&#34;\n        arrive = env.now\n        #print(&#39;%7.4f  %s: 到达&#39; % (arrive, name))\n        with counter.request() as req:\n            patience = A()\n            # 直到到达或者失去耐心\n            results = yield req | env.timeout(patience)\n            wait = env.now - arrive\n        \n            if req in results:\n                # 到达\n                WAIT=WAIT+wait\n                STAY=STAY+time_in_bank\n                AMT= AMT + account\n                #print(&#39;%7.4f %s:等待%6.3f&#39; % (env.now, name, wait))\n                yield env.timeout(time_in_bank)\n                SUCC=SUCC+1\n                #print(&#39;%7.4f %s:服务完成&#39; % (env.now, name))\n            else:\n                # We reneged\n                pass\n                #print(&#39;%7.4f %s:等待%6.3f后离开&#39; % (env.now, name, wait))\n    # 初始化环境\n    print(&#39;排队问题仿真&#39;)\n    env = Environment()\n\n    # 开始协程\n    counter = Resource(env, capacity=Z)\n    env.process(source(env, B, X(), counter))\n    env.run()\n    print(&#34;总服务人数：{0:n}人&#34;.format(SUCC))\n    print(&#34;总营业额：{0:n}元&#34;.format(AMT))\n    print(&#34;总计失去： {0:n}名客户&#34;.format(B-SUCC))\n    print(&#34;损失率为： {0:n}%&#34;.format((B-SUCC)/B*100))\n    print(&#34;平均等待时间：{0:n}&#34;.format(WAIT/SUCC) )\n    print(&#34;平均耗费时间：{0:n}&#34;.format(STAY/SUCC) )</code></pre></div><p>我们以下列参数作为输入</p><div class=\"highlight\"><pre><code class=\"language-text\">#间隔分布\nX=rng(erlang(3),3)\n#服务时间分布\nY=rng(erlang(3),10)\n#耐心时间分布\nA=rng(erlang(3),3)\n#业务额分布正态\ndef normaltocurry(s):\n    def normalcurry(lam,size):\n        return normal(lam,s,size=size)\n    return normalcurry\nEX=rng(normaltocurry(200),1000)\nbankSample(X,Y,3,A,1000,EX)</code></pre></div><p>输出的结果为：</p><p>排队问题仿真 </p><p>总服务人数：417人 </p><p>总营业额：409903元 </p><p>总计失去： 583名客户 </p><p>损失率为： 58.3% </p><p>平均等待时间：1.8828 </p><p>平均耗费时间：10.0787</p><h2>营业额优先队列模型</h2><p>然后，我们转变一下模型，变成营业额越高越优先的队列</p><div class=\"highlight\"><pre><code class=\"language-text\">#银行模型·ELite：优先队列\ndef eliteBankSample(X,Y,Z,A,B,EX):\n    &#34;&#34;&#34;\n银行排队服务例子\n\n情景:\n  一个柜台对客户进行服务, 服务耗时, 客户等候过长会离开柜台\n    %X 表示时间间隔分布\n    %Y 表示服务时间的分布\n    %Z 表示服务台的个数\n    %A 表示系统的容量,此处特殊化为客户的耐心时间分布\n    %B 表示顾客数\n    %以上参数必须有界，受到计算机精度限制，可以使用大常数近似无穷\n    %C 表示服务规则,请修改函数\n    %EX 传递了银行储蓄额的分布\n  &#34;&#34;&#34;\n    #加入随机种子是为了对比模型的变化\n    seed(2)\n    def source(env, number, interval,counter):\n        &#34;&#34;&#34;生成客户&#34;&#34;&#34;\n        for i in range(number):\n            c = customer(env, &#39;客户%04d&#39; % i, counter, time_in_bank=Y(),account=EX())\n            env.process(c)\n            yield env.timeout(interval)\n    #成功服务的客户\n    SUCC=0\n    #成功客户等待时间\n    WAIT=0\n    #成功客户逗留时间\n    STAY=0\n    #业务额\n    AMT=0\n    def customer(env, name, counter, time_in_bank,account):\n        nonlocal WAIT\n        nonlocal SUCC\n        nonlocal STAY\n        nonlocal AMT\n        &#34;&#34;&#34;顾客服务与离开仿真&#34;&#34;&#34;\n        arrive = env.now\n        #print(&#39;%7.4f  %s: 到达&#39; % (arrive, name))\n        #以业绩作为优先级，priority越小，优先级越大，\n        with counter.request(priority = 1/account) as req:\n            patience = A()\n            # 直到到达或者失去耐心\n            results = yield req | env.timeout(patience)\n            wait = env.now - arrive\n        \n            if req in results:\n                # 到达\n                WAIT=WAIT+wait\n                STAY=STAY+time_in_bank\n                AMT= AMT + account\n                #print(&#39;%7.4f %s:等待%6.3f&#39; % (env.now, name, wait))\n                yield env.timeout(time_in_bank)\n                SUCC=SUCC+1\n                #print(&#39;%7.4f %s:服务完成&#39; % (env.now, name))\n            else:\n                # We reneged\n                pass\n                #print(&#39;%7.4f %s:等待%6.3f后离开&#39; % (env.now, name, wait))\n    # 初始化环境\n    print(&#39;排队问题仿真&#39;)\n    env = Environment()\n\n    # 开始协程\n    counter = PriorityResource(env, capacity=Z)\n    env.process(source(env, B, X(), counter))\n    env.run()\n    print(&#34;总服务人数：{0:n}人&#34;.format(SUCC))\n    print(&#34;总营业额：{0:n}元&#34;.format(AMT))\n    print(&#34;总计失去： {0:n}名客户&#34;.format(B-SUCC))\n    print(&#34;损失率为： {0:n}%&#34;.format((B-SUCC)/B*100))\n    print(&#34;平均等待时间：{0:n}&#34;.format(WAIT/SUCC) )\n    print(&#34;平均耗费时间：{0:n}&#34;.format(STAY/SUCC) )</code></pre></div><p>以相同的参数测试</p><p>结果为：</p><p>排队问题仿真<br/>总服务人数：432人<br/>总营业额：450145元<br/>总计失去： 568名客户<br/>损失率为： 56.8%<br/>平均等待时间：1.28862<br/>平均耗费时间：9.69799</p><hr/><h2>总结</h2><p>可以看出，在加入了上述充满着歧视与不公平的规则之后， 人均营业额上升，并且等待时间和耗费时间都有所下降 即：富人和银行获得了利益，富人节约了自己的时间，银行增加了业绩<br/> </p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/sjtuzwj/OperationalResearchModeling/blob/master/%25E6%258E%2592%25E9%2598%259F%25E8%25AE%25BA_%25E7%25B3%25BB%25E7%25BB%259F%25E4%25BB%25BF%25E7%259C%259F.ipynb\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-af726a0c27ab1be16bc7442dde959312_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sjtuzwj/OperationalResearchModeling</a><p>内部含网络图/决策论等算法。</p>", 
            "topic": [
                {
                    "tag": "数学建模", 
                    "tagLink": "https://api.zhihu.com/topics/19575624"
                }, 
                {
                    "tag": "运筹学", 
                    "tagLink": "https://api.zhihu.com/topics/19634329"
                }, 
                {
                    "tag": "仿真", 
                    "tagLink": "https://api.zhihu.com/topics/19578073"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67177829", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 19, 
            "title": "C++|对象模型|对象模型综述", 
            "content": "<p>作为C++的核心单元，对象模型在编译器眼中是如何实现的？本文从几个基本理论模型出发，剖析实际。</p><blockquote>深度探索C++对象模型</blockquote><hr/><h2>简单对象模型</h2><p>对象存放若干slots，由slot指向实际成员。members按声明顺序</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-625945dada17d41460ba007e18cd7d28_b.jpg\" data-size=\"normal\" data-rawwidth=\"702\" data-rawheight=\"501\" class=\"origin_image zh-lightbox-thumb\" width=\"702\" data-original=\"https://pic1.zhimg.com/v2-625945dada17d41460ba007e18cd7d28_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;702&#39; height=&#39;501&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"702\" data-rawheight=\"501\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"702\" data-original=\"https://pic1.zhimg.com/v2-625945dada17d41460ba007e18cd7d28_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-625945dada17d41460ba007e18cd7d28_b.jpg\"/><figcaption>简单对象模型</figcaption></figure><p>优点：对象大小等于指针数*成员数，并且取出成员时，只需要根据slot索引获取指针即可。编译器实现简单。</p><p>缺点：存在间接层，时空效率降低。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Extension：</b></p><p><b>尽管简单对象模型没有用于编译器中，但其slot思想应用在指向类成员的指针中。</b></p><blockquote>简单地说，简单对象模型将地址slot的获取定位于object level，而成员指针对地址slot的获取则定位于class level。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Pointer to Data Member</b></p><blockquote>实际使用中，指向类数据成员的指针用法如下。取static data的地址会是其真实地址，而non-static data的地址则会是offset，需要绑定到具体object上才会得到真实地址。</blockquote><p>在实际对象模型中，正如常识一样，对象只存有non-static data/vptr，而对non-static data的存取，则通过<b>object起始地址+成员偏移量</b>来获取。由于成员偏移量编译器已知，优化后实际上和直接存取同类型变量效率相同。</p><p>假设存在三维Point3D类，其中依次存在x,y,z三个float成员，那么</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">Point3D</span><span class=\"o\">::*</span> <span class=\"n\">pmd</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span> <span class=\"n\">Point3D</span><span class=\"o\">::</span><span class=\"n\">z</span>\n</code></pre></div><p>会是多少呢？<b>答案是z坐标在对象中的偏移量</b>。如果假设vptr不在类首，前面应该有至少8个byte。</p><p>最初的实现中，为了区分指向第一个data member的指针和没有指向data member的指针（均为0），真正的data member指针的偏移量都被加上1，用于区分。侯捷在VC++中进行了测试，偏移量并没有增加，很有可能VC++编译器对于其采用了另一种特殊处理。</p><p>实际使用中，指向类数据成员的指针用法如下。取static data的地址会是其真实地址，而non-static data的地址则会是offset，需要绑定到具体object上才会得到真实地址。</p><div class=\"highlight\"><pre><code class=\"language-text\">Point3D point；\npoint.*pmd == point.z</code></pre></div><p>多重继承情况下,编译器还需要对offset进行调整，填补上BaseClass导致的额外offset量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Pointer to Function Member</b></p><blockquote>实际使用中，指向类函数成员的指针用法如下。取non-virtual function的地址会是其真实地址，而virtual function的地址则会是其在虚表中的索引，需要绑定到具体object上才能通过虚表查询其真实地址。</blockquote><p>对于函数成员来说，情况有所不同。</p><p>对于nonvirtual函数而言，函数地址显然是确定的。而对于virtual函数而言，其地址编译器未知。</p><div class=\"highlight\"><pre><code class=\"language-text\">void (Point::*pmf）() = &amp; Point3D::virtualfunc;</code></pre></div><p>这又会是多少呢，答案是，虚表索引。编译期间</p><div class=\"highlight\"><pre><code class=\"language-text\">Point*ptr=new Point3d;\n（ptr-&gt;*pmf）();\n//将会被转换为（*ptr-&gt;vptr[int(pmf)]）(ptr);</code></pre></div><p><b>然而，问题在于，pmf并不一定只能指向虚函数，也可以指向非虚函数，如何寻址？</b></p><p>Bjarne Stoustrup设计了几种方案[LIPP88]，第一种存在普通指针内，限定了虚表大小，规定值小于128即为虚函数索引。第二种，他设计了一个结构体，其中index在不存在时会设置为-1作为哨兵，此时则会直接查询faddr：</p><div class=\"highlight\"><pre><code class=\"language-text\">struct _mptr{\nint delta;//this指针的offset值（应对多重继承情况）\nint index;//虚表索引\nunion{\nptrtofunc faddr;//非虚函数地址\nint v_offset;//虚基类虚表指针地址（应对虚拟继承情况）\n}</code></pre></div><p>代价很明显：每次调用必须付出检查成本。每次传递这个指针，都必须产生较大的临时对象。</p><p>为了减少上述调用成本，VC++引入了vcall thunk（可以参见专栏继承体系的指针偏移机制一文，有简单介绍），faddr引入的是成员函数地址或者vcall thunk的地址。</p><p>此外，由于部分字段只在多重继承或虚继承的情况下有用，不同情况下，指向成员函数的指针可以有着不同实例，VC++提供了</p><ol><li>单一继承实例（vcall thunk or faddr）</li><li>多重继承实例（vcall thunk or faddr+delta）</li><li>虚拟继承实例（上述四个member）</li></ol><hr/><h2>表驱动对象模型</h2><p>为了对class的所有object有一致表示方式，另一种对象模型是将所有member相关信息抽离。数据成员表存储数据本身，而函数成员表是一系列slots，指向成员函数。object本身仅仅含有两个指针，指向成员表。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a7a10e014d78b1c1cf2a67789be83e4f_b.jpg\" data-size=\"normal\" data-rawwidth=\"730\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb\" width=\"730\" data-original=\"https://pic4.zhimg.com/v2-a7a10e014d78b1c1cf2a67789be83e4f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;730&#39; height=&#39;508&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"730\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"730\" data-original=\"https://pic4.zhimg.com/v2-a7a10e014d78b1c1cf2a67789be83e4f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a7a10e014d78b1c1cf2a67789be83e4f_b.jpg\"/><figcaption>表驱动对象模型</figcaption></figure><p>这个模型的function部分可以看做在上面的简单对象模型基础上再增加了一层间接性，因此被称作<b>双表格模型。</b>IBM的系统对象模型SOM也依赖于这种模型。</p><p>优点：函数表作为整体被分离出类，而内部的指针又提供了灵活性，为其成为虚表打下基础</p><p>缺点：过度设计导致间接层暴增。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Extension:</b></p><p><b>尽管表驱动对象模型没有用于编译器中，但其member function table思想应用在virtual function中，并成为了主流实现。</b></p><blockquote>事实上，函数和数据均可以通过表驱动进行实现，前者为虚函数，后者为虚基类。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Virtual Table with Virtual Base Class：</b></p><blockquote>下列方法都只是实现模型，而不是标准。归根到底是为了解决虚基类位置变化导致的问题。<br/>1.为object的每个虚基类加上指针<br/>2.导入virtual base class table<br/>3.扩充virtual table</blockquote><p>虚基类，表现为菱形式的继承体系，其中菱形的顶部需要被实现为共享。</p><p>一个古老的实现方法是，<b>在每一个派生类对象中存放一个虚基类指针而非传统对象模型中的基类对象本身，对虚基类的访问通过指针间接实现</b>，以此实现共享。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fe72eef51eefd82ea1b481216c9e46f4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-fe72eef51eefd82ea1b481216c9e46f4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;482&#39; height=&#39;468&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-fe72eef51eefd82ea1b481216c9e46f4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fe72eef51eefd82ea1b481216c9e46f4_b.jpg\"/></figure><p>然而，这种实现方法有很多缺陷：</p><ol><li>对象为每个虚基类背负一个额外的指针，而理想上空间负担应该不随虚基类数目变化。</li><li>虚拟继承链的延伸导致间接层的增加，而理想上时间负担应该不随虚拟派生深度变化。</li></ol><p>对于问题二：</p><p><b>编译器使用拷贝操作获得所有嵌套虚基类的指针存至派生类，以空间换时间，从而解决了固定存取时间的问题。</b></p><p>而对于问题一：</p><p>VC++引入<b>virtual base class table</b>，当一个类出现多个虚基类，将会引入一层额外的间接层，由指针指向该表，而该表的slot指向真正的虚基类。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-228f9e210d7b25dc50f6a8ed1c696fa4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"534\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-228f9e210d7b25dc50f6a8ed1c696fa4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;534&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"534\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-228f9e210d7b25dc50f6a8ed1c696fa4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-228f9e210d7b25dc50f6a8ed1c696fa4_b.jpg\"/></figure><p>Bjarne Stoustrup采用的方式是，在<b>virtual function table中存储虚基类的offset</b>。使得虚基类的内存结构依然和<b>传统的继承</b>一致。如下图所示：派生类都可以通过vptr获取offset，从而正确地指向虚基类的地址。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-df3d29d8ec2067df1189e73e7f0d6c35_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"578\" class=\"origin_image zh-lightbox-thumb\" width=\"834\" data-original=\"https://pic2.zhimg.com/v2-df3d29d8ec2067df1189e73e7f0d6c35_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;834&#39; height=&#39;578&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"578\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"834\" data-original=\"https://pic2.zhimg.com/v2-df3d29d8ec2067df1189e73e7f0d6c35_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-df3d29d8ec2067df1189e73e7f0d6c35_b.jpg\"/></figure><p>作者的实现策略是：<b>虚表正值索引至virtual function entry，而负值索引至virtual base class offset</b>。代价则是对于member的存取较为昂贵。但是，如果是通过对象本身进行访问，而<b>不通过指针多态机制，则可以在编译期间决议</b>，无需代价，这一点和虚函数类似。</p><p>然而，上述方法都只是实现模型，而不是标准。归根到底是为了解决虚基类位置变化导致的问题。为语法苦恼的应该是C++编译器作者，而不是程序员。</p><blockquote>一般而言，为了避免上述困扰，推荐的方法是面向接口（类型）编程，即一个没有data member的虚基类。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Virtual Table with Virtual Function：</b></p><blockquote>一般的虚函数实现模型为，每一个类有一个虚表，虚表中存放虚函数地址，每一个对象有一个虚表指针，指向虚表。然而单一继承，多重继承，虚拟继承细节上又有不同。</blockquote><p>为了支持虚函数机制，必须有执行期的类型判断方法，因此，必须存在两个信息：</p><ol><li>对象地址</li><li>对象的typeinfo或是某个结构（其存储信息，用以正确决议虚函数实例）的地址</li></ol><p>如果把额外信息存放在指针中，会导致与C不兼容，并且明显增加了空间负担。因此应当存在对象中，而且仅当class真正需要时才存在。</p><blockquote>多态：以public base class的指针或引用，寻址出一个derived class object</blockquote><p>问题1：什么样的类需求此信息</p><p>答：定义虚函数的类 </p><p>问题2：这样的类需求什么样的信息</p><p>答：对象的类型/虚函数实例的地址</p><p>实现：typeinfo/虚表指针</p><p>虚表作为class的一员不参与object级的多态（<b>不懂请把OOP抄一万遍</b>），因此编译期即可决议虚函数的地址。然而这只是解答的一半。另一半是object如何在执行期找到地址。因此，每一个object被安插vptr指向虚表，每一个virtual function被指派一个slot，而虚表的第一个slot处存储typeinfo。</p><p>执行期所做的，只是在virtual table slot中激活virtual function，它们包括</p><ul><li>class定义的实例（可能override）-&gt;override：覆盖原slot/new：虚表增大slot</li><li>继承自base class的实例（不override时的情况）-&gt;拷贝函数实例地址</li><li>pure virtual called函数实例（占用纯虚函数空间/执行期处理纯虚函数调用的异常）</li></ul><p>单一继承下：虚表机制十分友好，效率高，并且模型容易塑造。</p><p>多重继承下：复杂度的问题在于this指针必须在执行期间调整，以正确获取vptr，具体实现可以见</p><a href=\"https://zhuanlan.zhihu.com/p/54199217\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">朝闻君：C++|对象模型|继承体系的指针偏移机制</a><p>虚拟继承下：在虚继承体系单层时，通过上文提及的虚基类寻址处理，还是可以正确地调整this指针，然而涉及虚基类继承虚基类时，并且都支持virtual function和nonstatic data member时（<b>共同特点：Object Level，如果你记忆好的话，上一节提到的成员指针中，这两者的共同之处在于必须绑定至对象才可决议</b>），Stanley表示</p><blockquote>我有一个柜子的答案，有一个以上的算法可以决定offset和各种调整，然而这些素材太过迷离，不适合在此讨论。（费马既视感）我的建议是，virtual base class坚决不要有nonstatic data member。</blockquote><hr/><h2>C++对象模型</h2><p>上述模型的Extension部分其实已经涵盖了部分对象模型的静态结构，而对象模型的生成与维护则更多见原书中的一系列章节。</p><p>Bjarne Stroustrup设计的C++对象模型从简单对象模型派生而来，对内存空间和存取时间做了优化。</p><p><b>Class Level</b></p><ul><li>static data member</li><li>static non-virtual function member</li><li>non-static non-virtual function member</li><li>virtual table（virtual base class offset+ virtual function entry+type info）</li></ul><p><b>Object Level</b></p><ul><li>virtual pointer to virtual table</li><li>non-static data member</li></ul><p><b>继承体系</b></p><p>虚继承体系间接存储，普通继承体系直接存储。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4e6c1ef47a5c5521f7d27d77f4ec636d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"608\" class=\"origin_image zh-lightbox-thumb\" width=\"728\" data-original=\"https://pic2.zhimg.com/v2-4e6c1ef47a5c5521f7d27d77f4ec636d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;728&#39; height=&#39;608&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"608\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"728\" data-original=\"https://pic2.zhimg.com/v2-4e6c1ef47a5c5521f7d27d77f4ec636d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4e6c1ef47a5c5521f7d27d77f4ec636d_b.jpg\"/></figure><hr/><h2>个人感想</h2><blockquote>All problems in computer science can be solved by another level of indirection.                                                            <i>Fundamental Theorem of Software Engineering</i> <b>David Wheeler</b></blockquote><p>程序员的这辈子都在和抽象打交道，而抽象的具体表现就是间接层。</p><p>间接层带来了<b>更高的编译效率</b>，代码的变动将会被间接层隔离。</p><p>然而间接层也带来了<b>更低的执行效率</b>，每一次的调用都必须经过反复的查询。</p><p>间接层带来了<b>动态的便利</b>，被藏在指针背后的实例轮替、更迭。</p><p>然而间接层也带来了<b>静态的复杂</b>，复杂结构的维护将成为编译器作者的梦魇。</p><p>如何平衡这种矛盾，或许才是设计的关键所在。</p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "面向对象编程", 
                    "tagLink": "https://api.zhihu.com/topics/19569910"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": [
                {
                    "userName": "朝闻君", 
                    "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                    "content": "唔，所以为什么关注：收藏：点赞居然是4：2：1啊[捂脸][捂脸]随手点个赞呗谢谢了，还是写文章比较务正业", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66534345", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 15, 
            "title": "C++|内存管理|new cookie实验", 
            "content": "<p>相关问题：</p><a data-draft-node=\"block\" data-draft-type=\"link-card\" href=\"https://www.zhihu.com/question/25556263/answer/32589012\" class=\"internal\">C++ delete[] 是如何知道数组大小的？</a><a data-draft-node=\"block\" data-draft-type=\"link-card\" href=\"https://www.zhihu.com/question/307703003\" class=\"internal\">MSVC中，对于new/delete数组的大小存放？</a><p>本文章来自于多年（误）前自己做的一次实验，因为打算什么时候把问题关了，故迁移实验内容自此。</p><h2>实验原因</h2><p>第一个问题的回答中，原答主指出：</p><div class=\"highlight\"><pre><code class=\"language-text\">    __inline void* _MarkAllocaS(_Out_opt_ __crt_typefix(unsigned int*) void* _Ptr, unsigned int _Marker)\n    {\n        if (_Ptr)\n        {\n            *((unsigned int*)_Ptr) = _Marker;\n            _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;\n        }\n        return _Ptr;\n    }</code></pre></div><p>malloc.h这个函数中存储了内存的大小，但是评论区有人指出实验结果不符，我个人也尝试了进行实验。此前我在Effective C++中了解了这个new cookie机制，但是未曾亲自动手。</p><h2>预实验</h2><p>通过对内存的打印，我在我创建的int堆数组附近并未找到类似的魔术数字。我仔细寻找了这个函数的访问点，唯一的访问点就在malloc.h内部。</p><div class=\"highlight\"><pre><code class=\"language-text\">#ifdef _DEBUG\n\n    #ifndef _CRTDBG_MAP_ALLOC\n        #undef _malloca\n        #define _malloca(size)                                                           \\\n            __pragma(warning(suppress: 6255 6386))                                       \\\n            (_MallocaComputeSize(size) != 0                                              \\\n                ? _MarkAllocaS(malloc(_MallocaComputeSize(size)), _ALLOCA_S_HEAP_MARKER) \\\n                : NULL)\n    #endif\n#else\n\n    #undef _malloca\n    #define _malloca(size)                                                                 \\\n        __pragma(warning(suppress: 6255 6386))                                             \\\n        (_MallocaComputeSize(size) != 0                                                    \\\n            ? (((_MallocaComputeSize(size) &lt;= _ALLOCA_S_THRESHOLD)                         \\\n                ? _MarkAllocaS(_alloca(_MallocaComputeSize(size)), _ALLOCA_S_STACK_MARKER) \\\n                : _MarkAllocaS(malloc(_MallocaComputeSize(size)), _ALLOCA_S_HEAP_MARKER))) \\\n            : NULL)\n\n#endif</code></pre></div><p>大意就是Debug模式下，所有_malloca（是微软的malloca私货，不是标准的malloc，所以原答主找错地方了）的内存均在堆上，而Release模式下，小数组的内存会通过_alloca而放到栈上。</p><div class=\"highlight\"><pre><code class=\"language-cpp\">    <span class=\"cp\">#define _ALLOCA_S_THRESHOLD     1024\n</span><span class=\"cp\"></span>    <span class=\"cp\">#define _ALLOCA_S_STACK_MARKER  0xCCCC\n</span><span class=\"cp\"></span>    <span class=\"cp\">#define _ALLOCA_S_HEAP_MARKER   0xDDDD\n</span></code></pre></div><p>通过上述代码，我们可以很明显地发现，_MarkAllocaS函数的Marker参数并不是原答主回答的size，而仅仅是用于标记Stack和Heap的标识符，在超过1kb时分配的内存会在堆上。而原答主拥有27赞8评论，其中质疑者包括我在内只有两人。可以看出尽管很多人知道这个知识点，但具体实操却没有经历。</p><p>在多次探索char数组的内存而不得后，我通过遍历的方式撞击前后1kb的内存，看是否有魔术数字正好能对应内存大小，尽管内存中因为随机性有这样的数字，但是位置的规律性根本看不出。我查阅了资料得知malloc的大小应该存储在某些被设置为保护的区块头，于是宣告对char数组的内存存储实验以失败告终。</p><h2>正式实验</h2><p>在继续查阅了其他资料之后，我得知了new的机制和malloc存在差异，例如malloc/free本身只需要宣告内存被占用/释放即可，而new/delete却要完成对应的构造/析构操作，如果仅仅存储字节大小，由于内存对齐原因，内存长度 / sizeof(T) &gt;= 对象个数，因此执行数组操作必须存储对象的数目而不仅仅是字节大小。</p><p>得到这个结论之后，很容易与</p><a data-draft-node=\"block\" data-draft-type=\"link-card\" href=\"https://zhuanlan.zhihu.com/p/50642330\" class=\"internal\">朝闻君：C++|对象模型|合成构造函数</a><p>中的POD（即平凡构造/平凡析构）联系在一起。</p><p>C语言中不存在new，因此仿C的对象也不会有独特的new cookie机制。因此上述C风格的char数组，struct数组，以及POD（Plain Ol&#39; Data）都不会存储这样的数组大小，自然也就没法找到了。</p><h2><b>实验结果</b></h2><p>在使用class封装int并添加上构造/析构函数后，我又一次对INT[32]探测了内存。结果如下</p><div class=\"highlight\"><pre><code class=\"language-text\">数组索引 地址 值\n-2 000001D0B18F51C0 20\n-1 000001D0B18F51C4 0</code></pre></div><p>在数组前8-4字节处正确存放了数组的大小0X20，因此编译器能够在new/delete[]时正确析构对象了。</p><h2>实验结论</h2><ol><li>对于栈中的自动对象，int a[5]等，直接由编译器提供大小，作为一种立即数直接参与汇编码中，这也是为什么栈数组必须使用常数的缘故，因为作为代码的一部分这必须是编译期间已知的。</li><li>对于堆上的内置类型或POD结构体（int，char等等），不存储大小，因为编译器根本无需析构，也没有必要知道数组具体的大小。内存的释放由malloc/free存储的字节大小处理即可。</li><li>对于堆上有构造或者析构函数的对象，在分配的对象前一段内存处分配size_t的大小存储大小，这段代码称为new cookie</li></ol>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }, 
                {
                    "tag": "编译器", 
                    "tagLink": "https://api.zhihu.com/topics/19608032"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>Debug模式下，所有malloc的内存均在堆上，而Release模式下，小数组的内存会通过_alloca而放到栈上<br>面试时遇到这个知识点，答错了啊</p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "朝闻君", 
                    "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                    "content": "不好意思[捂脸]主要是因为我实验的是new，不是malloc，所以那块打字太快，用词草率了。<br>总结一下：原答主那段代码并不是解释new的源代码，当然也不是解释malloc的源代码，只是微软自己的一个包装而已。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "朝闻君", 
                    "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                    "content": "走过路过的大佬们顺手点个赞呗，收藏已经是赞的两倍多了[捂脸]想务正业多搞点技术专栏", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>Debug模式下，所有malloc的内存均在堆上，而Release模式下，小数组的内存会通过_alloca而放到栈上<br>面试时遇到这个知识点，答错了啊</p>", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "你搜下malloca微软文档，备注里有写", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "不过我有点讲错了，应该是malloca不是malloc，这两个应该不是一回事，我是对着原答主的回答来说的。", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "朝闻君", 
                    "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                    "content": "走过路过的大佬们顺手点个赞呗，收藏已经是赞的两倍多了[捂脸]想务正业多搞点技术专栏", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63449574", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 2, 
            "title": "OOP/FP|重构|代码坏味道思维导图", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0c48fb7ffb5ecdcc24ae75f1489111b8_b.jpg\" data-size=\"normal\" data-rawwidth=\"3996\" data-rawheight=\"4096\" class=\"origin_image zh-lightbox-thumb\" width=\"3996\" data-original=\"https://pic1.zhimg.com/v2-0c48fb7ffb5ecdcc24ae75f1489111b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;3996&#39; height=&#39;4096&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"3996\" data-rawheight=\"4096\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"3996\" data-original=\"https://pic1.zhimg.com/v2-0c48fb7ffb5ecdcc24ae75f1489111b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0c48fb7ffb5ecdcc24ae75f1489111b8_b.jpg\"/><figcaption>代码的坏味道</figcaption></figure><p>这个版本作为国内3月刚出版的新书，算是第一手资料了。我也算是追着经典的脚步，当了一次开荒者。</p><p>了解代码的坏味道，我觉得不仅仅是帮助重构，更是对自己预先设计的一种提升。此外，了解什么地方该用什么重构，比单纯掌握重构方法更为重要。</p><p>这里只给出了代码坏味道这章，如果此前有第一版的基础，应该能很容易了解重构手法大体内容，当然最好选择支持一下Martin大牛。作者是敏捷开发界的创始人之一，这本书本身对于软件工程而言也尤为重要。</p><p>想提升自己的小伙伴千万别错过鸭。</p><p>我的github上上传了processon的链接，以及第一版思维导图的链接，感兴趣的朋友可以点击访问</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/sjtuzwj/BadSmellInCodeMindMap\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">代码的坏味道</a></p>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }, 
                {
                    "tag": "软件工程", 
                    "tagLink": "https://api.zhihu.com/topics/19557552"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62650625", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 1, 
            "title": "OOP|重构|重构手法思维导图", 
            "content": "<p>我的思维导图文件在下列链接，</p><a href=\"https://link.zhihu.com/?target=https%3A//www.processon.com/view/link/5cb5262ee4b059e209f987a9\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-90ed91de2169991f391e97560ec864b4_ipico.jpg\" data-image-width=\"200\" data-image-height=\"200\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">重构 | ProcessOn免费在线作图,在线流程图,在线思维导图</a><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2c8c9bb77dc8827edcadb99dd58ca70a_b.jpg\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"1407\" class=\"origin_image zh-lightbox-thumb\" width=\"4096\" data-original=\"https://pic3.zhimg.com/v2-2c8c9bb77dc8827edcadb99dd58ca70a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;4096&#39; height=&#39;1407&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"1407\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"4096\" data-original=\"https://pic3.zhimg.com/v2-2c8c9bb77dc8827edcadb99dd58ca70a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2c8c9bb77dc8827edcadb99dd58ca70a_b.jpg\"/><figcaption>第六章的部分内容</figcaption></figure><p>这本书的特色就在于他和GoF一样，给出了很多可行的手法和应用场景。</p><p>我目前摘选了重构手法部分，这也是作者所提倡的手册式学习。每个重构手法都在尽可能小的幅度下完成了代码抽象的改进，并且作为下一步重构的基础。</p><p>其中，第一项是应用场景，第二项一般为动机，分歧处阐述了不同场景下的选择。</p><p>概要为手法的最终结果。</p><p>与书本不同点在于，作为思维导图，这里省略了样例。</p><p>如果有所帮助的话，麻烦到github点个star谢谢了。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/sjtuzwj/RefactorMindMap\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sjtuzwj/RefactorMindMap</a></p><hr/><p>推荐一下第二版，三月出版，最好读新的。</p>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }, 
                {
                    "tag": "重构", 
                    "tagLink": "https://api.zhihu.com/topics/19553395"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54199217", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 2, 
            "title": "C++|对象模型|多继承虚机制实现", 
            "content": "<blockquote>本文参考深度探索C++对象模型</blockquote><hr/><p>我们常常使用基类指针指向派生类对象，那么，为什么基类指针能够如此轻松的调用派生类的方法呢？在多继承的情况下，this指针必须经过调整，才能正确地找到虚表。下文为你介绍多继承模型下的指针偏移机制</p><hr/><h2>指针偏移存在机制：</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>设一个多继承的类内存布局如下，单词代表对象首地址。（派生类假设无额外成员）</p><p>后[Derived[BASE1][BASE2]]前</p><p>有三种情况，指针会发生偏移。</p><hr/><p>使用基类指针指向派生类</p><p>赋值时：派生-&gt;基</p><p>派生类的指针转型为第二个基类指针。向前调整Base1长度以正确指向Base2。</p><p>调用时：基-&gt;派生</p><p>指向第二个基类的指针，调用派生类的虚函数。例如：对于Base1和Base2而言，如果Base2定义clone，Derived重写了clone，那么需要向后调整Base1长度以正确指向Derived object</p><hr/><p>使用派生类指针指向派生类</p><p>调用时：派生-&gt;基<br/>指向派生类的指针，调用第二个基类继承来的虚函数。向前调整Base1长度以正确指向Base2 sub-object。</p><hr/><h2>指针偏移实现机制：</h2><p>1.<b>赋值：</b>转型</p><p>temp为已知Derived指针。</p><p>Base2 * pbase2 =temp ? temp + sizeof (Base1):0;</p><p>目的是防止temp==nullptr时，仍然出现偏移。</p><p>2.<b>调用：</b></p><p>split functions</p><ul><li>函数较小时，产生两个函数，根据调用的指针类别判断是否需要调用<b>有调整</b>的函数</li><li>函数较大时，产生多重进入点，函数体分为（1）调整this （2）执行自定义函数码，根据是否需要调整，通过thunks跳转至对应的进入点</li></ul><p>address points：</p><p>虚函数期待获得的是引入虚函数的类对象的地址（而非派生类），这就是这个函数的address point。换而言之，它首先确保了转入的地址能够正确的指向对应的调用对象，此后再进行传递。（唔，我自己也没搞懂）</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54191913", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 1, 
            "title": "C++|对象模型|“虚构造函数“", 
            "content": "<blockquote>本文参考<a href=\"https://link.zhihu.com/?target=https%3A//isocpp.org/wiki/faq/virtual-functions%23virtual-ctors\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深度探索C++对象模型/ISO文档</a></blockquote><hr/><p>哈哈哈哈，这个标题是不是很毁三观。</p><p>析构函数必须为虚，构造函数不能为虚，因为在对象完全构造之前是没有类型的，也不存在虚表，所以虚构造函数也就不可能发生。这应该是常识，面试中问到也会不假思索回答。</p><p>但是，我从短暂的人生当中学到一件事......越是玩弄C++,就越会发现人类的能力是有极限的......除非超越人类。CC，我不做人了！</p><hr/><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Shape</span> <span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n  <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Shape</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"p\">}</span>                 <span class=\"c1\">// A virtual destructor\n</span><span class=\"c1\"></span>  <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">draw</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>             <span class=\"c1\">// A pure virtual function\n</span><span class=\"c1\"></span>  <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">move</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>  <span class=\"k\">virtual</span> <span class=\"n\">Shape</span><span class=\"o\">*</span> <span class=\"nf\">clone</span><span class=\"p\">()</span>  <span class=\"k\">const</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>   <span class=\"c1\">// Uses the copy constructor\n</span><span class=\"c1\"></span>  <span class=\"k\">virtual</span> <span class=\"n\">Shape</span><span class=\"o\">*</span> <span class=\"nf\">create</span><span class=\"p\">()</span> <span class=\"k\">const</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>   <span class=\"c1\">// Uses the default constructor\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Circle</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Shape</span> <span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n  <span class=\"n\">Circle</span><span class=\"o\">*</span> <span class=\"n\">clone</span><span class=\"p\">()</span>  <span class=\"k\">const</span><span class=\"p\">;</span>   <span class=\"c1\">// Covariant Return Types; see below\n</span><span class=\"c1\"></span>  <span class=\"n\">Circle</span><span class=\"o\">*</span> <span class=\"nf\">create</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>   <span class=\"c1\">// Covariant Return Types; see below\n</span><span class=\"c1\"></span>  <span class=\"c1\">// ...\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n\n<span class=\"n\">Circle</span><span class=\"o\">*</span> <span class=\"n\">Circle</span><span class=\"o\">::</span><span class=\"n\">clone</span><span class=\"p\">()</span>  <span class=\"k\">const</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Circle</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">this</span><span class=\"p\">);</span> <span class=\"p\">}</span>\n<span class=\"n\">Circle</span><span class=\"o\">*</span> <span class=\"n\">Circle</span><span class=\"o\">::</span><span class=\"n\">create</span><span class=\"p\">()</span> <span class=\"k\">const</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Circle</span><span class=\"p\">();</span>      <span class=\"p\">}</span>\n</code></pre></div><p>熟悉的人可能知道，在设计模式Prototype中，为了适应OOP模式下的复制，产生了Clone这样的接口。在C++中，这种idiom又被称为“虚构造函数“，是基于语法的拓展。</p><p>这里的虚构造函数，能够按照指针指向的实际对象给出多态式的拷贝与默认构造。</p><p>从上我们也可以看出，为什么返回值不作为函数标识符而可以参与重载了。</p><p>但是，需要注意的一点在于，由于是动态绑定，因此事先是不知道返回值的类型的，也就是说</p><div class=\"highlight\"><pre><code class=\"language-text\">Base* pb1=new Derived；\n//禁止！尽管知道指向的是Derived类\nDerived* pb2 =pb1-&gt;clone();\n//允许！尽管实际上后者并没有进行转型\nBase* pb3 =pb1-&gt;clone();\nDerived* pb4 =dynamic_cast&lt;Derive*&gt;(pb1-&gt;clone());</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>下次遇到这样的问题，故意说虚构造函数钓波鱼，有ISO官方文档和Stanley大佬背书我怕谁！</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53875602", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 4, 
            "title": "C++|内存管理|数组内存分配机制", 
            "content": "<blockquote>本文参考Effective C++与编译器源码</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>引言：你是否想过数组和指针为什么sizeof不同，你是否想过为什么new[]需要指定长度，而delete[]不需要，你是否质疑过为什么传数组一定要顺带传大小，你是否还以为堆上一定分配着数组大小？<br/>以下为您深（浅）入探索C++中的内存模型。</blockquote><hr/><p>本文内容为自己的读书笔记+实验，如无泛用性，杠精退散。</p><h2>数组-》指针，退化之路</h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">][</span><span class=\"mi\">5</span><span class=\"p\">];</span>\n<span class=\"kt\">int</span> <span class=\"o\">**</span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">];</span>\n</code></pre></div><p>这两者有什么不同呢？显然，对a进行sizeof，大小应该是100，而b则是8，也就是说，数组显然存在着某种额外的信息，告诉着你数组的大小。</p><p>很多无水平的教科书会对数组和指针进行混淆，事实上，由数组在传参中转化为指针的过程是一种退化，丢失了大小信息。</p><p>然而，这种退化并不是万能的</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">][</span><span class=\"mi\">5</span><span class=\"p\">];</span>\n<span class=\"kt\">void</span> <span class=\"nf\">fun</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">**</span> <span class=\"n\">para</span><span class=\"p\">);</span>\n</code></pre></div><p>你会发现，如果数组和指针可以任意转化的话，应该是能匹配的，然而，事实上却完全不可。</p><p>因为在a[1]这样的过程中，<b>计算a的偏移量是依赖于元素的大小的</b>，int**对象+1的偏移量会是int*的大小，而不是int[5]的大小. 而对于int*和 int[5]而言，他们的元素是一样的int。</p><p>总而言之，退化只能退化顶层的数组。</p><hr/><h2>如何存储数组的大小</h2><ol><li>对于栈中的自动对象，int a[5]等，直接由编译器提供大小，作为一种立即数直接参与汇编码中，这也是为什么栈数组必须使用常数的缘故，因为作为代码的一部分这必须是编译期间已知的。</li><li>对于堆上的内置类型或POD结构体（int，char等等），不存储大小，因为编译器根本无需析构，也没有必要知道数组具体的大小。内存的释放由malloc/free存储的字节大小处理即可。</li><li>对于堆上有构造或者析构函数的对象，存储大小有两种典型方式。一种是在分配的对象前一段内存处分配size_t的大小存储大小，另一种则是用关联数组，对将地址和对应的大小进行关联。前者实现简便，后者则避免了内存修改导致大小被污染的风险。</li></ol><p>事实上，很多人都有这样的误解，即所有数组前面都存放着大小，然而看了这一段，你会发现编译器很聪明，不会把内存浪费在无意义的地方。</p><hr/><h2>new[]的流程解析</h2><p>new的操作看似简单，实际上却由编译器进行重排，内联展开后插入很多隐藏的代码</p><div class=\"highlight\"><pre><code class=\"language-text\">1.判断数据类型\n2.计算内存大小（依据1中是否需要存储大小给予额外的空间）\n3.new_array函数直接调用new_scalar(事实上你的[]并没有实际作用，\n仅仅是一种提示，真正的改变是由编译器的额外代码完成的）\n4.new_scalar调用系统的malloc函数\n5.malloc函数查找到空余内存，开辟一段chunk，将chunk标记为已使用，然后记录chunk大小。（依赖于系统）\n6.返回chunk的首指针\n7.如果1中判断需要进行析构或者构造，则首先存储大小，再让指针加上一段偏移量，\n对于最终的指针，根据对象的大小和数量对于分配后每段内存进行对应的构造。\n8.返回（偏移后）的指针。</code></pre></div><p>可以看出，事实上malloc的大小会根据编译器对于数据类型的识别而改变，所以不能轻易地把所有的数组都当做存储大小混为一谈。在new[]操作符中，一部分内存用于存储数组大小；而在malloc操作符中，一部分内存用于存储字节大小。关于malloc的实现，请关注日后的专栏更新。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>以上就是对于new[]操作符经过对MSVC的源代码进行了一定的解读之后，我的一些理解。鉴于很多知乎答主对于堆上数组大小分配在哪里不是很清晰，包括很多知名的答主都存在一定的混淆，我分类讨论，对于易混淆点做出了一定的辨析，希望知友能理解更深！</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "内存（RAM）", 
                    "tagLink": "https://api.zhihu.com/topics/19570383"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": [
                {
                    "userName": "没精力的经历王", 
                    "userLink": "https://www.zhihu.com/people/88393098d787e2308d4a8d99bbb8650d", 
                    "content": "数组当行参退化为数组指针，被你说的有点复杂了哈", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "<p>你自己没搞懂，退化只能有一层，这是编译器决定的。不能简单说退化就完事。</p><p><br></p><p>另外可以自己了解一下C++的模板完美转发，能直接转发数组，保留所有信息包括sizeof。</p><p><br></p><p>如果“不求甚解“没啥问题，但是只用一句简单的话涵盖所有情况是不现实的。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "没精力的经历王"
                        }, 
                        {
                            "userName": "没精力的经历王", 
                            "userLink": "https://www.zhihu.com/people/88393098d787e2308d4a8d99bbb8650d", 
                            "content": "我说的c", 
                            "likes": 0, 
                            "replyToAuthor": "朝闻君"
                        }
                    ]
                }, 
                {
                    "userName": "兔哥", 
                    "userLink": "https://www.zhihu.com/people/fedb528e6bd842b01d42e15478a18831", 
                    "content": "<p>7.如果1中判断需要进行析构或者构造，则首先存储大小，再让指针加上一段偏移量，<br>对于最终的指针，根据对象的大小和数量对于分配后每段内存进行对应的构造。<br>8.返回（偏移后）的指针。</p><p><br></p><p>你看的是Debug版本的库吧。。。。。。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "[思考][思考]抱歉，我做了实验的。我找到了size，你呢。", 
                            "likes": 0, 
                            "replyToAuthor": "兔哥"
                        }, 
                        {
                            "userName": "朝闻君", 
                            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
                            "content": "我库很抱歉确实没找到，MSVC里没看到源码，另外release版本有什么区别呢？我想问下，如果有，这值得成为反驳的理由么", 
                            "likes": 0, 
                            "replyToAuthor": "兔哥"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52163769", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 1, 
            "title": "C++|I/O|基于缓冲区的位级IO流", 
            "content": "<blockquote>本文参考Sedgewick著Algorithms。</blockquote><p>本文来自于Huffman Trie的作业要求。我使用了普林斯顿版算法进行移植。对于作者定义的BinaryStdIn/Out进行了移植与改造。</p><p>由于原文使用了Java语言与作者自定义的库，在移植时进行了一些适配。</p><hr/><blockquote>移植重点：</blockquote><p>C++中无法自主指定位移类型</p><p>而是通过有无符号类型判断</p><hr/><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>主体思路：</blockquote><p>8 bit的unsigned char型buffer</p><p>buffer大小n</p><p>工具函数：</p><p>fillBuffer，从流中获取一个字节</p><p>clearBuffer，清空buffer，不足以0补齐</p><hr/><blockquote>单位操作：</blockquote><h2>readBit：</h2><p>n自减</p><p>从buffer中通过位运算&gt;&gt;n &amp;1取出bit</p><p>n=0时，fill buffer</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>writeBit：</h2><p>n自增</p><p>从buffer中通过位运算&lt;&lt;=1 |=bit置入bit</p><p>n=8时，clear buffer</p><hr/><blockquote>单字节操作：</blockquote><h2>readByte：</h2><p>字节对齐：</p><p>返回buffer，fill buffer</p><p>否则：</p><p>将buffer的后n位，与fill buffer后buffer的前8-n组合后返回。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>writeByte：</h2><p>字节对齐：</p><p>调用朴素输出byte</p><p>否则：</p><p>对每一位writeBit</p><hr/><blockquote>多字节操作</blockquote><h2>readVal：</h2><p>根据sizeof，进行循环</p><p>&lt;&lt;=8  |=readByte（）</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>writeVal：</h2><p>根据sizeof=N，进行循环</p><p>&gt;&gt;8*k (k from N-1 -&gt; 0）&amp;oxff</p><hr/><blockquote>仓库地址</blockquote><p>个人作业用途，因此只移植了部分方法。此外在异常处理上仍然存在问题。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/sjtuzwj/Bit-IO-in-Cpp\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/sjtuzwj/Bit-</span><span class=\"invisible\">IO-in-Cpp</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "I/O", 
                    "tagLink": "https://api.zhihu.com/topics/19647303"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/50644397", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 1, 
            "title": "Python|函数式编程|类的函数式实现", 
            "content": "<blockquote>本文参考SICP，Function Abstraction</blockquote><p>python作为一个现代语言，结合着OOP和FP的多种性质，不同于其他OOP语言，python中的函数具有自己的环境，让我们从这里入手，看看类在FP中可以如何实现.</p><p>函数，闭包，其内部名称只可被内部访问，因此，本质上，它可以视为大部分成员都是私有的对象。</p><p>那么，函数有什么是public的呢，答案是，返回值，这是函数与外界沟通的桥梁.</p><p>而我们则要借助这个桥梁，一点一点地把内部的所有私有成员给撬开。</p><p>答案是，表驱动，而这种实现也被称为Dispatcher，表内记载public，而其他的数据则是不可见的，这也是另一种形式下的权限访问。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"err\">：</span>\n   <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"n\">a</span>\n   <span class=\"k\">def</span> <span class=\"nf\">c</span><span class=\"p\">()</span><span class=\"err\">：</span>\n     <span class=\"k\">return</span> <span class=\"mi\">1</span>\n   <span class=\"nb\">map</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">&#34;b&#34;</span><span class=\"p\">:</span><span class=\"n\">b</span><span class=\"err\">，</span><span class=\"s2\">&#34;c&#34;</span><span class=\"err\">：</span><span class=\"n\">c</span><span class=\"p\">}</span>\n   <span class=\"k\">def</span> <span class=\"nf\">getitem</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">):</span>\n      <span class=\"k\">return</span> <span class=\"nb\">map</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]</span>\n<span class=\"k\">return</span> <span class=\"n\">getitem</span></code></pre></div><p>我们可以回忆OOP中对象模型是如何实现的。C++中，为了操控一个对象，我们实际拥有的是this指针。而内部的成员等等都是通过偏移量计算得出。在编译器内部，偏移量又是一张符号表。它不可见于外界，但是同时又被类所知晓。</p><p>回头看一看，FP和OOP的思路殊途同归，都是借助着对外公开的唯一信息，逐渐抽丝剥茧，完成了对内部成员的访问。</p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }, 
                {
                    "tag": "函数式编程", 
                    "tagLink": "https://api.zhihu.com/topics/19585411"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/50642330", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 1, 
            "title": "C++|对象模型|合成构造函数", 
            "content": "<blockquote>本文参考深度探索C++对象模型<br/>编译器为未定义构造函数的类合成默认构造和拷贝构造函数</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>如果你已经开始点头了，那么你和我一样，陷入了深深的误解。</p><p>当我看到书中作者的这句话时，几乎是一身冷汗。老实说，我个人对于合成构造函数的理解的确是无则加，有则否。但是Stanley却直接指出了新手常有的这一误解。</p><hr/><p>让我们从最初的C语言开始回忆，当我们对struct进行构造时，存在着构造函数的机制么?</p><p>很明显，不存在。</p><p>在C++中，class和struct在某些实现中是转换等同的。那么，为什么还需要合成构造函数呢?按C的做法来不就好了么。</p><p>事实上，C的做法，将对应的成员一一拷贝或初始化，称为bitwise，因为在编译器眼中，这仅仅需要malloc或者memcpy一段bit而已。同理，在C++中，完全也可以进行这样的处理，而根本不需要合成一个构造函数! 这样的情形，我们称之为trivial.</p><hr/><p>那么，什么时候才叫nontrivial呢。nontrivial其实指的就是，编译器是真正在干事，而不是本质上在摸鱼。</p><p>答案有四种</p><ol><li>组合：成员定义了构造函数(memberwise)</li><li>继承：基类定义了构造函数</li><li>虚函数</li><li>虚基类</li></ol><p>本质上，12和34还有所不同。</p><p>在12中，编译器采取的方式是在合成出的构造函数中调用这些已经定义好的构造函数。</p><p>在34中，编译器需要对虚表指针和虚基类指针进行初始化操作.</p><p>所以，空空如也的构造函数，在这种情况下，实际的代码量可能会让你惊讶。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>拓展：POD</p><p>Plain Ol&#39; Data</p><p>对于所有合成函数为平凡，且不含虚机制的类（C style）编译器只产生平凡合成函数的声明，而不进行定义和调用。</p><p>除构造外的其他函数同理。</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "深度探索C++对象模型（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20126432"
                }, 
                {
                    "tag": "面向对象编程", 
                    "tagLink": "https://api.zhihu.com/topics/19569910"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/47744606", 
            "userName": "朝闻君", 
            "userLink": "https://www.zhihu.com/people/8f7341efa621f3422c7b14db692bbfd6", 
            "upvote": 2, 
            "title": "C++|内存管理|智能指针别名构造函数", 
            "content": "<blockquote>本文参考ISO文档</blockquote><p>在C++编程实践中, 几乎所有人都或多或少地使用过智能指针.但是在智能指针的一个小角落, Alias Constructor大概不为多少人所知.</p><hr/><p>根据stackoverflow上的一个讨论, Alias Constructor被描述如下</p><blockquote><i>Additionally, shared_ptr objects can share ownership over a pointer while at the same time pointing to another object. This ability is known as aliasing (see constructors), and is commonly used to point to member objects while owning the object they belong to. Because of this, a shared_ptr may relate to two pointers:</i></blockquote><ul><li><i>A stored pointer, which is the pointer it is said to point to, and the one it dereferences with operator*.</i></li><li><i>An owned pointer (possibly shared), which is the pointer the ownership group is in charge of deleting at some point, and for which it counts as a use.</i></li></ul><blockquote><i>Generally, the stored pointer and the owned pointer refer to the same object, but alias shared_ptr objects (those constructed with the alias constructor and their copies) may refer to different objects.</i></blockquote><hr/><p>什么意思呢,在谈Alias Constructor之前, 我们先简略了解一下shared_ptr实现机制, shared_ptr由两个指针构成, 一个指向控制块, 一个指向存储的指针. 控制块会控制其存储指针的生存期. 但是, 重点来了, 控制块中存储的指针未必是sharedptr存储的指针.</p><p>事实上, shared_ptr中存储的控制块指针仅仅只是一个非模板基类, 而存储指针/删除器/分配器等特征都通过指向派生出的模板子类(多态)而体现. 这里后面的特征通过了Type erasure 而逃过了编译器的类型检查.</p><p> 内部控制块的模板参数和外部智能指针的模板参数毫无干系, 因此控制块指针和存储指针本质上是完全独立的.</p><hr/><p>那么,为什么C++需要用如此复杂的方式去实现呢?</p><p>一个原因是设计者认为删除器/分配器等非必需的工具不应该影响到指针的类型</p><p>另一个原因就要讲到这里的Alias了.</p><p>Alias,化名, 在这里意为两者具有相同的生命周期. </p><p>其语法为shared_ptr&lt;element&gt; ptr(Tptr, element*)</p><p>在这里尽管Tptr具有模板参数为T, 但是ptr(模板参数为element)仍旧可以共享其控制块.</p><p>在Stackoverflow上有这样一个例子.</p><div class=\"highlight\"><pre><code class=\"language-text\">struct Bar { \n    // some data that we want to point to\n};\n\nstruct Foo {\n    Bar bar;\n};\n\nshared_ptr&lt;Foo&gt; f = make_shared&lt;Foo&gt;(some, args, here);\nshared_ptr&lt;Bar&gt; specific_data(f, &amp;f-&gt;bar);\n\n// ref count of the object pointed to by f is 2\nf.reset();\n\n// the Foo still exists (ref cnt == 1)\n// so our Bar pointer is still valid, and we can use it for stuff\nsome_func_that_takes_bar(specific_data);</code></pre></div><p>对象的成员和对象本身,显然的确应该共享生存期,但有人可能会问了, 为什么不用-&gt;调用成员呢, 似乎这并非刚需.</p><hr/><p>在思考很久之后, 不同类型对象共享生存期的情况映入了我的脑中.</p><div class=\"highlight\"><pre><code class=\"language-text\">struct Base1 { int base1=0; };   \nstruct Base2 { int base2=0; };   \nstruct A:Base1,Base2{};    \n\nint main()\n{\n    auto ptr = new A;     \n\n        shared_ptr&lt;Base1&gt;ptr1 ((Base1*)ptr);    \n\n        //shared_ptr&lt;Base2&gt;ptr2 ((Base2*)ptr);    \n\n        //内存泄漏,ptr2已经被释放:-572662307end crash     \n\n        shared_ptr&lt;Base2&gt;ptr2(ptr1, (Base2*)(ptr));    \n\n        //化名,ptr2未被释放:0end    \n\n        ptr1.reset();    \n\n        cout &lt;&lt; ptr2-&gt;base2;    \n\n        cout &lt;&lt; &#34;end&#34;;    \n\n    return 0;    \n\n}    </code></pre></div><p>在C++中,一种特殊的情况在于多继承, 当我们面向接口(类型)编程时, 如果我们使用接口指针去操纵对象,就不得不遇到不同接口的智能指针指向同一个对象了. 一旦我们没有使用Alias, 由于不同类型指针无法共享控制块, 这势必会产生内存泄漏, 而通过Alias, 我们则完美地避免了这一情况.</p>", 
            "topic": [
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }, 
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "智能指针", 
                    "tagLink": "https://api.zhihu.com/topics/19616318"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1039197804748595200"
}
