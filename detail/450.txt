{
    "title": "TheAIchemist", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/san-ri-24", 
        "https://www.zhihu.com/people/ta-ni-47", 
        "https://www.zhihu.com/people/mch0dmin", 
        "https://www.zhihu.com/people/daniel-73-76", 
        "https://www.zhihu.com/people/quantun_", 
        "https://www.zhihu.com/people/sun-hui-18-14", 
        "https://www.zhihu.com/people/interesting-90-9", 
        "https://www.zhihu.com/people/dong-zhi-yong-16", 
        "https://www.zhihu.com/people/yang-ou-48", 
        "https://www.zhihu.com/people/lucky-45-9-77", 
        "https://www.zhihu.com/people/wu-hui-tian-ya-27", 
        "https://www.zhihu.com/people/liushuangs", 
        "https://www.zhihu.com/people/wang-li-xue-15", 
        "https://www.zhihu.com/people/li-mao-46-20", 
        "https://www.zhihu.com/people/xing-ba-tai-ji", 
        "https://www.zhihu.com/people/wj2014-59"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/89957379", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 31 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章  </blockquote><hr/><h2>Contents</h2><ul><li>Algorithm: 66. Plus One</li><li>Review: Deep learning: the final frontier for signal processing and time series analysis?</li><li>Tip: 推荐一个简单的图床应用</li><li>Share: 关于 5G 是不是伪需求的一点理解</li></ul><hr/><h2>Algorithm</h2><h3>66. Plus One</h3><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/plus-one/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">66. Plus One</a></p><p>难度：Easy</p><p>题意：</p><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p><p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p><p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.</code></pre></div><p>解法：</p><p>这个题目实际上有一些坑，在示例中应该加上 <code>[9, 9, 9]</code> 这种例子更方便理解。实际上我们要注意的也是这个地方，即进位的问题。我们需要从后往前遍历，区分是否为 <code>9</code> 即可。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">plusOne</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">digits</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]:</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">reversed</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">digits</span><span class=\"p\">))):</span>\n            <span class=\"k\">if</span> <span class=\"n\">digits</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">9</span><span class=\"p\">:</span>\n                <span class=\"n\">digits</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">digits</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"k\">return</span> <span class=\"n\">digits</span>\n        <span class=\"n\">digits</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"n\">digits</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">digits</span></code></pre></div><hr/><h2>Review</h2><h3>Deep learning: the final frontier for signal processing and time series analysis?</h3><p>本周阅读了 Medium 上的一篇关于信号处理与时间序列的<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40alexrachnog/deep-learning-the-final-frontier-for-signal-processing-and-time-series-analysis-734307167ad6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">综述类文章</a>，题目为《Deep learning: the final frontier for signal processing and time series analysis?》。</p><p>文章写得非常好，提纲挈领地总结并分析了目前关于信号分析与时序问题领域中被广泛运用的方法，将其罗列如下：</p><ul><li>信号与时间序列的来源</li><li>经典方法：</li><ul><li>时域分析</li><li>频域分析</li><li>最近邻分析</li><li>(S)AR(I)MA(X) 模型</li><li>时间序列分解</li><li>非线性动态系统</li><li>机器学习</li></ul><li>深度学习：</li><ul><li>循环神经网络</li><li>卷积神经网络</li><li>CNN + RNN</li><li>自回归神经网络</li><li>聚类方法</li><li>异常检测</li><li>混合方法</li></ul></ul><p>文末作者非常负责地给出了延伸阅读的链接，非常建议一读。</p><hr/><h2>Tips</h2><h3>推荐一个简单的图床应用</h3><p>目前我写作用的图床应用是 iPic，上传操作很方便，支持多种图床，上传完成之后直接将结果以 Markdown 格式返回保存到剪贴板中。<a href=\"https://link.zhihu.com/?target=https%3A//toolinbox.net/iPic/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官方详细介绍</a>。可以在 Mac App Store 下载。暂不支持 Windows。</p><hr/><h2>Share</h2><h3>关于 5G 是不是伪需求的一点理解</h3><p>最近和老爸聊天，老爸问起来 5G 的事情，他说他的很多朋友表示 5G 是一个伪需求，于是我和老爸探讨了一下关于「5G 是否是伪需求」这个命题，把自己的理解记录如下。</p><p>记得大概在六月份端午节的时候，<a href=\"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av54737593\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">何同学的一个 5G 视频</a>一夜之间收获了几十万的浏览量，并被央视转发，各种科技媒体也都在谈论 5G，老百姓也时不时把 5G 挂在嘴边。究其原因，无外乎一下三点：</p><ol><li>4G 技术已经使用了很长一段时间，现在已经到了技术突破的时候了；</li><li>中美的技术与毛衣争端把国内 5G 技术的领头羊华为推上了风口浪尖；</li><li>越来越多的质疑声开始出现，比如需求、成本、辐射问题等等。</li></ol><p>那么 5G 到底是不是一个为需求呢？</p><p>有这样的质疑声很正常，拿我自己所在的国家法国举一个例子。在法国很多地方，实际上 4G 都没有完全覆盖，要是乘坐大巴路过法国一些乡下，你会发现手机都是「无服务」，我所住的小区也还是去年年底才通上光纤网络。这些都反映了一个事实：人口密度小的地方，建立基站的成本非常高。这也是为什么在法国使用功能机的人随处可见的原因。</p><p>很多人认为，5G 只是速度比 4G 要快一些，4G 已经可以满足我们现在的所有需求，如刷微博、接打微信视频电话、在线观看高清电影等。这种看法是非常有道理的，因为我们目前对 5G 的媒体报道，大部分都是集中在 5G 的网速多么多么快上，动不动就拿出一台 5G 手机，打开 SpeedTest，到指定的 5G 测试地点进行网速测试，甚至很多运营商的宣传中也拿 5G 的网速作为噱头，比如一分钟下载一部高清电影、两分钟下载一个大型游戏等等。但是所有这些宣传，都没有指出 5G 所能解决的 4G 的痛点问题，就是 4G 的网络带宽。</p><p>举个栗子，在火车站、演唱会或者其他一些人多的场合，你是否有过「明明 4G 信号是满格，但却刷不出来朋友圈、发不出去图片」的经历呢？我猜测大部分人都有吧，那么这就印证了 4G 的痛点问题，就是带宽。一旦设备数量增加一两个数量及，4G 的带宽与并发能力就不够了。</p><p>从 4G 技术的最初设计来看，4G 最多支持的设备数是 10 万台/平方公里。而今后必定是 IoT 发展的时代，各种智能家居、智能设备、智能汽车都要加入到网络中来，那么每平方公里的设备数可能就远远不止 10 万台了，这也就到达了 4G 带宽的上限。就像是一条公路，建设的时候是四车道设计，这样的设计用来应付原先的车辆数可能绰绰有余，但是现在车辆数目猛增，要解决这个问题，一个非常容易想到的方法就是拓宽车道了。5G 的设计中有一项就是更大的带宽和更强的并发能力。</p><p>另外，在 4G 到来之前，4G 也经历了很多「是否是伪需求」的质疑，从现在的结果来看，4G 技术的成熟创造出了很多原先没有的市场，5G 也许也是这样。</p><p>让我们拭目以待。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "5G还有一堆坑呢[害羞]", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88751111", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 30 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents</h2><ul><li>Algorithm: 38. Count and say</li><li>Review: The World In 50 Years</li><li>Tip: 正则表达式测试工具</li><li>Share: Show-me-the-code-0001 思路以及代码</li></ul><hr/><h2>Algorithm</h2><h3>38. Count and say</h3><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/count-and-say/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">38. Count and say</a></p><p>难度：Easy</p><p>题意：</p><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><div class=\"highlight\"><pre><code class=\"language-text\">1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221</code></pre></div><p><code>1</code> is read off as <code>&#34;one 1&#34;</code> or <code>11</code>.</p><p><code>11</code> is read off as <code>&#34;two 1s&#34;</code> or <code>21</code>.</p><p><code>21</code> is read off as <code>&#34;one 2, then one 1&#34;</code> or <code>1211</code>.</p><p>Given an integer <code>n</code> where <code>1 ≤ n ≤ 30</code>, generate the <code>n</code> th term of the count-and-say sequence.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 1\nOutput: &#34;1&#34;</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 4\nOutput: &#34;1211&#34;</code></pre></div><p>解法：</p><p>本题乍一看比较难以理解，但是仔细一想其实并不难，就是对于前一个数，找出相同元素的个数，把个数和这个元素存储到新的字符串中去。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">countAndSay</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">str</span><span class=\"p\">:</span>\n        <span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;1&#34;</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">getNext</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">seq</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">getNext</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">seq</span><span class=\"p\">):</span>\n        <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">next_seq</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s2\">&#34;&#34;</span>\n        <span class=\"k\">while</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">):</span>\n            <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">while</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"n\">seq</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">seq</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]:</span>\n                <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">next_seq</span> <span class=\"o\">+=</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">count</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">seq</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"n\">next_seq</span></code></pre></div><hr/><h2>Review</h2><h3>The World In 50 Years</h3><p>本周阅读了 QUARTZ 上的一篇文章 <a href=\"https://link.zhihu.com/?target=https%3A//qz.com/is/the-world-in-50-years/questions/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The World In 50 Years</a>，QUARTZ 请了 50 位不同领域的学者就未来五十年做了预测，问题涉及到技术、经济、政治、人类生活中的生存、交流、娱乐、衣食住行等方方面面。</p><p>但实际上，这种预测的具体内容就当吃瓜看看就好，每个人对技术和未来的理解都不同，重要的是这些不同领域的学者智库站在不同角度观察世界的方式，这才是最能启迪人思想的地方。</p><hr/><h2>Tips</h2><h3>正则表达式测试工具</h3><a href=\"https://link.zhihu.com/?target=http%3A//tool.oschina.net/regex/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在线正则表达式测试</a><hr/><h2>Share</h2><h3>Show-me-the-code-0001 思路以及代码</h3><p>正如 Linux 之父 Linus 所言：</p><blockquote>Talk is cheap. Show me the code.</blockquote><p>代码才是最能反映一个编程人员水平的方式，于是有了这个 Github 上的一个开源项目：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Show-Me-the-Code/show-me-the-code\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Show-me-the-code：Python 练习册，每天一个小程序</a>。于是我尝试做了两道题，觉得比较有趣，记录下来。</p><h3>Show-me-the-code-0001</h3><blockquote>第 0001 题： 做为 Apple Store App 独立开发者，你要搞限时促销，为你的应用生成激活码（或者优惠券），使用 Python 如何生成 200 个激活码（或者优惠券）？</blockquote><p>思路： </p><ol><li>因为激活码要保证不能重复，所以使用<b>集合</b>这一数据结构来装所有的激活码。</li><li>首先生成一个 keys 的集合，生成一个大写字母和 0-9 的数字组成的 source 库，这是个列表。</li><li>使用 while 循环来生成激活码，从生成的 source 列表中使用 <code>random.choice()</code> 函数随机选择 length 个字符加到一起作为一个激活码。</li><li>将这个激活码加入到 keys 中去，这里 <code>add()</code> 函数会自动判断生成的激活码在不在 keys 中，如果不在，集合长度加一，否则集合长度不会增加。</li><li>继续循环直到集合长度等于初始设定的 number 数。  </li></ol><p>Code：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"ch\">#!/usr/bin/env python3</span>\n<span class=\"c1\"># -*- coding: utf-8 -*-</span>\n\n<span class=\"s1\">&#39;&#39;&#39;\n</span><span class=\"s1\">@Author: AlainOUYANG\n</span><span class=\"s1\">@Date: 2019-10-21 17:06:02\n</span><span class=\"s1\">@LastEditors: AlainOUYANG\n</span><span class=\"s1\">@LastEditTime: 2019-10-21 17:47:19\n</span><span class=\"s1\">@Description: Show-me-the-code 0001\n</span><span class=\"s1\">&#39;&#39;&#39;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n<span class=\"kn\">import</span> <span class=\"nn\">string</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">gen_activation_key</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"p\">,</span> <span class=\"n\">number</span><span class=\"p\">):</span>\n    <span class=\"s1\">&#39;&#39;&#39;\n</span><span class=\"s1\">    @description: generate activation key\n</span><span class=\"s1\">    @length {int}\n</span><span class=\"s1\">    @number {int}\n</span><span class=\"s1\">    @return: set\n</span><span class=\"s1\">    &#39;&#39;&#39;</span>\n    <span class=\"n\">keys</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">()</span>\n    <span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"o\">.</span><span class=\"n\">ascii_uppercase</span> <span class=\"o\">+</span> <span class=\"n\">string</span><span class=\"o\">.</span><span class=\"n\">digits</span><span class=\"p\">)</span>\n\n    <span class=\"k\">while</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">keys</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">number</span><span class=\"p\">:</span>\n        <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"p\">):</span>\n            <span class=\"n\">key</span> <span class=\"o\">+=</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">)</span>\n        <span class=\"n\">keys</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">keys</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">&#34;__main__&#34;</span><span class=\"p\">:</span>\n    <span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">(</span><span class=\"s2\">&#34;Please set the length of keys: &#34;</span><span class=\"p\">))</span>\n    <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">(</span><span class=\"s2\">&#34;Please set the number of keys: &#34;</span><span class=\"p\">))</span>\n    <span class=\"n\">keys</span> <span class=\"o\">=</span> <span class=\"n\">gen_activation_key</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"p\">,</span> <span class=\"n\">number</span><span class=\"p\">)</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s2\">&#34;Here are the keys generated (total: {0}):&#34;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">keys</span><span class=\"p\">)))</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">each_key</span> <span class=\"ow\">in</span> <span class=\"n\">keys</span><span class=\"p\">:</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">each_key</span> <span class=\"o\">+</span> <span class=\"s1\">&#39; length: {0}&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">each_key</span><span class=\"p\">)))</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87627794", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 29 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章  </blockquote><hr/><h2>Contents</h2><ul><li>Algorithm: 9. Palindrome Number</li><li>Review: The Most Underrated Productivity Technique Is Also the Simplest</li><li>Tip: 推荐几个 vscode 插件</li><li>Share: 列表与元组的几个常用方法总结</li></ul><hr/><h2>Algorithm</h2><h3>9. Palindrome Number</h3><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/palindrome-number\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">9. Palindrome Number</a></p><p>难度：Easy</p><p>题意：Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 121\nOutput: true</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</code></pre></div><p>示例 3：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.</code></pre></div><p>进阶：Coud you solve it without converting the integer to a string?</p><p>解法：</p><p>本题与上周的 Reverse Integer 那一题非常像，都需要反转一个数字。</p><ul><li>首先我们先尝试一下使用字符串的方式来解决这个问题。Python 中利用字符串的切片操作可以很方便地反转字符串：</li></ul><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isPalindrome</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span></code></pre></div><ul><li>我们利用上周相同的方式，对 10 取余并反向相加，最后比较最终的结果：</li></ul><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isPalindrome</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"n\">rev</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">):</span>\n            <span class=\"n\">rev</span> <span class=\"o\">=</span> <span class=\"n\">rev</span> <span class=\"o\">*</span> <span class=\"mi\">10</span> <span class=\"o\">+</span> <span class=\"n\">a</span> <span class=\"o\">%</span> <span class=\"mi\">10</span>\n            <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">//</span> <span class=\"mi\">10</span>\n\n        <span class=\"k\">return</span> <span class=\"bp\">True</span> <span class=\"k\">if</span> <span class=\"n\">rev</span> <span class=\"o\">==</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"bp\">False</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><h3>The Most Underrated Productivity Technique Is Also the Simplest</h3><p>本周阅读了一篇 Medium 上获得很多点赞的一篇文章，<a href=\"https://link.zhihu.com/?target=https%3A//forge.medium.com/the-most-underrated-productivity-technique-is-also-the-simplest-82b6b8d2891f\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Most Underrated Productivity Technique Is Also the Simplest</a>。文章短小精悍，遂将其翻译如下。</p><p>人类是不可能阅读完每一条有关生产力的建议的，但我想我已经接近了。我曾经一度尝试了非常多的生产力建议，无论这些建议有多反人类。有一次我尝试了冷水浴，据说他可以帮助你抵消拖延症（而实际上并没有）。</p><p>最终，有那么一下，我忽然意识到学习这些所谓的时间管理技巧、日历系统和多步策略实际上只会让我拖延真正的工作——把事情做了。事实上，我已经知道了最有效的生产力建议，只需要把它用起来。</p><p>这个建议只有两个步骤：</p><ol><li>身体上处于你的工作位置</li><li>做一件小事</li></ol><p>这就是全部的建议。</p><p>这个建议很简单，但不容易做到。通常的情况是，我们会竭尽我们所能去避免第一步的发生。我们会去喝杯咖啡、散个步、读本书、办个事。在我写这篇文章之前，我已经去整理了我的书架。我尝试去逃避，而我内心的声音告诉我去打开 Netflix。</p><p>然而，我坐到书桌前，收起了手机，关掉了浏览器，开始做一件我为今天安排的小事，然后，就像魔法一样，我开始工作了。</p><p>这个技巧的真正秘密在于，你必须要在第二天和下一天以及下下一天都去实践它，建立起一个动量并保持它。作家威尔·杜兰特（Will Durant）写道：「We are what we repeatedly do. Excellence, then, is not an act, but a habit.」（我们就是我们重复做的事。然后，优秀就不是一个行为了，而是一个习惯。）</p><p>「非零日」原则是这样的：只要每天做一件能让你朝着你的目标前进的事就行了。就像 Reddit 用户 ryans01 在<a href=\"https://link.zhihu.com/?target=https%3A//www.reddit.com/r/NonZeroDay/comments/1qbxvz/the_gospel_of_uryans01_helpful_advice_for_anyone/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一篇 post</a> 中说的：「Didn’t do anything all fucking day and it’s 11:58 PM? Write one sentence. One push up. Read one page of that chapter. One. Because one is non zero.」（一整天都没有做什么事情吗？写一个句子、做一个俯卧撑、读那一章的一页。只要做一个就好，因为一个总比零个要好。）</p><p>我们可以整日谈论最新的生产力系统，但是这样并不能帮你完成你真正的工作。你必须坐在椅子上并开始做一件小事。</p><hr/><h2>Tips</h2><h3>推荐几个 vscode 插件</h3><p>最近在折腾编辑器，由于 vscode 最近新支持了 .ipynb，这让验证算法结果又简单了一些，于是从 vim 切换到了 vscode，下面推荐几个我的插件：</p><ul><li>Vim：用惯了 vim，第一件事当然是将 vscode 的键位绑定至 vim 中的键位设置了</li><li>Code Runner：一键运行各种脚本（甚至 Java 和 C）</li><li>LeetCode：允许你直接在 vscode 中刷题</li><li>koroFileHeader：一键添加/自动生成文件头部注释和函数注释</li><li>Markdown Preview Enhannced：增强的 MD 文件预览插件，支持数学公式</li><li>Shebang Snippets：自动插入 shebang 代码片段</li></ul><hr/><h2>Share</h2><h3>列表常用方法总结</h3><h3>概念</h3><p>Python：列表（list），其他语言：数组（array）</p><h3>查询（访问）</h3><ul><li>index：返回第一个出现的值的索引</li><li> count：返回值出现的次数<br/> index 和 count 的时间复杂度是 O(n)，与数据规模线性相关<br/> </li></ul><h3>修改</h3><p>通过索引赋值即可</p><h3>增加</h3><ul><li>append：原地修改，加在最后一位</li><li> insert：将值插入指定位置；<b>越界的时候，不会报错，而直接插入到最左或最右</b><br/> append 时间复杂度 O(1)，insert 时间复杂度 O(n)；尽量使用 append<br/> </li><li> extend：原地修改，将可迭代对象添加到列表末尾；相当于在列表末尾对新可迭代对象进行了循环的 append<br/> extend 经常用在两个列表的相加上，但是原地修改，不会增加新的列表<br/> </li><li> list + list：两个列表相加，但是会返回一个新的列表<br/> </li></ul><h3>删除</h3><ul><li>remove：删除第一个值，如果没有，抛出异常；原地修改，无返回值</li><li> pop：不传入参数则默认返回并删除最后一个值，若传入参数 index，则返回并删除 index 所在位置的值；索引不存在抛出异常<br/> remove 不传递 index 参数，O(1)，返回 None；pop 传递 index 参数，O(n)，返回删除的元素<br/> </li><li> clear：清空列表，但列表对象还存在<br/> </li></ul><h3>其他</h3><ol><li>求长度：len(lst)</li><li>反转：reverse</li><li>排序：sort(reverse=False)</li><li>拷贝：</li><ol><li>浅拷贝（影子拷贝）copy：</li></ol></ol><ul><li>copy 过来的列表中，可变对象（如列表、字典、集合等）是引用传递，改变可变对象中的元素也会改变原列表中可变对象的值</li><li>而不可变对象（如元组、字符串、int、float、bool 等）是值传递，改变这些不可变对象不会改变原列表 </li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>深拷贝 from copy import deepcopy：</li><ul><li>改变可变对象中的元素不会影响原列表</li></ul></ul><h3>元组常用方法总结</h3><h3>定义</h3><p>另一种有序列表，与 list 很像，但一旦创建便不可被修改。</p><p>tuple 没有 append、insert 这样的方法。</p><p>可以使用下标去访问元组中的元素，但不能赋值，同样支持负数下标。</p><p>tuple 因为不可变，所以比 list 更安全，如果可能，尽量使用 tuple。</p><h3>元组的陷阱</h3><p>定义元组的时候，如果元组中只有一个元素，那么需要在这个元组之后加上逗号 <code>,</code>，否则会与数学中的小括号产生歧义。</p><h3>「可变」的元组</h3><p>元组中的元素本身是可变的时候，我们还是可以对其进行修改。举例：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]]</span>\n<span class=\"n\">t</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"c1\"># [&#39;a&#39;, &#39;b&#39;, [1, 2, 3]]</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/86675427", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 28 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章  </blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 7. Reverse Integer</li><li>Review: Google Drive: How cloud storage and deep search saved my day -- again and again</li><li>Tip: PyCharm 的数据科学模式</li><li>Share: PyCharm 中设置 pipenv 虚拟环境</li></ul><hr/><h2>Algorithm</h2><p><b>7. Reverse Integer</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/reverse-integer/description/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">7. Reverse Integer</a></p><p>难度：Easy</p><p>题意：Given a 32-bit signed integer, reverse digits of an integer.</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 123\nOutput: 321</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: -123\nOutput: -321</code></pre></div><p>示例 3：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 120\nOutput: 21</code></pre></div><p>说明：</p><p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^31,  2^{31} − 1]$. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p>解法：</p><p>本题解法比较简单，只要使用对 10 取余和反向相加即可，需要注意就是不能超过题目设定的数字范围。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">reverse</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"n\">rev</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n        <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">):</span>\n            <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">%</span> <span class=\"mi\">10</span>\n            <span class=\"n\">rev</span> <span class=\"o\">=</span> <span class=\"n\">rev</span> <span class=\"o\">*</span> <span class=\"mi\">10</span> <span class=\"o\">+</span> <span class=\"n\">tmp</span>\n            <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">//</span> <span class=\"mi\">10</span>\n\n        <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"ow\">and</span> <span class=\"n\">rev</span> <span class=\"o\">&lt;</span> <span class=\"mh\">0x7FFFFFFF</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">rev</span>\n        <span class=\"k\">elif</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span>  <span class=\"ow\">and</span> <span class=\"n\">rev</span> <span class=\"o\">&lt;</span> <span class=\"mh\">0x7FFFFFFF</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">rev</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"mi\">0</span></code></pre></div><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//www.zdnet.com/article/google-drive-how-cloud-storage-and-deep-search-saved-my-day-again-and-again/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Google Drive: How cloud storage and deep search saved my day -- again and again</a></b></p><p>这周分享一篇 <a href=\"https://link.zhihu.com/?target=https%3A//www.zdnet.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ZDNET</a> 上的<a href=\"https://link.zhihu.com/?target=https%3A//www.zdnet.com/article/google-drive-how-cloud-storage-and-deep-search-saved-my-day-again-and-again/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">文章</a>，作者写了一个亲身经历的小故事，讲述了如何使用 Google Drive 和深度搜索简化生活。这类文章展示了云服务带来的种种便利，我也相信，未来云服务与 AI 的结合，会进一步优化用户的体验。</p><hr/><h2>Tips</h2><p><b>PyCharm 的数据科学模式</b></p><p>在 PyCharm 中，如果你是用的是 Professional 版本，那么一旦你使用了 NumPy 或者 Matplotlib 这类科学计算工具包，PyCharm 就会提示你是否要开启数据科学模式。这算是一个小技巧。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-969d2261772ebb09664235c75a88b31d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"370\" data-rawheight=\"68\" class=\"content_image\" width=\"370\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;370&#39; height=&#39;68&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"370\" data-rawheight=\"68\" class=\"content_image lazy\" width=\"370\" data-actualsrc=\"https://pic2.zhimg.com/v2-969d2261772ebb09664235c75a88b31d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>开启数据科学模式之后，你可以使用 Documentation、SciView（Data 和 Plots）以及可以查看 Special Variables。 </p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.jetbrains.com/help/pycharm/matplotlib-tutorial.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PyCharm 对 Scientific mode 的官方介绍</a>。</p><hr/><h2>Share</h2><p><b>PyCharm 中设置 pipenv 虚拟环境</b></p><p>众所周知，PyCharm 是一个非常好的 Python IDE，关于它的好处和优点在此就不再陈述，我们主要讲讲如何在 PyCharm 中使用 pipenv 这一官方钦定的虚拟环境和包管理器。</p><p>首先你需要下载 pipenv，关于这点我就不多介绍了，我主要介绍如何为新的 Python 项目设置 pipenv，以及如何为现有项目设置 pipenv。</p><h3>如何为新的项目设置 pipenv</h3><ol><li>初始化一个 pure python project。</li><li>在 New Project 选项中，点击小三角形展开 Project Interpreter 选项，将 New environment using 设置为「Pipenv」。</li><li>如果你已经将 PATH 设置好了，那么 PyCharm 会自动帮你设置 Base interpreter 和 Pipenv executable。</li><li>点击 OK。</li></ol><h3>如何为现有项目设置 pipenv</h3><ol><li>有下面两种方式打开 Add Python Interpreter：</li><li>如果你在 Editor 中，那么最方便的方式就是在状态栏中点击 Python Interpreter 这个 widget。点击它然后选择 Add Interpreter。</li><li>打开 Settings，点击 Project: ，展开，选择 Project Interpreter，在左边栏选择 Pipenv Environment。</li><li>点击 OK。</li></ol>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85400931", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 27 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章  </blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 58. Length of last world</li><li>Review: Understanding Conda and Pip</li><li>Tip: 关闭 vim 的中文拼写检查</li><li>Share: 清理杂乱的 Python 环境（macOS）</li></ul><hr/><h2>Algorithm</h2><p><b>58. Length of last world</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/length-of-last-word/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">58. Length of last world</a></p><p>难度：Easy</p><p>题意：给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。</p><p>如果不存在最后一个单词，请返回 <code>0</code>。</p><p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p><p>示例：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;Hello World&#34;\nOutput: 5</code></pre></div><p>解法：</p><p>本题思路非常简单，使用两个计数器，<code>count</code> 和 <code>final_count</code>，遍历整个字符串，如果遇到空格，那么将 <code>count</code> 置为 0，否则 <code>count</code> 自增 1，同时 <code>final_count = count</code>，这样可以最后一个字符为空格的时候，也一样可以记住最后一个单词的长度。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">lengthOfLastWord</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"n\">count</span><span class=\"p\">,</span> <span class=\"n\">final_count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">&#39; &#39;</span><span class=\"p\">:</span>\n                <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">final_count</span> <span class=\"o\">=</span><span class=\"n\">count</span>\n        <span class=\"k\">return</span> <span class=\"n\">final_count</span></code></pre></div><hr/><h2>Review</h2><p><b>Understanding Conda and Pip</b></p><p>这周在配置 vim 的 python-mode 插件的时候遇到一个问题，就是 python-mode 并不支持 Conda 的虚拟环境，于是想尝试将 Conda 环境迁移到 virtualenv 中，于是就开始查询迁移方式，偶然间遇到这一篇文章，<a href=\"https://link.zhihu.com/?target=https%3A//www.anaconda.com/understanding-conda-and-pip/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Understanding Conda and Pip</a>，详细讲述了 Conda 和 Pip 的区别和联系。</p><p>文章首先说明，Pip 是 Python Packing Authority (Pypa) 推荐的，从 Python Packages Index (<a href=\"https://link.zhihu.com/?target=https%3A//pypi.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PyPI</a>) 下载标准库的包管理器。Pip 可安装打包为 wheel 或者 source 分发的 Python 软件，而后者可能要求系统在调用 pip 之前已经安装了兼容的编译器，或者库。</p><p>而 Conda 是一个跨平台的软件包河环境管理器，它允许用户在 Anaconda 的存储库或者 Anaconda Cloud 安装和管理 conda 软件包。Conda 将软件包下载为二进制格式，而且它不需要系统提前安装任何编译器。另外，conda 不仅支持 Python 软件包，还包括 C/C++ 库或者 R 软件以及其他的任何软件。</p><p>这就是 Conda 和 Pip 之间的关键区别：即 Pip 安装 Python 软件包，而 Conda 不仅可以用于安装 Python 软件包，还能安装其他语言编写的软件；Pip 需要系统安装有 Python 解释器，而 Conda 不需要，它能直接安装 Python 软件包和 Python 解释器。</p><p>另外一个主要区别是 Conda 可以创建虚拟环境，而 Pip 没有内置虚拟环境支持，而是依赖于 virtualenv 或者 venv 等其他工具来创建虚拟环境。有一些像是 pipenv、poetry 或者 hatch 的工具将 pip 和 virtualenv 打包起来，实现了再虚拟环境中工作的统一方法。</p><p>Pip 和 Conda 在实现环境中的依赖关系也有所不同。Pip 是以递归的串行循环方式来安装依赖项的，它并不会确保所有软件包的依赖关系，所以如果你有某些较早安装的软件包对较晚安装的软件包有不兼容的依赖项版本，你的生产环境有可能会被破坏；而 Conda 则使用「Satisfiability (SAT)」的方式，在安装软件包之前就验证环境中的依赖关系，虽然可能花费额外的时间，但是却能避免环境被破坏。</p><p>最后一个区别是，PyPI 上可用的软件包有接近 150000 个，而 Anaconda 存储库与 Anaconda Cloud 上加起来的软件包也只有 1500 个。所以很多时候，混合使用 conda 和pip 是非常有意义的。</p><p>下面给出一个对比的表格：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fedf9a3d0e6e6fa8baf5daa869750473_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1002\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb\" width=\"1002\" data-original=\"https://pic4.zhimg.com/v2-fedf9a3d0e6e6fa8baf5daa869750473_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1002&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1002\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1002\" data-original=\"https://pic4.zhimg.com/v2-fedf9a3d0e6e6fa8baf5daa869750473_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-fedf9a3d0e6e6fa8baf5daa869750473_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>提供另外几篇讲解虚拟环境的文章：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//ocavue.com/pipenv.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Pipenv：Python 官方钦定的包管理工具</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/32913361\" class=\"internal\">使用pipenv管理你的项目</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//protostar.space/why-you-need-python-environments-and-how-to-manage-them-with-conda\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Why you need Python environments and how to manage them with Conda</a></li></ul><hr/><h2>Tips</h2><p><b>关闭 vim 的中文拼写检查</b></p><p>在 .vimrc 中加入如下一行即可：</p><div class=\"highlight\"><pre><code class=\"language-bash\">autocmd FileType markdown <span class=\"nb\">set</span> spell <span class=\"nv\">spelllang</span><span class=\"o\">=</span>en,cjk <span class=\"s2\">&#34;根据文件类型 md 执行 set spell 和 set spelllang=en 命令</span></code></pre></div><hr/><h2>Share</h2><p><b>清理杂乱的 Python 环境（macOS）</b></p><p>最近因为整理系统环境，发现 Anaconda 已经只吃到了 Python 3.7，而我无论如何也不能通过 <code>$ conda update python</code> 将 Python 升级到 3.7，于是想一探究竟，看看到底发生了什么，结果发现，从拿到手上这台 15 款的 MacBook Pro 开始，我就使用了包括 easy_install、anaconda、source code、homebrew 等在内的各种方式安装过 Python，这就导致我本机的 Python 环境一片混乱，就像下面这样。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-86c257f9f4b345f7da7c6f9326027ebb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb\" width=\"492\" data-original=\"https://pic4.zhimg.com/v2-86c257f9f4b345f7da7c6f9326027ebb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;492&#39; height=&#39;487&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"492\" data-original=\"https://pic4.zhimg.com/v2-86c257f9f4b345f7da7c6f9326027ebb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-86c257f9f4b345f7da7c6f9326027ebb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>为了有一个相对干净、整洁的 Python 环境，我决定将所有的 Python 全部卸载，以后使用虚拟环境来进行工作。</p><ol><li>在一台机器上有很多版本的 Python 这种情况非常常见，为了清理所有的 Python，需要执行以下几个步骤： 1. 在 macOS 上，系统自带的 Python 版本是 2.7，可执行的二进制文件位于 <code>/usr/bin/</code> 中（实际上是在 <code>/System/Library/Frameworks/Python.framework/Versions/2.7/bin/</code> 中，但实际上是一回事，如果你执行 <code>$ ls -l | grep python</code>，你就会看到，前者是后者的一个软链接）。如果你想要一个完全干净的 Python 环境，你需要将除了这个之外的所有的 Python 都删除干净。</li><li>那么接下来就需要确定你有多少个 Python 了。执行 <code>$ which -a python</code>，你会看到像下面类似的信息：</li></ol><div class=\"highlight\"><pre><code class=\"language-bash\">/Users/****/anaconda3/bin/python <span class=\"c1\"># &lt;- Anaconda</span>\n/usr/local/bin/python            <span class=\"c1\"># &lt;- brew</span>\n/usr/local/bin/python            <span class=\"c1\"># &lt;- brew</span>\n/usr/local/bin/python            <span class=\"c1\"># &lt;- brew</span>\n/usr/local/bin/python            <span class=\"c1\"># &lt;- brew</span>\n/usr/bin/python                  <span class=\"c1\"># &lt;- &#34;native&#34;</span>\n~/anaconda3/bin/python3          <span class=\"c1\"># &lt;- Anaconda</span>\n/Library/Frameworks/Python.framework/Versions/3.5/bin/python3 <span class=\"c1\"># &lt;- python3 for OSX</span>\n/usr/local/bin/python3           <span class=\"c1\"># &lt;- python3 for OSX</span></code></pre></div><p>这就是你的电脑上所有的 Python 版本，你可以挨个查看这些 Python 的位置和版本。</p><p>3. 首先你需要删除 anaconda，根据 <a href=\"https://link.zhihu.com/?target=https%3A//docs.anaconda.com/anaconda/install/uninstall/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Uninstalling Anaconda</a> 来进行相应的卸载：</p><div class=\"highlight\"><pre><code class=\"language-text\">conda install anaconda-clean\nanaconda-clean  </code></pre></div><p>之后按照说明，删除 <code>.bash_profile</code> 或者 <code>.zprofile</code> 中对环境变量进行修改的语句。</p><p>4. 删除 <code>/Library/Frameworks/Python.framework/</code> 中所有的内容：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo rm -rf /Library/Frameworks/Python.framework/ </code></pre></div><p>5. 删除 /Applications/Python*/ 中的所有内容，这里是你手动安装过的 Python：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo rm -rf /Applications/Python*</code></pre></div><p>6. 将 /usr/local/bin/ 中所有关于 Python 的软链接全部删除：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo rm /usr/local/bin/python*</code></pre></div><p>7. 将通过 <code>pip</code> 安装的所有 Python 库全部删除：</p><div class=\"highlight\"><pre><code class=\"language-text\">rm -rf ~/Library/Python/</code></pre></div><p>8. 删除使用 Homebrew  安装的 Python 和其他组件，因为这可能会损害其他的通过 Homebrew 安装的软件，所以正确的方式是通过 Homebrew 本身来删除：</p><div class=\"highlight\"><pre><code class=\"language-text\">brew unintsall python </code></pre></div><p>好了，现在你已经有一个干净的 Python 环境了，因为你只有系统自带的 Python 2.7。现在你可以按照自己的喜好去选择一个虚拟环境了，但是我个人（以及 Python 官方）建议使用 Pipenv。你可以在这里找到 <a href=\"https://link.zhihu.com/?target=https%3A//pipenv.readthedocs.io/en/latest/install/%23installing-pipenv\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Pipenv 的安装教程</a>。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84765199", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 26 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 344. Reverse String</li><li>Review: Journalology: Lambert Academic Publishing (or How Not to Publish Your Thesis)</li><li>Tip: 分享一个 LaTeX 公式在线编辑器 </li><li>Share: 分享一本在读的书</li></ul><hr/><h2>Algorithm</h2><p><b>344. Reverse String</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/reverse-string/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">344. Reverse String</a></p><p>难度：Easy</p><p>题意：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 <a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/ASCII%23Printable_characters\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ASCII 码表中的可打印字符</a>。</p><p>示例一：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [&#34;h&#34;,&#34;e&#34;,&#34;l&#34;,&#34;l&#34;,&#34;o&#34;]\nOutput: [&#34;o&#34;,&#34;l&#34;,&#34;l&#34;,&#34;e&#34;,&#34;h&#34;]</code></pre></div><p>示例二：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [&#34;H&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;h&#34;]\nOutput: [&#34;h&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;H&#34;]</code></pre></div><p>解法：</p><p>本题的解法相对非常简单，因为需要使用 O(1) 时间复杂度，并且原地进行更改，那么我们的思路其实相对非常简单，就是直接将列表最后一个元素和第一个元素进行置换，直到到达对称轴处。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">reverseString</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        Do not return anything, modify s in-place instead.\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n\n        <span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"o\">//</span><span class=\"mi\">2</span><span class=\"p\">):</span>\n            <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n            <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n            <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><p>另外有一种非常 Pythonic 的解法：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">reverseString</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        Do not return anything, modify s in-place instead.\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">s</span><span class=\"p\">[:]</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span></code></pre></div><p>需要注意的是，这个方法因为使用了 <code>list[:]</code> 这种形式，实际上是对 <code>list</code> 进行了一个浅拷贝，使用了额外的存储空间，不是一个合规的答案。</p><hr/><h2>Review</h2><p><b>Journalology: Lambert Academic Publishing (or How Not to Publish Your Thesis)</b></p><p>周五下午，我正在准备周一给导师们的汇报的时候，突然收到一封邮件，名为《Publishing Offer to **** （此处为我的名字）》，我好奇的点开这封邮件，是由一个名为 Lambert Academic Publishing 的公司的员工发来的，大意是他们对我的《Automatic extraction of embossed friezes on ceramic sherds by Deep Learning》这篇研究感兴趣，一个名为 Omniscriptum 的出版商有兴趣将其发表，问我能否将我的手稿发送给他们以便审核。</p><p>那么问题来了：</p><p>1. 我的这篇研究只是学校的一个学生项目，从技术深度和科研角度来看根本没有任何发表的价值。</p><p>2. 他们又是如何知道我有这篇研究的呢？事实上，我对这个《Automatic extraction of embossed friezes on ceramic sherds by Deep Learning》一点都不熟悉，还是去谷歌了一番才知道被发表在学校的项目手册上，而这个组织也并没有告诉我他们是如何知道我这个研究的。</p><p>3. 这封邮件的开头，在「Dear」和「我的名字」之间，有两个「空格」，而一般来说，英文邮件的称谓部分，「Dear」和名字之间只需要有一个空格。</p><p>综上三点，我判断出这个所谓的 Lambert Academic Publishing 的组织，无非是个利用爬虫技术获取初入科研圈子的年轻人的研究经历，并提供并不专业的咨询和发表机会，以某些手段来谋取利益的半吊子的学术组织。</p><p>为了印证我的猜测，一番谷歌之后，在 Quora 和 Reddit 上都有不少针对 Lambert Academic Publishing（以下简称 LAP）的指控，在这些指控和证据中间，我找到一篇名为 <a href=\"https://link.zhihu.com/?target=https%3A//journalology.blogspot.com/2012/09/lambert-academic-publishing-or-how-not.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Journalology: Lambert Academic Publishing (or How Not to Publish Your Thesis)</a> 的文章。</p><p>这篇文章从 Facebook 等社交账号的细节中推测出 LAP 的骗人把戏：第一编辑的照片实际上是从 Fotostock 上下载的，第二编辑的照片是从 istock 上下载的，其他几个编辑的照片也一样是从一下开源或商业图片库中找来的。</p><p>另外，LAP 还有一些其他的常见欺骗行为，如：</p><ul><li>他们通过暴力地给刚刚发表过一些文章的学生发邮件这种方式来寻找作者  他们没有选择性，所有提交过的手稿都会被发布</li><li>他们没有同行评审</li><li>他们并不编辑「书籍」，手稿原样发表，甚至不经过一点修改，很明显，在手稿被提交之后，他们向作者收取修改的费用</li><li>作者不会收到任何版税  他们并不对发表的书本做任何市场营销</li><li>很多的研究评定并不把他们的书籍作为严谨的科学参考</li></ul><p>作者还举了不少例子，感兴趣的读者可以点击链接进一步阅读。</p><hr/><h2>Tips</h2><p><b>分享一个 LaTeX 公式在线编辑器</b></p><a href=\"https://link.zhihu.com/?target=https%3A//www.codecogs.com/latex/eqneditor.php%3Flang%3Dzh-cn\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LaTeX 公式在线编辑器</a><hr/><h2>Share</h2><p><b>分享一本在读的书</b></p><p>这周在读德国学者迪特里希•施万尼茨的《欧洲：一堂丰富的人文课》。</p><p>迪特里希•施万尼茨的这本书，从历史、文学、艺术和音乐等方面，讲述了现代青年应该了解的众多人文知识。</p><p>历史方面，作者尽量简要而不简单地讲述了欧洲从众神的迷乱开始，到《伊利亚特》与《奥德赛》，再到特洛伊木马与拉奥孔、圣经、出埃及记、希腊雅典的艺术、三大哲学巨擘苏格拉底、柏拉图和亚里士多德，再到罗马历史和基督教、浩浩荡荡的一千年中世纪，再讲到文艺复兴以及宗教改革，之后再到启蒙运动和法国大革命、拿破仑的陨落和三月革命，两次世界大战一直到现代社会。可以说，这本书帮助我理清了整个欧洲历史的脉络，能够与中国的唐宋元明清朝代做一个对应。</p><p>文学方面，作者介绍了几种基本的文学类型和创作形式，并对重要的欧洲文学作品均作了简要解读。艺术方面，作者介绍了罗曼与哥特艺术、巴洛克、洛可可、古典与浪漫主义、印象主义和委拉斯凯兹。作者还对音乐史和性别讨论史略作介绍。另外，作者对近现代的大哲学家、思想家以及理论和科学的世界观也有所讲述。</p><p>第二部分的能力篇，作者对语言和文学创作、如何选书读书、各国风俗等方面也有不少篇幅的介绍，非常值得一读。</p><p>这本书的语言非常诙谐，在我印象里德国人应该是非常严谨的才对，结果却能在书中看到不少诸如「钱本身是没有生殖能力的，当犹太人通过利息使钱变多，他们表现得就像是巫师，与钱交欢生下“小钱”」、「从焚毁书籍到焚毁民众只有一步之遥」之类的句子的时候，总能让人莞尔一笑。</p><p>分享几页书摘：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f8665c92276f2f20d35cea7c7fc4633c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1440\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-f8665c92276f2f20d35cea7c7fc4633c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;1440&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1440\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-f8665c92276f2f20d35cea7c7fc4633c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f8665c92276f2f20d35cea7c7fc4633c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-91aaa827fedd679d847cc110814a6120_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"1377\" class=\"origin_image zh-lightbox-thumb\" width=\"775\" data-original=\"https://pic1.zhimg.com/v2-91aaa827fedd679d847cc110814a6120_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;775&#39; height=&#39;1377&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"1377\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"775\" data-original=\"https://pic1.zhimg.com/v2-91aaa827fedd679d847cc110814a6120_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-91aaa827fedd679d847cc110814a6120_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-74a78afaa6c1a59bd3141aa0e83e566e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1440\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb\" width=\"1440\" data-original=\"https://pic3.zhimg.com/v2-74a78afaa6c1a59bd3141aa0e83e566e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1440&#39; height=&#39;1080&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1440\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1440\" data-original=\"https://pic3.zhimg.com/v2-74a78afaa6c1a59bd3141aa0e83e566e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-74a78afaa6c1a59bd3141aa0e83e566e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9c963b71b99a18f5cb9d6e5d3147743c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1395\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb\" width=\"1395\" data-original=\"https://pic1.zhimg.com/v2-9c963b71b99a18f5cb9d6e5d3147743c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1395&#39; height=&#39;1080&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1395\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1395\" data-original=\"https://pic1.zhimg.com/v2-9c963b71b99a18f5cb9d6e5d3147743c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9c963b71b99a18f5cb9d6e5d3147743c_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83634136", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 25 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 14. Longest Common Prefix</li><li>Review: 5G and the New Foundation of the Internet</li><li>Tip: vim 中的文件管理插件 NERDTree</li><li>Share: 聊聊最近看的一本书和一部科幻小说改编的电影</li></ul><hr/><h2>Algorithm</h2><p><b>14. Longest Common Prefix</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/longest-common-prefix/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">14. Longest Common Prefix</a></p><p>难度：Easy</p><p>题意：</p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&#34;&#34;</code>。</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [&#34;flower&#34;,&#34;flow&#34;,&#34;flight&#34;]\nOutput: &#34;fl&#34;</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [&#34;dog&#34;,&#34;racecar&#34;,&#34;car&#34;]\nOutput: &#34;&#34;\nExplanation: There is no common prefix among the input strings.</code></pre></div><p>说明：</p><p>所有输入只包含小写字母 a-z 。</p><p>解法：</p><p>本题的解题思路比较直接，首先判断是否为空集，如果是空集，那么直接返回 <code>&#34;&#34;</code>。接下来选取第一个字符串作为参照字符串，其他字符串作为对比字符串，从第二个字符串开始，遍历每一个位置上的字母，如果出现索引位置超出对比字符串的长度，或者出现字母不相同的情况，那么说明之前比较过的位置上的字母都相同，则可以返回参照字符串的前 i 位。如果直到遍历结束也没有出现上述两种状况，说明字符串集合中所有字符串都一样，直接返回第一个字符串即可。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">longestCommonPrefix</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">strs</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">str</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">strs</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"s2\">&#34;&#34;</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">strs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])):</span>    \n            <span class=\"k\">for</span> <span class=\"n\">each</span> <span class=\"ow\">in</span> <span class=\"n\">strs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]:</span>\n                <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">each</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"n\">each</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">strs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">i</span><span class=\"p\">]:</span>\n                    <span class=\"k\">return</span> <span class=\"n\">strs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][:</span><span class=\"n\">i</span><span class=\"p\">]</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">strs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。n 为字符串的个数。</p><p>在查看参考答案的过程中，有一个解法十分巧妙，它利用了 <code>zip()</code> 函数的特性和 python 中列表的乘法，将其解法分享给大家：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">longestCommonPrefix</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">strs</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type strs: List[str]\n</span><span class=\"s2\">        :rtype: str\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">lcp</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;&#34;</span>\n        <span class=\"k\">for</span> <span class=\"n\">s</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">strs</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],)</span> <span class=\"o\">*</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">s</span><span class=\"p\">:</span>\n                <span class=\"n\">lcp</span> <span class=\"o\">+=</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"k\">break</span>\n        <span class=\"k\">return</span> <span class=\"n\">lcp</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b>5G and the New Foundation of the Internet</b></p><p>本周阅读了一篇由 DailyIO 推荐的文章 <i><a href=\"https://link.zhihu.com/?target=https%3A//techpinions.com/5g-and-the-new-foundation-of-the-internet/58413\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">5G and the New Foundation of the Internet</a></i>，从「新型互联网」和「5G 会给互联网带来哪些变化」两个角度讲述了 5G 和互联网的新格局。</p><p>文章首先从作者对「苹果今年的新机 iPhone 11 系列不支持 5G」的看法引入，作者表示，即便是在中国，5G 网络仍然没有为苹果这家公司可能发布的大量 5G 设备做好准备，而苹果选择不在今年发布支持 5G 的手机是一个明智之举。</p><p>接下来作者谈到了 5G 和新型互联网之间的关系。5G 会让我们的智能手机更快，让我们享受到更高质量的视频和更低延迟的游戏体验，总体上让我们能更快地上网。但 5G 不仅仅是解决了当前无线网络的带宽问题，5G 是为更大的物联网设计的。这也是为什么作者认为 5G 是未来互联网的基础设施。</p><p>文章在接下来使用最多的篇幅描述了「5G 会给互联网带来哪些变化」，下面是作者的一些非常有趣且很真实的观点：</p><ul><li>低延时让 Mission-Critical Applications 成为可能</li><li>高吞吐量和低功耗</li><li>真正的边缘计算</li><li>动态网络切片</li></ul><p>本文长句比较多，但内容翔实有趣，非常客观理性地分析了 5G 与未来互联网的新格局。作者的很多观点与吴军老师在得到 App 课程《前沿科技之吴军讲 5G》中的很多观点不谋而合，比如「5G 是否是伪需求」、「5G 的优势」和「5G 对未来互联网的影响」等等。此外，吴军老师的课程中涉及了更多的技术细节和商业上的分析，在此也一并推荐给大家。</p><hr/><h2>Tips</h2><p><b>vim 中的文件管理插件 NERDTree</b></p><p>vim 中由于没有默认的文件管理系统，所以在文件之间跳转经常会比较麻烦。这里推荐一个 vim 中的文件管理插件 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/scrooloose/nerdtree\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NERDTree</a>。</p><p>使用 vim 插件管理器安装 NERDTree 之后就可以使用了，将下面一行写入 vimrc 中，即可通过按 F2 来打开文件管理目录：</p><div class=\"highlight\"><pre><code class=\"language-bash\">nnoremap &lt;silent&gt; &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</code></pre></div><p>使用 jk 来进行文件（夹）之间的切换，使用 o 或回车来打开文件或文件夹，使用 <code>&lt;C-w&gt;-hjkl</code> 来在窗口之间切换。</p><hr/><h2>Share</h2><p><b>聊聊最近看的一本书和一部科幻小说改编的电影</b></p><h3>书</h3><p>最近又看了一遍林达的《带一本书去巴黎》，依旧最喜欢其中的《安布瓦斯的古堡》。</p><p>书中有大量的历史场景和历史细节，作者尤其着墨于法国大革命，用这些场景和细节讲述了他们自己对于文学、历史、政治、艺术、文化、建筑、美学和社会的理解，也探寻了自由、民主、人性这些代表理性的东西是如何在与非理性之间的冲突中成为人类共有的现代理念的。也是从这本书里，我才渐渐意识到，现在看起来平和甚至有点儿“圣母”的欧洲，他们的历史也一样沉重和血腥。</p><p>但是重要的，是现代的人们如何去看待当年的事。我去过当年路易十六和安托瓦内特王后被砍头的协和广场，巴黎人或匆忙路过或安详踱步，明亮的阳光照射在方尖碑上，广场上空的鸽子成群结队地飞着，这一切也让人产生一些错觉，仿佛断头台从未存在过。</p><h3>电影</h3><p>周一的时候和实验室的墨西哥小哥 Antonio 讨论到思考时使用的语言对思路清晰程度的影响，我表示每当使用中文和英语/法语去思考某件事的时候，总感觉使用中文会纠结不清，但使用英语或者法语思考事情的时候，思路却比较容易变得清晰起来，小哥表示他也有类似的体验，但西语的熵并没有比法语大很多，甚至比英语还要小，所以这种对比并不强烈。当晚碰巧看了一部电影《降临》，本片改编自美籍华裔科幻作家 Ted Jiang（姜峯楠）的小说《你一生的故事》，小说篇幅不长，属于中篇小说，Ted Jiang 凭借这部作品获得了 2000 年的星云奖最佳中篇小说奖（星云奖相当于科幻界的诺贝尔文学奖）。</p><p>故事的梗概是，外星人七肢桶突然到访地球，作为语言学家的女主受命去与七肢桶沟通，终于掌握了外星人的语言，女主从此不仅能够清晰地看透自己的过去和现在，还能够预测未来。故事的这个设定基于 Sapir-Whorf 假说，也即 <i>语言相对论</i>：</p><blockquote>语言相对性原理（萨丕尔-沃夫假说）认为，不同语言里所包含的文化概念和分类会影响语言使用者对于现实世界的认知，也就是说不同的语言的使用者会因语言差异而产生思考方式，行为方式的不同。这个“语言结构影响语者认知结构”的说法涉及到人类语言学、心理学、语言心理学、神经语言学、认知科学、语言人类学、语言社会学、语言哲学等多个领域，并在这些领域中被广泛学习。<br/>语言决定论认为语言决定思考模式。<br/>不同语系的语言看待世界的方式都不一样，也就呈现了各种语言彼此间的相对性，所以任何民族的语言都与其文化和生活环境的需要而成长和改变。</blockquote><p>这就与今天和小哥的聊天内容不谋而合了。</p><p>这本书还有另外一个让我思考的点。在故事的结尾，女主预见了一个会背叛自己的男人和一个注定会死去的女儿，即便如此，几年之后当男主向她求婚，女主还是选择了接受。「她像每个恋爱中的女孩一样，微笑着接受了对方，去开始一段注定会分离的感情，去孕育一个早逝的生命，去落实一系列不可逃避的悲剧命运。」这让结尾看起来像是一个悲剧。</p><p>历史上有名的哲学家，几乎没有不被「决定论」和「意志自由论」困扰的，就像叔本华就认为「人是受到因果支配的，人是不自由的」。历史故事中也有诸如宙斯弑父和俄狄浦斯杀父娶母的故事。Ted Jiang 在这本书中针对这个问题给出了自己的答案：如果你已经知道自己的无法改变的命运，你是否仅仅是一个傀儡呢？还有没有必要再去经历一遍这样的命运呢？作者的答案是：是的，有必要，因为仅仅是「预知」，不能代表「经历」，就像婚礼上每个人都知道会有那句「我宣布你们二人结为夫妻」，但这仅仅只是「预知」，只有在主持人宣布这句话的时候，它才会成为一个「经历」或者「事实」。</p><p>爱情是这样，明知会失去，会受伤，但是还是义无反顾地去爱了，也许会后悔，也许就像阿信唱的会「欠了她一生的一句抱歉」；生活大抵也是这样，不然何来「欲渡黄河冰塞川，将登太行雪满山」，何来「莫听穿林打叶声，何妨吟啸且徐行」，何来「更喜岷山千里雪，三军过后尽开颜」？</p><p>在这部电影或者这本书里，作者想告诉我们的是，未来就像一个车轮，会不可抗拒的向我们碾压过来，无论是喜是悲，我们都应该积极地去面对，去拥抱生活，这样，人才能从决定论的束缚中获得意志的自由。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": [
                {
                    "userName": "自負的演員", 
                    "userLink": "https://www.zhihu.com/people/ffc18949bc15d903dd9481b22bf8583e", 
                    "content": "写的很详细，收益匪浅，虽然有些小地方我还是不懂，我再慢慢揣摩", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "什么鬼……水经验的吗？[小情绪]", 
                            "likes": 0, 
                            "replyToAuthor": "自負的演員"
                        }, 
                        {
                            "userName": "自負的演員", 
                            "userLink": "https://www.zhihu.com/people/ffc18949bc15d903dd9481b22bf8583e", 
                            "content": "假装路人支持一下嘛", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82528919", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 24 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 283. Move Zeroes</li><li>Review: What does it take to be an expert at Python</li><li>Tip: 一个 vim 配色神器</li><li>Share: Vim 中的「宏」（Macro）</li></ul><hr/><h2>Algorithm</h2><p><b>283. Move Zeroes</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/move-zeroes/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">283. Move Zeroes</a></p><p>难度：Easy</p><p>题意：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例：</p><div class=\"highlight\"><pre><code class=\"language-bash\">Input: <span class=\"o\">[</span><span class=\"m\">0</span>,1,0,3,12<span class=\"o\">]</span>\nOutput: <span class=\"o\">[</span><span class=\"m\">1</span>,3,12,0,0<span class=\"o\">]</span></code></pre></div><p>说明： 1. 必须在原数组上操作，不能拷贝额外的数组。 2. 尽量减少操作次数。</p><p>解法：</p><p>本题的思路非常的直接，但也很巧妙。大体上是，使用两个指针，其中一个 i 指针遍历整个数组，碰到一个不是 0 的元素就将它赋予当前的 pos 指针，然后 pos 指针加一，当遍历完成之后，整个数组的前 pos 位就自然而然的是相对位置没有变化的元素了，再将数组的第 pos 位到最后全部置为 0 即可。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">moveZeroes</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        Do not return anything, modify nums in-place instead.\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">pos</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]:</span>\n                <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">pos</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n                <span class=\"n\">pos</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n            <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></code></pre></div><hr/><h2>Review</h2><p><b>What does it take to be an expert at Python</b></p><p>这周 review 的不是文章，是 YouTube 上 PyData 的一个<a href=\"https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DcKPlPJyQrt4\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">视频</a>，这个视频是 James Powell 在 2017 年 PyData Seattle 的 talk，讲述了他对如何成为 Python 高手的理解。视频比较长，有网友根据视频内容做了一个配套的 notebook，放到了<a href=\"https://link.zhihu.com/?target=https%3A//github.com/austin-taylor/code-vault/blob/master/python_expert_notebook.ipynb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个 github 页面</a>上。</p><p>James Powell 大致讲述了以下几个方面，以及如何使用这些 Python 的特性来方便日常的生活。</p><ul><li>Python 的定义</li><li>元类（metaclass）及其解释</li><li>装饰器</li><li>生成器</li><li>上下文管理器</li></ul><p>虽然 James Powell 的语速比较快，但是吐字清晰，配上现场敲出的代码，听明白他的意思并不难，但真正理解并应用他所说的，还有不少功课要做。建议反复观看，仔细理解。</p><p>B 站链接：<a href=\"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av23614888%3Ffrom%3Dsearch%26seid%3D14157061807513830142\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这里</a>。</p><hr/><h2>Tips</h2><p><b>一个 vim 配色神器</b></p><p>发现一个 all-in-one 的 vim 配色神器：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/flazz/vim-colorschemes\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/flazz/vim-co</span><span class=\"invisible\">lorschemes</span><span class=\"ellipsis\"></span></a>。</p><p>使用 <code>:colorscheme {colorschemename}</code> 可以改变当前配色，若需要永久使用指定配色需要将其写入 vimrc 中。</p><hr/><h2>Share</h2><p><b>Vim 中的「宏」（Macro）</b></p><p>不知道有没有人和我一样，第一眼看到「宏」这个词，就想起来小时候玩 Word 或者 Excel 的时候时不时蹦出来的「没有这个宏」之类的提示。。。</p><p>下面我们来说说 vim 中的「宏」。首先我们从一个问题入手。工作当中一个很典型的场景是，现在我们写了一个爬虫，将一堆网页的 url 爬取下来了，但是发现之后在使用这些 url 的时候，需要两边添加引号 <code>&#39;</code>。就比如下面这种，你会怎么做呢？</p><div class=\"highlight\"><pre><code class=\"language-django\"><span class=\"x\">https://www.zhihu.com/question/332265335\n</span><span class=\"x\">https://www.zhihu.com/question/23392154\n</span><span class=\"x\">https://www.zhihu.com/question/345698784\n</span><span class=\"x\">https://www.zhihu.com/question/292450646\n</span><span class=\"x\">https://www.zhihu.com/question/20058733\n</span><span class=\"x\">https://www.zhihu.com/question/36671668</span></code></pre></div><p>有的人可能会说，就这么点儿，我就手动加就行了。这种方式在行数比较少的时候绝对可行，但是经常我们需要处理上百行几千行的数据，这时候手动添加绝对是笨办法。</p><p>还有人可能会说，我写个脚本，读取每一行处理完之后再写回原文件也可以。实际上这样做是可行的，而且很多时候我们也会倾向使用这种方式。但在我们现在这种情况下，vim 提供了一个更为简便的处理方式，就是「宏」。</p><p>Vim 中所谓的「宏」，就是一系列操作的集合，可以将这些特定的操作记录下来，然后应用到其他文本处理中去。使用「宏」的方式如下：</p><ul><li>使用 <code>q</code> 开始录制宏，再按一次 <code>q</code> 结束录制  录制宏的时候需要将宏保存到指定的寄存器中，使用 <code>q{register}</code> 来指定寄存器</li><li>使用 <code>@{register}</code> 来回放指定寄存器中的宏</li></ul><p>比如针对上面的情况，我们可以首先按下 <code>q</code> 开始录制宏，再按下 <code>a</code> 表示将这个宏保存到名为 a 的寄存器中。再针对第一行，按下 <code>I</code>（大写 i）表示在本行最前端插入，再按 <code>&#39;</code> 插入引号，之后按 <code>Esc</code> 回到 normal 模式，按下 <code>A</code>（大写 a）表示在本行末尾插入，再按 <code>&#39;</code> 插入引号，之后按 <code>Esc</code> 回到 normal 模式。这样我们就完成了宏的录制。</p><p>之后我们使用 <code>V</code>（大写的 v）选中需要更改的行，按下冒号 <code>:</code> 进入命令模式，这时候 vim 会默认有 <code>&#39;&lt;&#39;&gt;</code> 这样的命令，不用管它，在其之后输入 <code>normal</code> 表示我们这个宏是在 normal 模式下运行，再接着输入 <code>@a</code> 表示回放放在名称为 a 寄存器中的宏。这样我们就完成了宏的回放。所有 url 的两端也被添加上了引号。就像下面这样。</p><a class=\"video-box\" href=\"https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1156415341482713088\" target=\"_blank\" data-video-id=\"\" data-video-playable=\"true\" data-name=\"\" data-poster=\"https://pic3.zhimg.com/v2-4770de63f92e72f806cb15cd0d85b202.jpg\" data-lens-id=\"1156415341482713088\"><img class=\"thumbnail\" src=\"https://pic3.zhimg.com/v2-4770de63f92e72f806cb15cd0d85b202.jpg\"/><span class=\"content\"><span class=\"title\"><span class=\"z-ico-extern-gray\"></span><span class=\"z-ico-extern-blue\"></span></span><span class=\"url\"><span class=\"z-ico-video\"></span>https://www.zhihu.com/video/1156415341482713088</span></span></a><p></p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82047698", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 23 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 88. Merge Sorted Array</li><li>Review: Math in Data Science, Great Developers Never Stop Learning</li><li>Tip: Vim 剪贴板错误缩进的解决办法</li><li>Share: 同步 Vim 与系统剪贴板，同时解决 Vim 没有 clipboard 编译选项的问题</li></ul><hr/><h2>Algorithm</h2><p><b>88. Merge Sorted Array</b></p><p>题目：88. Merge Sorted Array</p><p>难度：Easy</p><p>题意：给定两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，将 <code>nums2</code> 合并到 <code>nums1</code> 中，使得 <code>num1</code> 成为一个有序数组。</p><p>说明：初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code>。 你可以假设 <code>nums1</code> 有足够的空间（空间大小大于或等于 <code>m + n</code>）来保存 <code>nums2</code> 中的元素。</p><p>示例：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"n\">Input</span><span class=\"p\">:</span>\n<span class=\"n\">nums1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n<span class=\"n\">nums2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">],</span>       <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"n\">Output</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">]</span></code></pre></div><p>要求：原地更改 <code>nums1</code>。</p><p>解法：</p><p>这一题由于有「<code>nums1</code> 和 <code>nums2</code> 都是有序的」这一前提，题目就变得比较简单。要求是将 <code>nums2</code> 插入到 <code>nums1</code> 中，我们就直接对 <code>nums1</code> 进行更改。</p><p>我们的思路非常直接，从后往前将 <code>nums2</code> 插入到 <code>nums1</code> 中，挨个比较 <code>nums1[m-1]</code> 和 <code>nums2[n-1]</code> 的元素的大小，如果前者比较大，那么将前者覆盖到 <code>nums1[m+n-1]</code> 的位置，然后 <code>m</code> 自减 1，否则将后者覆盖到 <code>nums1[m+n-1]</code> 的位置，然后 <code>n</code> 自减 1。这样循环到最后，自然就将 <code>nums2</code> 插入到 <code>nums1</code> 中去了。最后，考虑到有可能 <code>nums1</code> 遍历完毕之后，<code>nums2</code> 还没有遍历完，这样的情况下，<code>nums2</code> 中剩下的元素就是两个数组中最小的那几个，由于 <code>nums1</code> 中的所有数字都已经归位，这时候只要将 <code>nums1</code> 中前 <code>n</code> 个数字赋值为 <code>nums2</code> 中剩下的元素即可。另外，如果 <code>nums2</code> 已经遍历完成，<code>n = 0</code>， 那么之前说的替换操作其实也不会执行，这样就可以省去一个「判断 <code>nums2</code> 是否遍历完成」的过程。代码如下</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">merge</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums1</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">m</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">nums2</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        Do not return anything, modify nums1 in-place instead.\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"k\">while</span> <span class=\"n\">m</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"ow\">and</span> <span class=\"n\">n</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">nums1</span><span class=\"p\">[</span><span class=\"n\">m</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">nums2</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]:</span>\n                <span class=\"n\">nums1</span><span class=\"p\">[</span><span class=\"n\">m</span><span class=\"o\">+</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums1</span><span class=\"p\">[</span><span class=\"n\">m</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n                <span class=\"n\">m</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">nums1</span><span class=\"p\">[</span><span class=\"n\">m</span><span class=\"o\">+</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums2</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n                <span class=\"n\">n</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n        <span class=\"n\">nums1</span><span class=\"p\">[:</span><span class=\"n\">n</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums2</span><span class=\"p\">[:</span><span class=\"n\">n</span><span class=\"p\">]</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b>Math in Data Science, Great Developers Never Stop Learning</b></p><p>本周和大家分享两篇文章。</p><p>第一篇文章是 Dataquest 上的一篇文章，名为 <a href=\"https://link.zhihu.com/?target=https%3A//www.dataquest.io/blog/math-in-data-science/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Math in Data Science</a>，文章讲解了数据科学几大类常用算法的数学基础，包括：朴素贝叶斯、线性回归、逻辑回归、神经网络、K-Means 聚类和决策树。</p><p>文章语言比较简单，涵盖面也已经比较广，可以作为入门读物。</p><p>第二篇是 Towards Data Science 上的一篇名为 <a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/great-developers-never-stop-learning-77b9ce867eac\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Great Developers Never Stop Learning</a> 的文章。顾名思义，文章标题意为「伟大的开发者从不停止学习」，那么伟大的开发者都是如何学习的呢？作者给出了自己的方法。</p><ol><li>阅读的艺术：书、博客、Twitter</li><li>从狂热的阅读者变为狂热的写作者：To teach is ti learn twice.</li><li>听播客：<a href=\"https://link.zhihu.com/?target=https%3A//herdingcode.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Herding Code</a>, <a href=\"https://link.zhihu.com/?target=https%3A//www.dotnetrocks.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">.NET Rocks!</a>, <a href=\"https://link.zhihu.com/?target=https%3A//www.hanselminutes.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hanselminutes</a>, <a href=\"https://link.zhihu.com/?target=https%3A//www.se-radio.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Software Engineering Radio</a>, <a href=\"https://link.zhihu.com/?target=https%3A//www.codingblocks.net/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Coding Blocks</a>, <a href=\"https://link.zhihu.com/?target=https%3A//twit.tv/shows/this-week-in-tech\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">This Week in Tech</a>, <a href=\"https://link.zhihu.com/?target=https%3A//spec.fm/podcasts/developer-tea\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Developer Tea</a>, <a href=\"https://link.zhihu.com/?target=https%3A//softwareengineeringdaily.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Software Engineering Daily</a>.</li><li>学习在线课程</li><li>熟能生巧：写 prototype 验证想法、小项目、为开源社区做贡献、在线社区、Katas、黑客马拉松活动</li><li>接触同侪：结对编程、code review</li><li>社交活动：参加业界活动、领英、加入职业组织以及本地用户群，甚至建立你自己的人脉网络</li></ol><hr/><h2>Tips</h2><p><b>Vim 剪贴板错误缩进的解决办法</b></p><p>在使用 vim 编辑代码的时候，我们经常会遇到这样一个问题：从别处复制来的代码，粘贴到 vim 中之后，代码的缩进就全乱了，像这样：</p><p>复制前：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">def</span> <span class=\"nf\">findmax</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">):</span>\n\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"mi\">0</span>\n\n    <span class=\"n\">curr_max</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"n\">curr_max</span><span class=\"p\">:</span>\n            <span class=\"n\">curr_max</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">curr_max</span></code></pre></div><p>粘贴后：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0524eef597391deac4cf5b086d1a0c08_b.jpg\" data-rawwidth=\"1064\" data-rawheight=\"464\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"1064\" data-original=\"https://pic1.zhimg.com/v2-0524eef597391deac4cf5b086d1a0c08_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1064&#39; height=&#39;464&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1064\" data-rawheight=\"464\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1064\" data-original=\"https://pic1.zhimg.com/v2-0524eef597391deac4cf5b086d1a0c08_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0524eef597391deac4cf5b086d1a0c08_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这种现象一是特别难看，二是针对 Python 这种对缩进敏感的语言是个大坑，因为 Python 使用缩进来区分代码块。</p><p>出现这种现象的原因是，很多人在 .vimrc 中都设置了自动缩进的功能，这时候我们需要使用 <code>:set paste</code> 和 <code>:set nopaste</code> 来解决。</p><p>在粘贴代码之前使用 <code>:set paste</code> 来设置粘贴模式，效果如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-69d664cc1f8e889451b2a6f7991348e2_b.jpg\" data-rawwidth=\"1064\" data-rawheight=\"498\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"1064\" data-original=\"https://pic3.zhimg.com/v2-69d664cc1f8e889451b2a6f7991348e2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1064&#39; height=&#39;498&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1064\" data-rawheight=\"498\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1064\" data-original=\"https://pic3.zhimg.com/v2-69d664cc1f8e889451b2a6f7991348e2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-69d664cc1f8e889451b2a6f7991348e2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>但是这样会取消自动缩进的功能，这时候我们再次 <code>:set nopaste</code> 即可。</p><p>有的人会问，那这样每次都要切换很麻烦，不想要每次复制粘贴都要敲一段代码，怎么办呢？</p><p>这里提供两种思路，一种是使用插件，这个之后我会介绍，第二种就是 share 部分提到的，同步 vim 和系统剪贴板的方式，直接在 normal 模式下使用 <code>p</code> 来进行粘贴。</p><hr/><h2>Share</h2><p><b>同步 Vim 与系统剪贴板，同时解决 Vim 没有 clipboard 编译选项的问题</b></p><p>Vim 的剪贴板使用 register（寄存器）的方式，简单来说就是，在 vim 中复制的文本是存储在一个个寄存器中的，粘贴的时候也是将这个寄存器中的文本粘贴进去。使用特定寄存器的时候，我们需要在复制或剪切之前按下 <code>&#34;{register}</code>，即「双引号 + 寄存器名称」来引用该寄存器，然后再进行复制或剪切。</p><p>举个例子，我们希望复制一段文字到 <code>a</code> 剪贴板，那么我们在复制之前就按下 <code>&#34;a</code>，然后复制，这样就把选中的内容复制到 <code>a</code> 剪贴板了，我们也可以同时使用一个 <code>b</code> 剪贴板来保存另一段文本。</p><p>使用 <code>:reg {register}</code> 来查看寄存器中的内容。</p><p>粘贴之前引用该寄存器，即可对该寄存器内容进行粘贴。如 <code>&#34;ap</code> 粘贴 <code>a</code> 寄存器中的内容。</p><p>系统剪贴板在 vim 中的寄存器默认名为「加号 <code>+</code>」，所以复制之前引用系统剪贴板即可实现与系统剪贴板同步。</p><p>下面介绍另外一种简便的方法。</p><p>要实现这个功能，需要你的 vim 编译选项中有 <code>clipboard</code>。这里提供两种方式来检查你的 vim 是否有这个功能。</p><p>第一种，进入 vim，使用 <code>:echo has(&#39;clipboard&#39;)</code> 命令，如果返回值是 <code>1</code>，那么说明你的 vim 版本支持这个 feature，直接看下面的配置方法，如果返回值是 <code>0</code>，那么你需要升级你的 vim，或者重新编译安装。</p><p>第二种，在命令行输入 <code>vim --version | grep clipboard</code>，如果你的 <code>clipboard</code> 前面是一个加号 <code>+</code>，那么说明你的 vim 版本支持这个 feature，如果是减号 <code>-</code>，则不支持，需要升级你的 vim。</p><p>那么如何升级 vim 呢？</p><p>这里建议使用 Homebrew 安装。在命令行中输入以下命令：</p><div class=\"highlight\"><pre><code class=\"language-bash\">brew install vim -- --with-override-system-vi</code></pre></div><p>安装完成之后再查看你的 vim 是否支持 <code>clipboard</code>。</p><p>这个时候我本人遇到了一个坑，新下载安装的 vim 还是不支持 <code>clipboard</code>。这是因为使用 homebrew 安装的 vim 在 <code>/usr/local/bin/</code> 这个路径下，而默认的是 <code>/usr/bin/</code> 路径下的 vim。</p><p>在 .vimrc 中添加 alias：</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"nb\">alias</span> <span class=\"nv\">vim</span><span class=\"o\">=</span><span class=\"s2\">&#34;/usr/local/bin/vim&#34;</span></code></pre></div><p>这样你就会使用 homebrew 下载的 vim 来代替默认的 vim 了。</p><p>再次检查是否支持 <code>clipboard</code>。</p><p>最后，在你的 .vimrc 中添加下面一行即可：</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"nb\">set</span> <span class=\"nv\">clipboard</span><span class=\"o\">=</span>unnamed</code></pre></div><p>重启 terminal 即可。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80741486", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 22 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 53. Maximum Subarray</li><li>Review: Complete Guide to Parameter Tuning in XGBoost with codes in Python</li><li>Tip: 一个 LeetCode 题解项目</li><li>Share: Vim 中的多文件操作——Buffer、Window、Tab</li></ul><hr/><h2>Algorithm</h2><p><b>53. Maximum Subarray</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/maximum-subarray/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">53. Maximum Subarray</a></p><p>难度：Easy</p><p>题意：给定一个整数数组 <code>nums</code>，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [-2,1,-3,4,-1,2,1,-5,4],\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.</code></pre></div><p>解法：</p><p>本题可用暴力法来解决，基本思路就是计算出所有子序列的和，然后找出最大的和即可。但一般情况下，暴力法并不是最好的解决方法。</p><p>由于最大子序和这个问题是一道很经典的算法题（参考<a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%259C%2580%25E5%25A4%25A7%25E5%25AD%2590%25E6%2595%25B0%25E5%2588%2597%25E9%2597%25AE%25E9%25A2%2598\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科</a>），它于 1997 年被布朗大学的 Ulf Grenander 教授提出，然而一直到 1984 年卡内基梅隆大学的 Jay Kedane 才发现了线性时间的最优解法，虽然算法看起来很短，但是并不容易理解。下面介绍 Kedane 算法。</p><p>Kedane 算法的基本思路就是把整个的数组遍历一遍，使用两个变量，<code>max_ending_here</code> 记录遍历的时候，如果当前元素是子序列的最后一个元素，所能找到的最大子序列的和，由于真正的最大子序列必然存在一个结尾元素，所以只需要从每个位置计算出的 <code>max_ending_here</code> 中，找到最大值，就是全局的最大子序列的值，<code>max_so_far</code> 记录遍历的时候找到的最大的 <code>max_ending_here</code>，当遍历完成之后，即是我们要找的整个序列的最大子序和。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">maxSubArray</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"n\">max_ending_here</span> <span class=\"o\">=</span> <span class=\"n\">max_so_far</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]:</span>\n            <span class=\"n\">max_ending_here</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span> <span class=\"n\">max_ending_here</span> <span class=\"o\">+</span> <span class=\"n\">num</span><span class=\"p\">)</span>\n            <span class=\"n\">max_so_far</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">max_so_far</span><span class=\"p\">,</span> <span class=\"n\">max_ending_here</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">max_so_far</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b>Complete Guide to Parameter Tuning in XGBoost with codes in Python</b></p><p>本周继续阅读有关 XGBoost 的文章，<i><a href=\"https://link.zhihu.com/?target=https%3A//www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Complete Guide to Parameter Tuning in XGBoost with codes in Python</a></i>。</p><p>本文分为三个部分。</p><p>第一部分讲述了 XGBoost 的几个优点：</p><ul><li>正则化</li><li>并行处理</li><li>高灵活性</li><li>缺失值处理</li><li>优化的剪枝</li><li>内置的交叉验证</li><li>可以继续使用最后一次迭代训练之后的模型</li></ul><p>第二部分讲述了使用 XGBoost 时有关的参数。第三部分用完整的例子讲述了对 XGBoost 进行调参的过程。</p><p>第二三部分由于叙述过于详细，在此就不予阐述，感兴趣的同学可以去阅读原文。</p><hr/><h2>Tips</h2><p><b>一个 LeetCode 题解项目</b></p><p>这周和大家分享一个 GitHub 上的 LeetCode 题解项目。</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/azl397985856/leetcode\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-67c33d9c780921b1a4f86cbe5dfb34a8_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">azl397985856/leetcode</a><hr/><h2>Share</h2><p><b>Vim 中的多文件操作——Buffer、Window、Tab</b></p><p>本周和大家分享一下 vim 中如何比较方便地去同时查看编辑多个文件。</p><h3>Buffer</h3><p>首先和大家介绍一下 vim 中的一个概念叫 buffer，可能学计算机相关的同学们会比较熟悉，没错，它就是计算机内存中的「缓冲区」。我们每次打开一个文件，vim 都会在内存中申请一块缓冲区来存放我们这个文件，只有我们使用 <code>:w</code> 保存的时候才会将缓冲区中修改的内容写入到文件中去。</p><p>使用 <code>:ls</code> 命令来查看当前我们打开了多少个文件，即缓冲区中的文件数量。使用 <code>:b n</code> 跳转到第 n 个缓冲区，也可以使用 <code>:bpre</code>、<code>:bnext</code>、<code>:bfirst</code>、<code>:blast</code> 来跳转，还可以使用 <code>:b [buffer_name]</code> 来跳转到指定名称的缓冲区。</p><h3>Window</h3><p>第二个要介绍的概念就是 window，理解起来很简单就是「窗口」。一个 buffer 可以分割成多个 window，一个 window 也可以打开几个不同的 buffer。</p><p>使用 <code>:sp</code> 或 <code>&lt;C-w&gt;s</code>来水平分割，<code>:vs</code> 或 <code>&lt;C-w&gt;v</code>来垂直分割。这个过程你试一下就知道了，非常的简单。</p><p>那么如何在几个窗口之间跳转呢？</p><p>使用 <code>&lt;C-w&gt;</code> 作为 leader 键，同时加上 hjkl 四个键就可以实现光标在不同窗口之间跳转，使用 <code>&lt;C-w&gt;w</code> 在窗口之间循环切换。</p><h3>Tab</h3><p>最后一个概念叫做 tap，就是标签页，用来分组窗口的。你可以把它类比作 Linux 中的「工作区」，每个标签页中都只打开同一个类型的文件，比如第一个标签页只打开 Java 文件，第二个标签页只打开 Python 文件，第三个标签页只打开 HTML 文件。</p><p>使用 <code>:tabe[dit] {filename}</code> 来来一个新标签页中打开一个文件，<code>:tabc[lose]</code> 来关闭当前标签页，这个标签页中的所有窗口也都会被关闭，<code>:tabo[nly]</code> 来关闭出当前标签页外的所有标签页。</p><p>使用 <code>gt</code> 或 <code>gT</code> 来切换到下一个或上一个标签页。</p><h3>总结</h3><p>是不是感觉 vim 有太多命令？可能这也是 vim 把很多人劝退的原因，但是我们有强大的「二八定律」（笑），只要掌握了几个常用的命令，我们就能完成大部分的工作。最后当然要一直强迫自己去使用 vim 来达到一个手熟的程度。</p><p>Bon courage !</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80035758", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "决策树中的特征选择", 
            "content": "<p>这一篇我们来讲决策树中的特征选择问题，会涉及到什么是特征选择以及特征选择的准则。</p><h2>特征选择</h2><p>「特征选择」顾名思义就是对特征进行选择，以达到提高决策树学习的效率的目的。那么选择的是什么样的特征呢？这里我们选择的特征需要是<b>对训练数据有分类能力</b>的特征，如果一个特征参与分类与否和随机分类的结果差别不大的话，我们就说这个特征<b>没有分类能力</b>，舍去这个特征对学习的精度不会有特别大的影响。</p><blockquote>特征选择是决定用哪个特征来划分特征空间。</blockquote><p>那么如果有多个有分类能力的特征怎么办呢？直观上来讲，如果一个特征比另外一个特征有更好的分类能力，那就应该选择它，我们按照这个特征将训练数据分割成子集，各个子集在当前条件下就会有最好的分类结果。</p><p>比如女生找男朋友，可能这个女生<b>首先</b>会问「这个男生帅不帅」，其次再是「身高如何」、「有无房子」、「收入区间」、「做什么工作」等等，那么「帅否」这个特征就是这位女生心中有着最好分类能力的特征了。</p><p>那怎么判断哪个特征有更好的分类能力呢？这时候「信息增益」就要出场了。</p><h2>信息增益（Information gain）</h2><p>为了解释什么是信息增益，我们首先要讲解一下什么是<b>熵（entropy）</b>。</p><h3>熵（Entropy）</h3><p>在热力学与化学中：</p><blockquote>熵是一种测量在动力学方面不能做功的能量的总数，当总体熵增加，其做功能力也下降，熵的度量是能量退化的指标。</blockquote><p>1948 年，香农把热力学中的熵引入到信息论中，称为<b>香农熵</b>。根据维基百科的描述：</p><blockquote>在信息论中，熵是接收的每条消息中包含的信息的平均量。</blockquote><p>更一般的，熵表示随机变量的不确定性。假设一个有限取值的离散随机变量 X 的概率分布如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=P%28X+%3D+x_i%29+%3D+p_i%2C%5C+%5C+%5C+%5C+i+%3D+1%2C+2%2C+%5Ccdots%2C+n\" alt=\"P(X = x_i) = p_i,\\ \\ \\ \\ i = 1, 2, \\cdots, n\" eeimg=\"1\"/> </p><p>那么它的熵定义为：</p><p><img src=\"https://www.zhihu.com/equation?tex=H%28X%29+%3D+-%5Csum_%7Bi%3D1%7D%5En+p_i+%5Clog_%7Bb%7D+p_i\" alt=\"H(X) = -\\sum_{i=1}^n p_i \\log_{b} p_i\" eeimg=\"1\"/> </p><p>上式中的 b 通常取 2 或者自然对数 <i>e</i>，这时熵的单位就分别称为比特（bit）或纳特（nat），这也是信息论中，信息量的单位。</p><p>从上式中，我们可以看到，熵与 X 的取值是没有关系的，它只与 X 的分布有关，所以 H 也可以写作 p 的函数：</p><p><img src=\"https://www.zhihu.com/equation?tex=H%28p%29+%3D+-%5Csum_%7Bi%3D1%7D%5En+p_i%5Clog+p_i\" alt=\"H(p) = -\\sum_{i=1}^n p_i\\log p_i\" eeimg=\"1\"/> </p><p>我们现在来看两个随机变量的情况。</p><p>假设随机变量 (X, Y) 的联合概率分布如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=P%28X+%3D+x_i%2C+Y+%3D+y_j%29+%3D+p_%7Bij%7D%2C%5C+%5C+%5C+%5C+i+%3D+1%2C+2%2C+%5Ccdots%2C+n%3B%5C+j+%3D+1%2C+2%2C+%5Ccdots%2C+m\" alt=\"P(X = x_i, Y = y_j) = p_{ij},\\ \\ \\ \\ i = 1, 2, \\cdots, n;\\ j = 1, 2, \\cdots, m\" eeimg=\"1\"/> </p><p>我们使用<b>条件熵（conditional entropy）H(Y|X)</b>来度量在已知随机变量 X 的条件下随机变量 Y 的不确定性。</p><p>条件熵定义为：X 给定条件下，Y 的条件概率分布的熵对 X 的数学期望。</p><p>是不是看晕了，没关系，我们来看数学公式，这才是最简单直接让你晕过去的方法：</p><p><img src=\"https://www.zhihu.com/equation?tex=H%28Y%7CX%29+%3D+%5Csum_%7Bi%3D1%7D%5En+p_i+H%28Y%7CX%3Dx_i%29%2C%5C+%5C+%5C+%5C+p_i+%3D+P%28X%3Dx_i%29%2C%5C+i+%3D+1%2C+2%2C+%5Ccdots%2C+n\" alt=\"H(Y|X) = \\sum_{i=1}^n p_i H(Y|X=x_i),\\ \\ \\ \\ p_i = P(X=x_i),\\ i = 1, 2, \\cdots, n\" eeimg=\"1\"/> </p><p>有了上面的公式以后，条件熵的定义就非常容易理解了。</p><p>那么这些奇奇怪怪的熵又和我们要讲的信息增益有什么关系呢？</p><h3>信息增益的定义与信息增益算法</h3><p>有经验的读者可能猜出来了，既然熵是信息量的一种度量，那么信息增益就是熵的增加咯？</p><p>没错，由于熵表示不确定性，严格来说，信息增益（information gain）表示的是「得知了特征 X 的信息之后，类别 Y 的信息的不确定性减少的程度」。</p><p>我们给出信息增益的最终定义：</p><blockquote>特征 A 对训练数据集 D 的信息增益 g(D, A)，定义为，集合 D 的经验熵 H(D) 与特征 A 给定条件下 D 的经验条件熵 H(D|A) 之差。</blockquote><p><img src=\"https://www.zhihu.com/equation?tex=g%28D%2C+A%29+%3D+H%28D%29+-+H%28D%7CA%29\" alt=\"g(D, A) = H(D) - H(D|A)\" eeimg=\"1\"/> </p><p><i>这里你只要知道经验熵和经验条件熵就是依据经验（由数据估计特别是极大似然估计）得出来的熵就可以了。</i></p><p>假设我们有一个训练集 D 和一个特征 A，那么，经验熵 H(D) 就是对 D 进行分类的不确定性，经验条件熵 H(D|A) 就是给定 A 后，对 D 分类的不确定性，经验熵 H(D) 与经验条件熵 H(D|A) 的差就是信息增益。</p><p>很明显的，不同的特征有不同的信息增益，信息增益大的特征分类能力更强。我们就是要根据信息增益来选择特征。</p><p>下面我们给出信息增益的算法。</p><p>首先对数据做一些介绍：</p><ul><li> 假设我们有一个训练集 D，训练集的总的样本个数即样本容量为 |D|，最后的结果有 K 个类别，每个类别表示为 <img src=\"https://www.zhihu.com/equation?tex=C_k\" alt=\"C_k\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=%7CC_k%7C\" alt=\"|C_k|\" eeimg=\"1\"/> 为属于这个类的样本的个数，很显然 <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bk%3D1%7D%5EK+%7CC_k%7C+%3D+%7CD%7C\" alt=\"\\sum_{k=1}^K |C_k| = |D|\" eeimg=\"1\"/> 。<br/> </li><li> 再假设我们有一个特征叫 A，A 有 n 个不同的取值 <img src=\"https://www.zhihu.com/equation?tex=%5C%7Ba_1%2C+a_2%2C+%5Ccdots%2C+a_n%5C%7D\" alt=\"\\{a_1, a_2, \\cdots, a_n\\}\" eeimg=\"1\"/> ，那么根据 A 我们可以将 D 分成 n 个子集，每个子集表示为 <img src=\"https://www.zhihu.com/equation?tex=D_i\" alt=\"D_i\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=%7CD_i%7C\" alt=\"|D_i|\" eeimg=\"1\"/> 是这个子集的样本个数，很显然 <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5En+%7CD_i%7C+%3D+%7CD%7C\" alt=\"\\sum_{i=1}^n |D_i| = |D|\" eeimg=\"1\"/> 。<br/> </li><li> 我们把 <img src=\"https://www.zhihu.com/equation?tex=D_i\" alt=\"D_i\" eeimg=\"1\"/> 中属于类别 <img src=\"https://www.zhihu.com/equation?tex=C_k\" alt=\"C_k\" eeimg=\"1\"/> 的集合称作 <img src=\"https://www.zhihu.com/equation?tex=D_%7Bik%7D%2C%5C+D_%7Bik%7D+%3D+D_i+%5Cbigcap+C_k\" alt=\"D_{ik},\\ D_{ik} = D_i \\bigcap C_k\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=%7CD_%7Bik%7D%7C\" alt=\"|D_{ik}|\" eeimg=\"1\"/> 是其样本个数。<br/> </li></ul><p>信息增益的计算就分为如下几个步骤：</p><ol><li>计算 D 的经验熵 H(D)：</li></ol><p><img src=\"https://www.zhihu.com/equation?tex=H%28D%29+%3D+-%5Csum_%7Bk%3D1%7D%5EK+%5Cfrac%7B%7CC_k%7C%7D%7B%7CD%7C%7D+%5Clog_2+%5Cfrac%7B%7CC_k%7C%7D%7B%7CD%7C%7D\" alt=\"H(D) = -\\sum_{k=1}^K \\frac{|C_k|}{|D|} \\log_2 \\frac{|C_k|}{|D|}\" eeimg=\"1\"/> </p><p>2. 计算 A 对 D 的经验条件熵 H(D|A)：</p><p><img src=\"https://www.zhihu.com/equation?tex=H%28D%7CA%29+%3D+%5Csum_%7Bi%3D1%7D%5En+%5Cfrac%7B%7CD_i%7C%7D%7B%7CD%7C%7D+H%28D_i%29+%3D+-+%5Csum_%7Bi%3D1%7D%5En+%5Cfrac%7B%7CD_i%7C%7D%7B%7CD%7C%7D+%5Csum_%7Bk%3D1%7D%5EK+%5Cfrac%7B%7CD_%7Bik%7D%7C%7D%7B%7CD_i%7C%7D+%5Clog_2+%5Cfrac%7B%7CD_%7Bik%7D%7C%7D%7B%7CD_i%7C%7D\" alt=\"H(D|A) = \\sum_{i=1}^n \\frac{|D_i|}{|D|} H(D_i) = - \\sum_{i=1}^n \\frac{|D_i|}{|D|} \\sum_{k=1}^K \\frac{|D_{ik}|}{|D_i|} \\log_2 \\frac{|D_{ik}|}{|D_i|}\" eeimg=\"1\"/> </p><p>3. 计算信息增益 g(D, A)：</p><p><img src=\"https://www.zhihu.com/equation?tex=g%28D%2C+A%29+%3D+H%28D%29+-+H%28D%7CA%29\" alt=\"g(D, A) = H(D) - H(D|A)\" eeimg=\"1\"/> </p><h3>信息增益比</h3><p>看到这个小标题，可能有人会问，信息增益我知道了，信息增益比又是个什么玩意儿？</p><p>按照经验来看，以信息增益准则来选择划分数据集的特征，其实倾向于选择有更多取值的特征，而有时这种倾向会在决策树的构造时带来一定的误差。</p><p>为了校正这一误差，我们引入了信息增益比（information gain ratio），又叫做信息增益率，它的定义如下：</p><blockquote> 特征 A 对训练数据集 D 的信息增益比 <img src=\"https://www.zhihu.com/equation?tex=g_R%28D%2C+A%29\" alt=\"g_R(D, A)\" eeimg=\"1\"/> 定义为其信息增益 <img src=\"https://www.zhihu.com/equation?tex=g%28D%2C+A%29\" alt=\"g(D, A)\" eeimg=\"1\"/> 与训练数据集 D 关于特征 A 的值的熵 <img src=\"https://www.zhihu.com/equation?tex=H_A%28D%29\" alt=\"H_A(D)\" eeimg=\"1\"/> 之比。<br/> </blockquote><p><img src=\"https://www.zhihu.com/equation?tex=g_R%28D%2C+A%29+%3D+%5Cfrac%7Bg%28D%2C+A%29%7D%7BH_A%28D%29%7D\" alt=\"g_R(D, A) = \\frac{g(D, A)}{H_A(D)}\" eeimg=\"1\"/> </p><p>其中， <img src=\"https://www.zhihu.com/equation?tex=H_A%28D%29+%3D+-%5Csum_%7Bi%3D1%7D%5En+%5Cfrac%7B%7CD_i%7C%7D%7B%7CD%7C%7D+%5Clog_2+%5Cfrac%7B%7CD_i%7C%7D%7B%7CD%7C%7D\" alt=\"H_A(D) = -\\sum_{i=1}^n \\frac{|D_i|}{|D|} \\log_2 \\frac{|D_i|}{|D|}\" eeimg=\"1\"/> ，n 是 A 取值的个数。</p><p>在下一节中，我们要讲到的两个决策树算法 ID3 算法和 C4.5 算法，分别会采用信息增益和信息增益比作为特征选择的依据。</p>", 
            "topic": [
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "决策树", 
                    "tagLink": "https://api.zhihu.com/topics/19569936"
                }, 
                {
                    "tag": "特征选择", 
                    "tagLink": "https://api.zhihu.com/topics/19809410"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79735976", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 21 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 11. Container with most water</li><li>Review: XGBoost Algorithm: Long May She Reign!</li><li>Tip: 分享一个 vim 中的注释插件</li><li>Share: 分享一张我自己制作的决策树、提升算法和 XGBoost 的脑图</li></ul><hr/><h2>Algorithm</h2><p><b>11. Container with most water</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/container-with-most-water/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">11. Container with most water</a></p><p>难度：Medium</p><p>题意：给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-48ea24f1dba1a1a82b21bf3eb259108e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"801\" data-rawheight=\"383\" class=\"origin_image zh-lightbox-thumb\" width=\"801\" data-original=\"https://pic3.zhimg.com/v2-48ea24f1dba1a1a82b21bf3eb259108e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;801&#39; height=&#39;383&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"801\" data-rawheight=\"383\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"801\" data-original=\"https://pic3.zhimg.com/v2-48ea24f1dba1a1a82b21bf3eb259108e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-48ea24f1dba1a1a82b21bf3eb259108e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>图中垂直线代表输入数组 <code>[1,8,6,2,5,4,8,3,7]</code>。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [1,8,6,2,5,4,8,3,7]\nOutput: 49</code></pre></div><p>解法一， 暴力法：</p><p>使用暴力法，将所有可能的组合全部计算出来，再选择一个最大的结果返回即可。</p><p>代码如下：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">maxArea</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"n\">max_water</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">height</span><span class=\"p\">)):</span>\n            <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">height</span><span class=\"p\">)):</span>\n                <span class=\"n\">water</span> <span class=\"o\">=</span> <span class=\"n\">height</span><span class=\"p\">[(</span><span class=\"n\">i</span> <span class=\"k\">if</span> <span class=\"n\">height</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">height</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"k\">else</span> <span class=\"n\">j</span><span class=\"p\">)]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n                <span class=\"n\">max_water</span> <span class=\"o\">=</span> <span class=\"n\">water</span> <span class=\"k\">if</span> <span class=\"n\">water</span> <span class=\"o\">&gt;</span> <span class=\"n\">max_water</span> <span class=\"k\">else</span> <span class=\"n\">max_water</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">max_water</span></code></pre></div><p>提交上去之后，OJ 提示：Time Limit Exceeded。说明算法复杂度太高，需要重新设计。很明显，暴力法的时间复杂度为 O(n2)，空间复杂度 O(1)。</p><p>解法二，双指针法：  </p><p>使用 Left 和 right 两个指针，一个指向数组开头，一个指向数组结尾，考虑两个指针指向的线段之间的面积。为了让面积最大，我们需要让两个指针之间的距离尽量长，并且需要找到尽量长的的线段。如果我们将较长的线段的指针往中间移动，那么面积会受限于较短的那个线段的长度而不可能增加，但如果我们将较短的线段的指针往中间移动，那么指针距离的缩短则可能由线段长度的增加来弥补，反而使矩形面积增加。下面我们来写代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">maxArea</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">max_water</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">height</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span>\n\n        <span class=\"k\">while</span> <span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">r</span><span class=\"p\">:</span>\n            <span class=\"n\">water</span> <span class=\"o\">=</span> <span class=\"n\">height</span><span class=\"p\">[(</span><span class=\"n\">l</span> <span class=\"k\">if</span> <span class=\"n\">height</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">height</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span> <span class=\"k\">else</span> <span class=\"n\">r</span><span class=\"p\">)]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">l</span><span class=\"p\">)</span>\n\n            <span class=\"k\">if</span> <span class=\"n\">water</span> <span class=\"o\">&gt;</span> <span class=\"n\">max_water</span><span class=\"p\">:</span>\n                <span class=\"n\">max_water</span> <span class=\"o\">=</span> <span class=\"n\">water</span>\n\n            <span class=\"k\">if</span> <span class=\"n\">height</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">height</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]:</span>\n                <span class=\"n\">l</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">r</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">max_water</span></code></pre></div><p>因为只进行了一轮遍历，时间复杂度为 O(n)，只使用了恒定的额外空间，空间复杂度为 O(1)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/https-medium-com-vishalmorde-xgboost-algorithm-long-she-may-rein-edd9f99be63d\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">XGBoost Algorithm: Long May She Reign!</a></b></p><p>本周 review 的是 Medium 上一篇讲解 XGBoost 的文章，<i>XGBoost Algorithm: Long May She Reign!</i>。本文语言较为简单易懂，但比较全面地介绍了 XGBoost 的由来、发展和展望。</p><p>文章由作者本身的 regression modeling 经历引入，讲解了提升树模型的发展历史，用面试的例子讲解了决策树（Decision Tree）、装袋法（bagging）、随机森林（Random Forest）、提升方法（Boosting）、梯度提升（Gradient Boosting）以及 XGBoost。之后从系统优化和算法优势两个层面讲解了 XGBoost 强大的原因，之后给出了 XGBoost 速度的证据。在回答「我们是否应在所有情况下都使用 XGBoost」这个问题时，作者表示，一名数据科学家应该为数据和问题测试所有可能的算法，选择最佳算法还不够，数据科学家还需要能够对算法中的超参数进行微调，另外还需要对算法的计算复杂度、可解释性以及易实现性进行深度的思考。在文章的最后，作者还列举了例如微软研究院的 LightGBM、 Yandex Technology 的 CatBoost 等 XGBoost 的类似算法，并对未来提升算法进行了展望。</p><p>对 XGBoost 算法有兴趣的同学推荐阅读。</p><hr/><h2>Tips</h2><p><b>分享一个 vim 中的注释插件</b></p><p>本周分享一个 vim 中的注释插件：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/tpope/vim-commentary\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">tpope 大神的 vim-commentary</a>。</p><p>根据插件描述： </p><ul><li>使用 <code>gcc</code> 来注释掉光标所在行 </li><li>使用 <code>gc</code> 与文本对象的动作搭配（如 <code>gcap</code> 来注释掉一个段落） </li><li>使用 <code>gc</code> 注释掉选中的部分 </li><li>也可以将它作为命令，或者标上使用范围，如 <code>:7,17Commentary</code>，或者作为 <code>:global</code>调用的一部分 <code>:g/TODO/Commentary</code></li></ul><hr/><h2>Share</h2><p><b>分享一张我自己制作的决策树、提升算法和 XGBoost 的脑图</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9d9b1e0153e7087fa2ef943d6a157fe2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1793\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb\" width=\"1793\" data-original=\"https://pic3.zhimg.com/v2-9d9b1e0153e7087fa2ef943d6a157fe2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1793&#39; height=&#39;1080&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1793\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1793\" data-original=\"https://pic3.zhimg.com/v2-9d9b1e0153e7087fa2ef943d6a157fe2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9d9b1e0153e7087fa2ef943d6a157fe2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果看不清可以私信我 ;)</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/78724009", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 20 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 122. Best Time to Buy and Sell Stock II</li><li>Review: Time Series in Python — Exponential Smoothing and ARIMA processes</li><li>Tip: Vim 中的两个补全操作</li><li>Share: 决策树（一）：决策树学习的基本概念</li></ul><hr/><h2>Algorithm</h2><p><b>122. Best Time to Buy and Sell Stock II</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">122. Best Time to Buy and Sell Stock II</a></p><p>难度：Easy</p><p>题意：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n             engaging multiple transactions at the same time. You must sell before buying again.</code></pre></div><p>示例 3：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.</code></pre></div><p>解法：</p><p>本题的解法其实也非常直接，从数学上来讲，因为我可以无限次买进卖出，只要每次卖出的价格比买进的价格高，那么就是稳赚不赔并且能够获取最多利润的。那么我们只要遍历价格数组，只要当前价格比前一个价格高，那么就卖出，如此重复并且将利润累加，我们就能获得最大的利润。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">prices</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"n\">max_profit</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">prices</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]:</span>\n                <span class=\"n\">max_profit</span> <span class=\"o\">+=</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">max_profit</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/time-series-in-python-exponential-smoothing-and-arima-processes-2c67f2a52788\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Time Series in Python — Exponential Smoothing and ARIMA processes</a></b></p><p>本周阅读的是 Medium 上的一篇讲述使用 Python 对时间序列进行分析的一篇文章，《Time Series in Python — Exponential Smoothing and ARIMA processes》。本文讲述了如何使用 Python 对时间序列进行指数平滑和 ARIMA 过程的建模。</p><p>文章首先举例讲述了时间序列的几种存在情况，然后说明了时间序列的四大属性：trend（趋势）、seasonality（季节性）、cyclicity（周期性）、residual（残差）以及时间序列的分解，之后使用简单的例子对平稳性及其检验和自相关与偏自相关函数进行了说明，最后分别对几种指数平滑的模型和 ARIMA 模型的建模过程进行了详细的讲解。</p><p>本文是从 Python 的角度对时间序列建模展开讲解，并且给出了较为详细的代码，使用的是 statsmodels 库。这个库中没有和 R 中 <code>autoarima()</code> 对标的函数，所以如果想要实现自动调参的功能，可以利用 aic/bic 准则，grid search 出最佳的参数。</p><hr/><h2>Tips</h2><p><b>Vim 中的两个补全操作</b></p><p>Vim 中有两个常用的不依赖插件的补全操作：</p><ul><li>CTRL-N、CTRL-P：补全单词</li><li>CTRL-X-F：补全路径</li></ul><p>另外有一个输出当前路径的命令：</p><div class=\"highlight\"><pre><code class=\"language-bash\">:r! <span class=\"nb\">echo</span> % <span class=\"c1\"># 输出当前文件名</span>\n:r! <span class=\"nb\">echo</span> %:p <span class=\"c1\"># 输出完整路径名</span></code></pre></div><hr/><h2>Share</h2><p><b>决策树（一）：决策树学习的基本概念</b></p><blockquote>本文是我阅读李航老师《统计学习方法》中决策树章节的部分笔记，分享给大家。</blockquote><p>决策树是一种基本的分类与回归方法。我们这一篇文章对决策树模型的定义、其与 if-then 规则和条件概率的关系、以及决策树学习的基本方法进行了归纳总结。</p><h3>决策树模型</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b7b762aafd5d23b5ada96d84551782f2_b.jpg\" data-size=\"normal\" data-rawwidth=\"256\" data-rawheight=\"267\" class=\"content_image\" width=\"256\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;256&#39; height=&#39;267&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"256\" data-rawheight=\"267\" class=\"content_image lazy\" width=\"256\" data-actualsrc=\"https://pic3.zhimg.com/v2-b7b762aafd5d23b5ada96d84551782f2_b.jpg\"/><figcaption>决策树模型</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>一棵简单的决策树如上图所示，是一种树形结构，由结点和有向边组成。图中，圆形表示内部结点，内部结点表示一个特征或者属性，方形表示叶子结点，叶子结点表示分类结果，即一个类。</p><p>决策树可以看成一个 if-then 规则的集合：对决策树的根节点到叶子结点的每条路径都构建一条规则，路径上的内部结点表示的特征对应于规则的条件，叶子结点则对应着规则的结论。这样，这个 if-then 规则有一个重要的性质，即<i>互斥且完备</i>。</p><p>决策树还可以看成给定特征条件下的条件概率分布。这种条件概率分布可以理解为对特征空间的一个划分（partition）。如下图所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b4acabb9aa47408004aed870cf1dfd65_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"371\" class=\"origin_image zh-lightbox-thumb\" width=\"609\" data-original=\"https://pic2.zhimg.com/v2-b4acabb9aa47408004aed870cf1dfd65_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;609&#39; height=&#39;371&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"371\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"609\" data-original=\"https://pic2.zhimg.com/v2-b4acabb9aa47408004aed870cf1dfd65_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b4acabb9aa47408004aed870cf1dfd65_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在这种划分下，特征空间被划分为几个互不相交的 cell 或 region，每个 cell 都定义了一个类。这种概率分布即构成了一个条件概率分布。</p><h3>决策树学习</h3><p>决策树学习的目的就是：根据给定的训练数据构建一个决策树模型，使它能够对实例进行争取的分类。本质上，决策树学习是从训练集中归纳出一组分类规则的过程，那么符合训练集的决策树可能有很多个（也可能一个都没有），决策树学习需要从众多树中选择一棵不仅对训练集有较好拟合的树，并且要求这棵树对未知数据也有较好的泛化能力。那么这个过程就是一个 NP 完全问题（关于什么是 NP 问题与决策树的 NP 完全问题，请参考<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/dcb0b52f4935\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这篇文章</a>），意味着我们无法使用计算机在多项式时间复杂度内找出全局最优解，也就从另一个角度说明，决策树最后的结果，是在每一步、每一个节点上做的局部最优选择。</p><p>决策树学习的过程如下（引自《统计学习方法》）：</p><blockquote>开始，构建根节点，将所有的训练数据集都放在根节点，选择一个最优特征，按照这一特征将训练数据集分割成子集，使得各个子集有一个在当前条件下获得最好的分类。如果这些子集已经能够被基本正确分类，那么构建叶节点，并将这些子集分到对应的叶节点中去；如果还有子集不能够被基本正确分类，那么就对这些子集新的选择最优特征，继续对其进行分割，构建相应的结点。如此递归下去，直到所有的训练数据子集被基本正确分类，或者没有合适的特征为止。最后每个子集都被分到叶节点上，即都有了明确的分类，这就生成了一棵决策树。<br/>以上方法生成的决策树可能对训练数据有很好的分类能力，但是对未知数据集未必有很好的分类能力，即可能发生过拟合的现象。我们需要对已生成的树自下而上进行剪枝，将树变得更简单，从而使它拥有更好的泛化能力。</blockquote><p>可以看出，决策树学习算法大致包含三个步骤：特征选择、决策树生成与决策树的剪枝。</p><p>下一篇文章我们更新决策树学习中的特征选择与信息增益相关的内容。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/77454187", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 19 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 121. Best Time to Buy and Sell Stock</li><li>Review: The Differences Between a Junior, Mid-Level, and Senior Developer</li><li>Tip: Pandas 中的 <code>groupby</code> 函数</li><li>Share: Vim 的文本对象</li></ul><hr/><h2>Algorithm</h2><p><b>121. Best Time to Buy and Sell Stock</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/best-time-to-buy-and-sell-stock/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">121. Best Time to Buy and Sell Stock</a></p><p>难度：Easy</p><p>题意：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n             Not 7-1 = 6, as selling price needs to be larger than buying price.</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.</code></pre></div><p>解法：</p><p>这道题的解法非常直接，只要遍历循环完所有的价格，然后将每一天的价格与之前存储的最低价格比较，选出这两者之间的较低价格作为最低价格，再计算当天价格与最低价格之差，将这个差与之前存储的最大利润相比较，选出两者之间的最大值，当遍历完成之后，最大利润也就找到了。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">prices</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"n\">max_profit</span><span class=\"p\">,</span> <span class=\"n\">min_price</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"s1\">&#39;inf&#39;</span><span class=\"p\">)</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">prices</span><span class=\"p\">:</span>\n            <span class=\"n\">min_price</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">min_price</span> <span class=\"k\">else</span> <span class=\"n\">min_price</span>\n            <span class=\"n\">max_profit</span> <span class=\"o\">=</span>  <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">min_price</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">max_profit</span> <span class=\"o\">&lt;</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">min_price</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"n\">max_profit</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">max_profit</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b>The Differences Between a Junior, Mid-Level, and Senior Developer</b></p><p>本周阅读了 Medium 上的一篇讲述初级、中级和高级开发者之间的区别的文章，<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/better-programming/the-differences-between-a-junior-mid-level-and-senior-developer-bb2cb2eb000d\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Differences Between a Junior, Mid-Level, and Senior Developer</a>。</p><p>本文就三者之间的区别以及如何进行跨越展开讨论：</p><ul><li>区别：</li><ul><li>知识</li><li>编码技巧</li><li>提问的技巧</li><li>经验</li></ul><li>跨越：</li><ul><li>初级到中级：经历多次开发周期</li><li>中级到高级：承担难题与掌握技术栈</li></ul></ul><hr/><h2>Tips</h2><p><b>Pandas 中的 <code>groupby</code> 函数</b></p><p>本周和大家分享 Pandas 中的一个常用且高效的函数，叫做 <code>groupby()</code>。</p><p>顾名思义，「groupby」就是「按 XXX 进行分组」的意思。举个简单的例子，我们有如下所示的表，将其按照「A」进行分组，结果如右所示。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d3dec6146c8182b81b3bb642119e5450_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1414\" data-rawheight=\"762\" class=\"origin_image zh-lightbox-thumb\" width=\"1414\" data-original=\"https://pic1.zhimg.com/v2-d3dec6146c8182b81b3bb642119e5450_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1414&#39; height=&#39;762&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1414\" data-rawheight=\"762\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1414\" data-original=\"https://pic1.zhimg.com/v2-d3dec6146c8182b81b3bb642119e5450_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d3dec6146c8182b81b3bb642119e5450_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><code>groupby</code> 的功能大致来说有 split、apply 和 combine：</p><ul><li>split：先将数据按一个属性分组 (得到 DataFrameGroupby / SeriesGroupby )</li><li>apply：对每一组数据进行操作 (求均值、中值、方差或应用自定义函数)</li><li>combine：将操作后的结果结合起来 (得到一个 DataFrame 或 Series 或可视化图像)</li></ul><p>细节功能请参考文档 <a href=\"https://link.zhihu.com/?target=https%3A//pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">pandas.pydata.org/panda</span><span class=\"invisible\">s-docs/stable/user_guide/groupby.html</span><span class=\"ellipsis\"></span></a>。</p><hr/><h2>Share</h2><p><b>Share: Vim 中的文本对象</b></p><p>Vim 中有一个与「面向对象编程」比较相似的一个概念，就是「文本对象」，其实「文本对象」并没有那么的神秘，大概有以下两种：</p><ul><li>w，s，p 分别表示：word（单词），sentence（句子）和 paragraph（段落）</li><li>引号与括号</li></ul><p>配合几个常用的命令（command）就可以很快的对代码进行修改了：</p><ul><li>v：visual 模式，选择一段文字</li><li>d：delete 删除，删除文本对象选择的文字</li><li>c：change 修改，删除选中的文字并进入插入模式</li><li>y：yank 复制，复制选中的文字</li></ul><p>另外还需要记住在选择文本对象时，i 和 a 这两个命令的区别：</p><ul><li>i：inner 内部，表示选择的对象仅限于文本对象内部，不包括文字后面的空格</li><li>a：around 周围，表示选择的对象环绕文本对象，包括文字后面的空格（但不包括前面的空格）</li></ul><p>常用的使用方法如下：</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"o\">[</span>number<span class=\"o\">]</span>&lt;command&gt;<span class=\"o\">[</span>text object<span class=\"o\">]</span></code></pre></div><ul><li>number 表示次数，比如几个单词、几句话或者几个段落</li><li>command 表示命令，常用的有 v、d、c 和 y</li><li>text object 就是配合 i/a 和 w/s/p/各种引括号 选择的文本对象了</li></ul><p>示例：</p><ul><li><code>viw</code>：选择光标当前所在的单词</li><li><code>vaw</code>：选择光标当前所在的单词以及其后面的空格</li><li><code>ci&#34;</code>：删除双引号内部的文字并进入插入模式</li><li><code>ya{</code>：复制光标所在的大括号内部的所有内容到剪贴板（包括大括号 <code>{</code>）</li></ul>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76654386", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 18 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 35. Search Insert Position</li><li>Review: Almost Everything You Need to Know About Time Series</li><li>Tip: <a href=\"https://link.zhihu.com/?target=http%3A//Codeimg.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">Codeimg.io</span><span class=\"invisible\"></span></a></li><li>Share: Vim 中的搜索替换</li></ul><hr/><h2>Algorithm</h2><p><b>搜索插入位置</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/search-insert-position/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">35. Search Insert Position</a></p><p>难度：Easy</p><p>题意：给定一个排序数组 <code>nums</code> 和一个目标值 <code>target</code>，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [1,3,5,6], 5\nOutput: 2</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [1,3,5,6], 2\nOutput: 1</code></pre></div><p>示例 3：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [1,3,5,6], 7\nOutput: 4</code></pre></div><p>示例 4：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [1,3,5,6], 0\nOutput: 0</code></pre></div><p>解法 1：</p><p>非常直接简单的思路。首先将 <code>target</code> 与 <code>nums</code> 最后一位进行比较，因为 <code>nums</code> 是有序的，如果 <code>target</code> 大于 <code>nums</code> 最后一位，那么直接返回最后一位的序号，即将 <code>targrt</code> 插入到这个位置。否则开始从头访问 <code>nums</code> 中的元素，因为 <code>nums</code> 是有序的，一旦这个元素大于 <code>target</code>，那么这个元素的位置就是我们要找的应该插入的位置。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">searchInsert</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">target</span> <span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]:</span>\n            <span class=\"k\">return</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&gt;=</span> <span class=\"n\">target</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">i</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><p>解法 2：</p><p>因为 <code>nums</code> 是有序的，我们很容易就想到<b>二分查找</b>。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">searchInsert</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n\n        <span class=\"k\">while</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n            <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"n\">right</span><span class=\"p\">)</span> <span class=\"o\">//</span> <span class=\"mi\">2</span>\n\n            <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">mid</span>\n            <span class=\"k\">elif</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">target</span><span class=\"p\">:</span>\n                <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">left</span></code></pre></div><p>时间复杂度 O(log n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/almost-everything-you-need-to-know-about-time-series-860241bdc578\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Almost Everything You Need to Know About Time Series</a></b></p><p>本周阅读了一篇 Medium 上名为 <i>Almost Everything You Need to Know About Time Series</i> 的关于时间序列的文章。文章深入浅出，从最简单的平稳性、季节性和自相关性开始，介绍了 Dickey-Fuller 平稳性测试、滑动平均、指数平滑与 (S)ARIMA 等时间序列模型。文章语言很简单，配图很多，方便理解，在讨论模型时还附带了几个关键的公式，非常直观。阅读时需要一些简单的统计学知识。</p><hr/><h2>Tips</h2><p><b><a href=\"https://link.zhihu.com/?target=http%3A//Codeimg.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">Codeimg.io</span><span class=\"invisible\"></span></a></b></p><p>推荐一款免费在线把代码生成为图片的工具。</p><p>高度可定制样式，创建图片时提供 Facebook、Twitter 和 Instagram 的尺寸模板。</p><p>地址：<a href=\"https://link.zhihu.com/?target=https%3A//codeimg.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">codeimg.io</a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-013dcfe4cc1238af97b64fe8b5209323_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-013dcfe4cc1238af97b64fe8b5209323_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;365&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-013dcfe4cc1238af97b64fe8b5209323_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-013dcfe4cc1238af97b64fe8b5209323_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>Share</h2><p><b>Vim 中的搜索替换</b></p><p>substitute 命令允许进行查找替换文本，并且支持正则表达式：</p><ul><li>:[range]s[ubstitute]/{pattern}/{string}/[flags]</li><li>range 表示搜索的范围：10, 20 表示第 10 行到底 20 行，% 则表示全部文本</li><li>pattern 是要替换的对象，string 是替换后的文本</li><li>flags 是替换的标志位，几个常用的标志：</li><ul><li>g(globle)：表示全局范围内执行</li><li>c(confirm)：确认，vim 提供了「确认」或者「拒绝」修改的选项</li><li>n(number)：查询匹配到的次数，但是不替换</li></ul></ul>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75237700", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 17 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 367. Valid Perfect Square</li><li>Review: Generative Adversarial Networks - The Story So Far</li><li>Tip: 推荐两个有趣好用的 vim 插件</li><li>Share: Vim 中的增删改查</li></ul><hr/><h2>Algorithm</h2><p><b>367. Valid Perfect Square</b></p><p>题目：367. 有效的完全平方数</p><p>难度：Easy</p><p>题意：给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p><p>说明：不要使用任何内置的库函数，如 <code>sqrt</code>。</p><p>示例一：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 16\nOutput: true</code></pre></div><p>示例二：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 14\nOutput: false</code></pre></div><p>解法：</p><p>本题相对比较容易，目前来看有四种解法：暴力搜索、公式法、二分搜索和牛顿法。下面分别就这四种解法作出解释和代码。</p><p><b>暴力搜索法</b></p><p>从 1 开始遍历，直到 num，判断 i 的平方是否为 num，如果是，返回 True，否则返回 False。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isPerfectSquare</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">i</span><span class=\"o\">*</span><span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"n\">num</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">True</span>\n        <span class=\"k\">return</span> <span class=\"bp\">False</span></code></pre></div><p>这个解法，思路上是没错的，但是当我们提交代码的时候就会发现，OJ 报错“Time Limit Exceeded”，说明我们的算法耗时太长。</p><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><p><b>公式法</b></p><p>我们根据数学知识知道，一个首项为 1、等差为 2 的等差数列的前 n 项和，即为 n 的平方：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d1d0f79fdee9979948a7fc1875968d7f_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"904\" data-rawheight=\"96\" class=\"origin_image zh-lightbox-thumb\" width=\"904\" data-original=\"https://pic4.zhimg.com/v2-d1d0f79fdee9979948a7fc1875968d7f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;904&#39; height=&#39;96&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"904\" data-rawheight=\"96\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"904\" data-original=\"https://pic4.zhimg.com/v2-d1d0f79fdee9979948a7fc1875968d7f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d1d0f79fdee9979948a7fc1875968d7f_b.png\"/></figure><p>我们可以利用这个方法来解这道题：让 num 逐项减去上述等差数列的前 n 项，一直减到 num 大于 0，判断结果，如果为 0，那么证明 num 是完全平方数，否则不是。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isPerfectSquare</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">while</span> <span class=\"n\">num</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"n\">num</span> <span class=\"o\">-=</span> <span class=\"n\">i</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span>\n\n        <span class=\"k\">if</span> <span class=\"n\">num</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">True</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">False</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><p><b>二分搜索</b></p><p>借鉴了二分查找的思路，设置 left、right、mid 指针，当 left &lt;= right 的时候，计算 mid，如果 mid == num/mid，那么返回 True，否则重新计算 mid，在计算完毕之后，如果还没有找到 mid == num/mid，那么返回 False。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isPerfectSquare</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">num</span>\n        <span class=\"k\">while</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n            <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">right</span> <span class=\"o\">-</span> <span class=\"n\">left</span><span class=\"p\">)</span> <span class=\"o\">//</span> <span class=\"mi\">2</span>\n            <span class=\"k\">if</span> <span class=\"n\">mid</span> <span class=\"o\">&gt;</span> <span class=\"n\">num</span><span class=\"o\">/</span><span class=\"n\">mid</span><span class=\"p\">:</span>\n                <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n            <span class=\"k\">elif</span> <span class=\"n\">mid</span> <span class=\"o\">&lt;</span> <span class=\"n\">num</span><span class=\"o\">/</span><span class=\"n\">mid</span><span class=\"p\">:</span>\n                <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">True</span>\n\n        <span class=\"k\">return</span> <span class=\"bp\">False</span></code></pre></div><p>由于是二分查找，时间复杂度为 O(log n)，空间复杂度为 O(1)。</p><p><b>牛顿法</b></p><p>首先我们需要对牛顿法的数学原理做一些了解。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bf4ae4f7ce50f4126e49a3f996910bd6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"463\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb\" width=\"463\" data-original=\"https://pic3.zhimg.com/v2-bf4ae4f7ce50f4126e49a3f996910bd6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;463&#39; height=&#39;411&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"463\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"463\" data-original=\"https://pic3.zhimg.com/v2-bf4ae4f7ce50f4126e49a3f996910bd6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bf4ae4f7ce50f4126e49a3f996910bd6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如图所示，有曲线 f(x)，在 f(x_n) 处画一条切线，与 x 轴相交于 x_{n+1}，继续在 f(X_{n+1}) 处画一条切线，与 x 轴相交于 x_{n+2}。如果继续这个步骤 m 次，我们会发现，第 m 个交点 x_{n+m} 会无限逼近方程 f(x) = 0 的根 x_0，最终能够得到一个与精确值无限接近的近似值。</p><p>此处我们的问题讨论的是平方（根），那么我们如果能找到 num 的整数平方根，就说明 num 为完全平方根数。</p><p>此处求 num 的平方根即是求曲线方程为 f(x) = x^2 - N 的零点。函数 f(X) 的导数为 f&#39;(x) = 2x，那么曲线在 (x_n, x^2_n - N) 处的切线的斜率为 2x_n，切线方程为 y - (x^2_n - N) = 2x_n * (x - x_n)，即 y = 2x_n x - x^2_n - N，切线与 x 轴的交点为 x_{n+1} = \\frac{1}{2}(x_n + \\frac{N}{x_n})。</p><p>我们可以一直将 x_{n+1} 的平方与 num 相比，如果 x^2_{n+1} 大于 num，那么就再次循环迭代，直到 x^2_{n+1} 不大于 num，如果此时两者相等，那么即可判断 num 为完全平方数，否则不为完全平方数。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isPerfectSquare</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">num</span>\n        <span class=\"k\">while</span> <span class=\"n\">r</span><span class=\"o\">*</span><span class=\"n\">r</span> <span class=\"o\">&gt;</span> <span class=\"n\">num</span><span class=\"p\">:</span>\n            <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">+</span> <span class=\"n\">num</span> <span class=\"o\">/</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">//</span> <span class=\"mi\">2</span>\n        <span class=\"k\">if</span> <span class=\"n\">r</span><span class=\"o\">*</span><span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"n\">num</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">True</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">False</span></code></pre></div><p>时间复杂度 O(log n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b>Generative Adversarial Networks - The Story So Far</b></p><p>本周阅读了 FloydHub 上的一篇介绍 GAN（生成对抗网络）的发展历史的文章，<a href=\"https://link.zhihu.com/?target=https%3A//blog.floydhub.com/gans-story-so-far/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Generative Adversarial Networks - The Story So Far</a>。这篇文章从 GAN 的历史角度，对 10 种 GAN 以及他们的变体进行了较为详细的介绍，并附上了代码和 Paper，如果你想入门 GAN，这是非常值得一读的好文章。</p><hr/><h2>Tips</h2><p><b>推荐两个有趣好用的 vim 插件</b></p><ul><li>Goyo，禅模式     </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4d874be8d5ac9e2e8763a12f546a3930_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1728\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb\" width=\"1728\" data-original=\"https://pic1.zhimg.com/v2-4d874be8d5ac9e2e8763a12f546a3930_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1728&#39; height=&#39;1080&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1728\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1728\" data-original=\"https://pic1.zhimg.com/v2-4d874be8d5ac9e2e8763a12f546a3930_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4d874be8d5ac9e2e8763a12f546a3930_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-36981277b84d43c39f264b1fb9a04a0c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1728\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb\" width=\"1728\" data-original=\"https://pic1.zhimg.com/v2-36981277b84d43c39f264b1fb9a04a0c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1728&#39; height=&#39;1080&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1728\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1728\" data-original=\"https://pic1.zhimg.com/v2-36981277b84d43c39f264b1fb9a04a0c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-36981277b84d43c39f264b1fb9a04a0c_b.jpg\"/></figure><ul><li>Vim-startify，进入 vim 时给与一些提示和快速打开上回编辑的文件</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2865005b0f38032b38a0d201542ea07c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2880\" data-rawheight=\"1800\" class=\"origin_image zh-lightbox-thumb\" width=\"2880\" data-original=\"https://pic1.zhimg.com/v2-2865005b0f38032b38a0d201542ea07c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2880&#39; height=&#39;1800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2880\" data-rawheight=\"1800\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2880\" data-original=\"https://pic1.zhimg.com/v2-2865005b0f38032b38a0d201542ea07c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2865005b0f38032b38a0d201542ea07c_b.jpg\"/></figure><hr/><h2>Share</h2><p><b>Vim 中的增删改查</b></p><p>增：</p><ul><li>a/i/o 分别对应于 append（在光标之后插入），insert（在光标之前插入），open a line below（在光标所在行下面插入一行并进入插入模式）</li><li>A/I/O 分别对应于 append after line（在行尾插入），insert before line（在行首插入），open a line above（在光标所在行上面插入一行并进入插入模式）</li></ul><p>删：</p><ul><li>在普通模式下使用 x 可以删除光标所在的字符</li><li>使用 d（delete）配合文本对象删除一段字符：daw/diw/dt(‘x’)/d$/d0</li><li>x 与 d 与数字配合使用</li></ul><p>改：</p><ul><li>常用的三个命令：r（replace）、c(change)、s（substitute）</li><li>r：在普通模式下替换一个字符；s：在普通模式下删除当前字符并进入插入模式；r 和 s 均可以搭配数字来使用</li><li><i>R：进入替换模式，将光标所在位置的字符替换为输入的字符</i></li><li>S：删除当前行并进入插入模式  * c：配合文本对象删除一段字符，并进入插入模式，使用方法同 d</li></ul><p>查：</p><ul><li>使用 / 和 ? 进行正向或反向的搜索</li><li>使用 n/N 跳转到下一个/上一个匹配</li><li><i>使用 */# 进行当前单词的前向或后向匹配 </i> 输入命令 <code>:noh</code> 取消高亮</li></ul>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74511130", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 16 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 3. Longest Substring Without Repeating Characters</li><li>Review: Why IoT Needs Machine Learning to Thrive</li><li>Tip: vim 中的快速移动</li><li>Share: 机器学习中的朴素贝叶斯分类</li></ul><hr/><h2>Algorithm</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/longest-substring-without-repeating-characters/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3. Longest Substring Without Repeating Characters</a></b></p><p>题目：无重复字符的最长子串</p><p>难度：Medium</p><p>题意：给定一个字符串，请你找出其中不含有重复字符的 <b>最长子串</b> 的长度。</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;abcabcbb&#34;\nOutput: 3 \nExplanation: The answer is &#34;abc&#34;, with the length of 3.</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;bbbbb&#34;\nOutput: 1\nExplanation: The answer is &#34;b&#34;, with the length of 1.</code></pre></div><p>示例 3：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;pwwkew&#34;\nOutput: 3\nExplanation: The answer is &#34;wke&#34;, with the length of 3. \n             Note that the answer must be a substring, &#34;pwke&#34; is a subsequence and not a substring.</code></pre></div><p>解法：</p><div class=\"highlight\"><pre><code class=\"language-text\">构造一个起始计数点 start，需要返回的结果 max\n构造一个字典 dict，对字符串中的每一个字符进行读取：\n    如果这个字符在字典中，且它上一次出现在字符串中的位置比 start 要大[注1]，那么：\n        将这个字符出现的位置置为 start（重新开始计数），并且将字典中这个字符的值修改为当前位置\n    如果这个字符不在字典中，那么：\n        将这个字符作为键，字符的位置作为值，加入到字典中去\n        如果当前位置减去起始位置比 max 要大，即说明我们目前读取过的字符数是最大的，那么修改 max 的值为当点位置减去 start\n\n注意，如果字符串为空，那么返回值需要是 1，所以应该设置起始点为 -1</code></pre></div><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">lengthOfLongestSubstring</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type s: str\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n\n        <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n        <span class=\"nb\">max</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"ow\">in</span> <span class=\"n\">d</span> <span class=\"ow\">and</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span> <span class=\"o\">&gt;</span> <span class=\"n\">start</span><span class=\"p\">:</span>\n                <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span>\n                <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n                <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">start</span> <span class=\"o\">&gt;</span> <span class=\"nb\">max</span><span class=\"p\">:</span>\n                    <span class=\"nb\">max</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">start</span>\n\n        <span class=\"k\">return</span> <span class=\"nb\">max</span></code></pre></div><p>注1：为什么这里一定要说明「读取到的字符上一次出现的位置比 <code>start</code> 要大」呢？</p><blockquote>如果条件中没有 <code>d[s[i]] &gt; start</code>，那么就不能保证计算的子字符串是从上一个子字符串之后重新开始计算的。</blockquote><p>第一次做 Medium 难度的题目，感觉还是很有挑战的，这里参考了 B站up主 <i>Michelle 小梦想家</i> 的<a href=\"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av46146545\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个视频</a>。</p><p>时间复杂度为 O(n)，空间复杂度也是 O(n)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//www.iotforall.com/why-iot-needs-machine-learning/amp/%3Fmc_cid%3D1df5995a8d%26mc_eid%3Dc2ab58e995\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Why IoT Needs Machine Learning to Thrive</a></b></p><p>本周阅读了 <a href=\"https://link.zhihu.com/?target=https%3A//www.iotforall.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">IoT for All</a> 上的一篇文章，<i>Why IoT Needs Machine Learning to Thrive</i>，比较短小，但值得一读，尤其是物联网面临的几个关键挑战和机器学习能够应用的几个因素，非常有针对性。</p><p>文章从以下几个方面讲述了机器学习如何为 IoT 行业赋能：</p><ul><li>机器学习的能力</li><li>物联网行业面临的关键挑战：</li><ul><li>安全与隐私</li><li>操作的准确性</li><li>大数据的 3V：volume（数据的数量）、variety（数据的种类）、velocity（处理数据的速度）</li><li>互联性 </li></ul><li>机器学习能够在物联网领域应用的两个因素：</li><ul><li>数据分析的自动化</li><li>机器学习的预测能力 </li></ul><li>如何起作用</li><li>从大数据到智能数据</li></ul><hr/><h2>Tips</h2><p><b>vim 中的快速移动</b></p><p>大家知道，vim 的 normal 模式使用了 <b>hjkl</b> 这四个键来进行上下左右的移动，除了这四个键，Vim 其实还有很多其他的移动方式：</p><p>在单词之间进行移动：</p><ul><li>w/W 移动到下一个 word/WORD 的开头，e/E 移动到下一个 word/WORD 的结尾</li><li>b/B 移动到上一个 word/WORD 的开头，你可以将它理解为 backward</li><li>word 是指以非空白符分割的单词，WORD 指以空白符分割的单词</li></ul><p>行间搜索移动：</p><ul><li>使用 <code>f{char}</code> 移动到该行第一个 <code>char</code> 字符上（f 可以理解为 find），使用 <code>t{char}</code> 移动到 <code>char</code> 的前一个字符上（t 可以理解为 till）</li><li>如有多个 <code>char</code>，那么可以使用 分号 <code>;</code> 跳转到下一个 <code>char</code>，逗号 <code>,</code> 跳转到上一个 <code>char</code></li><li>如果光标在行尾，那么可以使用 F/T 来进行反向的查找，这时分号和逗号的作用也相反</li></ul><p>水平移动：</p><ul><li>0 移动到行首，^ 移动到第一个非空白字符（如果这时候本就在行首的话，直接使用 w 即可）</li><li>$ 移动到行尾，g_ 移动到行尾最后一个非空白字符</li></ul><p>垂直移动：</p><ul><li>使用 括号 <code>()</code> 在句子间移动，使用 花括号 <code>{}</code> 在段落间移动</li></ul><p>页面移动：</p><ul><li>gg 移动到文件开头，G 移动到文件结尾，使用 CTRL-o 回到上一次的位置</li><li>H/M/L 移动到开头（Head）、中间（Middle）和底部（Lower）</li><li>CTRL-u/f 翻页，zz 把当前行放到屏幕中间</li></ul><p>以上这些命令，看不懂记不住的话，多用用多练习几次，这里附上一份 <a href=\"https://link.zhihu.com/?target=https%3A//www.fprintf.net/vimCheatSheet.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vim 命令速查表</a>。</p><hr/><h2>Share</h2><p><b>机器学习中的朴素贝叶斯分类</b></p><p>这篇内容是我学习的学习笔记，稍作整理，分享给大家。</p><h3>贝叶斯定理</h3><p>朴素贝叶斯算法起源于上世纪四五十年代，它基于的贝叶斯定理如下公式所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9c33532b4e3f244fb56144d7a8149511_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"468\" data-original=\"https://pic2.zhimg.com/v2-9c33532b4e3f244fb56144d7a8149511_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;468&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"468\" data-original=\"https://pic2.zhimg.com/v2-9c33532b4e3f244fb56144d7a8149511_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9c33532b4e3f244fb56144d7a8149511_b.jpg\"/></figure><p>我们先来看一个例子：</p><p>一家生产某种产品的工厂有两台机床，也会生产出正品和次品，一共生产了 1000 个产品</p><ul><li>机器一：30 个/小时，机器二：20 个/小时</li><li>所有的产品中有 1% 的次品</li><li>在所有次品中，50% 出自机器一，50% 出自机器二</li><li><b>问题：求生二号机床生产的产品是次品的概率？</b></li></ul><p>解答：本题使用贝叶斯公式就能很好地解决问题</p><ul><li>P(Mach 1) = 30/50 = 0.6</li><li>P(Mach 2) = 20/50 = 0.4</li><li>P(Defect) = 1%</li><li>P(Mach 1 | Defect) = 50%</li><li>P(Mach 2 | Defect) = 50%</li><li>P(Defect | Mach 2) = ?</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-06c86459f5089dc258f6d878384f8b73_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"1044\" data-original=\"https://pic4.zhimg.com/v2-06c86459f5089dc258f6d878384f8b73_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1044&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1044\" data-original=\"https://pic4.zhimg.com/v2-06c86459f5089dc258f6d878384f8b73_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-06c86459f5089dc258f6d878384f8b73_b.png\"/></figure><p>另一个角度（方法二）：</p><ul><li>1000 个产品中，600 个来自机器一，400 个来自机器二</li><li>1000 个产品中 1% 的有问题 = 10 个</li><li>10 个中有 50% 来自机器二 = 5 个</li><li>机器二生产出来的产品是次品的概率 = 5/400 = 0.0125</li></ul><p>其实就只是在贝叶斯公式的上下各乘了 1000，但胜在思路清晰：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b16386256d0bc759f886d161fbb389ce_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"934\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"934\" data-original=\"https://pic3.zhimg.com/v2-b16386256d0bc759f886d161fbb389ce_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;934&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"934\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"934\" data-original=\"https://pic3.zhimg.com/v2-b16386256d0bc759f886d161fbb389ce_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b16386256d0bc759f886d161fbb389ce_b.png\"/></figure><p>问题：为什么有方法二还要使用贝叶斯公式呢？</p><ul><li>因为在实际生产过程中，概率是很方便知晓的，而总数中的个数是不太方便知道的</li><li>计算 P(Defect | Mach 1)</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e868746175fbf84b634f93fc190a44fb_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"1044\" data-original=\"https://pic4.zhimg.com/v2-e868746175fbf84b634f93fc190a44fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1044&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1044\" data-original=\"https://pic4.zhimg.com/v2-e868746175fbf84b634f93fc190a44fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e868746175fbf84b634f93fc190a44fb_b.png\"/></figure><h3>朴素贝叶斯分类器 - 原理</h3><p>首先我们看一下贝叶斯公式：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9c33532b4e3f244fb56144d7a8149511_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"468\" data-original=\"https://pic2.zhimg.com/v2-9c33532b4e3f244fb56144d7a8149511_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;468&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"468\" data-original=\"https://pic2.zhimg.com/v2-9c33532b4e3f244fb56144d7a8149511_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9c33532b4e3f244fb56144d7a8149511_b.jpg\"/></figure><p>P(A|B) 称为条件概率，或者后验概率，而 P(B|A) 和 P(B) 并不完全是概率，因为它们表示的是特征，所以这两个概率又被称为“似然 Likelihood”。</p><p>我们再来看一个例子：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ff55ce5fbfd61ddda4b6e26c2a452ae4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1127\" data-rawheight=\"663\" class=\"origin_image zh-lightbox-thumb\" width=\"1127\" data-original=\"https://pic1.zhimg.com/v2-ff55ce5fbfd61ddda4b6e26c2a452ae4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1127&#39; height=&#39;663&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1127\" data-rawheight=\"663\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1127\" data-original=\"https://pic1.zhimg.com/v2-ff55ce5fbfd61ddda4b6e26c2a452ae4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ff55ce5fbfd61ddda4b6e26c2a452ae4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这个例子的问题是：根据年龄和薪水，判断一个新的员工是走路上班还是开车上班</p><ul><li>步骤一</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-dd9f8330e5509e3196469d66f621a04b_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"732\" data-original=\"https://pic4.zhimg.com/v2-dd9f8330e5509e3196469d66f621a04b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;732&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"732\" data-original=\"https://pic4.zhimg.com/v2-dd9f8330e5509e3196469d66f621a04b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-dd9f8330e5509e3196469d66f621a04b_b.png\"/></figure><ol><li>求 P(Walks)，抽一个人他是走路上班的概率，这个概率被称为“先验概率 Prior Probability”</li><li>求 P(X)，随机在数据空间中抽一个点，这个点和我们新用户之间的相似程度，即“似然 Likelihood”，似然是对特征的概率，或者叫 对特征的可能性</li><li>求 P(X|Walks)，已知一个用户是步行上班的，那么它的特征坐落在新用户特征周围的概率，即“边际似然 Marginal Likelihood”</li><li>求 P(Walks|X)，后验概率 Posterior Probability</li></ol><ul><li>步骤二<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3b23c94478e3c85c03a974e0738e6a29_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"754\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"754\" data-original=\"https://pic2.zhimg.com/v2-3b23c94478e3c85c03a974e0738e6a29_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;754&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"754\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"754\" data-original=\"https://pic2.zhimg.com/v2-3b23c94478e3c85c03a974e0738e6a29_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3b23c94478e3c85c03a974e0738e6a29_b.png\"/></figure><ol><ol><li>P(Drives)</li><li>P(X)</li><li>P(X|Drives)</li><li>P(Drives|X)</li></ol></ol><ul><li>步骤三</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9b9f25652dd9a363aeda3917b613167a_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"544\" data-rawheight=\"78\" class=\"origin_image zh-lightbox-thumb\" width=\"544\" data-original=\"https://pic3.zhimg.com/v2-9b9f25652dd9a363aeda3917b613167a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;544&#39; height=&#39;78&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"544\" data-rawheight=\"78\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"544\" data-original=\"https://pic3.zhimg.com/v2-9b9f25652dd9a363aeda3917b613167a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9b9f25652dd9a363aeda3917b613167a_b.png\"/></figure><p><br/>已知一个新用户的特征，分别求出他步行和开车上班的概率，这两个概率哪个比较大，新用户就会被分到哪一组<br/> </p><p>我们使用这种思路来进行试验：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-663078c55d9420d2f8212f6fb7754664_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"824\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb\" width=\"824\" data-original=\"https://pic1.zhimg.com/v2-663078c55d9420d2f8212f6fb7754664_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;824&#39; height=&#39;479&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"824\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"824\" data-original=\"https://pic1.zhimg.com/v2-663078c55d9420d2f8212f6fb7754664_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-663078c55d9420d2f8212f6fb7754664_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>步骤一，计算 P(Walks|X)，即「已知这个人的特征值落在 X 中（即下图中圈里），求他步行上班的概率」</li></ul><ol><li>P(Walks)<br/> 这个人走路上班的概率：</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-99ccb6069200385ad5cd4a7614016cec_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"794\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb\" width=\"794\" data-original=\"https://pic1.zhimg.com/v2-99ccb6069200385ad5cd4a7614016cec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;794&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"794\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"794\" data-original=\"https://pic1.zhimg.com/v2-99ccb6069200385ad5cd4a7614016cec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-99ccb6069200385ad5cd4a7614016cec_b.png\"/></figure><ol><ol><li>P(X)</li></ol></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2fc55c985e6e1c7beb71f79a6b6e8c94_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"823\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb\" width=\"823\" data-original=\"https://pic1.zhimg.com/v2-2fc55c985e6e1c7beb71f79a6b6e8c94_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;823&#39; height=&#39;477&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"823\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"823\" data-original=\"https://pic1.zhimg.com/v2-2fc55c985e6e1c7beb71f79a6b6e8c94_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2fc55c985e6e1c7beb71f79a6b6e8c94_b.jpg\"/></figure><p>在新数据点附近画一个小圈（圈的半径是一个参数，在算法中可调），看看圈中的点（不包含新数据点）在整个数据空间中所占的比例：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4dba3dc60b9eda9a1416a10be3eea829_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"964\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb\" width=\"964\" data-original=\"https://pic2.zhimg.com/v2-4dba3dc60b9eda9a1416a10be3eea829_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;964&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"964\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"964\" data-original=\"https://pic2.zhimg.com/v2-4dba3dc60b9eda9a1416a10be3eea829_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4dba3dc60b9eda9a1416a10be3eea829_b.png\"/></figure><ol><ol><li>P(X|Walks)<br/> </li></ol></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e4415245fbddb7dc4458e68e5bb25b5a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"822\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb\" width=\"822\" data-original=\"https://pic3.zhimg.com/v2-e4415245fbddb7dc4458e68e5bb25b5a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;822&#39; height=&#39;475&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"822\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"822\" data-original=\"https://pic3.zhimg.com/v2-e4415245fbddb7dc4458e68e5bb25b5a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e4415245fbddb7dc4458e68e5bb25b5a_b.jpg\"/></figure><p>已知这个人步行上班，求他的特征值落在图中圈里的概率：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3070f17e4511639e0301db975234413f_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1310\" data-rawheight=\"180\" class=\"origin_image zh-lightbox-thumb\" width=\"1310\" data-original=\"https://pic4.zhimg.com/v2-3070f17e4511639e0301db975234413f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1310&#39; height=&#39;180&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1310\" data-rawheight=\"180\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1310\" data-original=\"https://pic4.zhimg.com/v2-3070f17e4511639e0301db975234413f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3070f17e4511639e0301db975234413f_b.png\"/></figure><ol><ol><li>P(Walks|X)<br/></li></ol></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1247c489f0f4df76782a4b9156f93f61_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"530\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb\" width=\"530\" data-original=\"https://pic2.zhimg.com/v2-1247c489f0f4df76782a4b9156f93f61_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;530&#39; height=&#39;118&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"530\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"530\" data-original=\"https://pic2.zhimg.com/v2-1247c489f0f4df76782a4b9156f93f61_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1247c489f0f4df76782a4b9156f93f61_b.jpg\"/></figure><ul><li>步骤二，计算 P(Drives|X) ，即「已知这个人的特征值落在 X 中（即下图中圈里），求他开车上班的概率」 </li></ul><ol><li>P(Drives) = 20/30</li><li>P(X) = 4/30</li><li>P(X|Drives) = 1/20</li><li>P(Drives|X)<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4c753b37d09a8aaa989c2d3d0feae516_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb\" width=\"538\" data-original=\"https://pic3.zhimg.com/v2-4c753b37d09a8aaa989c2d3d0feae516_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;538&#39; height=&#39;118&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"538\" data-original=\"https://pic3.zhimg.com/v2-4c753b37d09a8aaa989c2d3d0feae516_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4c753b37d09a8aaa989c2d3d0feae516_b.jpg\"/></figure><ul><li>步骤三，P(Walks|X) v.s. P(Drives|X)<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f00c761ad4969c3f9caca15b1544fd4b_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"78\" class=\"origin_image zh-lightbox-thumb\" width=\"768\" data-original=\"https://pic4.zhimg.com/v2-f00c761ad4969c3f9caca15b1544fd4b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;768&#39; height=&#39;78&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"78\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"768\" data-original=\"https://pic4.zhimg.com/v2-f00c761ad4969c3f9caca15b1544fd4b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f00c761ad4969c3f9caca15b1544fd4b_b.png\"/></figure><p>因为 P(Walks|X) &gt; P(Drives|X)，所以这个新数据点被分到了走路上班这个类</p><h3>朴素贝叶斯的几个问题</h3><ul><li>Q1：为什么称为“朴素 Naïve”？</li><li>A1：在应用朴素贝叶斯之前，我们做了一个假设，即<b>数据的所有特征都是相互独立的</b>，但是在例子中，其实薪水和年龄之间并不是独立的（年龄越大经验越多薪水也就越来越高），但是在这个例子中这两个变量的相关性不是特别高，如果相关性很高的话，那么在计算圈中点的个数的时候，会有一点问题</li><li>Q2：似然函数 P(X) 的消去</li><li>A2：似然的计算</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-807d06300e1c9a694b800b1f47969aac_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb\" width=\"760\" data-original=\"https://pic1.zhimg.com/v2-807d06300e1c9a694b800b1f47969aac_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;760&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"760\" data-original=\"https://pic1.zhimg.com/v2-807d06300e1c9a694b800b1f47969aac_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-807d06300e1c9a694b800b1f47969aac_b.png\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-19bbfaea9066f44b561fe6494e93fbb6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1370\" data-rawheight=\"155\" class=\"origin_image zh-lightbox-thumb\" width=\"1370\" data-original=\"https://pic3.zhimg.com/v2-19bbfaea9066f44b561fe6494e93fbb6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1370&#39; height=&#39;155&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1370\" data-rawheight=\"155\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1370\" data-original=\"https://pic3.zhimg.com/v2-19bbfaea9066f44b561fe6494e93fbb6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-19bbfaea9066f44b561fe6494e93fbb6_b.jpg\"/></figure><ul><li>Q3：大于两类的情况，如何应用朴素贝叶斯？</li><ul><li>假如有另外一群人坐公交去上班</li><li>同样对三个分类计算后验概率，然后把待分类目标分到最大的后验概率那一组去</li></ul></ul>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73577941", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 15 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 28. Implement strStr()</li><li>Review: 12 Things I Learned During My First Year as a Machine Learning Engineer</li><li>Tip: Vim 插入模式中的一些小技巧</li><li>Share: 最近的一些感想</li></ul><hr/><h2>Algorithm</h2><p><b>28. Implement strStr()</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/implement-strstr/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">28. Implement strStr()</a></p><p>难度：Easy</p><p>题意：实现 <a href=\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/strstr/811469\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">strStr()</a> 函数。</p><p>给定一个 <code>haystack</code> 字符串和一个 <code>needle</code> 字符串，在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置 (从 0 开始)。如果不存在，则返回 <b>-1</b>。</p><p>示例一：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: haystack = &#34;hello&#34;, needle = &#34;ll&#34;\nOutput: 2</code></pre></div><p>示例二：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: haystack = &#34;aaaaa&#34;, needle = &#34;bba&#34;\nOutput: -1</code></pre></div><p>说明:</p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0。这与 C 语言的 <a href=\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/strstr/811469\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">strstr()</a> 以及 Java的 <a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/7/docs/api/java/lang/String.html%23indexOf%28java.lang.String%29\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">indexOf()</a> 定义相符。</p><p>解法：</p><p>本题实现了 Python 字符串的内置函数 <code>find()</code>的功能，思路比较直接，直接循环读取 <code>haystack</code> 的每一个字符，如果从这个字符开始的 <code>len(needle)</code> 个长度的字符串都与 <code>needle</code> 相同，那么返回当前的位置，否则返回 -1。</p><p>代码：</p><p>使用切片操作：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">strStr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">haystack</span><span class=\"p\">,</span> <span class=\"n\">needle</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type haystack: str\n</span><span class=\"s2\">        :type needle: str\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">haystack</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">needle</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">haystack</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">needle</span><span class=\"p\">)]</span> <span class=\"o\">==</span> <span class=\"n\">needle</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">i</span>\n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span></code></pre></div><p>不使用切片操作：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">strStr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">haystack</span><span class=\"p\">,</span> <span class=\"n\">needle</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type haystack: str\n</span><span class=\"s2\">        :type needle: str\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">needle</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"mi\">0</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">helper</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">):</span>\n            <span class=\"n\">haystack_p</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n            <span class=\"n\">needle_q</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n            <span class=\"k\">while</span> <span class=\"n\">needle_q</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">needle</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">haystack</span><span class=\"p\">[</span><span class=\"n\">haystack_p</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">needle</span><span class=\"p\">[</span><span class=\"n\">needle_q</span><span class=\"p\">]:</span>\n                    <span class=\"k\">return</span> <span class=\"bp\">False</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"n\">haystack_p</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                    <span class=\"n\">needle_q</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">return</span> <span class=\"bp\">True</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">haystack</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">needle</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">helper</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">):</span>\n                <span class=\"k\">return</span> <span class=\"n\">i</span>\n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span></code></pre></div><p>时间复杂度 O((M-N)N)，这里 M 为 <code>haystack</code> 的长度，N 为 <code>needle</code> 的长度，再乘以一个 N 是因为切片操作或者 <code>helper()</code> 需要 <code>len(needle)</code> 次操作；空间复杂度为 O(1)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/12-things-i-learned-during-my-first-year-as-a-machine-learning-engineer-2991573a9195\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">12 Things I Learned During My First Year as a Machine Learning Engineer</a></b></p><p>这周阅读了一篇 Medium 推送的文章，作者描述了他作为一个机器学习工程师的第一年中学到的 12 件事，文章语言比较口语化，有些句子的意思需要推测，阅读起来有些挑战。</p><ul><li>业务一直围绕着数据</li><li>沟通一直是比技术更难的问题</li><li>稳定 &gt; 最新的技术（通常来说是这样）</li><li>机器学习问题中的两个鸿沟：从课程到项目、从 notebook 到生产</li><li>二八原则</li><li>阅读论文的问题</li><li>成为你自己最大的怀疑者</li><li>开发一些小玩具应用来学习</li><li>小黄鸭调试法</li><li>重新起草一个模型已经不是非常必要</li><li>数学和代码的问题</li><li>工作的时效性</li></ul><hr/><h2>Tips</h2><p><b>Vim 插入模式中的一些小技巧</b></p><ul><li>Ctrl+h 删除字符</li><li>Ctrl+w 删除单词</li><li>Ctrl+u 删除一行</li><li>Ctrl+b 前移一个字符</li><li>Ctrl+f 后移一个字符</li><li>Ctrl+a 移动到当前行的最前面</li><li>Ctrl+e 移动到当前行的最后面</li><li>Ctrl+c/[ 功能同Esc 切换insert和normal模式</li><li>gi 快速跳转到最后一次编辑的地方并进入插入模式</li></ul><p>以上这些快捷键可以用在很多地方，比如终端。</p><hr/><h2>Share</h2><p><b>最近的一些感想</b></p><p>这周结束休假，从国内回到法国。回国这段时间，对国内的行情了解了不少，但是同样也看到了很多其他的可能性，太多的信息反到让我有些迷茫。回来的前一天晚上，我和 @天涯 聊了不少，让我对于眼前的困惑释然了许多，我需要静下心来，把看到的可能性都想清楚想明白，就像采铜在《精进》中提供的分析方法一样，根据自己的真实需求对每一个选择的各个方面进行考量。</p><p>另外这次回国让我明白了一点，真正决定你生活质量的，不是外在的环境，而是自己的心态，所以我决定重新拾起积极的态度，从小事做起，用行动来改变心态，从而能达到改变生活质量的目的。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72612259", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 14 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 20. Valid Parenthese</li><li>Review: Predicting Stock Price with LSTM</li><li>Tip: 几种查询 API 文档的方式</li><li>Share: 关于健身的一些常识和误区</li></ul><hr/><h2>Algorithm</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/valid-parentheses/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">20. Valid Parenthese</a></b></p><p>题目：20. Valid Parenthese</p><p>难度：Easy</p><p>题意：给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p>示例 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;()&#34;\nOutput: true</code></pre></div><p>示例 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;()[]{}&#34;\nOutput: true</code></pre></div><p>示例 3：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;(]&#34;\nOutput: false</code></pre></div><p>示例 4：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;([)]&#34;\nOutput: false</code></pre></div><p>示例 5：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;{[]}&#34;\nOutput: true</code></pre></div><p>解法：</p><blockquote>本题解法参考了B站up主 <i>Michelle 小梦想家</i> 的<a href=\"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av45842632\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个视频</a>。</blockquote><p><b>栈</b>这一数据结构非常适合在本题中使用，同时对于匹配问题，使用查找表找出每个左括号对应的右括号也是很好的思路。</p><p>首先我们创建一个空的栈 <code>stack</code>，再创建一个对应括号的查找表如下：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"n\">lookup</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;(&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;)&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;[&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;{&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;}&#39;</span><span class=\"p\">}</span></code></pre></div><p>然后对给定的字符串按位进行读取： </p><ul><li>如果读取到的括号在查找表中，那么说明是左括号，将其入栈； </li><li>如果读取到的括号不在查找表中，那么说明是右括号，我们将栈顶的括号出栈，并在查找表中进行查找，再与读取到的括号进行对比，如果相同，那么说明匹配完毕，如果不同，那么说明匹配已经出错，返回 False； </li><li>另外还有一种情况，就是如果第一个读取到的括号为 <code>)</code>、<code>]</code>、<code>}</code> 这种右括号，此时 <code>stack</code> 为空，那么应该直接返回 False，所以在这里也加上一个条件 <code>if len(stack) == 0</code>； </li><li>最后应该判断输入的字符串是否为空字符串，如果是，那么也认为是有效的。</li></ul><p>代码如下：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isValid</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type s: str\n</span><span class=\"s2\">        :rtype: bool\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n\n        <span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">lookup</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;(&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;)&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;[&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;{&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;}&#39;</span><span class=\"p\">}</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">each</span> <span class=\"ow\">in</span> <span class=\"n\">s</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">each</span> <span class=\"ow\">in</span> <span class=\"n\">lookup</span><span class=\"p\">:</span>\n                <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">each</span><span class=\"p\">)</span>\n            <span class=\"k\">elif</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"ow\">or</span> <span class=\"n\">lookup</span><span class=\"p\">[</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()]</span> <span class=\"o\">!=</span> <span class=\"n\">each</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">False</span>\n\n        <span class=\"k\">return</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/predicting-stock-price-with-lstm-13af86a74944\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Predicting Stock Price with LSTM</a></b></p><p>这周阅读了 Medium 上 TowardsDataScience 推送的一篇文章 <i>《Predicting Stock Price with LSTM》</i>。在这篇文章中，作者详细介绍了他是如何使用 LSTM（长短期记忆网络）来预测通用公司的股票价格的过程。步骤如下：</p><ol><li>读取与分析数据（Pandas）</li><li>数据归一化（SkLearn）</li><li>将数据转换成时间序列和监督学习问题</li><li>建立模型（Keras）</li><li>模型微调（<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40asutoshnayak/finding-the-right-architecture-for-neural-network-b0439efa4587\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个系列的下一篇文章</a>）</li><li>训练、预测与可视化结果</li><li>作者认为有用的技巧&amp;工具（这个系列的<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40asutoshnayak/tools-tips-critical-to-any-machine-learning-project-f01b59ad01e6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">最新文章</a>）</li></ol><p>文章讲述比较详细，并给出了代码，作者为这个项目写了一系列的文章，具体可以参考<a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/%40asutoshnayak\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这里</a>。</p><hr/><h2>Tips</h2><p><b>几种查询 API 文档的方式</b></p><p>常用的几种查询 API 文档的方式： </p><ul><li>Pycharm 中的 ⌘-B 可以跳转到定义 </li><li>IPython 中在函数后加上问号(?)可以查询该函数的定义</li><li>Mac 上的 Dash，Windows 和 Linux 上的 Zeal，在线版的 <a href=\"https://link.zhihu.com/?target=https%3A//devdocs.io/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">devdocs.io/</span><span class=\"invisible\"></span></a></li></ul><hr/><h2>Share</h2><p><b>关于健身的一些常识和误区</b></p><p>最近看完了斌卡的《硬派健身》，对于我这样的健身小白来说，的确起到了很好的扫盲作用，大致上明白了健身的一些常识和误区，其实自己也不算行家，暂且列下几点，算是总结：</p><ol><li>健身的目的，对于我来说，不仅在于拥有健康的体魄，更是一种生活中的减压方式，也是向内寻找自己的一种方式，发现囿于日常生活中的自己，并跳出来；</li><li>好身材就是瘦且有型——大肌群是最重要的：胸背臀腿。并且训练大肌群会促进合成生长激素与睾酮，减脂效果更好。我健身以来，基本上没有做过有氧，只做大肌群的力量训练，除了胸围臂围长了一点意外，体重从健身之前的 70 kg 减少到了现在的 67 kg；</li><li>节食减肥不可取，不仅会导致暴食让你吃得更多，而且这种方式减肥极其容易反弹，因为自然选择让我们成为那些「狂吃不止囤积脂肪挨过饥荒」的猴子🐒的后代；</li><li>有氧运动消耗的总热量和脂肪，要少于同等时间长度的高强度无氧阻抗训练和 HIIT 训练，且对于体重正常的人来说，有氧效果很差，对于超重者，有氧运动反而会因为脂肪和关节的共振导致损伤；</li><li>强推 HIIT；</li><li>健身之后肌肉酸痛，学名叫「延迟性肌肉疼痛 DOMS」，与肌肉纤维断裂和肌肉组织受损有关，是正常现象，在酸痛已经出现的情况下，继续运动能促进肌肉内血液循环加速，可以有效缓解当前的疼痛感；</li><li>下班之后很累，其实是由于神经系统紧张以及长时间从事单调的工作而产生的主观疲劳，这种疲劳是可以通过适当的运动来缓解的，运动会比同样条件下听音乐起到更好的缓解疲劳、集中注意力的的效果；</li><li>空腹训练更能消耗脂肪，但有限脑血管疾病的人要尽量避免做空腹训练，一般空腹训练前一定要多喝水；</li><li>对于大多数人来说，健身房训练都是要好过无器械健身即自重训练的，健身房的器械具有自重训练没有的安全、可控和针对性；</li><li>骑车训练对于减肥来说，在热量消耗、脂肪氧化率和脂肪供能比例等方面远远不如跑步，并且跑步的减肥作用可以随着身体水平的提高而提高，但是骑车也有不容易伤到关节和身体等优势；</li><li>关于关节异响，只要符合这几种情况，即可判断为生理性异响，并无大碍：只在关节运动时响、响的时候没有特别疼痛不适的感觉。但如果不符合，那么最好去医院检查；</li><li>对于普通人来说，深蹲训练不仅不会增加膝盖受伤的概率，反而因为能提高肌肉质量、改善关节周围组织功能，而对关节疼痛和炎症起到缓解作用，另外深蹲还能增加与保持骨密度，防止骨质疏松；</li><li>训练前拉伸会影响肌肉的最大力量，消除肌肉的自我保护机制而导致容易受伤，不应作为热身选择，而训练后拉伸则能大大改善身体的柔韧度、增加力量，减少受伤概率（作者建议使用 PNF 拉伸法）；</li><li>念动合一：在训练时将全部注意力集中到训练部位，能够提升训练效果，而且这不是什么迷信；</li><li>减脂与增肌可以同时进行，至少正确的运动塑身（抗阻+有氧）就是同时进行减脂和增肌的；</li><li>健身房的选择：位置、器械数量种类和功能、饮水机、洗澡、清洁、空气状况、泳池等；</li><li>食物的<b>血糖生成指数——GI 值</b>是一个非常值得参考的指标，简单来说，高 GI 值的食物吃下去容易被存储为脂肪，以及容易饿，具体与胰岛素的水平和分泌有关，这里不展开说，结论是，日常生活中可以多吃低 GI 食物，少吃高 GI 食物，但是运动之后多吃高 GI 食物可以更好地促进身体的吸收和恢复；</li><li>高蛋白饮食可以促进减脂，对维持体重、防止反弹也有很好的效果，因为吃下去的蛋白质其实不是能全部被消化吸收，消化不掉的会变成尿素排出体外，不像脂肪和碳水会以脂肪的形式储存在身体中。另外，蛋白质吃得多能增加基础代谢。最后，力量训练后的 3 小时内，身体会加速合成蛋白质，所以可以在健身中和健身后摄入蛋白粉或者脱脂牛奶来提高增肌效果；</li><li>碳水对于减脂增肌也很重要，尤其是高低 GI 值的食物的分配；</li><li>对于脂肪，训练前、训练中以及训练后的 2 个小时之内，都不要摄入脂肪，因为会影响到生长激素的生成水平，导致减脂增肌效果不佳，其他时间摄入适量的脂肪反而对减脂效果有益；</li><li>关于食欲：有氧运动可能会让食欲增强，让身体处于增加体脂体重的状态，无氧运动可能会让食欲下降，让身体处于减少体脂体重的状态；短期运动的话，结论可能正相反；原因与瘦素和生长激素的分泌有关；</li><li>纯瘦猪肉与瘦牛肉和鸡胸肉相比，营养价值并不差，甚至各有所长，对于健身者，吃瘦猪肉的增肌效果可能比瘦牛肉和鸡胸肉的效果更好，因为瘦猪肉的肌酸含量更高，对于增长肌肉和增强力量特别有效；</li><li>训练计划非常重要，好的训练计划能让你事半功倍。</li></ol><p>以上。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71656049", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 13 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 9. Palindrome Number</li><li>Review: Why Swift may be the next big thing in Deep Learning</li><li>Share 1: 知乎僵尸粉以及我的看法</li><li>Share 2: 半年总结</li></ul><hr/><h2>Algorithm</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/palindrome-number\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">9. Palindrome Number</a></p><p>题目：9. Palindrome Number</p><p>难度：Easy</p><p>题意：判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例一：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 121\nOutput: true</code></pre></div><p>示例二：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</code></pre></div><p>示例三：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.</code></pre></div><p>解法：</p><blockquote> 本题解法参考了B站up主_Michelle小梦想家_的<a href=\"https://link.zhihu.com/?target=https%3A//b23.tv/av45840363\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个视频</a>。<br/> </blockquote><p>回文数 思路：由于题目要求不使用字符串方法，所以这里我构造另外一个数字，使用取余和地板除法，最后去掉负数并比较原数字和新数字。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isPalindrome</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">    :type x: int\n</span><span class=\"s2\">    :rtype: bool\n</span><span class=\"s2\">    &#34;&#34;&#34;</span>\n    <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">):</span>\n        <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">%</span> <span class=\"mi\">10</span>\n        <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">num</span> <span class=\"o\">*</span> <span class=\"mi\">10</span> <span class=\"o\">+</span> <span class=\"n\">tmp</span>\n        <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">//</span> <span class=\"mi\">10</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span> <span class=\"ow\">and</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">num</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"bp\">True</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"bp\">False</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//link.medium.com/ZJk1duUrWX\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Why Swift may be the next big thing in Deep Learning</a></p><p>这周阅读了 Medium 上的文章《<a href=\"https://link.zhihu.com/?target=https%3A//link.medium.com/ZJk1duUrWX\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Why Swift may be the next big thing in Deep Learning</a>》。</p><p>文章讲解了以下内容：</p><p>Swift 的公司支持：Chris Lattner 在苹果任职期间发明了 Swift，但是现在他在 Google Brain 工作；</p><p>S4TF 不仅仅是一个标准库：S4TF 是 Swift 的一个分支，这意味着它是一门语言；</p><p>Swift 速度很快：正如其名，Swift 非常快，它有着和 C 比肩的数值计算速度，且没有内存安全问题，并且它还很容易学。Lattner 为 Swift 专门设计的 LLVM 编译器也非常强大；</p><p>在 Swift 中你可以使用 Python、C 和 C++：你可以直接在 Swift 中 import 你想使用的任何 Python 或 C/C Swift 可以是一个底层语言：如 Lattner 所说，Swift 有很多 LLVM 的语法糖，这意味着 Swift 非常接近底层，这也从另一个侧面说明 swift 非常快。</p><p>文章通俗易懂，简洁明了。</p><hr/><h2>Share 1</h2><p><b>知乎僵尸粉以及我的看法</b></p><p>大概是上周开始，我的知乎账号的粉丝开始增加，虽然我并没有写什么回答，知乎仅仅是我写 ARTS 打卡的地方，但聊胜于无，最初我还是很开心的。但过了几天我慢慢发现，关注我的粉丝都大多是关注数为 56、0 回答 0 赞同 0 感谢的「三零用户」，而且这种粉丝的数量还在急剧上升，最近两天日均涨粉量已经超过 70，我都怀疑自己是不是被别人买了僵尸粉。</p><p>一番搜索过后，我发现不少人有和我一样的困扰，涨粉的原因是我们都参与了知乎的「知友推荐计划」，这个计划的原意是「让新知友跟随你的动态，更快地融入知乎社区」，但我个人感觉就像官方买粉一样，其实对内容创作者而言并不是什么好事情。一是因为如果这些用户是僵尸粉，那么其实并没有为创作者带来任何实质性的利好，二是如果这些用户不是僵尸粉，那么像我这样的小透明也并不会起到引导新人的作用，三是作为一个资深小透明，我其实并不想为知乎贡献什么，知乎似乎已经变味，它的内容筛选机制决定了这个社区的走向，因为知乎以赞同数作为排序的依据，答案就一定是这批点赞的用户最低认知水平以上的合集，所以任何类型的问题（回答），认知水平最低人群的最大公约数就约等于赞同数，再加上知乎的目标用户的下沉，这就导致现在的「高赞答案未必高质」，抖机灵写段子的答案越来越多，认认真真写回答做科普的人越来越少，不过这样流量也越来越大。</p><p>我能理解知乎应该是做了抉择的，也能理解它的抉择，但我不喜欢它了。</p><hr/><h2>Share 2</h2><p><b>半年总结</b></p><p>这周回北京母校，没有 Tips 分享，正好今天是本周、本月和上半年的最后一天，我想写一写自己的上半年总结。</p><p>先调出去年年末立下的 Flag：</p><ol><li>2018 年很少吃早饭，所以 2019 年立的第一个 Flag 就是，坚持每天 9 点之前吃早饭。<b><i>养成了习惯</i></b></li><li>2018 年身体不好，长期的疲劳和伏案工作学习让身体素质下降很多，所以 2019 年要重新开始健身，控制饮食和作息时间，把体重控制在 130 斤。<b><i>从最胖的时候 140 斤，5 月开始健身，到现在健身快两个月了，体态纠正了很多，走路也比较有自信，体重降到了 134，不过这里重新定个目标，把体重升到 140，但是小肚子减掉，体脂控制在15% 左右</i></b></li><li>2018 年读了不少书，听了不少播客，拓展了视野，提升了认知，2019 年要把这两个习惯保持下去，目标是读完 50 本非虚构类书籍。<b><i>目前读完了《人类简史》、《硬派健身》、《带一本书去巴黎》，在读的有《香农传》、《你凭什么做好互联网》、《穷查理宝典》、《成为乔布斯》、《阅读是一座随身携带的避难所》、《精进》和《我是一个怪圈》，总结是目前为止读的太少，因为个人心理原因，除了那些本身就非常吸引我的书，对于其他的非虚构类书，我一直没办法安心下去读，落下太多，好在今年做了个很大的决定，对自己有莫大的帮助，今年争取能完成原定目标的 60%</i></b></li><li>在学习了张哥的《人人都该懂点投资理财》系列和长投网的小白课程之后，其实意识到了投资理财的重要性，但是随后的变故又让自己有些消沉和低迷，所以 2019 年在理财方面的目标是，赚取自己的第一笔被动收入。<b><i>由于复杂的原因，还没有开始挣属于自己的金钱，所以预计要到九月份开始，但在也大的星球和《穷查理宝典》里学了不少经验和理念，也算是为后期做些铺垫</i></b></li><li>自己的学术能力和编程技术同步提升，感觉这个不太好量化，「学完在极客时间上购买的技术相关的专栏」算不算？<b><i>开始了 ARTS 打卡，对算法有了一些新的理解，慢慢开始学会从分享中找到快乐（虽然不咋有人看），也开始注意写文章时的用词句法，锻炼了写作能力，另外看了几篇论文和 Medium 文章，专业和英语也有一些进步，但是不好量化</i></b></li><li>享受独处，继续向内探索自己，向外提升认知。<b><i>这次回国休假，亲戚朋友对我的评价都是「成熟了」，但也有「失去了本心和童真」的评价。也许成长就是这样，需要付出代价。生活也是这样吧，自己今后还是要多多学习「如何热爱生活」自己「如何把生活活出花样」，也许呢，生活在别处。</i></b></li></ol><p>再立一些好了：</p><p>1. 给老爸换手机</p><p>2. 给老妈买台新电脑</p><p>3. 去 10 个不同的城市玩</p><p>4. 调整饮食结构，健身，体脂控制到 15%</p><p>5. 输出 5 篇读书笔记，5 篇游记</p><p>就这些吧。以上。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69819500", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 12 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: 22. Generate Parentheses</li><li>Review: Using Machine Learning to Solve Real-World Problems</li><li>Tip: 删除 LaTeX 中的段落缩进</li><li>Share: 《Using Machine Learning to Solve Real-World Problems》翻译</li></ul><hr/><h2>Algorithm</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/generate-parentheses/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">22. Generate Parentheses</a></b></p><p>题目：22. Generate Parentheses</p><p>难度：Medium</p><p>题意：给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>示例：给出 n = 3，生成结果为：</p><div class=\"highlight\"><pre><code class=\"language-text\">[\n  &#34;((()))&#34;,\n  &#34;(()())&#34;,\n  &#34;(())()&#34;,\n  &#34;()(())&#34;,\n  &#34;()()()&#34;\n]</code></pre></div><p>解法：</p><blockquote>本题解法参考了B站up主<i>Michelle小梦想家</i>的<a href=\"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av45844036\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个视频</a>。</blockquote><p>本题使用了递归法，又即「回溯法」。思路是： 1. 如果当前剩下的左右括号的数目大于 0，那么直接添加左右括号到名为 <code>curr</code> 的当前字符串中； 2. 因为最后一个括号一定为右括号，所以如果右括号的数目为 0，说明左括号已经全部使用（匹配）完毕，那么就可以将当前字符串 <code>curr</code> append 进 result 中； 3. 检查当前剩下的右括号的数目是否小于左括号的数目，如果是，说明这样的匹配是错误的，那么直接跳出递归，终止程序</p><p>代码如下：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">generateParenthesis</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type n: int\n</span><span class=\"s2\">        :rtype: List[str]\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n\n        <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"p\">[]</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">helper</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">helper</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">curr</span><span class=\"p\">,</span> <span class=\"n\">n_left</span><span class=\"p\">,</span> <span class=\"n\">n_right</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">n_right</span> <span class=\"o\">&lt;</span> <span class=\"n\">n_left</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span>\n        <span class=\"k\">if</span> <span class=\"n\">n_right</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">curr</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">result</span>\n        <span class=\"k\">if</span> <span class=\"n\">n_left</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">helper</span><span class=\"p\">(</span><span class=\"n\">curr</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;(&#39;</span><span class=\"p\">,</span> <span class=\"n\">n_left</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n_right</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">n_right</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">helper</span><span class=\"p\">(</span><span class=\"n\">curr</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;)&#39;</span><span class=\"p\">,</span> <span class=\"n\">n_left</span><span class=\"p\">,</span> <span class=\"n\">n_right</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">)</span></code></pre></div><p>时间复杂度和空间复杂度的分析比较困难，这里参考 LeetCode 的结论，均为</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-68be725aabcd218e7dbeec07929b2a67_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"106\" data-rawheight=\"68\" class=\"content_image\" width=\"106\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;106&#39; height=&#39;68&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"106\" data-rawheight=\"68\" class=\"content_image lazy\" width=\"106\" data-actualsrc=\"https://pic4.zhimg.com/v2-68be725aabcd218e7dbeec07929b2a67_b.jpg\"/></figure><p>。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//blog.usejournal.com/using-machine-learning-to-solve-real-world-problems-97fb089d19ef%3Fmc_cid%3D44d40569b7%26mc_eid%3Dc2ab58e995\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Using Machine Learning to Solve Real-World Problems</a></b></p><p>这周 review 的文章是 Medium 上的一篇推荐文章，Using Machine Learning to Solve Real-World Problems。这篇文章是作者参加 Lambda School 课程的一篇笔记，笔记的内容是一项 Kaggle 比赛，使用 <a href=\"https://link.zhihu.com/?target=https%3A//www.drivendata.org/competitions/7/pump-it-up-data-mining-the-water-table/page/24/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DrivenData.org</a> 提供的数据，预测坦桑尼亚境内井水泵的好坏与是否需要维修，以节省金钱时间和人力。详细内容请看 Share 部分我的翻译版本。</p><hr/><h2>Tips</h2><p><b>删除 LaTeX 中的段落缩进</b></p><p>这个技巧看起来很简单，但是我发现我需要翻遍一页半的谷歌搜索结果才能找到答案。这里提供一下找到的方法。</p><p>LaTeX 会将前面有空行或用 <code>\\par</code> 标记定义的任何内容归类为一个新段落。默认情况下，LaTeX 会缩进每个段落的第一行。要关闭此功能，将以下内容放在文档顶部或.sty文件中：</p><div class=\"highlight\"><pre><code class=\"language-text\">\\setlength{\\parindent}{0in}</code></pre></div><hr/><h2>Share</h2><p><b>《Using Machine Learning to Solve Real-World Problems》翻译</b></p><a href=\"https://zhuanlan.zhihu.com/p/69816887\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">马克图布：《Using ML to Solve Real World Problems》翻译</a><p></p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69816887", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "《Using ML to Solve Real World Problems》翻译", 
            "content": "<blockquote>本文是《<a href=\"https://link.zhihu.com/?target=https%3A//blog.usejournal.com/using-machine-learning-to-solve-real-world-problems-97fb089d19ef%3Fmc_cid%3D44d40569b7%26mc_eid%3Dc2ab58e995\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Using Machine Learning to Solve Real-World Problems</a>》这篇文章的翻译版本，由于译者水平有限，欢迎批评指正。</blockquote><p>参加 <a href=\"https://link.zhihu.com/?target=https%3A//lambdaschool.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Lambda School</a> 的培训已经十周了，我们已经完成了一个端到端的机器学习项目。这个项目是我们班内的一个时长一周的 Kaggle 竞赛项目，它使用 <a href=\"https://link.zhihu.com/?target=https%3A//www.drivendata.org/competitions/7/pump-it-up-data-mining-the-water-table/page/24/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DrivenData.org</a> 提供的水井数据。基于这些数据预测坦桑尼亚境内井水泵的工作状况与维修需要，以节省金钱时间和人力。</p><p>这个项目对我们目前为止学到的这些知识进行了一个测试：数据获取、数据探索、数据整理、建立模型、超参调整、模型验证、模型解释，以及数据可视化。这篇博客将会关注于模型解释。如果你对更多的技术细节感兴趣，你可以在<a href=\"https://link.zhihu.com/?target=https%3A//github.com/JLDaniel77/Water-Pump-Project\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">我的 GitHub 仓库</a>上找到我的 Notebook。</p><h2>数据探索的结论</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8c883adb544bce0026094db21798d9ae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"580\" class=\"origin_image zh-lightbox-thumb\" width=\"468\" data-original=\"https://pic3.zhimg.com/v2-8c883adb544bce0026094db21798d9ae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;468&#39; height=&#39;580&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"580\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"468\" data-original=\"https://pic3.zhimg.com/v2-8c883adb544bce0026094db21798d9ae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8c883adb544bce0026094db21798d9ae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>建立模型之后，我建立了一个重要度排序报告。这个报告显示了「水量」这个特征对模型有最大的影响。「水量」有 5 个种类：<i>充足</i>、<i>不足</i>、<i>干涸</i>、<i>季节性</i>和<i>未知</i>。如下图所示，我们可以看出，有超过 5000 个<i>正常工作</i>的水泵具有<i>足够</i>的水量。然而，有超过 2000 个水泵具有<i>足够</i>的水量，但是<i>未正常工作</i>。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5cc68dfeda0854ab5949e445c8d73102_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb\" width=\"762\" data-original=\"https://pic3.zhimg.com/v2-5cc68dfeda0854ab5949e445c8d73102_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;762&#39; height=&#39;465&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"762\" data-original=\"https://pic3.zhimg.com/v2-5cc68dfeda0854ab5949e445c8d73102_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5cc68dfeda0854ab5949e445c8d73102_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从上图我们也可以看出，<i>未正常工作</i>的水泵有着最高的「干涸」水源。这很容易理解，因为一口干井会被放弃和忽略。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d5b085c7291d2ed7776a7497981f967f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"778\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb\" width=\"778\" data-original=\"https://pic4.zhimg.com/v2-d5b085c7291d2ed7776a7497981f967f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;778&#39; height=&#39;470&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"778\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"778\" data-original=\"https://pic4.zhimg.com/v2-d5b085c7291d2ed7776a7497981f967f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d5b085c7291d2ed7776a7497981f967f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上图显示，超过 4000 个<i>未正常工作</i>的水泵有着「好的」水质。这 2000 个<i>有充足水量</i>的<i>未正常工作</i>的水泵中的某些或全部水泵，也可能含有可饮用的水。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-95a933df9e1d8e2f8f141ba8567d48e8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"797\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"797\" data-original=\"https://pic1.zhimg.com/v2-95a933df9e1d8e2f8f141ba8567d48e8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;797&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"797\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"797\" data-original=\"https://pic1.zhimg.com/v2-95a933df9e1d8e2f8f141ba8567d48e8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-95a933df9e1d8e2f8f141ba8567d48e8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从上图我们可以看出，有接近 2000 个水质很好且水量充足的水泵<i>未正常工作</i>。很显然，这些水泵将会被优先考虑维修，但是，你如何知道哪一个水泵是第一个需要维修的呢？</p><p>你可以随机选择一批水泵然后查看每一个水泵是否需要维修。这看起来很合理，但是也可能完全是对时间和资源的浪费。事实上，基于下图训练数据中水泵状态的分布，我们得知我们有大约 46% 的机会正确地访问到一个<i>未正常工作</i>或<i>可以工作但需要维修</i>的水泵。这其实是一个恐怖的赔率。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-70b485221d29ec5cc7b6f28e0c450fe5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"432\" data-rawheight=\"117\" class=\"origin_image zh-lightbox-thumb\" width=\"432\" data-original=\"https://pic2.zhimg.com/v2-70b485221d29ec5cc7b6f28e0c450fe5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;432&#39; height=&#39;117&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"432\" data-rawheight=\"117\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"432\" data-original=\"https://pic2.zhimg.com/v2-70b485221d29ec5cc7b6f28e0c450fe5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-70b485221d29ec5cc7b6f28e0c450fe5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>我们如何改进结果？</h2><p>我们需要建立一个预测模型来加强我们「基于新的数据正确分类水泵」的能力。通过有限的数据，我们不可能去查看所有的 14000 多个水泵，所以我们需要一个有的放矢的方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-474395b235c46991391886b8e9c308d9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb\" width=\"610\" data-original=\"https://pic2.zhimg.com/v2-474395b235c46991391886b8e9c308d9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;610&#39; height=&#39;352&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"610\" data-original=\"https://pic2.zhimg.com/v2-474395b235c46991391886b8e9c308d9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-474395b235c46991391886b8e9c308d9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面这两个表格一个是分类报告，一个是混淆矩阵。为了简洁起见，我结合了<i>未正常工作</i>和<i>可以工作但需要维修</i>的水泵的结论。分类报告展示了我们模型的准确率（precision）、召回率（recall）和 F1 值（f1-score）；混淆矩阵展示了我们模型的真正（true positive）、真负（true negative）、假正（false positive）和假负（false negative）的数量。</p><p>由下图可知，「准确率」是真正数量在预测正数量中的占比，「召回率」是真正数量在所有正数量中的占比。混淆矩阵显示，我们的模型正确地将 6805 个水泵预测为<i>正常工作</i>，正确地将 5030 个水泵预测为<i>未正常工作</i>。然而，模型也错误地将 1530 个<i>未正常工作</i>的水泵预测为<i>正常工作</i>，将 993 个<i>正常工作</i>的水泵预测为<i>未正常工作</i>。</p><p>「F1 值」是准确率和召回率的平均值。我们使用这三个指标来检测我们模型的准确性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5aec207c6532ef94f9c84f545286e040_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"955\" class=\"origin_image zh-lightbox-thumb\" width=\"525\" data-original=\"https://pic1.zhimg.com/v2-5aec207c6532ef94f9c84f545286e040_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;525&#39; height=&#39;955&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"955\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"525\" data-original=\"https://pic1.zhimg.com/v2-5aec207c6532ef94f9c84f545286e040_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5aec207c6532ef94f9c84f545286e040_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>这如何与我们的实际情况相联系？</h2><p>假设我们的资源只能支持我们访问并维修 2000 个水泵，我们要确保将维修人员只送到<i>未正常工作</i>的水泵处。我们运行我们的模型然后排列出我们的预测值，然后选择出 2000 个模型预测为<i>未正常工作</i>的水泵。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-66f82e526367fca379553db85b8d4454_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"414\" data-rawheight=\"338\" class=\"content_image\" width=\"414\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;414&#39; height=&#39;338&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"414\" data-rawheight=\"338\" class=\"content_image lazy\" width=\"414\" data-actualsrc=\"https://pic1.zhimg.com/v2-66f82e526367fca379553db85b8d4454_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从我们前 2000 个预测中，我们发现我们的模型正确地将 1982 个水泵预测为<i>未正常工作</i>；这是 99.1% 的准确率。与之前随机选择样本的只有 46% 的准确率的方式相比，如果我们基于随机方式派出维修人员，我们会将他们送到 1080 个并不需要维修的水泵处去。这完全是对时间、金钱和人力的严重浪费。使用预测模型，我们可以最小化我们的损失，同时最大化我们对资源的利用率。</p>", 
            "topic": [
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "Kaggle", 
                    "tagLink": "https://api.zhihu.com/topics/20003862"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69394323", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 11 周", 
            "content": "<h2>ARTS 第 11 周</h2><hr/><h2>Contents:</h2><ul><li>Algorithm: <a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/roman-to-integer/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">13. Roman to Integer</a></li><li>Review: <a href=\"https://link.zhihu.com/?target=https%3A//datawhatnow.com/things-you-are-probably-not-using-in-python-3-but-should/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Things you’re probably not using in Python 3 – but should</a></li><li>Tip: 将 Jupyter Notebook 转换为其他格式</li><li>Share: 分享几个我获取有价值信息的渠道</li></ul><hr/><h2>Algorithm</h2><p><b>罗马数字到整型数字</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/roman-to-integer/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">13. Roman to Integer</a></p><p>难度：Easy</p><p>题意：</p><p>罗马数字包含以下七种字符: <code>I</code>，<code>V</code>，<code>X</code>，<code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><div class=\"highlight\"><pre><code class=\"language-text\">字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</code></pre></div><p>例如， 罗马数字 2 写做 <code>II</code>，即为两个并列的 1。12 写做 <code>XII</code>，即为 <code>X</code> + <code>II</code>。27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code>。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><p><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。 <code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。  <code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</p><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例一：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;III&#34;\nOutput: 3</code></pre></div><p>示例二：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;IV&#34;\nOutput: 4</code></pre></div><p>示例三：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;IX&#34;\nOutput: 9</code></pre></div><p>示例四：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;LVIII&#34;\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.</code></pre></div><p>示例五：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: &#34;MCMXCIV&#34;\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.</code></pre></div><p>解法：</p><blockquote>说明，本题解法参考了 B 站 up 主「Michelle 小梦想家」的<a href=\"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av45841108\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">题解过程</a>。</blockquote><p>此题理解题意并找到几个最重要的关键点，即可快速写出算法： 1. 最多两个字母成一对 2. 当前的字母是否比前一个读到的字母要大？如果大，那么这两个字母就是一对，否则不是一对 3. 判断如果是一对之后，那么需要直接计算这一对的数值，即「当前值」-「前一位的值」，但是之前由于是每一位都直接加在 result 上，所以这里需要把「前一位的值」再减掉，故这里计算一对的值的时候，需要减两次「前一位的值」，即「当前值」- 2 *「前一位的值」 4. 如果不是一对，那么直接加在 result 上即可</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">romanToInt</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type s: str\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n\n        <span class=\"n\">numeral_map</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;I&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;V&#39;</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">&#39;X&#39;</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"s1\">&#39;L&#39;</span><span class=\"p\">:</span> <span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"s1\">&#39;C&#39;</span><span class=\"p\">:</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"s1\">&#39;D&#39;</span><span class=\"p\">:</span> <span class=\"mi\">500</span><span class=\"p\">,</span> <span class=\"s1\">&#39;M&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1000</span><span class=\"p\">}</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)):</span>\n            <span class=\"n\">result</span> <span class=\"o\">+=</span> <span class=\"n\">numeral_map</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span> <span class=\"o\">-</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">numeral_map</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"ow\">and</span> <span class=\"n\">numeral_map</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span> <span class=\"o\">&gt;</span> <span class=\"n\">numeral_map</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]])</span> <span class=\"k\">else</span> <span class=\"n\">numeral_map</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">result</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//datawhatnow.com/things-you-are-probably-not-using-in-python-3-but-should/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Things you’re probably not using in Python 3 – but should</a></b></p><p>Python 3 是 Python 2 的全新升级版，有重大的改进。本文介绍 Python 3 到底增加了哪些功能。</p><p>简单罗列如下：</p><ul><li>f-strings (3.6+)</li><li>Pathlib (3.4+)</li><li>Type hinting (3.5+)</li><li>Enumerations (3.4+)</li><li>Built-in LRU cache (3.2+)</li><li>Extended iterable unpacking (3.0+)</li><li>Data classes (3.7+)</li><li>Implicit namespace packages (3.3+)</li></ul><p>所有的代码都可以在作者的 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/Weenkus/DataWhatNow-Codes/blob/master/things_you_are_probably_not_using_in_python_3_but_should/python%25203%2520examples.ipynb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GitHub</a> 上找到。</p><hr/><h2>Tips</h2><p><b>将 Jupyter Notebook 转换为其他格式</b></p><blockquote>本部分参考优达学城的 Jupyter 教程</blockquote><p>Notebook 是 JSON 文件，所以可以很轻松地把它转换为其他格式以方便使用。</p><p>Jupyter 附带了一个名为 <code>nbconvert</code> 的实用程序，可将 notebook 转换为 HTML、Markdown、幻灯片等格式。</p><p>例如，要将 notebook 转换为 HTML 文件，请在终端中使用</p><div class=\"highlight\"><pre><code class=\"language-bash\">jupyter nbconvert --to html notebook.ipynb</code></pre></div><p>要将 notebook 与不使用 notebook 的其他人共享，转换为 HTML 很有用。而要在博客和其他接受 Markdown 格式化的文本编辑器中显示 notebook，Markdown 很合适。</p><p>另外，通过 notebook 创建幻灯片也是非常受欢迎的功能之一，你可以打开<a href=\"https://link.zhihu.com/?target=https%3A//nbviewer.jupyter.org/format/slides/github/jorisvandenbossche/2015-PyDataParis/blob/master/pandas_introduction.ipynb%23/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个关于 Pandas 的示例</a>。</p><p>在 notebook 中创建幻灯片的过程像平常一样，但需要指定作为幻灯片的单元格和单元格的幻灯片类型。在菜单栏中，点击“View”（视图）&gt; “Cell Toolbar”（单元格工具栏）&gt; “Slideshow”（幻灯片），以便在每个单元格上弹出幻灯片单元格菜单。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8a4bf45a6d8e8f685cd15bf709d65631_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb\" width=\"482\" data-original=\"https://pic2.zhimg.com/v2-8a4bf45a6d8e8f685cd15bf709d65631_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;482&#39; height=&#39;167&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"482\" data-original=\"https://pic2.zhimg.com/v2-8a4bf45a6d8e8f685cd15bf709d65631_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8a4bf45a6d8e8f685cd15bf709d65631_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这会在每个单元格上显示一个下拉菜单，让你选择单元格在幻灯片中的显示方式。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-14488d25799f677be1693c07b0c80620_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"190\" class=\"origin_image zh-lightbox-thumb\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-14488d25799f677be1693c07b0c80620_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;482&#39; height=&#39;190&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"190\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-14488d25799f677be1693c07b0c80620_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-14488d25799f677be1693c07b0c80620_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Slides（幻灯片）是你从左向右移动的完整幻灯片。按向上或向下的箭头时，Sub-slides（子幻灯片）会出现在幻灯片中。Fragments（片段）最初是隐藏的，在你按下按钮时会出现。选择 Skip（忽略）会忽略幻灯片中的单元格，而选择 Notes（备注）会将为演讲者保留备注。</p><p>要通过 notebook 文件创建幻灯片，需要使用 <code>nbconvert</code>：</p><div class=\"highlight\"><pre><code class=\"language-bash\">jupyter nbconvert notebook.ipynb --to slides</code></pre></div><p>这只是将 notebook 转换为幻灯片必需的文件，你需要向其提供 HTTP 服务器才能真正看到演示文稿。 要转换它并立即看到它，请使用</p><div class=\"highlight\"><pre><code class=\"language-bash\">jupyter nbconvert notebook.ipynb --to slides --post serve</code></pre></div><p>这会在浏览器中打开幻灯片，让你可以演示它。</p><hr/><h2>Share</h2><p><b>分享几个我获取有价值信息的渠道</b></p><p>公众号：</p><ul><li>stormzhang</li><li>我就BB怎么了</li><li>我爱问帅张</li><li>caoz的梦呓</li><li>小道消息</li><li>MacTalk</li><li>路人甲TM</li><li>辉哥奇谭</li><li>三表龙门阵</li><li>也谈钱</li><li>小猫倩倩</li><li>理想屯（同名播客）</li></ul><p>RSS 订阅 &amp; 网站：</p><ul><li>阮一峰的网络日志</li><li>Medium</li><li>利器</li><li>酷壳 - CoolShell</li><li>Tim Ferriss’ Blog</li><li>少数派</li><li>小众软件</li><li>面向信仰编程</li><li>城堡阅读周刊</li><li>霍炬的博客</li></ul><p>邮件订阅：</p><ul><li>DailyIO</li><li>Wait but why</li><li>The Profile</li><li>Recomendo</li><li>News from the future</li><li>Wired</li><li>The Economist</li></ul>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68502572", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 10 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: <a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/majority-element-ii/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">229. Majority Element II</a></li><li>Review: <a href=\"https://link.zhihu.com/?target=https%3A//dev.to/lewismenelaws/what-is-aws-a-guide-for-beginners-p4l%3Fmc_cid%3D80ef9e3ee9%26mc_eid%3Dc2ab58e995\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What is AWS? A Guide for Beginners.</a></li><li>Tip: 分享一个百度网盘加速器</li><li>Share: Anaconda 简洁教程</li></ul><hr/><h2>Algorithm</h2><p><b>求众数 II</b> 题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/majority-element-ii/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">229. Majority Element II</a></p><p>难度：Medium</p><p>题意：给定一个大小为 n 的数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><p>示例一：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [3,2,3]\nOutput: [3]</code></pre></div><p>示例二：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [1,1,1,3,3,2,2,2]\nOutput: [1,2]</code></pre></div><p>提示：How many majority elements could it possibly have?</p><p>解法：这道题是上周求众数那一题的升级版，将出现次数由 n/2 变为了 n/3，并且限定了时空间复杂度，那么只能使用摩尔投票法了。题目里给了一个很重要的提示：最多可能有多少个「出现超过 <code>⌊ n/3 ⌋</code> 次」的元素？那么可以考虑到：如果有超过 2 个，也就是至少 3 个数字满足「出现的次数大于 n/3」，那么就意味着数组里总共有超过 3*(n/3) = n 个数字，这与已知的数组大小矛盾，所以，只可能有两个或者更少的「众数」。有了这层思考之后，我们就可以效仿上周的摩尔投票法，使用两个计数器 count1 与 count2 以及两个数字 candidate1 与 candidate2，其他思路与之前一致。另外，这题需要验证「众数」是否存在，那么就多了一个计数的过程。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">majorityElement</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :rtype: List[int]\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n\n        <span class=\"n\">candidate1</span><span class=\"p\">,</span> <span class=\"n\">candidate2</span><span class=\"p\">,</span> <span class=\"n\">count1</span><span class=\"p\">,</span> <span class=\"n\">count2</span> <span class=\"o\">=</span> <span class=\"bp\">None</span><span class=\"p\">,</span> <span class=\"bp\">None</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"n\">nums</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">num</span> <span class=\"o\">==</span> <span class=\"n\">candidate1</span><span class=\"p\">:</span>\n                <span class=\"n\">count1</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">elif</span> <span class=\"n\">num</span> <span class=\"o\">==</span> <span class=\"n\">candidate2</span><span class=\"p\">:</span>\n                <span class=\"n\">count2</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">elif</span> <span class=\"n\">count1</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"n\">candidate1</span><span class=\"p\">,</span> <span class=\"n\">count1</span> <span class=\"o\">=</span> <span class=\"n\">num</span><span class=\"p\">,</span><span class=\"mi\">1</span>\n            <span class=\"k\">elif</span> <span class=\"n\">count2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"n\">candidate2</span><span class=\"p\">,</span> <span class=\"n\">count2</span> <span class=\"o\">=</span> <span class=\"n\">num</span><span class=\"p\">,</span><span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">count1</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">count2</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n\n        <span class=\"n\">count1</span><span class=\"p\">,</span> <span class=\"n\">count2</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"n\">nums</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">num</span> <span class=\"o\">==</span> <span class=\"n\">candidate1</span><span class=\"p\">:</span>\n                <span class=\"n\">count1</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">if</span> <span class=\"n\">num</span> <span class=\"o\">==</span> <span class=\"n\">candidate2</span><span class=\"p\">:</span>\n                <span class=\"n\">count2</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"n\">candidates</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">if</span> <span class=\"n\">count1</span> <span class=\"o\">&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span><span class=\"o\">//</span><span class=\"mi\">3</span><span class=\"p\">:</span>\n            <span class=\"n\">candidates</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">candidate1</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">count2</span> <span class=\"o\">&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span><span class=\"o\">//</span><span class=\"mi\">3</span><span class=\"p\">:</span>\n            <span class=\"n\">candidates</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">candidate2</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">candidates</span></code></pre></div><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//dev.to/lewismenelaws/what-is-aws-a-guide-for-beginners-p4l%3Fmc_cid%3D80ef9e3ee9%26mc_eid%3Dc2ab58e995\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What is AWS? A Guide for Beginners.</a></b></p><p>这周阅读了一篇系统而简洁地介绍 AWS 的文章。AWS（Amazon Wes Services）是亚马逊的云服务，这篇文章对 AWS 的各项服务做了简洁明了的介绍，以及对「在何时应选何种服务」提供了很好的建议。包括：</p><ul><li>Amazon EC2</li><li>Amazon S3</li><li>Amazon Aurora</li><li>Amazon DynamoDB</li><li>Amazon Lambda</li><li>Amazon Lightsail</li><li>Amazon SageMaker</li></ul><hr/><h2>Tips</h2><p><b>分享一个百度网盘加速器</b></p><p>链接：<a href=\"https://link.zhihu.com/?target=https%3A//www.baiduwp.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">baiduwp.com/</span><span class=\"invisible\"></span></a></p><hr/><h2>Share</h2><p><b>Anaconda 简洁教程</b></p><p>在数据科学中，我们经常需要切换不同的 Python 虚拟环境以及安装经常使用的程序包，以便更轻松地处理多个项目。这个时候，我们就需要一个可以对虚拟环境和程序包进行高效管理的工具了，Anaconda 即是其中的一个很好的选择。</p><h3>Anaconda 是什么？</h3><p>Anaconda 其实是一个软件发行版（Distribution），它包含了<b>包和环境管理器 conda</b>、<b>Python</b> 以及非常多常用的<b>工具包和依赖项</b>（尤其是数据科学），所以使用 Anaconda 可以让你立即上手处理数据。如果你想要节省空间，也可以使用不包含那些工具包和依赖项的 <b>miniconda</b>。</p><h3>管理包</h3><p>包管理器是在计算机上安装库和依赖项的工具。如果你有使用 Python 的经验的话，那你对 <b>pip</b> 一定不陌生，它是 Python 默认的包管理器。而 conda 和 pip 非常相似，但是 conda 以数据科学的包为主，pip 更适合一般的用途。此外 conda 也支持为其他的语言提供包管理的功能，你可以通过它安装非 Python 的包。使用 conda 的同时你也可以使用 pip 来管理 Python 库。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4acabe0f996053339710c5a2feaef83f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1490\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb\" width=\"1490\" data-original=\"https://pic4.zhimg.com/v2-4acabe0f996053339710c5a2feaef83f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1490&#39; height=&#39;1002&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1490\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1490\" data-original=\"https://pic4.zhimg.com/v2-4acabe0f996053339710c5a2feaef83f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4acabe0f996053339710c5a2feaef83f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>环境</h3><p>除了可以管理包，conda 还提供环境管理的功能。另外两个很流行的环境管理工具是 <b>virtualenv</b> 和 <b>pyenv</b>。</p><p>环境能让你分隔用于不同项目的 Python 版本和包。比如你有两个项目需要使用不同版本的 numpy，因为你需要使用 numpy 最新版本的新功能，或者旧版本中的一些新版本已经不再支持的功能，最明智的做法是为这两个项目分别创建两个不同的 Python 环境，然后分别在这两个环境下工作。对于 Python 2 和 Python 3 也是如此。你可以很方便地将环境中的包列表导出为一个文件，并与你的代码保存在一起：<code>pip freeze &gt; requirements.txt</code>。</p><h3>如何安装 Anaconda</h3><p>Anaconda 是全平台通用软件。<a href=\"https://link.zhihu.com/?target=https%3A//www.anaconda.com/distribution\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">anaconda.com/distributi</span><span class=\"invisible\">on</span><span class=\"ellipsis\"></span></a> 上可以找到安装程序和说明。 安装了 Anaconda 之后，你的所有 Python 脚本以及程序会默认使用 Anaconda 附带的 Python，所以即是你的电脑上之前已经安装过 Python，也不会有任何影响。 选择 Python 3.7 版本（你也可以根据具体的需要选择 Python 2 的版本）。如果是 64 位操作系统，则选择 64 位安装程序，否则选择 32 位安装程序。完成安装后，会自动进入默认的 conda 环境，而且所有包均已安装完毕，如下面所示。可以在终端或命令提示符中键入 <code>conda list</code>，以查看你安装的内容。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-674ccd8b746493491c68ee02107917f2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1490\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb\" width=\"1490\" data-original=\"https://pic3.zhimg.com/v2-674ccd8b746493491c68ee02107917f2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1490&#39; height=&#39;1002&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1490\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1490\" data-original=\"https://pic3.zhimg.com/v2-674ccd8b746493491c68ee02107917f2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-674ccd8b746493491c68ee02107917f2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>管理包</h3><p>你可以很方便的使用 conda 安装和管理包：</p><ul><li>安装包：<code>conda install &lt;package_name&gt;</code></li><li>安装指定版本的包：<code>conda install &lt;package_name&gt;=&lt;version_number&gt;</code></li><li>安装多个包：<code>conda install &lt;package_name1&gt; &lt;package_name2&gt; &lt;package_name3&gt;</code> </li><li>卸载包：<code>conda remove &lt;package_name&gt;</code></li><li>更新包：<code>conda update &lt;package_name&gt;</code></li><li>更新所有包：<code>conda update --all</code></li><li>列出所有包：<code>conda list</code></li><li>查找包：<code>conda search &lt;package_name&gt;</code></li><li>更多功能可以使用 <code>conda -h(--help)</code> 来查看帮助</li></ul><h3>管理环境</h3><p>使用 conda 的目的之一便是管理环境以实现 Python 项目的互相隔离。以下是使用 conda 管理环境的常用命令：</p><ul><li>创建环境：<code>conda create -n &lt;env_name&gt; python=&lt;version_of_python&gt; &lt;list_of_packages&gt;</code>。其中，<code>&lt;env_name&gt;</code> 是环境的名字，<code>&lt;version_of_python&gt;</code> 可以让你指定 Python 的版本，<code>&lt;list_of_packages&gt;</code> 是要在环境中安装的包的名称列表。</li><li>进入环境：<code>(source) activate &lt;env_name&gt;</code>。Windows 中不需要使用 <code>source</code>。进入环境后，你可以看到类似 <code>(&lt;env_name&gt;) ~ $</code> 之类的提示，这证明你已经成功地进入并工作在指定的 Python 环境下。之后你可以像之前一样安装和管理各种包了，由于新建的环境只安装了几个默认和包，所以你可能需要安装其他你需要的包。</li><li>退出环境：<code>conda deactivate</code>。</li><li>列出环境：<code>conda env list</code>。这个命令可以列出系统中存在的环境，当前工作的环境前会出现一个星号 <code>*</code>。如图所示，其中 (base)（或 (root)）表示默认的 Python 环境。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8239ddae8726932b601e9996a3981655_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1048\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb\" width=\"1048\" data-original=\"https://pic2.zhimg.com/v2-8239ddae8726932b601e9996a3981655_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1048&#39; height=&#39;212&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1048\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1048\" data-original=\"https://pic2.zhimg.com/v2-8239ddae8726932b601e9996a3981655_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8239ddae8726932b601e9996a3981655_b.jpg\"/></figure><p>删除环境：<code>conda env remove -n &lt;env_name&gt;</code>。</p><p>导出环境：<code>conda env export &gt; environment.yaml</code>。这会导出一个环境文件 <code>environment.yaml</code>。要通过环境文件创建环境，使用 <code>conda env create -f environment.yaml</code>，这样会创建一个具有在 <code>environment.yaml</code> 中列出的库的新环境。</p><h3>更多</h3><p>要详细了解 conda，请查看这篇文章：<a href=\"https://link.zhihu.com/?target=https%3A//jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Conda myths and misconceptions</a>，此外，conda 的官方文档也是很好的材料。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67829260", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 9 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: <a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/majority-element/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">169. Majority Element</a> 的摩尔投票解法</li><li>Review: <a href=\"https://link.zhihu.com/?target=https%3A//organizationsandmarkets.com/2010/08/31/how-to-read-an-academic-article/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How to Read an Academic Article</a></li><li>Tip: 分享两个微信公众号排版工具</li><li>Share: 关于健身的一些想法</li></ul><hr/><h2>Algorithm</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/majority-element/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">169. Majority Element</a> 的摩尔投票解法</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/majority-element/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">169. Majority Element</a></p><p>难度：Easy</p><p>题意：给定一个大小为 <code>n</code> 的数组，找到其中的众数。众数是指在数组中出现次数大于 <code>[ n/2 ]</code> 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p>示例一：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [3,2,3]\nOutput: 3</code></pre></div><p>示例二：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [2,2,1,1,1,2,2]\nOutput: 2</code></pre></div><p>解法：这周想把上周没有总结的「摩尔投票」解法好好理解一下。</p><p>「摩尔投票」的原理是：每次从数组中找出一对不同的元素，将它们从数组中删除（或者称为「抵消」更好理解），直到遍历完整个数组。由于这道题已经说明一定存在一个出现次数超过一半的元素，所以遍历完数组后数组中一定会存在至少一个元素。</p><p>知乎上对这一题有一个很好的<a href=\"https://www.zhihu.com/question/49973163/answer/617122734\" class=\"internal\">解释</a>：</p><blockquote>核心就是对拼消耗。玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。最后能剩下的必定是自己人。</blockquote><p>所以目标就是「干仗」+「同归」，我们来一步一步推导一下这个过程：</p><p>假设我们的初始数组是<code>{1,2,1,3,1,1,4}</code>，我们初始化两个变量<code>array</code>和<code>result</code>，<code>array</code>中存储的是「当前还没有和敌人同归于尽的元素」，<code>result</code>中存储的是「每次干仗同归于尽之后战场上现存的元素」。</p><ol><li>从第一个数字 1 开始，<code>array</code>中暂时没有元素，所以我们把它加入到<code>array</code>中，<code>array</code>变成<code>{1}</code>，<code>result</code>由于没有元素被抵消所以还是<code>{1,2,1,3,1,1,4}</code></li><li>第二个元素是 2，我们可以使用另一个不是 2 的数字与它抵消，<code>array</code>中扫描到一个 1，所以我们用 1 与 2 抵消了，<code>array</code>变成了<code>{}</code>，<code>result</code>由于其中的<code>{1,2}</code>互相抵消，变成了<code>{1,3,1,1,4}</code></li><li>第三个元素是 1，但是<code>array</code>中现在没有元素，所以我们把 1 加入到<code>array</code>中，<code>array</code>变成<code>{1}</code>，<code>result</code>还是<code>{1,3,1,1,4}</code></li><li>第四个元素是 3，我们可以使用另一个不是 3 的数字与它抵消，<code>array</code>中扫描到一个 1，所以我们用 1 与 3 抵消了，<code>array</code>变成了<code>{}</code>，<code>result</code>由于其中的<code>{1,3}</code>互相抵消，变成了<code>{1,1,4}</code></li><li>第五个元素是 1，但是<code>array</code>中现在没有元素，所以我们把 1 加入到<code>array</code>中，<code>array</code>变成<code>{1}</code>，<code>result</code>还是<code>{1,1,4}</code></li><li>第六个元素是 1，我们可以使用另一个不是 1 的数字与它抵消，而<code>array</code>中扫描到的元素也是 1，它们不能相互抵消，于是就加入<code>array</code>中，<code>array</code>变成了<code>{1,1}</code>，<code>result</code>还是<code>{1,1,4}</code>，这时我们可以发现，<code>array</code>中只可能存在一种数，因为只有当前<code>array</code>为空或者扫描到的数字与<code>array</code>中的数字相同才可以将其放进<code>array</code>中</li><li>第七个元素是 4，我们可以使用另一个不是 4 的数字与它抵消，<code>array</code>中有两个 1，所以我们用 1 与 4 抵消了，<code>array</code>变成了<code>{1}</code>，<code>result</code>由于其中的<code>{1,4}</code>互相抵消，变成了<code>{1}</code></li></ol><p>至此扫描完了数组里所有的数，<code>result</code>里剩下一个 1，所以 1 就是我们要找的出现次数大于<code>n/2</code>的元素。</p><p>在上述步骤中的第 6 步，我们已经知道「<code>array</code>中只可能存在一种数」，所以其实<code>array</code>数组是没有必要存在的，我们只需要存放一个数字即可，使用<code>candidate</code>来表示，同时我们可以使用<code>count</code>来表示<code>array</code>中的元素个数，另外<code>result</code>数组也可以不存在，因为最后<code>array</code>与<code>result</code>变成一样了，都表示「最后无法删除的元素」。</p><p>当<code>count</code>为 0 的时候，将<code>candidate</code>置为扫描到的下一个元素；当<code>count</code>不为 0 的时候，将扫描到的下一个元素与<code>candidate</code>相比较，如果相同，那么<code>count</code>自增 1，如果不同，<code>count</code>自减 1；直到扫描完整个数组，那么<code>candidate</code>就是我们要找的出现次数大于<code>n/2</code>的元素。</p><p>我们使用这种思路再看一遍，先将<code>count</code>置为 0，<code>candidate</code>随便初始化为一个数：</p><ol><li>第一个元素是 1，由于此时<code>count</code>为 0，所以<code>candidate</code>置为 1，<code>count</code>自增 1，此时<code>count</code>为 1</li><li>第二个元素是 2，与<code>candidate</code>不同，所以<code>count</code>自减 1，<code>count</code>为 0，所以<code>candidate</code>应该取下一个扫描到的元素</li><li>第三个元素是 1，<code>candidate</code>置为 1，<code>count</code>自增 1，<code>count</code>为 1</li><li>第四个元素是 3，与<code>candidate</code>不同，所以<code>count</code>自减 1，<code>count</code>为 0，所以<code>candidate</code>应该取下一个扫描到的元素</li><li>第五个元素是 1，<code>candidate</code>置为 1，<code>count</code>自增 1，<code>count</code>为 1</li><li>第六个元素也是 1，与<code>candidate</code>一样，<code>count</code>自增 1，<code>count</code>为 2，<code>candidate</code>不变</li><li>第七个元素是 4，与<code>candidate</code>不同，所以<code>count</code>自减 1，<code>count</code>为 1</li></ol><p>此时扫描完了数组里所有的数，<code>count</code>为 1，表示还有一个没有被抵消的元素（它就是「全村的希望」啊！），<code>candidate</code>为 1，所以 1 就是我们要找的出现次数大于<code>n/2</code>的元素。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">majorityElement</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">candidate</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"bp\">None</span><span class=\"p\">,</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"n\">nums</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"n\">candidate</span> <span class=\"o\">=</span> <span class=\"n\">num</span>\n            <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"k\">if</span> <span class=\"n\">num</span> <span class=\"o\">==</span> <span class=\"n\">candidate</span> <span class=\"k\">else</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">candidate</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><p>关于「摩尔投票法」，还可以参考<a href=\"https://link.zhihu.com/?target=https%3A//www.cs.utexas.edu/~moore/best-ideas/mjrty/example.html%23step13\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个网页</a>。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//organizationsandmarkets.com/2010/08/31/how-to-read-an-academic-article/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How to Read an Academic Article</a></b></p><p>这周阅读的文章是 <a href=\"https://link.zhihu.com/?target=https%3A//organizationsandmarkets.com/2010/08/31/how-to-read-an-academic-article/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How to Read an Academic Article</a>，作者是 Peter Klein。</p><p>首先，作者提出「一个方法不可能适用于所有人」。</p><p>作者提出的<i>略读</i>、<i>跳读</i>和<i>处理</i>学术文章的基本步骤如下： </p><ul><li>阅读摘要（如果提供了摘要） </li><li>阅读引言</li><li>阅读结论</li><li>略读中间的部分，仔细查看每个章节的标题、表格和图像等等，尝试了解整篇文章的风格和流程</li><ul><li>这篇文章是方法论、概念论还是理论研究（口头或是数学的）、经验论断还是其他的什么？</li><li>它主要是一项调查，一种新颖的理论贡献，一种现有理论或技术的实证应用，一种批评，还是其他什么？</li></ul><li>回头再快速读一遍文章，跳过方程和大部分的图表</li><li>回头仔细地阅读这篇文章，重点关注看起来最重要的章节或部分</li></ul><p>一旦你掌握了作者想要尝试论述的基本论点，那就批评它：</p><ul><li>询问这个论点是否有意义。它的内部是否一致，论点是否被论据或证据很好的支持？（这个技巧需要一些经验）</li><li>将文章与你在相同或相关主题上阅读的其他文章进行比较。（如果这是你在特定主题领域中阅读的第一篇论文，多找一些相关文章并浏览它们，引言和结论是关键。）对它们进行比较和对比。它们的论证是一致的吗？矛盾的吗？正交的吗？</li><li>使用 Google 学术、SSCI、出版商网页和其他资源来查找那些引用你正在阅读的文章的那些文章，看看他们对此有何看法。看看它是否在博客，群组等中被提及</li><li>查看参考文献，例如 <i>Journal of Economic Literature</i>，手册或百科全书的文章，或类似来源的文章，以了解本文如何在更广泛背景下填补其主题领域。</li></ul><hr/><h2>Tips</h2><p><b>分享两个微信公众号排版工具</b></p><p><a href=\"https://link.zhihu.com/?target=http%3A//md.aclickall.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Md2All</a>：</p><blockquote>Markdown 排版利器，支持 <b>&#34;一键排版&#34;</b> 、自定义 CSS、80 多种代码高亮。<br/>能让 Markdown 内容，无需作任何调整就能<b>一键复制</b>到微信公众号、博客园、掘金、知乎、csdn、51cto、wordpress、hexo。。。等平台。<br/>支持把图片自动上传到云图床；<br/>支持 LaTeX 数学公式在公众号等平台完美显示；<br/>支持生成带样式的 HTML 文件；<br/>甚至支持直接用原生的 HTML，CSS 排版。</blockquote><p><a href=\"https://link.zhihu.com/?target=https%3A//lab.lyric.im/wxformat\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">WeChat-Format</a>：</p><p>同样的 Markdown 排版利器，相比较 Md2All，WeChat-Format 提供了「所有外链变成“参考文献”」的功能，并使用了微信官方的高亮配色，同时支持表格功能（这个我用的很少）。缺点是不支持二级无序列表和 LaTeX。</p><hr/><h2>Share</h2><p><b>关于健身的一些想法</b></p><p>最近从法国回家休息两个月，回家就被老妈吐槽驼背，正好一个练习健身的朋友也在家，于是被拖着去了健身房，开始健身。在这里说一下自己关于健身的一些想法吧。</p><p>健身之前，其实我感觉自己的身体是非常虚弱的，再加上刚回来有些倒时差，每天晚上的深睡时间只能有 1 个小时左右，白天无精打采，吃饭也没有胃口。健身一个礼拜之后，运动量上来了，胃口大增，晚上深睡时间也直接上升到了两个多小时，整个人的状态好了很多。而且由于主练胸和背部，驼背问题也好了很多。</p><p>朋友在澳洲留学，我们说起在外面留学时面对孤独寂寞时的排解方法，他告诉我，难过的时候，他就在宿舍撸铁…</p><p>健身时间长了，无聊的时候，我就慢慢开始思考健身的意义。就像 <i>How to Read an Academic Article</i> 的作者 Peter Klein 说的，「no single style works for everyone」。对于每个健身的人来说，健身的目标和意义都是不一样的吧。</p><p>村上春树有一本很有名的书叫《当我谈跑步时我谈些什么》，村上春树跑步，并不是因为跑步很爽，其实是因为跑步很苦。跑一两天似乎很快乐，天天跑，这玩意就很辛苦了。他当然不喜欢跑步，但是他还是要逼着自己去跑，而这很可能就是为了追求一种境界，很多事情相辅相成，苦的事情做到极致，也会有甘甜的味道吧。而且跑步和写作，尤其是长跑和写长篇小说，都需要专注、坚持和忍耐，这两件看起来不相干的事情其实有很多相似之处。另外，艺术家对于「极端」的追求，更甚于常人，以至于许多艺术家选择颓废，而村上找到了另一条看起来更健康的释放方式，就是跑步。</p><p>之前希望锻炼自己的专注力，在法国练习过一段时间的射箭，那位教练老爷爷快七十了，精神矍铄，我一个二十多的小伙子对他的专注力都自叹不如。</p><p>知乎健身达人斌卡在《硬派健身》一书里说：</p><blockquote>身材不是你健身的目的，快乐也不是健身的目的，甚至健身都不是你的目的。你的目的，是发现你自己，困缚于日常生活中的自己。<br/>其实健身就像一个越狱的过程。我在训练中，渐渐发现了曾经忽视的身体。我开始发现自己身体每一个部位存在的意义，我可以渐渐了解它们、熟悉它们。我开始明白，健身是自己和自己的身体一起，为了更好的生活去努力。</blockquote><p>确实，也许最初我健身的目的只是为了矫正身形（甚至并没有什么目的），但健身快一个月了，我渐渐认识到，不论是跑步、射箭还是健身，生活中的很多事情都是息息相关的。不管是为了塑造身形，还是为了保持健康，或者是像村上一样追求极端和释放压力，亦或是追求更高的生活质量，我都应该把健身这件事情坚持下去。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "是的，身体是构建精力，专注力，和思考力的基础，一个好身体可以就像个好的马达，可以为很多工作提供动力。坚持吧！！！[酷][酷][酷]", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66311267", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 8 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: <a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/majority-element/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">169. Majority Element</a></li><li>Review: <a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/cyber-insects-cb2ce599ca85\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cyber Insects</a></li><li>Tip: 推荐几个 Vim 插件</li><li>Share: Python 中的生成器</li></ul><hr/><h2>Algorithm</h2><p><b>求众数</b> 题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/majority-element/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">169. Majority Element</a></p><p>难度：Easy</p><p>题意：给定一个大小为 <code>n</code> 的数组，找到其中的众数。众数是指在数组中出现次数大于 <code>[ n/2 ]</code> 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p>示例一：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [3,2,3]\nOutput: 3</code></pre></div><p>示例二：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [2,2,1,1,1,2,2]\nOutput: 2</code></pre></div><p>解法一，暴力循环： 暴力算法遍历整个数组，然后再次遍历每一个元素来统计它出现的次数，一旦一个元素出现次数大于 <code>[ n/2 ]</code>，即返回它。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">majorityElement</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">majority_count</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span><span class=\"o\">//</span><span class=\"mi\">2</span>\n        <span class=\"k\">for</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"n\">nums</span><span class=\"p\">:</span>\n            <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"k\">for</span> <span class=\"n\">elem</span> <span class=\"ow\">in</span> <span class=\"n\">nums</span> <span class=\"k\">if</span> <span class=\"n\">elem</span> <span class=\"o\">==</span> <span class=\"n\">num</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">count</span> <span class=\"o\">&gt;</span> <span class=\"n\">majority_count</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">num</span></code></pre></div><p>时间复杂度为 O(n2)，空间复杂度为 O(1)。</p><p>这个解法有一点需要注意，就是在第二次循环的时候，使用了生成器来统计元素的出现次数，这可以减少内存的使用。</p><p>解法二，使用哈希表： 在 Python 中，我们可以使用 <code>collections</code> 中的 <code>Counter</code> 来统计元素出现的次数。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">majorityElement</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">counts</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">counts</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">(),</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">counts</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">)</span></code></pre></div><p>时间复杂度为 O(n)，空间复杂度为 O(n)。</p><p>解法三，排序法： 因为该题规定众数出现次数大于 <code>[ n/2 ]</code>，所以如果将数组排序，那么中间的一个元素一定是那个众数。在 Python 中，我们可以很容易使用 <code>sort</code> 来对数组进行排序。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">majorityElement</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"n\">sort</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span><span class=\"o\">//</span><span class=\"mi\">2</span><span class=\"p\">]</span></code></pre></div><p>时间复杂度为 O(nlogn)，空间复杂度为 O(1)（如果原地排序数组是可行的话） 或者 O(n)（如果原地排序数组不可行）。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/cyber-insects-cb2ce599ca85\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cyber Insects</a></b></p><p>这周读了一篇简短的文章，讲的是人造智能昆虫将如何从军事和农业两方面影响人类生活的。</p><p>其实大部分先进的科学技术首先都是被用于军事方面，基本上我们现在才开始使用的大部分的不可思议的事物，其实很早就被创造并应用于军事工业了。人造昆虫就是其中一个例子。在军事方面，人造昆虫被用于监视敌人、破坏无线电台、损坏线路和网络等。更为重要的是，人工智能为这些人造昆虫提供了升级能力的可能，这让他们能够躲避动物的攻击、远离人类、从复杂困难的环境中逃离以及像普通昆虫一样行动。</p><p>另外一方面，人造昆虫还能够被用于农业，能够极大的减少农业生产中的人力参与。人造昆虫可以被用于播种、对抗害虫、监控播种并汇报种子发芽的质量等等。</p><blockquote>We’re making this analogy that AI is the new electricity. Electricity transformed industries: agriculture, transportation, communication, manufacturing.</blockquote><p>不过这篇文章关于人造昆虫在军事上的应用让我想起了之前杀手机器人视频引起的恐慌。可以参考这个链接：<a href=\"https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DTlO2gcs1YvM\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">youtube.com/watch?</span><span class=\"invisible\">v=TlO2gcs1YvM</span><span class=\"ellipsis\"></span></a>。</p><hr/><h2>Tips</h2><p><b>推荐几个 Vim 插件</b></p><ul><li>Goyo</li><li>vim-startify</li><li>vim-airline</li><li>indentLine</li></ul><hr/><h2>Share</h2><p><b>Python 中的生成器</b></p><p>由于今天在 Algorithm 中又见到了生成器的身影，遂决定把生成器研究透彻。</p><p>这里分享一篇「Python 之禅」的文章<a href=\"https://link.zhihu.com/?target=https%3A//foofish.net/what-is-python-generator.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《看完这篇，你就知道Python生成器是什么》</a>，我个人觉得讲得非常的透彻易懂，重要的一点是「本质上 for 循环也是调用 next 方法」。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65520659", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 7 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: LeetCode 119. Pascal&#39;s Triangle II</li><li>Review: <a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/deep-inside-autoencoders-7e41f319999f\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Deep inside: Autoencoders</a></li><li>Tip: 在终端中使用代码编辑器打开文件或者目录</li><li>Share: 播客分享</li></ul><hr/><h2>Algorithm</h2><p><b>杨辉三角 II</b> 题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/pascals-triangle-ii/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">119. Pascal&#39;s Triangle II</a></p><p>难度：Easy</p><p>题意：给定一个不大于 33 的非负数 k，返回杨辉三角的第 k 行。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"240\" data-thumbnail=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.jpg\" class=\"content_image\" width=\"260\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;260&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"240\" data-thumbnail=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.jpg\" class=\"content_image lazy\" width=\"260\" data-actualsrc=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>示例：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 3\nOutput: [1,3,3,1]</code></pre></div><p>要求：优化算法到到 O(k) 空间复杂度</p><p>解法：</p><p>这道题目和上周的杨辉三角 I 很相像，只要找到数学公式即可轻易做出。</p><p>杨辉三角有一个性质是，它的第 n 行的第 i 个数字（n 和 i 均从 0 开始）为： <img src=\"https://www.zhihu.com/equation?tex=C_n%5Ei+%3D+%5Cfrac%7Bn%21%7D%7B%28n-i%29%21+%5Ctimes+i%21%7D\" alt=\"C_n^i = \\frac{n!}{(n-i)! \\times i!}\" eeimg=\"1\"/> 。那么由第 i 个数字就可以很容易推出第 i+1 个数字： <img src=\"https://www.zhihu.com/equation?tex=C_n%5E%7Bi%2B1%7D+%3D+%5Cfrac%7Bn%21%7D%7B%28n-i-1%29%21+%5Ctimes+%28i%2B1%29%21%7D+%3D+%5Cfrac%7Bn-i%7D%7Bi%2B1%7D+%5Ctimes+C_n%5Ei\" alt=\"C_n^{i+1} = \\frac{n!}{(n-i-1)! \\times (i+1)!} = \\frac{n-i}{i+1} \\times C_n^i\" eeimg=\"1\"/> 。</p><p>那么代码也就很容易写了:</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">getRow</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">rowIndex</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type rowIndex: int\n</span><span class=\"s2\">        :rtype: List[int]\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"k\">if</span> <span class=\"n\">rowIndex</span> <span class=\"o\">&gt;</span> <span class=\"mi\">33</span> <span class=\"ow\">or</span> <span class=\"n\">rowIndex</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"p\">[]</span>\n\n        <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">rowIndex</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">rowIndex</span><span class=\"p\">):</span>\n            <span class=\"n\">ans</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ans</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">rowIndex</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"o\">//</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">ans</span></code></pre></div><p>时间和空间复杂度均为 O(n)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/deep-inside-autoencoders-7e41f319999f\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Deep inside: Autoencoders</a></b></p><p>这篇文章选自 Medium 上 Towards Data Science 专栏。对自编码器有了一个大致的介绍。</p><p>本文先介绍了自编码器的基本结构：自编码器由两部分组成，<b>编码器</b>和<b>解码器</b>。 <i> 编码器：这是将输入压缩为潜在空间表征的网络部分。它可以由编码函数 h = f(x) 表示。 </i> 解码器：这部分旨在重建潜在空间表征的输入。它可以由解码函数 r = g(h) 表示。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ff00a56756f211b2c28011e3551c00b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1248\" data-rawheight=\"307\" class=\"origin_image zh-lightbox-thumb\" width=\"1248\" data-original=\"https://pic3.zhimg.com/v2-ff00a56756f211b2c28011e3551c00b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1248&#39; height=&#39;307&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1248\" data-rawheight=\"307\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1248\" data-original=\"https://pic3.zhimg.com/v2-ff00a56756f211b2c28011e3551c00b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ff00a56756f211b2c28011e3551c00b6_b.jpg\"/></figure><p>整个自编码器可以用函数 g(f(x)) = r 来表示，我们希望输出 r 与输入 x 尽量接近。这样做的目的在于，潜在表征 h 是非常有价值的。</p><blockquote> 自动编码器是从数据示例中自动学习的（无监督学习），这意味着可以很容易地将这个算法应用到某个数据集中，来取得良好的性能，且只需要适当地训练数据而不需要任何新的特征工程。<br/> </blockquote><p>需要注意的是，自编码器在<b>图像压缩</b>任务上表现不好，因为他只是在某个给定的数据集上训练，所以也只能在相似的图像上取得不错的效果，而对于一般的图像，JPEG 等图像压缩算法通常有更好的效果。</p><p>之后作者也对几种不同的自编码器进行了讨论，如 Vanilla 自编码器、多层自编码器、卷积自编码器和正则化自编码器。有兴趣的同学可以去看看。</p><hr/><h2>Tips</h2><p><b>在终端中使用代码编辑器打开文件或者目录</b></p><p>只要在你的 .zshrc 中添加这几行，之后 source 一下即可：</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"nb\">alias</span> <span class=\"nv\">atom</span><span class=\"o\">=</span><span class=\"s1\">&#39;/Applications/Atom.app/Contents/MacOS/Atom&#39;</span>\n<span class=\"nb\">alias</span> <span class=\"nv\">subl</span><span class=\"o\">=</span><span class=\"s1\">&#39;/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl&#39;</span>\n<span class=\"nb\">alias</span> <span class=\"nv\">code</span><span class=\"o\">=</span><span class=\"s1\">&#39;/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code&#39;</span></code></pre></div><hr/><h2>Share</h2><p><b>播客分享</b></p><p>我本人比较喜欢听播客节目，这周分享自己常用的几个 iOS 播客客户端和常听的几个播客节目。</p><p>客户端： </p><p><i>iOS 自带的 Podcast：界面清爽，节目数量大，但是使用逻辑比较混乱，这家伙还会偷偷在后台给你自动下载节目，有一次我的 iPhone 告诉我内存已满，打开一看才发现播客占了 10 个 G……</i></p><p>Castro：目前使用最多的泛用型播客客户端，非常流畅，缺点是网络稍有不佳播放就会出错</p><p>Moon FM：界面超级好看！也是泛用型播客客户端，使用需要适应一段时间，但没有导出订阅的功能，是一个小小的遗憾</p><p>节目： </p><ul><li>比特新声：很久没更新了，但是有才和海龙做的内容我蛮喜欢的 </li><li>单读：许知远的单读节目，已经没有更新了，内容非常文艺 </li><li>翻转电台 Flip Radio：可以学习到哲学心理学知识以及在实际生活中的应用 </li><li>狗熊阅读（会员版）：这是我听的第一个播客节目，也是引领我进入播客世界的第一个节目，大狗熊的获奖播客</li><li>狗熊有话说：大狗熊日常碎碎念，还有同款 YouTube</li><li>哈利播客：原 HPUP，《博物志》婉莹做的重新领读《哈利波特》的播客节目</li><li>一天世界：李如一老师。。。</li><li>Byte.Coffee：Milkshake羊的播客</li><li>The CJ show（理想屯）：陪伴我度过了最孤独的那段时间，球姐和 LJ 给人感觉非常亲切，听完又觉得人生有希望了</li><li>PAGE SEVEN：一个已经不更新了的播客节目，但是个人强推！！！创始人上过 TEDx，去听吧，回来你会感谢我的！</li></ul>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64741435", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 6 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: LeetCode 118. Pascal’s Triangle</li><li>Review: <a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/the-random-forest-algorithm-d457d499ffcd\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Random Forest Algorithm</a></li><li>Tip: Alfred 推荐</li><li>Share: <a href=\"https://link.zhihu.com/?target=https%3A//alainouyang.github.io/2018/02/21/CNN%25E5%258D%25B7%25E7%25A7%25AF%25E7%25A5%259E%25E7%25BB%258F%25E7%25BD%2591%25E7%25BB%259C%25E6%259E%25B6%25E6%259E%2584%25E7%25BB%25BC%25E8%25BF%25B0/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CNN 卷积神经网络架构综述</a></li></ul><hr/><h2>Algorithm</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/pascals-triangle/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode 118. Pascal’s Triangle</a></b></p><p>难度：Easy</p><p>题意：帕斯卡三角又称为杨辉三角，给定一个非负整数 <code>numRows</code>，生成杨辉三角的前 <code>numRows</code> 行。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"240\" data-thumbnail=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.jpg\" class=\"content_image\" width=\"260\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;260&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"240\" data-thumbnail=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.jpg\" class=\"content_image lazy\" width=\"260\" data-actualsrc=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>示例：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: 5\nOutput:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]</code></pre></div><p>解法：</p><p>这道题其实很简单，只要想明白如何由上一行生成下一行即可。</p><p>我们先定义一个列表 <code>triangle</code> 作为最后输出的杨辉三角，<code>triangle</code> 的每一个元素对应杨辉三角的每一行，所以 <code>triangle</code> 的每个元素也应该是列表，我们将其定义为 <code>L</code>。首先应该对 <code>L</code> 进行初始化，让 <code>L</code> 的长度与其行数相等，然后再将其首尾都置为 1。然后利用杨辉三角基本的计算原理对下一行进行计算：这一行的第 <code>i</code> 个数是上一行的第 <code>i-1</code> 个数与第 <code>i</code> 个数的和。最后将计算好的一行添加进 <code>triangle</code> 即可。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">generate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">numRows</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type numRows: int\n</span><span class=\"s2\">        :rtype: List[List[int]]\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">triangle</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">numRows</span><span class=\"p\">):</span>\n            <span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"bp\">None</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)]</span>\n            <span class=\"n\">L</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">L</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n                <span class=\"n\">L</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">triangle</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">triangle</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">i</span><span class=\"p\">]</span>\n            <span class=\"n\">triangle</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">triangle</span></code></pre></div><p>程序中有两个嵌套的循环，<code>L</code> 更新的次数与 <code>numRows</code> 的平方成正比。或者说，杨辉三角中元素的个数与它的行数成正比，所以时间复杂度和空间复杂度都为 O(n2)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/the-random-forest-algorithm-d457d499ffcd\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Random Forest Algorithm</a></b></p><p>这周选择了 Medium 上面一篇讲解随机森林算法的文章。</p><p>作者在文章的第一节，给出了随机森林算法的简单定义：</p><blockquote>随机森林构建多个决策树，并将它们合并在一起以获得更准确和稳定的预测。</blockquote><p>然后解释了随机森林是如何运作的，以及给出了真实生活中的一个例子，随后解释了特征的重要性以及决策树和随机森林的不同：</p><blockquote>决策树利用特征值构建起一套规则，随后利用这些规则作出预测；而随机森林利用随机选取的一些规则来构建若干个决策树，再去这些决策树结果的平均。 <br/>深度的决策树可能会陷入过拟合，而随机森林则利用随机选取的特征子集构建小的决策树，这在大多数情况下避免了过拟合。</blockquote><p>之后介绍了两类重要的超参数：一类是「预测能力」，包括 <code>n_estimators</code>，即随机森林中树的数量、<code>max_features</code>，即随机森林拆分一个结点是使用的最大的特征值的数量、<code>min_sample_leaf</code>，即拆分内部节点所需的最小叶子数；另一类是「模型速度」，包括 <code>n_jobs</code>，即每次并行运行的线程数，<code>random_state</code> 使模型的输出可复现，<code>oob_score</code> 是否使用袋外样品（out-of-bag）来估计泛化精度。</p><p>最后作者分析了随机森林的优缺点和使用场景。</p><hr/><h2>Tips</h2><p>这周给大家分享一个我一直在用的神器 「<a href=\"https://link.zhihu.com/?target=https%3A//www.alfredapp.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Alfred</a>」，它是 macOS 上的一款启动器。</p><blockquote>什么是启动器？顾名思义，就是通过键盘输入来执行相应动作，从而提高工作效率的软件。<br/>例如 macOS 自带的聚焦搜索（Spotlight），就能将文稿、邮件、应用等整合在一起，通过关键词匹配展示。</blockquote><p>而 Alfred 可以看做是 Spotlight 的高级版，它有更多的高级功能，如： </p><ul><li>添加自定义网络搜索引擎；  </li><li>文件搜索与快速操作；  </li><li>在命令框内使用计算器、词典等实用工具；  </li><li>……</li></ul><p>另外也可以通过购买 Powerpack 解锁更多的高级功能如 Workflow、Clipboard、Snippets、iTunes 管理、1Password 集成等功能。尤其是 Workflow，简直是大杀器。推荐大家一试。</p><hr/><h2>Share</h2><p>这周给大家分享一篇讲解 CNN 卷积神经网络架构的文章</p><p><a href=\"https://link.zhihu.com/?target=https%3A//alainouyang.github.io/2018/02/21/CNN%25E5%258D%25B7%25E7%25A7%25AF%25E7%25A5%259E%25E7%25BB%258F%25E7%25BD%2591%25E7%25BB%259C%25E6%259E%25B6%25E6%259E%2584%25E7%25BB%25BC%25E8%25BF%25B0/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CNN 卷积神经网络架构综述</a></p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64154368", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 5 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: LeetCode 189. Rotated Array</li><li>Review: <a href=\"https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3Dd4rBh6DBHyw\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Fei-Fei Li &amp; Yuval Noah Harari in Conversation - The Coming AI Upheaval</a></li><li>Tip: Python 字符串前面加「u, r, b」的含义</li><li>Share: 「收益值」与「半衰期」</li></ul><hr/><h2>Algorithm</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/rotate-array/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode 189. Rotated Array</a></b></p><p>难度：Easy</p><p>题意：给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例一：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [1,2,3,4,5,6,7] and k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]</code></pre></div><p>示例二：</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [-1,-100,3,99] and k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]</code></pre></div><p>说明： - 尝试想出你能想出的所有的解法，这道题至少有 3 种 - 你能否做到以 O(1) 的空间复杂度原地执行这个操作呢？</p><p><b>注：这里不使用 Python 内置的列表切片操作，锻炼思维。</b></p><p>解法一：</p><p>这道题目最容易想到的解法就是「每次往右移动一位，一共移动 k 次」这种暴力解法。我们使用在各个语言中都非常常见的 switch 方法：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">rotate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :type k: int\n</span><span class=\"s2\">        :rtype: None Do not return anything, modify nums in-place instead.\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">):</span>\n            <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n            <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n                <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span>\n                <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">pre</span>\n                <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span></code></pre></div><p>但是从 OJ 的反应来看，「Time Limit Exceeded」，说明我们的算法超时了。我们来看看这个算法的时间复杂度，有两个嵌套的循环，所以时间复杂度是 O(n^2)，空间上因为没有申请更多的空间，只用了两个临时的空间来储存元素，所以是 O(1)。</p><p>解法二：</p><p>考虑到将数组中每个数字右移，其实很像取余操作，所以有一个很好的思路：创建一个长度与原先数组长度相等的数组，用 len(nums) 对 k+i 取余，剩下的数字就是原先数组应该放到新数组中的位置。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">rotate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :type k: int\n</span><span class=\"s2\">        :rtype: None Do not return anything, modify nums in-place instead.\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">nums1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">))]</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n            <span class=\"n\">nums1</span><span class=\"p\">[(</span><span class=\"n\">k</span><span class=\"o\">+</span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"o\">%</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n            <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span></code></pre></div><p>这一次我们的算法被接受了，时间复杂度是 O(n)，由于申请了额外的空间用来存放新的数组，所以空间复杂度为 O(n)。</p><p>需要注意的是，我一开始在创建 nums1 的时候，直接将 <code>nums1 = nums</code> 了，这样的结果就是，由于 Python 中的「等号」是赋值操作，在对一个列表赋值为另一个列表的时候，其实只是一个简单的绑定操作，而并没有在内存中申请新的空间，所以之后对 nums1 做的任何修改都会直接修改原 nums，导致结果不正确。这个小错误我想了好久才想明白，看来还是对 Python 的坑不熟悉。</p><p>解法三：</p><p>每个数字往后移 k 位，一共移动 <code>len(nums)</code> 次。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">rotate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :type k: int\n</span><span class=\"s2\">        :rtype: None Do not return anything, modify nums in-place instead.\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n        <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n            <span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">idx</span> <span class=\"o\">+</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span>\n            <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span>\n\n            <span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"o\">+</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">distance</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">idx</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span>\n                <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span></code></pre></div><p>本解法参考了 Code_Granker 的<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/happyaaaaaaaaaaa/article/details/51462800\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">答案</a>。</p><p>解法四：</p><p>先把整个数组翻转，再在截断处前后分别翻转。这个思路非常清晰，但是却不容易想到。</p><div class=\"highlight\"><pre><code class=\"language-text\">Original List                   : 1 2 3 4 5 6 7\nAfter reversing all numbers     : 7 6 5 4 3 2 1\nAfter reversing first k numbers : 5 6 7 4 3 2 1\nAfter revering last n-k numbers : 5 6 7 1 2 3 4 --&gt; Result\nclass Solution(object):     \n    def rotate(self, nums, k):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :type k: int\n        :rtype: None Do not return anything, modify nums in-place instead.\n        &#34;&#34;&#34;\n        k %= len(nums)\n        self.reverse(nums, 0, len(nums) - 1)\n        self.reverse(nums, 0, k - 1)\n        self.reverse(nums, k, len(nums) - 1);\n\n    def reverse(self, nums, start, end):\n        while start &lt; end:\n            temp = nums[start]\n            nums[start] = nums[end]\n            nums[end] = temp\n            start += 1\n            end -= 1</code></pre></div><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3Dd4rBh6DBHyw\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Fei-Fei Li &amp; Yuval Noah Harari in Conversation - The Coming AI Upheaval</a></b></p><p>这周分享一个这两年比较火的《人类简史》、《未来简史》和《今日简史》的作者尤瓦尔·赫拉利与斯坦福大学 AI 研究院领导李飞飞在斯坦福大学举行的一场以人工智能为主题的对话（YouTube 视频）。</p><p>赫拉利用《今日简史》中的一个观点作为开场：人工智能除了带来科技挑战外，还带来了哲学上的挑战。当人工智能和生物学科技结合起来的时候，它就有可能入侵我们的大脑，现在的「自由」、「独立」、「民主」全部都有可能受到算法的操控，那么人类的生存问题也会被算法彻底操控——以一种我们无法感知的方式，在现在数据隐私和伦理问题如此严重的时代，人工智能极有可能会黑掉我们的大脑，替我们做出决策，因为它掌握了我们太多的数据，它比我们自己更了解我们。而这是非常危险的。</p><p>李飞飞解释，目前很多人工智能技术在被应用在生物医疗方面，而这取得了显著的成果，今后人工智能和生物医疗的结合也会更深入的造福人类。伦理、隐私等社会问题也已经在科学研究领域引起了关注，斯坦福的「Human-Centered AI Institute」也在开始积极应对这一问题。</p><p>赫拉利和李飞飞又谈到了「人工智能眼中的爱情」。赫拉利认为从生物学的角度，「爱」只不过是身体激素的化学反应引起的情绪和生理反应，如果人工智能了解并解码了这些，那么「爱情」又和流感有什么区别呢？</p><p>李飞飞认为，这个结论里的两个假设是：一、人工智能强大到能够预测人的意识了，而现在的技术完全没有达到这样的水平；二、未来只有人工智能一家独大，但是过去现在和未来，一直都有更多的技术比人工智能还要强大。李飞飞认为技术是把双刃剑，人工智能的危害也不应该被单独夸大。</p><p>两人之后还谈及了广告、AI 军备竞赛等问题，十分精彩，建议有条件的同学可以去观看。</p><h2>Tips</h2><p><b>Python 字符串前面加「u, r, b」的含义</b></p><p>u/U：表示 unicode 字符串  不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行 unicode 编码。  一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带<code>u</code>；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。  建议所有编码方式采用 utf8</p><p>r/R：非转义的原始字符串  与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的<code>\\n</code>表示换行，<code>\\t</code>表示 Tab 等。而如果是以 <code>r</code>开头，那么说明后面的字符，都是普通的字符了，即如果是<code>\\n</code>那么表示一个反斜杠字符，一个字母 n，而不是表示换行了。  以<code>r</code>开头的字符，常用于正则表达式，对应着 re 模块。</p><p>b：bytes  Python 3.x 里默认的 str 是（Python 2.x 里的）unicode, bytes 是（Python 2.x）的 str, <code>b</code>前缀代表的就是 bytes。 Python 2.x 里, <code>b</code>前缀没什么具体意义， 只是为了兼容 Python 3.x 的这种写法。</p><h2>Share</h2><p><b>「收益值」与「半衰期」</b></p><p>采铜的《精进》一书中提出了一个非常好的指导我们日常生活中应该选择做什么事的方法论，这个方法论使用两个维度去评估一件事适不适合去做：一是「收益值」，而是「半衰期」。</p><p>所谓「收益值」，是指一件事情在<b>当下</b>给「我」带来的「收益」，这个「收益」可以是心智、情感层面的，也可以是身体、物质层面的。</p><p>而「半衰期」是指这个「收益」随时间衰减的速度，类似于物理学中放射性元素的「半衰期」和生理学上药物浓度的「半衰期」。</p><p>生活中我们经常会倾向于做「高收益值短半衰期」的事情，比如「打游戏」、暴饮暴食吃自助餐、看综艺。用「收益值」和「半衰期」这两个维度来衡量生活中的大多数事情，就可以将他们分为四类：</p><ul><li>高收益值长半衰期事件：找到真爱、学会一种思维方式、与大神交流</li><li>高收益值短半衰期事件：玩游戏、看综艺节目、无节制地买买买</li><li>低收益值长半衰期事件：练字、读哲学书、背单词</li><li>低收益值短半衰期事件：网络上喷人、刷微博</li></ul><p>「短半衰期」事件的结果是不可累积的，就像「每一天都是崭新的一天，但是每一天都在重复昨天的故事」。而「长半衰期」的事件的结果具有累积性，不论「收益值」高低。</p><p>现代人经常会陷入「选择困难症」和「拖延症」之中，我们可以用采铜老师提出的「采铜法则」去改善：尽量少做「短半衰期」的事件。两层含义：一、收益的高地无关紧要，只要收益能被累加，就尽管去做；二、一些不重要、不紧急的事，只要长期有益处，那么就去做。</p><p>那么如何判断一件事的「半衰期」呢？这一点其实因人而异，具体来说与完成这件事的方式有关；另外还有一些事情本身就具有「长半衰期」的属性，比如某些稀缺性或者不可替代性的技能、竞争力等，要学会去识别具有这些属性的事情，需要在实践中去慢慢摸索。</p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "推荐《心流》这本书[爱]", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>thx</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63228298", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 4 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: LeetCode 80. Remove Duplicates from Sorted Array II</li><li>Review: <a href=\"https://link.zhihu.com/?target=https%3A//medium.com/yottabytes/i-wanna-be-a-data-scientist-but-how-779219ce6311\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">I wanna be a data scientist, but… how!?</a></li><li>Tip: 在 Chrome 上开启并行下载</li><li>Share: 朋友的观点</li></ul><hr/><h2>Algorithm</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">80. Remove Duplicates from Sorted Array II</a></b></p><p>难度：Easy</p><p>题意：给定一个有序数组 <code>nums</code>，<b>原地</b> 移除重复元素，每个元素在新数组中只出现 <i>两次</i>。要求不能给另一个数组分配额外的内存空间，所以必须以 O(1) 的空间复杂度 <b>原地更改</b> 输入数组。</p><p>例子 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Given nums = [1,1,1,2,2,3],\n\nYour function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\n\nIt doesn&#39;t matter what you leave beyond the returned length.</code></pre></div><p>例子 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Given nums = [0,0,1,1,1,1,2,3,3],\n\nYour function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.\n\nIt doesn&#39;t matter what values are set beyond the returned length.</code></pre></div><p>解法： 本题和之前的第 26 题基本一样，只是在细节上有一点不同，也是使用双指针法来解。指定两个指针，慢指针指向第 2 个元素，快指针指向第 2 个元素。<b>这里注意到这个数组是有序的，所以从[慢指针-2位置]开始到[慢指针-1位置]，这两个位置的元素不论是否相同，都是符合题意要求的</b>，快指针一直判断自己所在位置的元素是不是和[慢指针位置-2]所在的元素相同：若相同，快指针后移，若不同，把快指针所在位置的元素赋给慢指针所在的元素，快慢指针均后移。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">removeDuplicates</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">count</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]:</span>\n                <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">count</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n                <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">count</span></code></pre></div><p>时间复杂度 O(N)，空间复杂度 O(1)。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/yottabytes/i-wanna-be-a-data-scientist-but-how-779219ce6311\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">I wanna be a data scientist, but… how!?</a></b></p><p>这周选的文章是 Medium 上面的一篇讲述「如何一步一步成为一个数据科学家」的文章。</p><p>作者在文章开头用一张「地铁图」展示了数据科学的众多工作技能之间的关联。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9b9b69a19b72ca9c3875dac5b2208074_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1550\" data-rawheight=\"1258\" class=\"origin_image zh-lightbox-thumb\" width=\"1550\" data-original=\"https://pic1.zhimg.com/v2-9b9b69a19b72ca9c3875dac5b2208074_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1550&#39; height=&#39;1258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1550\" data-rawheight=\"1258\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1550\" data-original=\"https://pic1.zhimg.com/v2-9b9b69a19b72ca9c3875dac5b2208074_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9b9b69a19b72ca9c3875dac5b2208074_b.jpg\"/></figure><p>作者列举了数据科学领域经常出现的一些技能：</p><ul><li>线性代数、微积分、概率论和统计学（数学）</li><li>Python 或者 R 的编程技能以及与数据科学相关的标准库</li><li>SQL 的知识 - 获取数据的能力（API、网页爬虫）</li><li>数据清洗和预处理（以及有名的<i>特征工程</i>）</li><li>机器学习（算法、建模、评价、优化等等）</li><li>深度学习、强化学习、自然语言处理、计算机视觉……</li></ul><p>以及：</p><ul><li>可视化结果以对其进行解释</li><li>讲故事的能力</li><li>制定问题和准备/测试假设</li><li>领域里的其他知识</li><li>……</li></ul><p>作者说，其实这些附加技能（soft-skills）才能真正将你与其他人区分开来。另外，作者还列举回答了几个问题：</p><blockquote> 我需要一个硕士学位吗？ 不是必须。网络上有足够的信息能让你变成一个大牛。<br/> 但是公司在寻找一些经过额外训练和认证的人才… 重要的是展示你的知识，而非头衔。技术面试官会评估你关于所需知识的掌握程度，你要做的就是向他们证明你就是他们要找的人。</blockquote><p><b>作者接下来介绍了学习成为一个数据科学家的路径：</b></p><p>1. 在 Python 和 R 之间做一个选择（建议 Python 如果你之前没有学过 R 的话）</p><p>2. 学习语言的基础知识，慢慢扩展，另外关注 Git、GitHub 和 Jupyter，这些是你日后每天都要用到的工具</p><p>3. 了解常用的数据科学库</p><p>4. 机器学习！</p><p>5. 深度学习、强化学习和公司</p><p>6. 参与 Kaggle 的竞赛</p><p>7. 最重要的技巧：<b>做项目</b></p><p>8. 准备面试</p><p>一些技巧：</p><ul><li>Learn by doing</li><li>组织好时间表</li><li>像要去教给别人一样去学习</li><li>使用从上至下的方式：直接去学习机器学习，在需要的时候再学习对应的数学部分。这样可以不失去动力</li><li>学会寻找资源</li><li>将项目同步到 GitHub 上</li></ul><p>不要被各种推送信息淹没 - 好好准备面试</p><p>最后一个技巧：这个旅途很长，所以尽可能地把它看成一个半程马拉松，而不是一个竞速跑。</p><hr/><h2>Tip</h2><p><b>在 Chrome 上开启并行下载</b></p><p>Chrome 是自带并行下载功能的，开启方式如下：</p><p>在地址栏输入 chrome://flags/，然后在搜索框中输入 Parallel downloading，选择 enabled，重启 Chrome 即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e2dc426ae0974e7a6648429c9172ac8d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1512\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb\" width=\"1512\" data-original=\"https://pic2.zhimg.com/v2-e2dc426ae0974e7a6648429c9172ac8d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1512&#39; height=&#39;692&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1512\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1512\" data-original=\"https://pic2.zhimg.com/v2-e2dc426ae0974e7a6648429c9172ac8d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e2dc426ae0974e7a6648429c9172ac8d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>Share</h2><p>最近在思考读博士和做事情的意义。看到一位朋友在朋友圈中的分享，觉得非常有感触，摘录如下：</p><blockquote>作为一个正在读博的告诉你，读博的人每个人都有每个人的打算，但是有一点是肯定的，如果你不想去高校当老师的话，那么读博的过程一定不是你想象中的那样。前两天看王耀林发了一句话，这辈子越晚接触那些牛逼闪闪的人，这辈子可能越幸福。现在无比赞同。我觉得每个人最终干什么可以成功一定是他的性格和这个事情所需要的相匹配。不匹配的话再努力都不太可能成功。一个人做事不心狠手辣不在斗争中鱼死网破他做不到顶尖的位置，大多数人只看到了他坐在顶尖的位置，却没看到自己的性格与他性格之间的不同。大家只是想成为他那样的人，可先不说自己适不适合朝那个方向努力，就算做到了那，逼自己变成那个样子值不值得自己是要好好考量一下的。</blockquote><p>朋友的这段话有一些我比较赞同，有一些我则有自己的观点：</p><ol><li>「越晚接触那些牛逼闪闪的人，这辈子可能越幸福」。采铜在他的《精进》一书中提到，根据人们对过去、现在和未来的不同态度，即「时间视角」，可以将人们划分成五种人：「积极过去」、「消极过去」、「享乐主义」、「宿命论」和「未来视角」。「享乐主义者」在某种程度上是非常幸福的，村上的「小确幸」也提出了类似的观点，越晚接触更牛逼的人，你可能越会在意眼前和当下的事情，生活得越充实。而我本人其实属于「未来视角」，总是更关注待完成的目标和任务，为了完成这些目标和任务，我愿意牺牲当下的享乐，有的时候甚至到了焦虑的程度，这就导致了我日常生活中的幸福感并不高。另外一个例证是，每次回国，在生活了十几年的小城市里，我能明显感觉到极高的幸福感，不用去想以后的职业发展方向、需要学习的技能能力等等，只要早早出门去吃喜欢的早餐，每天的幸福感就会非常的高了。但是一回到原来的生活状态，就会开始习惯性焦虑。也许需要综合考虑，不要维持单一的时间视角，随需而变，这辈子才会越幸福吧。</li><li>「我觉得每个人最终干什么可以成功一定是他的性格和这个事情所需要的相匹配」。这一点我非常赞同。我们需要了解自己，关照自己的内心，<b>也许</b>才能知道自己想要什么，需要付出什么样的代价，能不能承受这样的代价，想明白了之后再用这个终极目标去指引日常生活，这样每一年、每个月、每一天都能过得充实，也许人生的意义也就慢慢清晰了。</li></ol>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62404129", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 3 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: LeetCode 26. Remove Duplicates from Sorted Array</li><li>Review: The AI for augmenting yourself</li><li>Tip: iTerm2 的外观配置</li><li>Share: iTerm2 外观配置详细过程</li></ul><hr/><h2>Algorithm</h2><p><b>在有序数组中移除重复元素</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/remove-duplicates-from-sorted-array/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">26. Remove Duplicates from Sorted Array</a></p><p>难度：Easy</p><p>题意：给定一个有序数组 <code>nums</code>，<b>原地</b> 移除重复元素，每个元素在新数组中只出现 <i>一次</i>。要求不能给另一个数组分配额外的内存空间，所以必须以 O(1) 的空间复杂度 <b>原地更改</b> 输入数组。</p><p>例子 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Given nums = [1,1,2],\n\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\n\nIt doesn&#39;t matter what you leave beyond the returned length.</code></pre></div><p>例子 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Given nums = [0,0,1,1,1,2,2,3,3,4],\n\nYour function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.\n\nIt doesn&#39;t matter what values are set beyond the returned length.</code></pre></div><p>解法：</p><p>这道题想明白了其实非常简单，因为不能申请额外的空间，所以需要直接修改原数组。题意是去除重复的元素，那么一定要遍历数组，发现重复的话，就把后面的元素往前移，覆盖掉前面重复的元素。具体实现应该是指定两个指针，一个慢指针指向第一个元素，快指针指向第二个元素，快指针一只判断自己所在位置的元素是不是和慢指针所在的元素相同，若相同则快指针后移，若不同则将快指针所在位置的元素赋值给慢指针后面的元素，慢指针再后移一位。最后慢指针指向的元素和之前的所有元素都不是重复的。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">removeDuplicates</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n            <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">count</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]:</span>\n                <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">count</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">+</span><span class=\"mi\">1</span></code></pre></div><p>时间复杂度 O(N)，空间复杂度 O(1)。</p><p>另外，自己看了一些大牛关于如何刷题的技巧，有一点还是比较同意的，即：第一遍刷题的时候应该直接看答案，因为我们：</p><ol><li>不知道特定的算法和数据结构</li><li>没有正确的思维方法</li></ol><p>这样就导致我们刷题的速度和质量非常的慢，所以应该第一遍刷题的时候直接看答案，第二遍再来慢慢思考巩固从答案中总结出来的知识和技巧。</p><hr/><h2>Review</h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//towardsdatascience.com/use-ai-for-augmenting-yourself-b53c39db0b95\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The AI for augmenting yourself</a></b></p><p>这周选的文章是 Medium 上面关于“虚拟世界中的真实人物”的一篇文章。</p><p>作者在文中解释了互联网世界中我们的虚拟人物（digital profiles）是如何被建立起来的：</p><blockquote> 我们生活在过去，我们所有的人物画像都存储在过时的数据格式中，这些格式与几十年前没有太大差别。但是现在人工智能通过我们喜欢的社交媒体、我们的购买记录、我们与世界的互动方式等数据来强化自己，我们可以将认知能力赋予我们的虚拟人物。<br/> 现在想象一下，我们的虚拟人物能够说话，思考，选择，执行我们特有的某些行为。从在线个性模式中诞生的虚拟人物件直接与我们相关。我们的第二个身份生活在虚拟世界中，这是一个增强的世界，我们的3D智能虚拟人物具有我们的个性，我们知道它是可信赖的代表，就像我们喜欢的一切。我们将有无限的可能性在数字空间的任何地方使用我们的虚拟人物。而最奇妙的是，这将是一个巨大的用途，我们的世界将一劳永逸地改变。<br/> </blockquote><p>作者在这之后还展示了人工智能的各种可能性，表达了自己对这一新技术的关注和期待，作者对人工智能有着非常积极的态度。</p><p><b>个人观点</b>：</p><p>本以为西方世界中大多数人民应该对人工智能这一产物有着更高的认知，但是这篇积极正面的文章以及下面很多正面的评论却让我感到一种隐隐的不安。我想到<a href=\"https://link.zhihu.com/?target=https%3A//www.theguardian.com/technology/2019/feb/22/new-york-facebook-privacy-data-app-wall-street-journal-report\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">各大公司不断爆出的个人隐私的泄露和滥用</a>（可笑的是我在搜索这篇文章的时候，点今卫报的网站，然后快速的点击了接受 Cookies 🙂），我想到很多电影小说中的超出人类掌控的智能体（黑客帝国、银翼杀手），我想到<a href=\"https://link.zhihu.com/?target=http%3A//survivor.ruanyifeng.com/future/unabomber.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">卡辛斯基的警告</a>和<a href=\"https://link.zhihu.com/?target=https%3A//www.bbc.com/ukchina/simp/uk_life/2014/12/141202_stephan_hawking_ai\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">霍金等人的人工智能威胁论</a>，也想到尤瓦尔·赫拉利提到的<a href=\"https://www.zhihu.com/question/45353023\" class=\"internal\">吉尔伽美什计划</a>。也许我们对数据和人工智能的使用，应该放缓一些？在这一方面，也许欧盟的 GDPR 做的不错。</p><hr/><h2>Tips</h2><p>这周的 Tip 我觉得还蛮有必要把它写成一个单独的文章，步骤比较多，就放在 Share 部分了。关于如何配置自己的 iTerm2 的外观。</p><p>结果： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d373b5a8e1aab74d633dee6642eae242_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb\" width=\"1700\" data-original=\"https://pic3.zhimg.com/v2-d373b5a8e1aab74d633dee6642eae242_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1700&#39; height=&#39;1002&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1700\" data-original=\"https://pic3.zhimg.com/v2-d373b5a8e1aab74d633dee6642eae242_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d373b5a8e1aab74d633dee6642eae242_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>Share</h2><p><b><a href=\"https://zhuanlan.zhihu.com/p/62399121\" class=\"internal\">iTerm2 的外观配置</a></b></p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62399121", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 2, 
            "title": "iTerm2 外观配置", 
            "content": "<h2>iTerm2 外观配置</h2><p>前几天在使用 iTerm2 的时候，发现配色很久没有换过，慢慢已经看腻了，于是决定重新进行外观配置。步骤如下：</p><p><b>Prerequisite:</b> Homebrew，<a href=\"https://link.zhihu.com/?target=https%3A//brew.sh/index_zh-cn\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">下载</a></p><h2>逐步配置过程</h2><ol><li> 安装 <a href=\"https://link.zhihu.com/?target=https%3A//www.iterm2.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">iTerm2</a><br/> iTerm2 比 mac 自带的 Terminal 好很多，关于两者的比较，网上已经有众多讨论，在此不再赘述。<br/> </li><li> 安装 zsh<br/> <code>bash brew install zsh</code><br/> <a href=\"https://link.zhihu.com/?target=https%3A//rick.cogley.info/post/use-homebrew-zsh-instead-of-the-osx-default/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这里</a>有一篇非常好的讲解如何安装 zsh 的文章。<br/> </li><li> 安装 <a href=\"https://link.zhihu.com/?target=https%3A//ohmyz.sh/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">oh-my-zsh</a> 插件<br/> 复制这一行到你的命令行窗口，然后静静等待它运行完毕就可以了：<br/> <code>bash sh -c &#34;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&#34;</code><br/> </li><li> 为 oh-my-zsh 安装 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/bhilburn/powerlevel9k\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">powerlevel9k</a> 主题<br/> 在命令行窗口运行这一行代码：<br/> <code>bash git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k</code><br/> </li><li> 安装字体<br/> 在 <a href=\"https://link.zhihu.com/?target=https%3A//nerdfonts.com/%23downloads\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Nerd Font</a> 网站找到 Meslo 这个字体，下载解压。<br/> 打开「字体册」这个 App，将解压好的字体全部拖进去，Mac 会自动为你安装好所有的字体。<br/> 打开 iTerm2，打开 Preference，选择 Profile，选一个你自己的 Profile（默认是 Default），选择 Text 栏，在 Font 中选择刚刚安装的 Meslo 字体（注意这里应该是 Nerd Font Complete），调整适合自己的字体大小。选号字体之后，勾选「Use a different font for non-ASCII text」和「Anti-aliased」，之后会出现「Non-ASCII Font」这个选项，点击选择 Melso 字体，同样勾选「Anti-aliased」。<br/> </li><li> 为 iTerm2 安装 Material Design Theme<br/> 根据 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/MartinSeeler/iterm2-material-design\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Material Design Theme</a> 进行下载安装。<br/> </li><li> 为 zsh 安装两个额外的插件<br/> </li><ol><li> 语法高亮：<br/> <code>bash git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</code><br/> </li><li> 自动建议：<br/> <code>bash git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code><br/>  </li></ol><li> 替换 .zshrc 文件<br/> 去我的 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/AlainOUYANG/my_zsh_config\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Github</a> 下载 .zshrc 文件，复制第 89 行（包含）之后的内容，粘贴到你的 .zshrc 中去。<br/> </li></ol><p>安装字体时 iTerm2 中的配置：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-936913bc0ad1098332e835a2ff20d8d4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1631\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb\" width=\"1631\" data-original=\"https://pic1.zhimg.com/v2-936913bc0ad1098332e835a2ff20d8d4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1631&#39; height=&#39;1080&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1631\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1631\" data-original=\"https://pic1.zhimg.com/v2-936913bc0ad1098332e835a2ff20d8d4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-936913bc0ad1098332e835a2ff20d8d4_b.jpg\"/></figure><p>最终效果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d373b5a8e1aab74d633dee6642eae242_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb\" width=\"1700\" data-original=\"https://pic3.zhimg.com/v2-d373b5a8e1aab74d633dee6642eae242_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1700&#39; height=&#39;1002&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1700\" data-original=\"https://pic3.zhimg.com/v2-d373b5a8e1aab74d633dee6642eae242_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d373b5a8e1aab74d633dee6642eae242_b.jpg\"/></figure><h3>知乎的 Markdown 编辑器太难用了！！！</h3>", 
            "topic": [
                {
                    "tag": "iTerm2", 
                    "tagLink": "https://api.zhihu.com/topics/19674686"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61604757", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 0, 
            "title": "左耳听风：ARTS 第 2 周", 
            "content": "<blockquote>每周完成一个 ARTS：<br/>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: LeetCode 27. Remove Element</li><li>Review: IBM 的 Data Science Community 中的一篇文章 <a href=\"https://link.zhihu.com/?target=https%3A//community.ibm.com/community/user/datascience/blogs/paco-nathan/2019/03/12/a-landscape-diagram-for-python-data\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">A landscape diagram for Python data</a></li><li>Tip: Linux 中的 <code>/bin</code>，<code>/sbin</code>，<code>/usr/bin</code>，<code>/usr/sbin</code>，<code>/usr/local/bin</code> 和 <code>/usr/local/sbin</code></li><li>Share: 自己对《A landscape diagram for Python data》这篇文章的翻译</li></ul><hr/><h2>Algorithm</h2><p><b>移除元素</b></p><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/remove-element/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">27. Remove Element</a></p><p>难度：Easy</p><p>题意：给定一个数组 <code>nums</code> 和一个值 <code>val</code>，<b>原地</b>移除数组中包含的所有的 <code>val</code> 值，然后返回新的数组的长度。要求不能给另一个数组分配额外的内存空间，所以必须以 O(1) 的空间复杂度原地更改输入的数组。元素的顺序可以改变，超出新数组长度的情况可以不考虑。</p><p>例子 1：</p><div class=\"highlight\"><pre><code class=\"language-text\">Given nums = [3,2,2,3], val = 3,\n\nYour function should return length = 2, with the first two elements of nums being 2.\n\nIt doesn&#39;t matter what you leave beyond the returned length.</code></pre></div><p>例子 2：</p><div class=\"highlight\"><pre><code class=\"language-text\">Given nums = [0,1,2,2,3,0,4,2], val = 2,\n\nYour function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.\n\nNote that the order of those five elements can be arbitrary.\n\nIt doesn&#39;t matter what values are set beyond the returned length.</code></pre></div><p>在 LeetCode 的环境下，你的输出应是一个整数，但输出的答案是一个数组。因为在实际生产过程中，数组是以「引用（Reference）」的方式传递的，这也就意味着，在函数中修改输入数组对调用者可见。为了避免这种「可见」性，LeetCode 内部有如下操作：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// nums is passed in by reference. (i.e., without making a copy)\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"n\">removeElement</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// any modification to nums in your function would be known by the caller.\n</span><span class=\"c1\">// using the length returned by your function, it prints the first len elements.\n</span><span class=\"c1\"></span><span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">len</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>解法： </p><p>1. 创建一个 <code>i</code>，使用一个 <code>for</code> 循环，没有碰到 <code>val</code> 的时候，直接借用当前数字替换原有数组中的 <code>nums[i]</code>，累加 <code>i</code>，最后返回 <code>i</code> 即可</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">removeElement</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :type val: int\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"n\">nums</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">num</span> <span class=\"o\">!=</span> <span class=\"n\">val</span><span class=\"p\">:</span>\n                <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">num</span>\n                <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">i</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。最坏的情况是，待移除的元素都在数组最末尾的时候，<code>num</code> 需要移动到数组末尾，<code>nums[i]</code> 也需要移动到自己的末尾，一共是 2n 步。</p><p>2. 考虑一些需要移除的元素比较少的情况，比如 <code>nums = [1,2,3,5,4], val = 4</code>，如果按照上面的算法，需要对前四个元素做一个不必要的拷贝操作；另外一个例子，<code>nums = [4,1,2,3,5], val = 4</code>，按照之前的算法我们需要将 <code>1,2,3,5</code> 这几个元素全部往前移一位，但是根据题目描述，我们其实不需要保留原来的元素顺序，所以我们只需要在遇到目标元素的时候，把数组最后的元素拿来覆盖当前的元素，然后将数组长度减 1 即可，这样即使最后一个元素也是目标元素，我们也会在下一个循环中检查它。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">removeElement</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type nums: List[int]\n</span><span class=\"s2\">        :type val: int\n</span><span class=\"s2\">        :rtype: int\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">val</span><span class=\"p\">:</span>\n                <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n                <span class=\"n\">length</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">i</span></code></pre></div><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><p>注：不使用 Python 内部自带的一些函数，可以锻炼思考能力。</p><hr/><h2>Review</h2><a href=\"https://link.zhihu.com/?target=https%3A//community.ibm.com/community/user/datascience/blogs/paco-nathan/2019/03/12/a-landscape-diagram-for-python-data\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> A landscape diagram for Python data</a><p>这周的文章选择的是 IBM 的 Data Science Community 中的一篇文章。 文章列举说明了当下最流行的 Python 库和数据科学框架。这个景观图中显示了 50 个左右的 Python 库和框架，以及它们之间的相互关系。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9b2eb36a2fbef8970cb2f7aa2dd03fa1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"2530\" class=\"origin_image zh-lightbox-thumb\" width=\"4096\" data-original=\"https://pic2.zhimg.com/v2-9b2eb36a2fbef8970cb2f7aa2dd03fa1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;4096&#39; height=&#39;2530&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"2530\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"4096\" data-original=\"https://pic2.zhimg.com/v2-9b2eb36a2fbef8970cb2f7aa2dd03fa1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9b2eb36a2fbef8970cb2f7aa2dd03fa1_b.jpg\"/></figure><p> 中文翻译版可以参考 Share 部分中我自己的翻译。</p><hr/><h2>Tips</h2><p><b>理解 Linux 中的 <code>/bin</code>，<code>/sbin</code>，<code>/usr/bin</code>，<code>/usr/sbin</code>，<code>/usr/local/bin</code> 和 <code>/usr/local/sbin</code></b></p><p>在清理电脑中 Python 版本时发现的两个链接，完全理解了这几个路径的意义和区别：</p><a href=\"https://link.zhihu.com/?target=https%3A//unix.stackexchange.com/questions/8656/usr-bin-vs-usr-local-bin-on-linux\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-ea462939073ac599d3f467ba077e287c_ipico.jpg\" data-image-width=\"316\" data-image-height=\"316\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">/usr/bin vs /usr/local/bin on Linux</a><a href=\"https://link.zhihu.com/?target=https%3A//askubuntu.com/questions/308045/differences-between-bin-sbin-usr-bin-usr-sbin-usr-local-bin-usr-local\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-c8fcb8f216e75f1c02b93fbc689a81c1_ipico.jpg\" data-image-width=\"316\" data-image-height=\"316\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Differences between /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin</a><hr/><h2>Share</h2><p><b>《A landscape diagram for Python data》翻译</b></p><a href=\"https://zhuanlan.zhihu.com/p/61604019\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-a900be4ea7e7d3cf0a1a93fcad7efc52_180x120.jpg\" data-image-width=\"2048\" data-image-height=\"1363\" class=\"internal\">马克图布：Python 数据科学的风景图</a><p></p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61604019", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 10, 
            "title": "Python 数据科学的风景图", 
            "content": "<blockquote>本文是 <a href=\"https://link.zhihu.com/?target=https%3A//community.ibm.com/community/user/datascience/blogs/paco-nathan/2019/03/12/a-landscape-diagram-for-python-data\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">A landscape diagram for Python data</a> 这篇文章的翻译版本，由于译者水平有限，欢迎批评指正。</blockquote><p>这篇文章介绍了一张「<a href=\"https://link.zhihu.com/?target=https%3A//higherlogicdownload.s3.amazonaws.com/IMWUC/UploadedImages/0d63eecd-fa76-4440-b4c0-a34a9e757e49/landscape.png\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">风景图</a>」，图中列举说明了当下最流行的 50 个左右 Python 库和数据科学框架。风景图展示了技术栈中的各个部分和他们的互补技术。换句话说，「零件是怎么组合起来的？」</p><p>举个例子，IBM 赞助的一些项目适用于数据科学工作中哪些大型开源 Python 的生态系统呢？<a href=\"https://link.zhihu.com/?target=https%3A//blog.jupyter.org/introducing-jupyter-enterprise-gateway-db4859f86762\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Jupyter Enterprise Gateway</a> 就是一个很好的例子，它弥补了 <a href=\"https://link.zhihu.com/?target=https%3A//jupyter.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Project Jupyter</a> 和 <a href=\"https://link.zhihu.com/?target=https%3A//spark.apache.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache Spark</a> 之间的差距，并允许 Jupyter notebook 在企业级集群计算上运行。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9b2eb36a2fbef8970cb2f7aa2dd03fa1_b.jpg\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"2530\" class=\"origin_image zh-lightbox-thumb\" width=\"4096\" data-original=\"https://pic2.zhimg.com/v2-9b2eb36a2fbef8970cb2f7aa2dd03fa1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;4096&#39; height=&#39;2530&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"2530\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"4096\" data-original=\"https://pic2.zhimg.com/v2-9b2eb36a2fbef8970cb2f7aa2dd03fa1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9b2eb36a2fbef8970cb2f7aa2dd03fa1_b.jpg\"/><figcaption>A landscape diagram for Python data</figcaption></figure><p>这张风景图提供了非常有用的信息，帮助我们概念化和讨论复杂的技术主题。随着 Python 生态系统的发展，保持这个图表的策划和更新非常重要。我们会这样做的。</p><p>注意：尝试将大量复杂的互连部件组合成整齐且格式化的二维网格是一项挑战。任何图表都必须“模糊定义的界限”以简化说明，这些定义之后可以详细讨论。一方面，这张风景图不包括极其详尽的列表。我们选择了广泛使用的流行的标准库，但也不得不舍弃一些相对不那么常用的。例如，我们没有讨论各种音频处理库，这些库用于语音到文本的识别任务。另一方面，我们来谈谈这个吧！如果您有关于任何更新的建议，请告诉我们。我们将在这里建立一个讨论论坛。</p><h2>基础</h2><p>为什么是 Python 呢？目前来看，Python 已经成为数据科学工作中的通用语言。这门语言学习起来相对容易，并且有非常多的开源框架和库可以实现任何你的需求。如果没有的话，开发一个新的框架也非常容易。在构建 Web 应用、操作等方面，Python 也正变得的越来越受欢迎，所以它也非常适合于将数据科学的项目集成到大型应用环境上去。虽然其他的语言比如 R、Java 和 Scala 同样也适用于数据科学工作，但是还是让我们先关注一下 Python 吧，否则这个风景图会变得非常拥挤。</p><p>我们来谈论一下版本吧。2.x 版本和 3.x 版本的 Python 之间存在着非常大的差距，如果你刚刚开始使用 Python 编程，我建议你从 Python 3.x 开始，除非你的公司仍然需要 Python 2.x —— 确实有一些公司会需要 2.x 版本，并且这些原因是不同而且复杂的。然而如果你有机会从<a href=\"https://link.zhihu.com/?target=https%3A//www.python.org/downloads/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">最新稳定版本</a>开始（目前是 Python 3.7.1），那将是最好的选择。</p><p>如果你正好刚刚开始学习 Python 编程，这里有两个非常受欢迎的推荐课程：</p><ul><li>Jessica McKellar 的 <i><a href=\"https://link.zhihu.com/?target=https%3A//www.oreilly.com/library/view/introduction-to-python/9781491904794/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Introduction to Python</a></i></li><li>Allen Downey 的 <i><a href=\"https://link.zhihu.com/?target=https%3A//greenteapress.com/wp/think-python-2e/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Think Python</a></i></li></ul><p>你可能也听过某些 Python 开发者谈论被称为「<a href=\"https://link.zhihu.com/?target=https%3A//www.python.org/dev/peps/pep-0008/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PEP8</a>」的东西。这是 Python 编码的最新风格指南，它提供了很好的建议以及许多有用的例子。<a href=\"https://link.zhihu.com/?target=https%3A//www.python.org/doc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个文档</a>提供了许多一般情况下的编码示例。</p><p>Python 的原作者 Guido van Rossum 指出，「代码被阅读的频率远远高于被写出来的频率」，所以可读性就成为了 Python 语言的一个核心方面。Allen Downey（上面 <i>Think Python</i> 课程的作者）发现，Python 的可读性给它带来了独特的性质。举例来说，如果你对在学术文献中描述算法的<i>伪代码</i>比较熟悉，那么 Downey 已经展示了<a href=\"https://link.zhihu.com/?target=https%3A//blogs.scientificamerican.com/guest-blog/programming-as-a-way-of-thinking/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">比同等伪代码更加简洁的 Python 实现</a>。简介、可读的代码的使用为数据科学团队带来了很多的方便，人们需要理解彼此的代码并且能够复现结果。</p><h2>包管理</h2><p>风景图最底部的一层是<i>包管理</i>。换句话说，是如何安装和更新你将需要的 Python 库。</p><p>Python 为此有两个推荐的选项： </p><ul><li><i>pip</i>：一个通用的 Python 包管理器，使用 <a href=\"https://link.zhihu.com/?target=https%3A//pypi.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PyPi</a> 包索引的「官方」管理器</li><li><i>conda</i>：跨平台的环境管理器，与语言无关，使用 <a href=\"https://link.zhihu.com/?target=https%3A//www.anaconda.com/what-is-anaconda/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Anaconda</a> 发行版</li></ul><p>请注意，<i><a href=\"https://link.zhihu.com/?target=https%3A//packaging.python.org/tutorials/installing-packages/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pip</a></i> 和 <i><a href=\"https://link.zhihu.com/?target=https%3A//conda.io/docs/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">conda</a></i> 是两个完全不同的工具，用于非常不同的目的，只是它们两个恰巧共同拥有 Python 的包管理功能——而且他们在这个目的上是几乎相同的。几年前我可能说过「conda 在学术研究人员中更受欢迎，而 pip 在生产工作中更受欢迎」这种话，但现在已经不再是这样了。如果你的组织要求你使用其中的一个或另一个，那么最好根据要求来，两个混着用可能会导致问题。另见 Jake VanderPlas 在「<a href=\"https://link.zhihu.com/?target=https%3A//jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Conda: Myths and Misconceptions</a>」中对这两个工具的精彩讨论。</p><p>选择好包管理器之后，接下来我强烈建议在开始安装各种库之前使用<i>虚拟环境</i>。换句话说，创建一个具有自己安装目录的环境，以避免修改其他环境中被依赖的 Python 库。根据你自己的项目不同，你有可能会同时激活几个不同的虚拟环境。</p><p>如果你正在使用 <i>conda</i>，那么它自己就有<a href=\"https://link.zhihu.com/?target=https%3A//uoa-eresearch.github.io/eresearch-cookbook/recipe/2014/11/20/conda/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">设置虚拟环境的功能</a>。而 <i>pip</i> 则有多个选择。有关所有的细节，请见 Colin Carroll 的 「<a href=\"https://link.zhihu.com/?target=https%3A//www.dropbox.com/s/04dyvo8eifsi8nz/Colin%2520Carroll.key%3Fdl%3D0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Improved Workflows With Isolated Jupyter Environment</a>」——尤其是幻灯片的第 11-14 页。我建议使用 <i><a href=\"https://link.zhihu.com/?target=https%3A//virtualenv.pypa.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">virtualenv</a></i>，它运行良好，并且网上有非常多的示例。</p><p>目前在我的笔记本上我使用 <i>pip</i> 和 <i>virtualenv</i> 并且为不同的项目在四个 Python 虚拟环境中来回切换。我的大多数编码示例都会展示如何使用它们，但这些示例也可以转换为 <i>conda</i>。</p><p>说到管理库，请查看 <a href=\"https://link.zhihu.com/?target=https%3A//libraries.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libraries.io</a>，它会自动跟踪代码库所依赖的包，甚至可以跟踪许多不同的包管理器或语言。</p><h2>应用框架</h2><p>在底层的上面一层，让我们来思考一下如何运行 Python 应用。代码必须在某处运行。你的数据科学的工作很可能对<i>安全</i>、<i>数据隐私</i>、<i>资源管理</i>、<i>监控</i>等等都有很高的要求。在企业环境中，在这些合规性要求下运行代码是很有挑战性的。</p><p>当然直接在命令行中运行 Python 程序是一个很简单的方式，对于个人的开发/测试来说有可能没问题，但是，当你需要与人合作，你的代码需要在生产环境中运行的时候，你还有其他的选择。这些选择也有助于并行工作负载，因为某些用例可能处于规模和速度需要多个服务器。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//spark.apache.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache Spark</a></i> 是数据科学工作流中最受欢迎的框架，使用 <i><a href=\"https://link.zhihu.com/?target=https%3A//spark.apache.org/docs/latest/quick-start.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PySpark</a></i> 运行 Python 代码也是非常容易的。你可以在 PySpark 的<i>独立模式</i>下执行 Python 代码，即从笔记本的命令行或者一个可以帮助并行化工作负载的 Spark 集群上运行。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//jupyter.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Project Jupyter</a></i> 在管理数据科学工作流中也非常受欢迎，「Python」是它的名字「Jupyter」中「py」的部分。Peter Parente 追踪了 Github 上<a href=\"https://link.zhihu.com/?target=http%3A//nbviewer.jupyter.org/github/parente/nbestimate/blob/master/estimate.ipynb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">公共的 Jupyter notebook 的数量</a>，这个数字最近超过了三百万。Jupyter 为编辑代码、可视化结果和编辑文档提供了很多方式——所有这些方式都是在同一个文档中。你的同事可以重新运行你的 notebook 以重复你的分析，或者他们可能调整它以适应于其他的数据来源、不同的参数等等。<i><a href=\"https://link.zhihu.com/?target=https%3A//jupyterlab.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JupyterLab</a></i> 现在是编辑和运行 notebook 的推荐方式。</p><p>虽然不是严格的 Python 库，但如果你想让很多（数千？）人在你的组织中运行同样的 notebook，<i><a href=\"https://link.zhihu.com/?target=https%3A//jupyterhub.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JupyterHub</a></i> 提供了很多生成和管理并发实例的方法。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//jupyter-enterprise-gateway.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Jupyter Enterprise Gateway</a></i> 为由 Jupyter 构建的工作流提供了企业级的资源管理。数据科学团队可以利用分布式资源并显著地扩展并行内核数的上限。通过增加企业级的安全性，任何在工作流中使用 JupyterLab 的团队都有潜在的可用性。它的构建是利用大数据工具和分布式资源、企业安全性，同时包括  <i>JupyterLab</i> 的所有 UX 和集成功能等。</p><p>Spark 和 JupyterHub 等分布式框架倾向于使用过多的系统工程开销。 Spark 使用 Scala，而且有时候会需要 <a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/cd/E13222_01/wls/docs81/perform/JVMTuning.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JVM tuning</a> 来突破系统性能的瓶颈。此外，<i>PySpark</i> 需要使用特使的数据集来完成规模和并行特性。通常这并不能够直接被转换为 Python 通用的分析建模库——这也就意味着你可能需要重构你的代码以便他们能高效地跑在 Spark 上面。</p><p>另一些选择并不需要过多的开销，并且能在规模上运行 Python 代码，同时要求更少的代码重构。<i><a href=\"https://link.zhihu.com/?target=http%3A//docs.dask.org/en/latest/why.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Dask</a></i> 是一个常用的并行工作负载的 Python 库，它可以扩展到 HPC 超级计算机上——或者只是在笔记本上运行。它遵循与用于分析和建模的流行 Python 包相同的语言和数据结构，例如 <i>NumPy</i> 和 <i>scikit-learn</i>。<i><a href=\"https://link.zhihu.com/?target=http%3A//pywren.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PyWren</a></i> 提供了相似的方法来在<a href=\"https://link.zhihu.com/?target=http%3A//pywren.io/pywren_backends.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">无服务器的云 API</a> 上扩展 Python 代码，而无需重写数据结构或管理集群，并且它被证明对于在构建完整管道时可能过度的临时查询很有价值。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//rise.cs.berkeley.edu/projects/ray/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Ray</a></i> 是另一个分布式的 Python 框架，来自 UC Berkeley 的 RISElab 实验室，被用于<i>多智能体强化学习</i>。但实际上，这个框架有更多的意义：它几乎被认为是来自同一个实验室五年后的「下一代的 Spark」——这次是以先进的机器学习为核心。强化学习的大型生产用例开始在工业界中浮出水面，请继续关注，你会很快听到更多相关信息。</p><p>有时候，数据科学项目会以<i>微服务</i>的方式运行，或者提供 <a href=\"https://link.zhihu.com/?target=https%3A//www.openapis.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenAPI 集成</a>，或者出于其他的某些原因被构建为 Web 应用。很显然，使用 <i><a href=\"https://link.zhihu.com/?target=https%3A//www.docker.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Docker</a></i> 和 <i><a href=\"https://link.zhihu.com/?target=https%3A//kubernetes.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Kubernetes</a></i> 组合来管理基于<i>容器</i>的微服务架构现在已经受到了非常多的关注。虽然使用 <a href=\"https://link.zhihu.com/?target=https%3A//jupyter-kernel-gateway.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Jupyter Kernel Gateway</a> 来展示一个简单的基于 Jupyter 的微服务是可行的，但你可能仍然需要迁移到其他 Web 框架以实施大规模服务，以及满足企业中的其他性能或合规性问题（请参阅下一节中的更多相关信息）。<i><a href=\"https://link.zhihu.com/?target=http%3A//flask.pocoo.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Flask</a></i> 是一个流行的 Python 「微框架」，它非常易用。<i><a href=\"https://link.zhihu.com/?target=https%3A//gunicorn.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Gunicorn</a></i> 是一个与 WSGI 兼容的 HTTP 服务器，可以快速（3 行 Python 代码）与 <i>Flask</i> 集成。即是：<i>Gunicorn</i> 是一个将 <i>Flask</i> Web 应用程序直接插入高性能、高安全性的 Web 服务器框架（如 <i><a href=\"https://link.zhihu.com/?target=https%3A//www.nginx.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Nginx</a></i>）的好方法。即使对于更复杂的环境，这也是将数据科学工作融入组织开发实践（例如安全措施、负载平衡、边缘缓存等）的好方法。</p><h2>网络资源</h2><p>往上一层，有时你会需要与网络资源集成。你可能需要提供数据、消费数据，或者与其他应用分项数据？</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//arrow.apache.org/docs/python/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PyArrow</a></i> 是一个 <a href=\"https://link.zhihu.com/?target=https%3A//arrow.apache.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Apache Arrow</a> 的 Python 绑定。它相对来说比较新，提供了一个「内存数据的跨语言的开发平台…为在现代硬件上进行高效的分析操作而组织」。例如，你可能在 Node.js 应用程序中收集了大量的数据，并在其中运行分析 <a href=\"https://link.zhihu.com/?target=https%3A//spark.apache.org/streaming/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Spark Streaming</a>，以及 Python 中的其他报告…对于 IoT 应用来说，这是一个非常合理的场景。<i>PyArrow</i> 允许您在不同的技术之间共享数据，<i>零拷贝</i>；应用程序直接共享彼此的内存，超级快速、高效。<i>PyArrow</i> 已经集成到 Spark 中。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//scrapy.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Scrapy</a></i> 是一个非常流行的用于 Web 爬取的 Python 框架。举个例子，你可能需要抓取数百万个网页并从中收集数据，以创建自定义搜索引擎。<i><a href=\"https://link.zhihu.com/?target=http%3A//docs.python-requests.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Requests</a></i> 库提供了一个非常受欢迎的 API 来发出 Web 请求——这是一个比 <i>Scrapy</i> 更为常见的情况——并且它非常容易使用。如果你需要调用 API 来获取数据，运行机器学习模型等，我强烈建议使用。<i>Requests</i> 的口号是个有力的证明：</p><p>Requests 是 Python 中唯一一个 Non-GMO 的 HTTP 库，人类可以安全使用。</p><p><i><a href=\"https://link.zhihu.com/?target=http%3A//flasgger.pythonanywhere.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Flasgger</a></i> 却截然相反，当你需要为你的数据科学工作<i>发布</i>一个 API 时，Flasgger 是为在 <i>Flask</i> 上运行的 Web 应用发布 <a href=\"https://link.zhihu.com/?target=https%3A//www.openapis.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenAPI specs</a> 和 <a href=\"https://link.zhihu.com/?target=https%3A//swagger.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Swagger 工具</a>的简单方法。也就是说：从你的 Python 代码中创建自文档化的 API，人们可以在浏览器中测试它们的集成效果。一个简单的例子：试验在我的网站上运行 /api/v1/info 端点 <a href=\"https://link.zhihu.com/?target=https%3A//derwen.ai/apidocs/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">derwen.ai/apidocs/</span><span class=\"invisible\"></span></a>。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//istio.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Istio</a></i> 提供了一种部署内部微服务的方法，对于扩展、安全性、监控等具有企业级的管理能力。即，数据科学团队可以创建出让开发团队喜欢的应用。</p><p>注意，<i>Flask</i> + <i>Gunicorn</i> + <i>Flasgger</i> + <i>Istio</i> 非常适合于把 Python 的数据科学应用转换为大规模部署的企业级微服务。即，快速将机器学习模型投入生产只需要很少的额外代码，同时也可以保持运营团队的满意度。</p><h2>数据访问</h2><p>数据科学的第一步：准备好你的数据。数据科学的第二步：返回并花更多时间准备好数据。面对现实吧，你花费了大量时间在准备数据、访问数据、加载数据等工作上。我们可以在这一层写出非常多的东西，因为许许多多大数据工具和数据科学平台经常关注这一层。我们已经知道像 Spark 这样的工具会在 ETL 中起到作用并帮助加载来自多种格式的数据（译者注：ETL，是英文 Extract-Transform-Load 的缩写，用来描述将数据从来源端经过萃取、转置、加载至目的端的过程。ETL 一词较常用在数据仓库，但其对象并不限于数据仓库），让我们考虑一些你可能需要自己编码的其他流行的数据访问方法/框架吧。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//www.sqlalchemy.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SQLAlchemy</a></i> 是一个用于从 Python 访问 SQL 数据库的流行的「瑞士军刀」。它支持各种不同的数据库平台和特性。SQLAlchemy 被设计成 DBA 友好型，是一个功能齐全的 ORM（object-relational mapper 对象关系映射器），非常适用于需要与 Java 数据库框架集成的任务——类似于 J2EE + Hibernate 工具包。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//pillow.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Pillow</a></i> 通过 Python Imaging Library 提供图像处理的功能。视频和图像数据是目前最受欢迎的深度学习数据源。这是一种阅读图像文件的流行方式。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//www.crummy.com/software/BeautifulSoup/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">BeautifulSoup</a></i> 是读取 HTML 和 XML 文档最流行的包之一。它对 HTML 中的格式错误容错率很高，而实际上大部分的网页也确实如此。<i>BeautifulSoup</i> 还可以自动将文档转换为 Unicode，因为这一点，它就应该获得诺贝尔奖。一旦你为你的 NLP 项目抓取了数百万个网页，就可以使用 <i>BeautifulSoup</i> 将 HTML 标记转换为 NLP 库可以解析的文本数据了。</p><h2>数据表示</h2><p>我们向上移动到<i>数据表示</i>这一层——在将数据加载到数据科学工作流程之后，它需要在某个地方「生存」，最好是在高效的数据结构中。粗略地说，<i>特征工程</i>就经常使用在这一层。根据使用情况和涉及的数据类型，有几种流行的选择。</p><p><i><a href=\"https://link.zhihu.com/?target=http%3A//pandas.pydata.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Pandas</a></i> 可能是现存<i>最彻底的数据科学的</i> Python 软件包。如果我们的风景图只显示一个矩形，那么该矩形就是「<i>Pandas</i>」。Wes McKinney 的 <i><a href=\"https://link.zhihu.com/?target=http%3A//shop.oreilly.com/product/0636920050896.do\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Python for Data Analysis</a></i> 提供了有关 Pandas 的所有细节。一旦您访问到了数据——通过 SQL 查询、读取图像文件、抓取 HTML 页面等——然后在工作流的下一个阶段之前，在 <i>Pandas</i> 中对数据进行切片和切块，即用于可视化、报告、特征工程、建模、评估等。</p><p>就在 <i>Pandas</i> 库旁边，<i><a href=\"https://link.zhihu.com/?target=http%3A//www.numpy.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NumPy</a></i> 是「用 Python 进行科学计算的基础包。」换句话说，<i>NumPy</i> 是 Python 数据科学的主力工具包。请注意，在数据科学和机器学习中，我们所做的大部分工作都使用大型数组和矩阵，实际上是反复执行计算大量的<i>线性代数</i>。<i>NumPy</i> 为许多线性代数问题提供了高度优化的数据结构。</p><p>有时候大数据会因为数据量太大而无法展现自己的优势。例如，如果你需要计算数十亿个项，将一个非常庞大的数字除以另一个非常庞大的数字，这可能会产生不必要的处理性能瓶颈。如果你的最终结果是计算比率，并且你只需要一些有效数字，例如在 95％ 的置信区间内，那么你真正执行的计算量至少比所需要的计算值高两个数量级（近似）。正如他们在 Twitter 上所说的那样——<i>概率数据结构</i>成为大数据工作的一个重要优势——「哈希，而不是采样。」<a href=\"https://link.zhihu.com/?target=https%3A//github.com/ekzhu/datasketch\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">datasketch</a> 库在 Python 中为<i>概率数据结构</i>提供了一些更好的实现方式。例如，查看我的同名<a href=\"https://link.zhihu.com/?target=https%3A//www.oreilly.com/learning/probabilistic-data-structures-in-python-new\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">教程</a>。作为 <i>NumPy</i> 的替代和补充，这对于特别是 NLP 应用和一般的<i>特征工程</i>非常有用。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//modin.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Modin</a></i> 是 <i>Ray</i> 上的 <i>Pandas</i>。换句话说，Modin 通过仅仅更改一行代码来扩展 <i>Pandas</i> 的工作流程。同样，这基本上是<i>五年后的下一代 Spark</i>——再加上 <i>Ray</i> 对于数据科学的 Python 库来说更为惯用。</p><p>移到图表的 NLP 区域，<i><a href=\"https://link.zhihu.com/?target=https%3A//spacy.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">spaCy</a></i> 的好处实在太多。如果你需要在 Python 中进行自然语言的工作——例如文本分析——请使用 <i>spaCy</i>。它是 Python 中最先进、最快、最流行的 NLP 软件包，并且它也与其他软件包相得益彰。请注意，<i>spaCy</i> 是一种「专横的API」，也就是说它只包含了它的作者所需的内容，但不包括所有需要的东西。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//www.nltk.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NLTK</a></i> 来自上一代的 Python 自然语言库。与 <i>spaCy</i> 相反，<i>NLTK</i> 通常 (a) 较慢，(b) 不太先进，(c) 不仅包括厨房水槽，还包括堆叠在其他厨房水槽内的许多厨房水槽（指代码复杂）。即便如此，你仍会遇到许多仍然使用 <i>NLTK</i> 的代码。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//rdflib.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">RDFLib</a></i> 是一个用于处理 RDF、OWL 和其他语义 Web 格式的 Python 库。即，如何在<i>知识图谱</i>中进行读取和写入。请注意，RDF 来自十多年前的早期 AI 工作。技术可能已经发展，但数据格式仍然有些标准化。知识图谱是一个趋势，因为它们提供了一些好方法，用以添加容易被深度学习方法遗漏的一些上下文。</p><h2>分析和建模</h2><p>向上移动一层，既然我们已准备好了数据，执行了特征工程并转换了数据，那么它已准备好去训练机器学习模型或运行其他类型的分析了。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//www.scipy.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SciPy</a></i> 是「科学计算的基础库」。因此它横跨了我们的风景图中的两层：一方面，<i>SciPy</i> 提供数值分析、高级线性代数、以及用于科学计算的全系列 Python-atop-FORTRAN 代码；另一方面，<i>SciPy</i> 包含了用于读取特殊格式的功能，例如图像文件。一般来说，它能与 <i>NumPy</i> 很好地匹配。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//scikit-learn.org/stable/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">scikit-learn</a></i> 算法家族可以说是 Python 上最流行的机器学习库。它很好地夹在下面的 <i>Pandas</i> + <i>NumPy</i> + <i>SciPy</i> 和上面的 <i>Matplotlib</i> 之间。坦率地说，我使用 scikit-learn 比任何其他机器学习库更多。有关优秀（且非常受欢迎）的指南，请参阅Aurélien Géron 的 <i><a href=\"https://link.zhihu.com/?target=http%3A//shop.oreilly.com/product/0636920052289.do\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hands-On Machine Learning with Scikit-Learn and TensorFlow</a></i>。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//www.statsmodels.org/stable/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StatsModels</a></i> 是 Python 中的通用统计软件包，它通常与 <i>NumPy</i> 一起使用。结果使用现有的统计软件包进行测试，以确保正确性。我特别喜欢他们文档中的「<a href=\"https://link.zhihu.com/?target=https%3A//www.statsmodels.org/stable/pitfalls.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">陷阱</a>」和「<a href=\"https://link.zhihu.com/?target=https%3A//www.statsmodels.org/stable/examples/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">示例</a>」部分。</p><p><i>深度学习</i>的使用已经变得如此普遍，Python 有一些最流行的框架：</p><ul><li>谷歌的 <a href=\"https://link.zhihu.com/?target=https%3A//www.tensorflow.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TensorFlow</a>，这是最流行的方法</li><li><a href=\"https://link.zhihu.com/?target=http%3A//deeplearning.net/software/theano/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Theano</a>，去年停止了开发，但仍被广泛使用</li><li><a href=\"https://link.zhihu.com/?target=https%3A//keras.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Keras</a> 在 <i>TensorFlow</i> 和 <i>Theano</i> 上提供了一个易于使用的抽象层</li><li>来自 Facebook 的 <i><a href=\"https://link.zhihu.com/?target=https%3A//pytorch.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PyTorch</a></i>，其用户稳步增长</li></ul><p><i><a href=\"https://link.zhihu.com/?target=https%3A//allennlp.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">AllenNLP</a></i> 建立在 <i>PyTorch</i> 之上，为 NLP 问题提供深度学习解决方案。提示：这个研究项目与基于 <i>TensorFlow</i> 的研究相互竞争，有时他们会在几周之内发表论文，以获得基准测试结果的第一名。</p><p>作为 Python 中比较流行的 NLU（<i>natural language understanding</i> 自然语言理解）库之一， <i><a href=\"https://link.zhihu.com/?target=https%3A//github.com/RasaHQ/rasa_nlu\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Rasa</a></i> 获得了大量关注。它对于分类意图特别有用——换句话说，构建聊天机器人和语音应用。你可以根据用例在 <i>spaCy</i>，<i>scikit-learn</i>，<i>TensorFlow</i> 和其他基本 NLP + ML 技术上构建管道。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//radimrehurek.com/gensim/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Gensim</a></i> 是另一个用于 Python 中<i>主题建模</i>、<i>矢量嵌入</i>和相关文本挖掘算法的流行库。</p><p>转移到风景图的图区域，<i><a href=\"https://link.zhihu.com/?target=https%3A//networkx.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NetworkX</a></i> 获得了我对 Python 数据科学工作中「最不被重视，然而稳操胜券」的库的投票。它提供了一个用于在内存中创建、操作和分析图的包。坦率地说，图数据库往往会妨碍严格的图算法工作，特别是对于大规模的知识图谱工作。<i>NetworkX</i> 允许你在内存中处理大型的图、自定义图算法以及为你的用例进行分析，通常比图数据库框架更快，也更灵活。如果你需要创建知识图谱，请将 <i>NetworkX</i> 视为一个出色的工具吧。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//docs.pymc.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PyMC3</a></i> 为贝叶斯统计建模、概率编程、高级机器学习算法等提供了一个流行的 Python 包。如果你需要运行 <i><a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Markov_chain_Monte_Carlo\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MCMC</a></i>，你可能已经熟悉了 <i>PyMC3</i>。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//airflow.apache.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Airflow</a></i> 是一个 Python 框架——来源于 Airbnb——用于构建、运行和监视工作流。有趣的是，<i>Airflow</i>、<i>AllenNLP</i>、<i>TensorFlow</i>、<i>Rasa</i> 等正在开始定义另一个用于编排管道和工作流程的新兴的一层。</p><h2>可视化</h2><p>向上移动到<i>可视化</i>层：获取数据了？（检查），有功能了？（检查），有型号了？（检查），现在你需要查看结果，以评估你的分析和建模工作。有关其中一些软件包的理论详情，请参阅 Leland Wilkinson 的 <i><a href=\"https://link.zhihu.com/?target=https%3A//www.amazon.com/Grammar-Graphics-Statistics-Computing/dp/0387245448\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Grammar of Graphics</a></i> 一书。</p><p>风景图中列出了 Python 中六个最流行的通用可视化库，因为技术栈的这一部分在数据科学中尤其重要：</p><ul><li><i><a href=\"https://link.zhihu.com/?target=https%3A//matplotlib.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Matplotlib</a></i>，可以说是最广泛使用的，虽然对于「门外汉」来讲，有时候有点难以理解</li><li><i><a href=\"https://link.zhihu.com/?target=https%3A//seaborn.pydata.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Seaborn</a></i>，一个基于 <i>Matplotlib</i> 的抽象层，可以生成漂亮的图形，更易于使用</li><li><i><a href=\"https://link.zhihu.com/?target=https%3A//altair-viz.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Altair</a></i>，一个声明式的统计可视化库，更简洁，更易于理解</li><li><i><a href=\"https://link.zhihu.com/?target=https%3A//bokeh.pydata.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Bokeh</a></i>，专为网页上的交互式数据可视化而构建（例如 <i>Jupyter</i>）</li><li><i><a href=\"https://link.zhihu.com/?target=https%3A//plotnine.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">plotnine</a></i>，也是声明式的，<i>ggplot2</i> 的 Python 实现</li><li><i><a href=\"https://link.zhihu.com/?target=https%3A//plot.ly/online-chart-maker/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Plotly</a></i>，一个交互式 <a href=\"https://link.zhihu.com/?target=https%3A//plot.ly/online-chart-maker/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">D3 charts</a> 的在线编辑器</li></ul><p>如果你的数据可视化需要表示为地图怎么办？换句话说，如果你正在处理地理空间数据，该怎么办？<i><a href=\"https://link.zhihu.com/?target=https%3A//scitools.org.uk/cartopy/docs/latest/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cartopy</a></i> 是 <i>Matplotlib</i> 的一部分，你可以用它绘制基本的地图层（形状等），在这之上你又可以绘制其他分析和可视化的层。<i><a href=\"https://link.zhihu.com/?target=http%3A//geopandas.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GeoPandas</a></i> 扩展了 <i>Pandas</i>，可以有效地利用地理空间数据，支持 <i><a href=\"https://link.zhihu.com/?target=https%3A//shapely.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Shapely</a></i> 绘图。<i><a href=\"https://link.zhihu.com/?target=https%3A//rasterio.readthedocs.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Rasterio</a></i> 渲染<i>栅格</i>数据，例如卫星图像。</p><p>回到图的图形区域，<i><a href=\"https://link.zhihu.com/?target=https%3A//pypi.org/project/pydot/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Pydot</a></i> 是一个适配 <i><a href=\"https://link.zhihu.com/?target=https%3A//www.graphviz.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GraphViz</a></i> 的 Python 库。<i>Pydot</i> 与 <i>NetworkX</i> 搭配很好。在 NLP 用例和知识图谱工作中尤为方便。</p><h2>可解释性、公平性、偏见、伦理问题</h2><p>在风景图的顶层，我们展示了一组 Python 包，用来处理机器学习模型的<i>可解释性</i>，并解决数据科学中的<i>公平性</i>、<i>偏见</i>和<i>伦理问题</i>。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//developer.ibm.com/code/open/projects/ai-fairness-360/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">AIF360</a></i> 更正式地称为 IBM 的「AI Fairness 360 toolkit」。这可以检测进入机器学习管道的不需要的偏差，并有助于减少这些偏差。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//datascienceinc.github.io/Skater/overview.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Skater</a></i> 提供了用于机器学习模型解释的 Python 包。它根据多种策略构建，包括 <i><a href=\"https://link.zhihu.com/?target=https%3A//github.com/marcotcr/lime\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LIME</a></i>、贝叶斯规则列表（Bayesian rule lists）和深度学习模型解释器（deep learning model interpreters）。</p><p><i><a href=\"https://link.zhihu.com/?target=http%3A//deon.drivendata.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">deon</a></i> 是一个数据科学家的道德检查表。它可以简单地集成到 Git 代码库中，并且可以用作数据科学团队工程流程的一部分。</p><p><i><a href=\"https://link.zhihu.com/?target=https%3A//dsapp.uchicago.edu/projects/aequitas/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Aequitas</a></i> 是一种用于机器学习模型用例风险评估的偏见审计工具。</p><h2>总结</h2><p>好了，这是 Python 中数据科学的旋风之旅。虽然许多数据科学项目可能只使用了这些库中的一小部分，但希望引入的一些新功能和技术有助于你的实践。</p><p>同样，这是一个讨论的基础，我们将以此建立一个论坛以进行更多讨论。这个风景图是一个众所周知的「版本 1.0」，所以特别地，让我们讨论一下如何建议改进这个风景图怎么样？</p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "数据科学", 
                    "tagLink": "https://api.zhihu.com/topics/20034729"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>很强</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60999909", 
            "userName": "马克图布", 
            "userLink": "https://www.zhihu.com/people/ef51c5d54efa9ca30261e1725bb9f619", 
            "upvote": 1, 
            "title": "左耳听风：ARTS 第 1 周", 
            "content": "<p>每周完成一个 ARTS：</p><blockquote>Algorithm: 每周至少做一个 LeetCode 的算法题<br/>Review: 阅读并点评至少一篇英文技术文章<br/>Tips: 学习至少一个技术技巧<br/>Share: 分享一篇有观点和思考的技术文章</blockquote><hr/><h2>Contents:</h2><ul><li>Algorithm: LeetCode 1. Two Sum</li><li>Review: CohortPlus 上的一篇文章《<a href=\"https://link.zhihu.com/?target=https%3A//cohortplus.com/blog/common-machine-learning-algorithms-and-their-applications-nP4\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Common Machine Learning Algorithms and their applications</a>》</li><li>Tip: 分享了如何使用 <code>scp</code> 命令在 Linux 上通过 ssh 的方式传输文件</li><li>Share: 分享了一篇自己的旧文，并打算从这里开始继续写下去</li></ul><hr/><h2>Algorithm</h2><h3>两数之和</h3><p>题目：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/two-sum/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">1. Two Sum</a></p><p>难度：Easy</p><p>题意：给定一个整数数组 <code>nums</code>，找出其中两个和为给定目标的数字，并返回其下标。假定每个输入都只有一个确定的答案，但是要求数字的下标不能重复。</p><p>例子：</p><div class=\"highlight\"><pre><code class=\"language-text\">Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].</code></pre></div><p>解法： 1. 使用穷举法，两遍嵌套的 <code>for</code> 循环找出对应的 i 和 j 使得 <code>nums[i] + nums[j] == target</code> 即可。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n        <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">]</span></code></pre></div><p>很明显，这样的做法是非常耗时的，两遍嵌套循环的时间复杂度为 O(n^2)，如果想减小时间复杂度，应该考虑使用牺牲空间换取时间的方法。</p><ul><li>使用两遍哈希表（Python 中为字典）。创建一个名为 <code>values</code> 的空字典，第一遍遍历 <code>nums</code>，存储 <code>nums</code> 中所有的值和它们对应的位置，第二遍在 <code>values</code> 中寻找 <code>target - nums[i]</code>，并且判断符合条件的两个值的坐标是否相同（比如输入 <code>nums = [2, 7, 11, 15], target = 4</code>，那么 <code>result</code> 不应为 <code>[0, 0]</code>），如果相同就 <code>continue</code>。</li></ul><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"n\">values</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n        <span class=\"n\">values</span><span class=\"p\">[</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n        <span class=\"k\">if</span> <span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"ow\">in</span> <span class=\"n\">values</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"n\">values</span><span class=\"p\">[</span><span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]:</span>\n                <span class=\"k\">continue</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"p\">[</span><span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]]</span></code></pre></div><p>从 OJ 的结果来看还是相对比较耗时，在第一步我们存入了<b>所有的</b>数字，那么空间复杂度是 O(n)，牺牲了空间去换时间（这也是为什么提交的答案在「内存消耗」上之只超过了 5.08% 的用户的原因，因为大部分人都是使用的暴力解法，而暴力解法的空间复杂度是 O(1)）。</p><ul><li>一遍哈希。在查找过程中，每查找一个 <code>nums[i]</code>，如果不在 <code>values</code> 中，那么就将 <code>target - nums[i]</code> 存进 <code>values</code> 中，那么如果下一次查找，<code>nums[i]</code> 正好在 <code>values</code> 中，即之前存进来过的 <code>nums[某个i]</code>，那么直接返回。这样<b>不用遍历所有的数字</b>就可找出答案。返回的时候，应先返回存进 <code>values</code> 中的值，再返回当前的 <code>i</code>。</li></ul><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"n\">values</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)):</span>\n        <span class=\"k\">if</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">values</span><span class=\"p\">:</span>\n            <span class=\"n\">values</span><span class=\"p\">[</span><span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]],</span> <span class=\"n\">i</span><span class=\"p\">]</span></code></pre></div><p>这是我在 LeetCode 上做的第一道算法题，其实一开始并不知道如何去选择题目，就从第一题开始做了。在做完这道题目之后，我发现自己数据结构的基础非常不好，应该有意识地去针对性做练习，于是我找到了<a href=\"https://link.zhihu.com/?target=https%3A//cspiration.com/leetcodeClassification%2310301\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个网站</a>，它对 LeetCode 的题目进行了总结和排列。我打算之后按照 array，string，tree，linkedlist，math 的顺序来做题。请问大家是如何利用 LeetCode 进行练习的呢？</p><hr/><h2>Review</h2><h3><a href=\"https://link.zhihu.com/?target=https%3A//cohortplus.com/blog/common-machine-learning-algorithms-and-their-applications-nP4\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Common Machine Learning Algorithms and their applications</a></h3><p>这周的文章我选择的是 CohortPlus 上的一篇讲述常用的机器学习算法和应用的文章。</p><p>作者在文章开头就指出，拥有机器学习技术的工程师在市场上非常受欢迎，机器学习工程师和数据科学家拥有非常有竞争力的薪水。作者所有的工程师都应该尝试学习掌握机器学习技术。</p><p>那么对于初学者来说，应该掌握哪些常用的机器学习算法呢？对于一个实际问题，应该如何有针对性地选择高效的机器学习算法呢？对于某个确定的“过程”（即算法）来说，它又有哪些特点、优点和缺点呢？作者在后文给出了答案。</p><p>常用的机器学习算法分为四大类：</p><ol><li> 有监督学习 Supervised Learning<br/> 有监督学习算法包含了典型的分类（classification）和回归（regression）问题。从标注数据（训练集）中我们推测出（infer）一个合适的函数或模型，用它对输入数据（即测试集或者真实待求的数据）进行赋值（labeling）：如果结果为一个真实的数字，那么这个过程被称为<b><i>回归</i></b>；反之如果结果来自一些特定值的集合（set of values），这个过程被称为<b><i>分类</i></b>。<br/> </li><li> 无监督学习 Unsupervised Learning<br/> 和有监督学习正相反，在无监督学习中，我们并没有标注好的数据。我们对数据的相似性进行观察，并找出一些拥有相似数据的集合，将他们分为合适的聚类（cluster），当某些数据无法被分到某个类中时，将它们分为异常点或离群点（anomalies or outlines）。<br/> </li><li> 半监督学习 Semi-supervised Learning<br/> 半监督学习算法将有监督学习和无监督学习结合，使用很少的标注数据和一些未标注数据共同对模型进行训练，可以极大地提高训练的准确性。<br/> </li><li> 强化学习 Reinforcement Learning<br/> 和上面三种算法不同，在强化学习中，智能体（agent）根据奖赏（reward, positive reinforcement）或惩罚（penalty, negative reinforcement）进行学习并决定在某种情况下采取何种行为。<br/> </li></ol><p>接下下作者列出了一些常用的机器学习算法并进行了简要的介绍：</p><ol><li><b>线性回归 Linear Regression：</b>回归算法中最简单的机器学习算法，在大型数据集上表现非常好，可以使用梯度下降法来降低计算量。<br/> </li><li><b>逻辑回归 Logistic Regression：</b>用于二分类问题，逻辑回归算法计算每个数据属于某一类的概率，再根据概率进行分类。从某种角度来说，逻辑回归属于神经网络的一个非常小的例子。<br/> </li><li><b>决策树 Decision Tree：</b>决策树是一个非常系统的机器学习算法，决策的过程非常直观，很容易理解。决策树既可以做分类也可以做回归，分别使用交叉熵（或基尼纯度）或最小二乘法进行计算。<br/> </li><li><b>神经网络 Neural Network：</b>神经网络模仿人类大脑的结构，在层与层之间进行线性的连接，这赋予了网络非线性特征。对于图像和视频，深度卷积神经网络（Deep Convolutional Neural Networks）给出了最好的结果，对于自然语言处理（Natural Language Processing）问题，循环神经网络（Recurrent Neural Network）的表现最好。<br/> </li><li><b>支持向量机 Support Vector Machine：</b>支持向量机是一个非常经典的分类算法（当然也可以用于回归），它将待分类数据通过核函数（Kernel Function）映射到一个更高的维度，这样在更高的维度上数据就是线性可分的，使用一个超平面就可以对数据进行分类。<br/> </li><li><b>K 近邻算法 K-Nearest Neighbour：</b>K 近邻算法是另一个既可以做分类又可以做回归的机器学习算法，K 近邻算法通过来自数据点的 K 个最近邻居的多数表决来识别新的分类。K 近邻算法的计算量非常大（computationally expensive），所以在使用过程中应该尽量使数据最小化。<br/> </li><li><b>朴素贝叶斯模型 Naïve Bayes Model：</b>朴素贝叶斯模型是一个非常简单的分类算法，它使用经典的贝叶斯公式，对每一个数据属于某个类的概率进行计算（条件概率或后验概率），再根据概率进行分类判断。“朴素”的含义是，该算法假定数据的特征之间是相互独立的。<br/> </li></ol><p>最后作者对何种情况应选择何种算法进行了总结：</p><ol><li> 在数据量很大时，我们倾向于使用线性回归模型处理回归问题，因为其他的算法容易受到过拟合的影响；我们倾向使用逻辑回归来处理二分类问题。<br/> </li><li> 当计算量不是一个问题的时候，这也就意味着我们对模型的精细度有了更高的要求，那么神经网络是一个非常好的选择（理论上只要有足够多的神经元，神经网络就可以以任意精度逼近任意复杂度的连续函数）。<br/> </li><li> 当已知数据的特征是相互独立的时候，尽管数据集很大或者很复杂，我们依然可以选择朴素贝叶斯模型。<br/> </li></ol><hr/><h2>Tips</h2><h3>利用 ssh 传输文件</h3><p>在 Linux 下一般用 <code>scp</code> 这个命令来通过 ssh 传输文件。</p><ul><li>从服务器上下载文件</li></ul><p><code>scp username@servername:/path/filename /var/www/local_dir</code><br/>例如：<code>scp root@192.168.0.101:/var/www/test.txt /var/www/local_dir</code><br/>把 192.168.0.101 上的 /var/www/test.txt 的文件下载到 /var/www/local_dir（本地目录）。</p><ul><li>上传本地文件到服务器</li></ul><p><code>scp /path/filename username@servername:/path</code><br/>例如：<code>scp /var/www/test.php  root@192.168.0.101:/var/www/</code><br/>把本机 /var/www/ 目录下的 test.php 文件上传到 192.168.0.101 这台服务器上的 /var/www/ 目录中。</p><ul><li>从服务器下载整个目录</li></ul><p><code>scp -r username@servername:/var/www/remote_dir/ /var/www/local_dir/</code><br/> 例如：<br/><code>scp -r root@192.168.0.101:/var/www/test/ /var/www/</code> </p><ul><li>上传目录到服务器</li></ul><p><code>scp -r local_dir username@servername:remote_dir</code><br/> 例如：<br/><code>scp -r test root@192.168.0.101:/var/www/</code><br/> 把当前目录下的 test 目录上传到服务器的 /var/www/ 目录。<br/> </p><p>注：目标服务器要开启写入权限。</p><hr/><h2>Share</h2><p>一篇只完成了一半的旧文，是我自己学习《数据分析实战 45 讲》第 3 讲的笔记，对 Python 基础部分进行了不少补充，算是自己的一个复习过程。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/5dWcru1z62VHeFlQq28wfA\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> 针对数据分析工作的 Python 入门简介（上） </a></p>", 
            "topic": [
                {
                    "tag": "极客时间 App", 
                    "tagLink": "https://api.zhihu.com/topics/20165447"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1096367617937395712"
}
